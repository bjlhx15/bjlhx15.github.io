<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>007-shell-编程注意事项、引号区别</title>
    <url>/articles/20200212/b4490d2f.html</url>
    <content><![CDATA[<p>摘要：shell开发时，注意事项</p>
<a id="more"></a>

<h1 id="单引号、双引号、反单引号的区别"><a href="#单引号、双引号、反单引号的区别" class="headerlink" title="单引号、双引号、反单引号的区别"></a>单引号、双引号、反单引号的区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单引号&#39; &#39;：包围变量的值时，原样输出。强引用。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</span><br><span class="line"></span><br><span class="line">双引号&quot; &quot;：包围变量的值时，解析里面的变量和命令。弱引。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</span><br><span class="line"></span><br><span class="line">反引号&#96; &#96;：一般用于命令，执行的时候命令会被执行，相当于$()，赋值和输出都要用反引号引起来。</span><br></pre></td></tr></table></figure>

<p>两种均可，后者，支持嵌套</p>
<h1 id="Shell编程注意事项"><a href="#Shell编程注意事项" class="headerlink" title="Shell编程注意事项"></a>Shell编程注意事项</h1><ol>
<li>变量赋值时‘=’两边不能有空格</li>
<li>使用[]命令测试表达式的时候，在操作数和操作符或者方括号的前后都要至少留一个空格</li>
<li>变量的引用： 使用$var 或者 ${var}</li>
<li>命令的引用：【执行命令返回值给变量】<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var2&#x3D;&#96;command&#96; 或者 var3&#x3D;$(command)</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>cmd-data</title>
    <url>/articles/20200211/f7a4df92.html</url>
    <content><![CDATA[<p>摘要：shell开发时，常用date控制展示时间</p>
<a id="more"></a>

<h1 id="date"><a href="#date" class="headerlink" title="date"></a>date</h1><p>date 可以用来显示或设定系统的日期与时间。</p>
<h2 id="查看帮助语法说明"><a href="#查看帮助语法说明" class="headerlink" title="查看帮助语法说明"></a>查看帮助语法说明</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：date [选项]... [+格式]</span><br><span class="line">　或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">可选参数：</span><br><span class="line">  -d, --date&#x3D;STRING         显示字符串所指的日期与时间。字符串前后必须加上引号； not &#39;now&#39;</span><br><span class="line">  -f, --file&#x3D;DATEFILE       like --date once for each line of DATEFILE</span><br><span class="line">  -I[TIMESPEC], --iso-8601[&#x3D;TIMESPEC]  output date&#x2F;time in ISO 8601 format.</span><br><span class="line">                            TIMESPEC&#x3D;&#39;date&#39; for date only (the default),</span><br><span class="line">                            &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, or &#39;ns&#39; for date</span><br><span class="line">                            and time to the indicated precision.</span><br><span class="line">  -r, --reference&#x3D;文件		显示文件指定文件的最后修改时间</span><br><span class="line">  -R, --rfc-2822		以RFC 2822格式输出日期和时间，例如：2006年8月7日，星期一 12:34:56 -0600</span><br><span class="line">      --rfc-3339&#x3D;TIMESPEC   output date and time in RFC 3339 format.</span><br><span class="line">                            TIMESPEC&#x3D;&#39;date&#39;, &#39;seconds&#39;, or &#39;ns&#39; for</span><br><span class="line">                            date and time to the indicated precision.</span><br><span class="line">                            Date and time components are separated by</span><br><span class="line">                            a single space: 2006-08-07 12:34:56-06:00</span><br><span class="line">  -s, --set&#x3D;STRING          根据字符串来设置日期与时间。字符串前后必须加上引号；</span><br><span class="line">  -u, --utc, --universal    print or set Coordinated Universal Time (UTC)</span><br><span class="line">      --help		显示此帮助信息并退出</span><br><span class="line">      --version		显示版本信息并退出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>日期格式字符串</span></figcaption><table><tr><td class="code"><pre><span class="line"># 如果需要以指定的格式显示日期，可以使用“+”开头的字符串指定其格式</span><br><span class="line">  %%	一个文字的 %</span><br><span class="line">  %a	当前locale 的星期名缩写(例如： 日，代表星期日)</span><br><span class="line">  %A	当前locale 的星期名全称 (如：星期日)</span><br><span class="line">  %b	当前locale 的月名缩写 (如：一，代表一月)</span><br><span class="line">  %B	当前locale 的月名全称 (如：一月)</span><br><span class="line">  %c	当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)</span><br><span class="line">  %C	世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)</span><br><span class="line">  %d	按月计的日期(例如：01)</span><br><span class="line">  %D	按月计的日期；等于%m&#x2F;%d&#x2F;%y</span><br><span class="line">  %e	按月计的日期，添加空格，等于%_d</span><br><span class="line">  %F	完整日期格式，等价于 %Y-%m-%d</span><br><span class="line">  %g	ISO-8601 格式年份的最后两位 (参见%G)</span><br><span class="line">  %G	ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用</span><br><span class="line">  %h	等于%b</span><br><span class="line">  %H	小时(00-23)</span><br><span class="line">  %I	小时(00-12)</span><br><span class="line">  %j	按年计的日期(001-366)</span><br><span class="line">  %k   hour, space padded ( 0..23); same as %_H</span><br><span class="line">  %l   hour, space padded ( 1..12); same as %_I</span><br><span class="line">  %m   month (01..12)</span><br><span class="line">  %M   minute (00..59)</span><br><span class="line">  %n	换行</span><br><span class="line">  %N	纳秒(000000000-999999999)</span><br><span class="line">  %p	当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空</span><br><span class="line">  %P	与%p 类似，但是输出小写字母</span><br><span class="line">  %r	当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)</span><br><span class="line">  %R	24 小时时间的时和分，等价于 %H:%M</span><br><span class="line">  %s	自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</span><br><span class="line">  %S	秒(00-60)</span><br><span class="line">  %t	输出制表符 Tab</span><br><span class="line">  %T	时间，等于%H:%M:%S</span><br><span class="line">  %u	星期，1 代表星期一</span><br><span class="line">  %U	一年中的第几周，以周日为每星期第一天(00-53)</span><br><span class="line">  %V	ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)</span><br><span class="line">  %w	一星期中的第几日(0-6)，0 代表周一</span><br><span class="line">  %W	一年中的第几周，以周一为每星期第一天(00-53)</span><br><span class="line">  %x	当前locale 下的日期描述 (如：12&#x2F;31&#x2F;99)</span><br><span class="line">  %X	当前locale 下的时间描述 (如：23:13:48)</span><br><span class="line">  %y	年份最后两位数位 (00-99)</span><br><span class="line">  %Y	年份</span><br><span class="line">  %z +hhmm		数字时区(例如，-0400)</span><br><span class="line">  %:z +hh:mm		数字时区(例如，-04:00)</span><br><span class="line">  %::z +hh:mm:ss	数字时区(例如，-04:00:00)</span><br><span class="line">  %:::z			数字时区带有必要的精度 (例如，-04，+05:30)</span><br><span class="line">  %Z			按字母表排序的时区缩写 (例如，EDT)</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式化输出：</span></span><br><span class="line">date +<span class="string">"%Y-%m-%d"</span> </span><br><span class="line">2020-02-11</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date +%Y%m%d               <span class="comment">#显示当前天年月日 </span></span><br><span class="line">date -d <span class="string">"-1 day"</span> +%Y%m%d   <span class="comment">#显示前一天的日期 或 date -d "1 day ago" +%Y%m%d </span></span><br><span class="line">date -d <span class="string">"+1 day"</span> +%Y%m%d   <span class="comment">#显示后一天的日期 或 date -d "1 day" +%Y%m%d</span></span><br><span class="line"><span class="comment"># 其中：day 天；month 月；year 年；second 秒；</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-java-保留两位小数以及浮点类型精度问题</title>
    <url>/articles/20200211/7aa0e1b.html</url>
    <content><![CDATA[<p>摘要：保存成两个小数</p>
<a id="more"></a>

<h1 id="几种方式"><a href="#几种方式" class="headerlink" title="几种方式"></a>几种方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> roundLong = <span class="number">8710</span>;</span><br><span class="line">System.out.println((roundLong * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((roundLong /<span class="number">100.0</span>));</span><br><span class="line"><span class="comment">// 方式一、DecimalFormat</span></span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">".00"</span>);</span><br><span class="line">System.out.println(df.format(roundLong * <span class="number">0.01</span>));</span><br><span class="line"><span class="comment">// 方式二、String.format</span></span><br><span class="line">System.out.println(String.format(<span class="string">"%.2f"</span>, (roundLong * <span class="number">0.01</span>)));</span><br><span class="line"><span class="comment">// 方式三、BigDecimal</span></span><br><span class="line">BigDecimal bg = <span class="keyword">new</span> BigDecimal(roundLong * <span class="number">0.01</span>);</span><br><span class="line"><span class="keyword">double</span> d3 = bg.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">System.out.println(d3);</span><br><span class="line"><span class="comment">// 方式四：通过NumberFormat类实现</span></span><br><span class="line">NumberFormat nf = NumberFormat.getNumberInstance();</span><br><span class="line">nf.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">System.out.println(nf.format(roundLong * <span class="number">0.01</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">87.10000000000001</span><br><span class="line">87.1</span><br><span class="line">87.10</span><br><span class="line">87.10</span><br><span class="line">87.1</span><br><span class="line">87.1</span><br></pre></td></tr></table></figure>

<h1 id="浮点类型精度问题"><a href="#浮点类型精度问题" class="headerlink" title="浮点类型精度问题"></a>浮点类型精度问题</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t2 = <span class="number">8710</span>;</span><br><span class="line">System.out.println((t2 * <span class="number">0.1</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.001</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line">t2 = <span class="number">870</span>;</span><br><span class="line">System.out.println((t2 * <span class="number">0.1</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.001</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> number1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> number2 = <span class="number">20.2</span>;</span><br><span class="line"><span class="keyword">double</span> number3 = <span class="number">300.03</span>;</span><br><span class="line"><span class="keyword">double</span> result = number1 + number2 + number3;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">871.0</span><br><span class="line">87.10000000000001</span><br><span class="line">8.71</span><br><span class="line">0.871</span><br><span class="line">87.0</span><br><span class="line">8.700000000000001</span><br><span class="line">0.87</span><br><span class="line">0.08700000000000001</span><br><span class="line">321.22999999999996</span><br></pre></td></tr></table></figure>
<p>此处涉及，计算机浮点设计问题，详细可查阅资料。<br>float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。<br>主要是说明应用系统设计、数据库设计，商业计算标准金额时，请尽量避开浮点直接运算，推荐 long、BigDecimal等其他方式进行</p>
]]></content>
      <categories>
        <category>java-base</category>
      </categories>
  </entry>
  <entry>
    <title>005-cmd-stat显示与touch修改文件的各种时间</title>
    <url>/articles/20200211/ced46313.html</url>
    <content><![CDATA[<p>摘要：stat查看具体，touch操作具体<br>主要是测试log4j2日志删除策略时候使用。</p>
<a id="more"></a>

<h1 id="stat显示指定文件的状态信息"><a href="#stat显示指定文件的状态信息" class="headerlink" title="stat显示指定文件的状态信息"></a>stat显示指定文件的状态信息</h1><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><ul>
<li>mac<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -?</span><br><span class="line"><span class="comment"># stat: illegal option -- ?</span></span><br><span class="line"><span class="comment"># usage: stat [-FlLnqrsx] [-f format] [-t timefmt] [file ...]</span></span><br></pre></td></tr></table></figure></li>
<li>centos<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 用法：stat [选项]... 文件...</span></span><br><span class="line"><span class="comment"># Display file or file system status.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   -L, --dereference     follow links</span></span><br><span class="line"><span class="comment">#   -Z, --context         print the SELinux security context </span></span><br><span class="line"><span class="comment">#   -f, --file-system     display file system status instead of file status</span></span><br><span class="line"><span class="comment">#   -c --format=格式	使用指定输出格式代替默认值，每用一次指定格式换一新行</span></span><br><span class="line"><span class="comment">#       --printf=格式	类似 --format，但是会解释反斜杠转义符，不使用换行作</span></span><br><span class="line"><span class="comment"># 				输出结尾。如果您仍希望使用换行，可以在格式中</span></span><br><span class="line"><span class="comment"># 				加入"\n"</span></span><br><span class="line"><span class="comment">#   -t, --terse		使用简洁格式输出</span></span><br><span class="line"><span class="comment">#       --help		显示此帮助信息并退出</span></span><br><span class="line"><span class="comment">#       --version		显示版本信息并退出</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="查看具体时间"><a href="#查看具体时间" class="headerlink" title="查看具体时间"></a>查看具体时间</h2><ul>
<li>mac<br>一次尝试一下其中含义，发现 -x 比较容易理解各种时间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -x text.txt</span><br><span class="line"><span class="comment">#   File: "text.txt"</span></span><br><span class="line"><span class="comment">#   Size: 6            FileType: Regular File</span></span><br><span class="line"><span class="comment">#   Mode: (0644/-rw-r--r--)         Uid: (545858136/lihongxu6)  Gid: (699739227/(699739227))</span></span><br><span class="line"><span class="comment"># Device: 1,4   Inode: 15213285    Links: 1</span></span><br><span class="line"><span class="comment"># Access: Tue Feb 11 08:53:33 2020</span></span><br><span class="line"><span class="comment"># Modify: Tue Feb 11 08:53:32 2020</span></span><br><span class="line"><span class="comment"># Change: Tue Feb 11 08:53:32 2020</span></span><br></pre></td></tr></table></figure>

<p>Access是文件访问时间，Modify是文件内容最后修改时间，Change是文件属性最后修改时间，分别对应时间戳atime/mtime/ctime。<br>Change时间比较特殊，当改变文件的名称，大小和权限的时候Change时间才会改变。</p>
<p>通过上述发现并没有包含文件的创建时间，即crtime。查看源码可知，这是因为inode结构体中并没有crtime。</p>
<ul>
<li>centos<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span>  test.txt </span><br><span class="line"><span class="comment">#   File: "test.txt"</span></span><br><span class="line"><span class="comment">#   Size: 0         	Blocks: 0          IO Block: 4096   普通空文件</span></span><br><span class="line"><span class="comment"># Device: fc01h/64513d	Inode: 1579964     Links: 1</span></span><br><span class="line"><span class="comment"># Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line"><span class="comment"># Access: 2020-02-11 10:07:53.343752608 +0800</span></span><br><span class="line"><span class="comment"># Modify: 2020-02-11 10:08:14.709608664 +0800</span></span><br><span class="line"><span class="comment"># Change: 2020-02-11 10:08:14.709608664 +080</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="查看文件的创建时间。"><a href="#查看文件的创建时间。" class="headerlink" title="查看文件的创建时间。"></a>查看文件的创建时间。</h3><ul>
<li><p>mac<br>Mac OS X上没有debugfs（8）。Debugfs（8）是用于调试Linux文件系统ext2 / ext3的Linux程序。<br>可以使用： HFS+ try fsck(8) or use Disk Utility. 或者自带命令： GetFileInfo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GetFileInfo text.txt </span><br><span class="line"><span class="comment"># file: "/Users/lihongxu6/IdeaProjectsGit/shell/test/fileop/text.txt"</span></span><br><span class="line"><span class="comment"># type: "\0\0\0\0"</span></span><br><span class="line"><span class="comment"># creator: "\0\0\0\0"</span></span><br><span class="line"><span class="comment"># attributes: avbstclinmedz</span></span><br><span class="line"><span class="comment"># created: 02/11/2020 08:53:27</span></span><br><span class="line"><span class="comment"># modified: 02/11/2020 08:53:32</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>centos</p>
</li>
</ul>
<ol>
<li><p>查看文件的inode号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> test.txt</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">stat</span> -x text.txt</span><br></pre></td></tr></table></figure>
<p>inode:15213285</p>
</li>
<li><p>输出分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df test.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df text.txt                         </span></span><br><span class="line"><span class="comment"># Filesystem   512-blocks      Used Available Capacity iused               ifree %iused  Mounted on</span></span><br><span class="line"><span class="comment"># /dev/disk1s1  489620264 215965128 243191936    48% 2289359 9223372036852486448    0%   /</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过debugfs就可以查询到文件的完整信息<br>linux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugfs -R <span class="string">'stat &lt;15213285&gt;'</span> /dev/disk1s1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="linux修改文件各种时间"><a href="#linux修改文件各种时间" class="headerlink" title="linux修改文件各种时间"></a>linux修改文件各种时间</h1><p>查看下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span>  test.txt </span><br><span class="line"><span class="comment">#   File: "test.txt"</span></span><br><span class="line"><span class="comment">#   Size: 0         	Blocks: 0          IO Block: 4096   普通空文件</span></span><br><span class="line"><span class="comment"># Device: fc01h/64513d	Inode: 1579964     Links: 1</span></span><br><span class="line"><span class="comment"># Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line"><span class="comment"># Access: 2020-02-11 10:07:53.343752608 +0800</span></span><br><span class="line"><span class="comment"># Modify: 2020-02-11 10:08:14.709608664 +0800</span></span><br><span class="line"><span class="comment"># Change: 2020-02-11 10:08:14.709608664 +080</span></span><br></pre></td></tr></table></figure>

<h2 id="修改修改时间"><a href="#修改修改时间" class="headerlink" title="修改修改时间"></a>修改修改时间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件修改时间设置为：2020年02月11日09:17:52</span></span><br><span class="line">touch -t 202002110917.52 test.txt</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">touch -d <span class="string">"2020-02-11 09:18:08"</span> test.txt</span><br><span class="line"><span class="comment"># 查看实际是否修改</span></span><br><span class="line"><span class="built_in">stat</span> test.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>004-shell-函数以及传递参数的几种方式</title>
    <url>/articles/20200210/7355fbf4.html</url>
    <content><![CDATA[<p>摘要：linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<a id="more"></a>

<h1 id="函数语法格式"><a href="#函数语法格式" class="headerlink" title="函数语法格式"></a>函数语法格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
<li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。执行成功 默认是 0 </li>
</ol>
<p>shell 语言中 0 代表 true，0 以外的值代表 false。</p>
<ol start="3">
<li>函数返回值在调用该函数后通过 $? 来获得。$? 仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。</li>
</ol>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<p>示例1、无返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"test"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"返回值：$?"</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">返回值：0</span><br></pre></td></tr></table></figure>

<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… </p>
<p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数处理	说明</span><br><span class="line">$#	传递到脚本或函数的参数个数</span><br><span class="line">$*	以一个单字符串显示所有向脚本传递的参数</span><br><span class="line">$	脚本运行的当前进程ID号</span><br><span class="line">$!	后台运行的最后一个进程的ID号</span><br><span class="line">$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">$-	显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"进程id:$"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数个数: <span class="variable">$&#123;#&#125;</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"所有参数: $*"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"所有参数: <span class="variable">$@</span>"</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"显示Shell使用的当前选项:$-"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span> aa xx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"返回值：$?"</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程id:11414</span><br><span class="line">参数个数: 2</span><br><span class="line">所有参数: aa xx</span><br><span class="line">所有参数: aa xx</span><br><span class="line">aa</span><br><span class="line">xx</span><br><span class="line">显示Shell使用的当前选项:hB</span><br><span class="line">返回值：0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-tomcat-日志分割三种方法</title>
    <url>/articles/20200210/6998e040.html</url>
    <content><![CDATA[<p>概述:tomcat-日志分割三种方法<br>三种方式均有优缺点，</p>
<ul>
<li>cronolog：需要在主机安装软件</li>
<li>log4j：方便使用，但是不能删除</li>
<li>crontab：需要有对应目录权限</li>
</ul>
<p>采取cronolog、log4j缺点：已经做好对应主机镜像，大范围使用，在应用系统级别修改，所有使用者会参与修改；<br>采用crontab，crontab不需要安装，检测linux默认自带安装。正好部署时使用shell脚本，此时只需在脚本中嵌入执行crontab脚本即可。</p>
<a id="more"></a>
<h1 id="方法一、用cronolog分割tomcat的catalina-out文件"><a href="#方法一、用cronolog分割tomcat的catalina-out文件" class="headerlink" title="方法一、用cronolog分割tomcat的catalina.out文件"></a>方法一、用cronolog分割tomcat的catalina.out文件</h1><p>Linux 日志切割工具cronolog详解：<a href="https://blog.csdn.net/chenkeqin_2012/article/details/52670887" target="_blank" rel="noopener">https://blog.csdn.net/chenkeqin_2012/article/details/52670887</a></p>
<ol>
<li>编译安装cronolog<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://cronolog.org/download/cronolog-1.6.2.tar.gz </span><br><span class="line">tar zxvf cronolog-1.6.2.tar.gz </span><br><span class="line"><span class="built_in">cd</span> cronolog-1.6.2</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li>查看cronolog安装后所在目录（验证安装是否成功）<br>which cronolog<br>一般情况下显示为：/usr/local/sbin/cronolog </li>
<li>编辑tomcat目录bin下的catalina.sh文件<br>找到下面这行，类似这样的行有2处：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \</span><br><span class="line">      &gt;&gt; &quot;$CATALINA_OUT&quot; 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>第一处：tomcat是带“-security”参数的启动，</li>
<li>第二处：默认tomcat启动方式，也就是else下面的那部分，我们只修改这里。</li>
<li>另外还要把touch “$CATALINA_OUT”这行注释掉。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  touch "$CATALINA_OUT"</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"-security"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$have_tty</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"Using Security Manager"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="string">"<span class="variable">$_RUNJAVA</span>"</span> <span class="string">"<span class="variable">$LOGGING_CONFIG</span>"</span> <span class="variable">$LOGGING_MANAGER</span> <span class="variable">$JAVA_OPTS</span> <span class="variable">$CATALINA_OPTS</span> \</span><br><span class="line">      -Djava.endorsed.dirs=<span class="string">"<span class="variable">$JAVA_ENDORSED_DIRS</span>"</span> -classpath <span class="string">"<span class="variable">$CLASSPATH</span>"</span> \</span><br><span class="line">      -Djava.security.manager \</span><br><span class="line">      -Djava.security.policy==<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span>/conf/catalina.policy \</span><br><span class="line">      -Dcatalina.base=<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span> \</span><br><span class="line">      -Dcatalina.home=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span> \</span><br><span class="line">      -Djava.io.tmpdir=<span class="string">"<span class="variable">$CATALINA_TMPDIR</span>"</span> \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap <span class="string">"<span class="variable">$@</span>"</span> start \</span><br><span class="line">      &gt;&gt; <span class="string">"<span class="variable">$CATALINA_OUT</span>"</span> 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="string">"<span class="variable">$_RUNJAVA</span>"</span> <span class="string">"<span class="variable">$LOGGING_CONFIG</span>"</span> <span class="variable">$LOGGING_MANAGER</span> <span class="variable">$JAVA_OPTS</span> <span class="variable">$CATALINA_OPTS</span> \</span><br><span class="line">      -Djava.endorsed.dirs=<span class="string">"<span class="variable">$JAVA_ENDORSED_DIRS</span>"</span> -classpath <span class="string">"<span class="variable">$CLASSPATH</span>"</span> \</span><br><span class="line">      -Dcatalina.base=<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span> \</span><br><span class="line">      -Dcatalina.home=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span> \</span><br><span class="line">      -Djava.io.tmpdir=<span class="string">"<span class="variable">$CATALINA_TMPDIR</span>"</span> \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap <span class="string">"<span class="variable">$@</span>"</span> start 2&gt;&amp;1 | /usr/<span class="built_in">local</span>/sbin/cronolog /usr/<span class="built_in">local</span>/tomcat/logs/catalina.%Y%m%d.out &gt;&gt; /dev/null &amp;</span><br><span class="line"><span class="comment">#      &gt;&gt; "$CATALINA_OUT" 2&gt;&amp;1 &amp;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>重启tomcat<br>查看日志目录是否生成catalina.yymmdd.out的日志文件</li>
</ol>
<p>-rw-r–r– 1 root root 10537 Jul 30 10:50 catalina.20140730.out</p>
<p>配置cronolog完成了，观察每天是否有一个新的catalina.yymmdd.out的日志文件生成，定期删除日期较旧的日志文件。</p>
<h1 id="方法二、使用log4j成功使catalina-out文件实现分割"><a href="#方法二、使用log4j成功使catalina-out文件实现分割" class="headerlink" title="方法二、使用log4j成功使catalina.out文件实现分割"></a>方法二、使用log4j成功使catalina.out文件实现分割</h1><p>　　1、在tomcat根目录下建立common/classes/log4j.properties，内容如下<br>复制代码<br>log4j.rootLogger=INFO, R<br>log4j.appender.R=org.apache.log4j.RollingFileAppender<br>log4j.appender.R.File=${catalina.home}/logs/tomcat.newlog  #设定日志文件名<br>log4j.appender.R.MaxFileSize=100KB   #设定文件到100kb即分割<br>log4j.appender.R.MaxBackupIndex=10   #设定日志文件保留的序号数<br>log4j.appender.R.layout=org.apache.log4j.PatternLayout<br>log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n<br>复制代码<br>　　2、在tomcat根目录下的common/lib下加入log4j.jar和commons-logging.jar<br>　　3、重新启动tomcat即可。</p>
<h1 id="方法三、使用系统crontab"><a href="#方法三、使用系统crontab" class="headerlink" title="方法三、使用系统crontab"></a>方法三、使用系统crontab</h1><ol>
<li>编写一个crontab_log_work.sh文件,shell脚本如下:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>  `dirname <span class="variable">$0</span>`</span><br><span class="line">d=`date +%Y%m%d`</span><br><span class="line">d7=`date -d<span class="string">'7 day ago'</span> +%Y%m%d`</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>  ../logs/</span><br><span class="line"></span><br><span class="line">cp catalina.out catalina.out.<span class="variable">$&#123;d&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; catalina.out </span><br><span class="line">rm -rf catalina.out.<span class="variable">$&#123;d7&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>编写任务执行计划 crontab_log<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55 23 * * * crontab_log_work.sh</span><br></pre></td></tr></table></figure></li>
<li>使用crontab 启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab crontab_log</span><br></pre></td></tr></table></figure>






</li>
</ol>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>003-shell-crontab定时任务</title>
    <url>/articles/20200208/a16096f7.html</url>
    <content><![CDATA[<p>摘要：有时需要操作系统统，定时做一些任务，解决一些问题。<br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>说明：</p>
<ol>
<li>Linux和Mac下操作crontab都是一致的</li>
<li>配置文件都在/etc/crontab下，如果没有就创建。默认系统级别存在，不需要额外安装定时任务</li>
<li>测试直接使用crontab -e命令创建的定时任务是放在临时文件夹的，重启会删除，并且与/etc/crontab文件无关联。</li>
</ol>
<h2 id="crontab服务的重启关闭，开启"><a href="#crontab服务的重启关闭，开启" class="headerlink" title="crontab服务的重启关闭，开启"></a>crontab服务的重启关闭，开启</h2><p>系统级别，是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。所以下述命令不可用。</p>
<ul>
<li>Mac系统下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/cron start</span><br><span class="line">sudo /usr/sbin/cron restart</span><br><span class="line">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure></li>
<li>Ubuntu<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/cron start</span><br><span class="line">sudo /etc/init.d/cron stop</span><br><span class="line">sudo /etc/init.d/cron restart</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看定时任务：<code>crontab -l</code><br>列出用户test的所有调度任务:<code>crontab -l -u test</code><br>删除所有调度任务：<code>crontab -r</code></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li><p>方式一、系统级别-/etc/crontab 方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/crontab</span><br><span class="line">*/1 * * * * root /bin/date &gt;&gt; /tmp/time2.txt</span><br></pre></td></tr></table></figure>
<p>保存使用：<code>:wq!</code>；默认超管只读权限，需要强制保存退出</p>
</li>
<li><p>方式二、用户级别-crontab -e 自定义脚本启动</p>
</li>
</ul>
<ol>
<li>执行脚本编写<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每分钟执行一次date命令，输出时间到time.txt文本</span></span><br><span class="line">*/1 * * * * /bin/date &gt;&gt; /tmp/time.txt</span><br></pre></td></tr></table></figure></li>
<li>crontab命令调用crontab文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab testing_crontab</span><br></pre></td></tr></table></figure></li>
<li>查看 文件内容<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f  /tmp/time.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="etc-crontab文件和crontab-e命令区别"><a href="#etc-crontab文件和crontab-e命令区别" class="headerlink" title="/etc/crontab文件和crontab -e命令区别"></a>/etc/crontab文件和crontab -e命令区别</h2><ol>
<li>修改/etc/crontab这种方法只有root用户能用，这种方法更加方便与直接直接给其他用户设置计划任务，而且还可以指定执行shell等等，crontab -e这种所有用户都可以使用，普通用户也只能为自己设置计划任务。然后自动写入/var/spool/cron/usename</li>
<li>crontab -e是某个用户的周期计划任务；/etc/crontab是系统的周期任务</li>
<li>crontab -e与/etc/crontab修改语法格式不一样，后者多一个user指定</li>
<li>不管用crontab -e或者/etc/crontab都不需要重新启动crond服务</li>
<li>crontab  -e是针对用户的cron来设计的，如果是系统的例行性任务，需要编辑/etc/crontab文件。需要注意的是：crontab -e的作用其实是/usr/bin/crontab这个执行文件，但是/etc/crontab是个纯文本文件，可以root的身份编辑这个文件。</li>
<li>cron服务的最低检测时间单位是分钟，所以cron会每分钟读取一次/etc/crontab与/var/spool/cron中的数据内容，因此，只要您编辑完/etc/crontab文件并且保存之后，crontab时设定就会自动执行。</li>
</ol>
<p>注意：在Linux下的crontab会自动帮我们每分钟重新读取一次/etc/crontab的例行工作事项，但是某些原因或在其他的unix系统中，由于crontab是读到内存中，所以在您修改完/etc/crontab之后可能并不会马上执行，这时请重新启动crond服务。</p>
<p>/et</p>
<h1 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file [-u user] [ -e | -l | -r ]</span><br><span class="line">*   -u user：用来设定某个用户的crontab服务；</span><br><span class="line">*   file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">*   -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">*   -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">*   -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">*   -i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<h1 id="cron语法"><a href="#cron语法" class="headerlink" title="cron语法"></a>cron语法</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>分钟 小时 日期 月份 周 命令<br>如：数字范围 0-59 0-23 1-31 1-12 0-7 echo “hello” &gt;&gt; abc.log  </p>
<figure class="highlight plain"><figcaption><span>特殊字符的含义</span></figcaption><table><tr><td class="code"><pre><span class="line">*(星号) 代表任何时刻都接受。</span><br><span class="line">,(逗号) 代表分隔时段的意思。</span><br><span class="line">-(减号) 代表一段时间范围内。</span><br><span class="line">&#x2F;n(斜线) 那个 n 代表数字，每隔 n 单位间隔。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>每年的五月一日 10:5 执行一次：<code>5 10 1 5 * command（要是执行网址（curl &quot;http://网址&quot;），或者执行其它的直接写路径）</code></li>
<li>每天的三点，六点各执行一次：<code>00 3,6 * * * command</code></li>
<li>每天的8:20, 9:20,10:20,11:20各执行一次：<code>20 8-11 * * * command</code></li>
<li>每五分钟执行一次：<code>*/5 * * * * command</code></li>
<li>每周一十点执行一次：<code>00 10 * * 1 command</code></li>
<li>每天 02:00 执行任务：<code>0 2 * * * /bin/sh backup.sh</code></li>
<li>每天 5:00和17:00执行任务：<code>0 5,17 * * * /scripts/script.sh</code></li>
<li>每分钟执行一次任务：<code>* * * * * /scripts/script.sh</code></li>
<li>每周日 17:00 执行任务：<code>0 17 * * sun /scripts/script.sh</code></li>
<li>每 10min 执行一次任务：<code>*/10 * * * * /scripts/monitor.sh</code></li>
<li>在特定的某几个月执行任务：<code>* * * jan,may,aug * /script/script.sh</code></li>
<li>在特定的某几天执行任务：<code>0 17 * * sun,fri /script/scripy.sh（在每周五、周日的17点执行任务）</code></li>
<li>在某个月的第一个周日执行任务：<code>0 2 * * sun [ $(date +%d) -le 07 ] &amp;&amp; /script/script.sh</code></li>
<li>每四个小时执行一个任务：<code>0 */4 * * * /scripts/script.sh</code></li>
<li>每周一、周日执行任务：<code>0 4,17 * * sun,mon /scripts/script.sh</code></li>
<li>每个30秒执行一次任务：我们没有办法直接通过上诉类似的例子去执行，因为最小的是1min。但是我们可以通过如下的方法。<br><code>* * * * * /scripts/script.sh</code><br><code>* * * * * sleep 30; /scripts/script.sh</code></li>
<li>多个任务在一条命令中配置<br><code>* * * * * /scripts/script.sh; /scripts/scrit2.sh</code></li>
<li>每年执行一次任务<br><code>@yearly /scripts/script.sh</code><br>@yearly 类似于“0 0 1 1 *”。它会在每年的第一分钟内执行，通常我们可以用这个发送新年的问候。</li>
<li>系统重启时执行：<code>@reboot /scripts/script.sh</code></li>
</ul>
<h1 id="清除日志命令"><a href="#清除日志命令" class="headerlink" title="清除日志命令"></a>清除日志命令</h1><p>主要目标：每日凌晨前10分钟，将catalina.out日志，copy重命名 catalina.out-2020-02-08.log，清空服务器上的catalina.out日志，</p>
<p>编译一个shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>002-tools-mac-vscode</title>
    <url>/articles/20200208/6d6ffdd4.html</url>
    <content><![CDATA[<p>概述:mac下基础操作</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><p>支持：JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity).</p>
<h2 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载 安装"></a>下载 安装</h2><ol>
<li>下载地址<br><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></li>
</ol>
<p>下载后直接运行</p>
<h2 id="界面操作说明"><a href="#界面操作说明" class="headerlink" title="界面操作说明"></a>界面操作说明</h2><h3 id="界面展示语言设置"><a href="#界面展示语言设置" class="headerlink" title="界面展示语言设置"></a>界面展示语言设置</h3><p>command + shift + p，配置语言 或者 Configure Language，选择后会打开 locale.json 文件,【版本不一样其他类似】</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"locale"</span>:<span class="string">"zh-CN"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>界面说明<br>顶部：工具栏<br>最左侧：快捷工具栏【资源管理器、搜索、git、调试、扩展工具】</li>
<li>关闭更新<br>并将联机社会组中部分关闭</li>
</ol>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ &#96; ：调取和关闭终端</span><br><span class="line">⌘ + 、 ⌘ + ：很容易的实现整个页面所有字体大小</span><br><span class="line">⌥ ⇧ F：格式化文件快捷键</span><br></pre></td></tr></table></figure>

<h2 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h2><p>点击 左侧 打开git 操作窗，列表中即文件变化,输入框可以输入 commit message，上面 对号 是提交 </p>
<ol>
<li>界面说明<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左下角，分支选择</span><br><span class="line">顶部 操作</span><br><span class="line">省略号  是 git更多操作</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="markdown-支持"><a href="#markdown-支持" class="headerlink" title="markdown 支持"></a>markdown 支持</h2><p>  vscode 在没有安装任何插件的情况下是可以直接编写markdown文档的，以及 可以预览</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>001-tools-mac-sublime text3</title>
    <url>/articles/20200208/6c7c66a.html</url>
    <content><![CDATA[<p>概述:mac下基础操作</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><h2 id="停止更新提示："><a href="#停止更新提示：" class="headerlink" title="停止更新提示："></a>停止更新提示：</h2><ol>
<li>preferences→setting→增加如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;font_size&quot;: 17,</span><br><span class="line">    &quot;update_check&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意：一定要在每一行结束加逗号</li>
</ol>
<h2 id="插件安装包"><a href="#插件安装包" class="headerlink" title="插件安装包"></a>插件安装包</h2><h3 id="安装-Package-Control"><a href="#安装-Package-Control" class="headerlink" title="安装 Package Control"></a>安装 Package Control</h3><ol>
<li>安装</li>
</ol>
<ul>
<li>方式一、在线安装<br>Mac: cmd+shift+p<br>输入;Install Package Control, 按 enter</li>
<li>方式二、离线安装<br>下载：<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a> 下载 ： Package Control.sublime-package 即可</li>
</ul>
<p>Mac位置:/Users/用户名/Library/Application Support/Sublime Text 3/Installed Packages</p>
<ol start="2">
<li>使用<br>重启Sublime3,如果菜单-&gt;Preferences有Package Setting和Package Control就说明安装成功。</li>
</ol>
<p>Ctrl+Shift+p输入install选中Install Package回车就可以安装插件。</p>
<p>一般有些慢，可以在 菜单-&gt;Preferences有Package Setting 的setting user增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;debug&quot;: true,</span><br><span class="line">&quot;downloader_precedence&quot;:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;linux&quot;:[&quot;curl&quot;,&quot;urllib&quot;,&quot;wget&quot;],</span><br><span class="line">	&quot;osx&quot;:[&quot;curl&quot;,&quot;urllib&quot;],</span><br><span class="line">	&quot;windows&quot;:[&quot;wininet&quot;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="安装markdown-相关"><a href="#安装markdown-相关" class="headerlink" title="安装markdown 相关"></a>安装markdown 相关</h3><ol>
<li>安装预览：cmd+ shift + p,输入 install package，注意看左下角在加载，完毕后 出现输出框，输入 markdown preview 查找合适即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>

<p>markdown edit,preview</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>003-mysql-基础操作-常用数据类型</title>
    <url>/articles/20200205/93944b35.html</url>
    <content><![CDATA[<p>摘要：mysql 常用数据类型:数值类型、字符串类型、日期类型</p>
<a id="more"></a>

<p>更多：<a href="https://www.cnblogs.com/bjlhx/category/998292.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/998292.html</a></p>
<h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><p>MySQL中支持5种整数类型，其实很大程度上相同的，只是存储值的大小范围不同而已。其次是浮点类型float和double类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tinyint：占用1个字节，相对于java中的byte</span><br><span class="line">smallint：占用2个字节，相对于java中的short</span><br><span class="line">int：占用4个字节，相对于java中的int【推荐直接使用这个，已于扩展，降低转换】</span><br><span class="line">bigint：占用8个字节，相对于java中的long【自增主键推荐使用】</span><br><span class="line">float：4字节单精度浮点类型，相对于java中的float</span><br><span class="line">double：8字节双精度浮点类型，相对于java中的double</span><br></pre></td></tr></table></figure>
<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char()------定长字符串，最长255个字符。定长会浪费空间</span><br><span class="line">varchar()----变长(不定长)字符串，最长不超过 65535个字节,一般超过255个字节，会使用text类型. 不定长节省空间,剩余空间会留给别的数据使用</span><br><span class="line">text--------长文本类型,最长65535个字节</span><br></pre></td></tr></table></figure>

<p>总结： char、varchar、text都可以表示字符串类型，其区别在于：</p>
<ol>
<li>char在保存数据时, 如果存入的字符串长度小于指定的长度n,后面会用空格补全。</li>
<li>varchar和text保存数据时, 按数据的真实长度存储, 剩余的空间可以留给别的数据用.</li>
<li>char会造成空间浪费(不足指定长度的会用空格补全), 但是由于不需要计算数据的长度, 因此速度更快。（即浪费空间、节约时间）</li>
<li>varchar和text但是节省了空间, 但是存储的速度不如char快(因为要计算数据的实际长度)</li>
</ol>
<h1 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date：年月日</span><br><span class="line">time：时分秒</span><br><span class="line">datetime：年月日 时分秒</span><br><span class="line">	5.6后：使用：DEFAULT NOW()、DEFAULT CURRENT_TIMESTAMP设置</span><br><span class="line">timestamp：时间戳，与datetime存储相同的数据。</span><br><span class="line">	1、插入记录时，时间戳字段包含DEFAULT CURRENT_TIMESTAMP，如插入记录时未指定具体时间数据则将该时间戳字段值设置为当前时间</span><br><span class="line">  	2、更新记录时，时间戳字段包含ON UPDATE CURRENT_TIMESTAMP，如更新记录时未指定具体时间数据则将该时间戳字段值设置为当前时间</span><br><span class="line">	CURRENT_TIMESTAMP表示使用CURRENT_TIMESTAMP()函数来获取当前时间，类似于NOW()函数</span><br></pre></td></tr></table></figure>
<ul>
<li>timestamp最大表示2038年，而datetime范围是1000~9999</li>
<li>timestamp在插入数、修改数据时，可以自动更新成系统当前时间</li>
</ul>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>002-mysql-基础操作-连接、库表操作、字段</title>
    <url>/articles/20200205/8d83348a.html</url>
    <content><![CDATA[<p>摘要：mysql 库表操作</p>
<a id="more"></a>

<p>其他：<a href="https://www.cnblogs.com/bjlhx/category/998292.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/998292.html</a></p>
<h1 id="连接登录"><a href="#连接登录" class="headerlink" title="连接登录"></a>连接登录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 帮助</span></span><br><span class="line">mysql -?</span><br><span class="line"><span class="comment"># 常用参数</span></span><br><span class="line"><span class="comment"># -h 表示服务器名字。localhost表示本地 可以省略</span></span><br><span class="line"><span class="comment"># -P 端口</span></span><br><span class="line"><span class="comment"># -u 表示用户名</span></span><br><span class="line"><span class="comment"># -p 表示密码。直接在-p后面输入密码即可，中间不能有空格。 新版本不能指定，需要手工输入</span></span><br><span class="line"><span class="comment"># -D 指定数据库，权限不够时。</span></span><br></pre></td></tr></table></figure>
<p>连接 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p123456</span><br></pre></td></tr></table></figure>
<p>进入后，语句以 ; 结尾</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul>
<li>查看所有数据库: <code>show databases;</code></li>
<li>进入数据库: <code>use 库名;</code></li>
<li>查看数据库使用端口:<code>show variables like &#39;port&#39;;</code></li>
<li>数据库编码:<code>show variables like &#39;character%&#39;;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">character_set_client      为客户端编码方式；</span><br><span class="line">character_set_connection  为建立连接使用的编码；</span><br><span class="line">character_set_database    为数据库的编码；</span><br><span class="line">character_set_results     为结果集的编码；</span><br><span class="line">character_set_server      为数据库服务器的编码；</span><br></pre></td></tr></table></figure></li>
<li>查看数据库最大连接数:<code>show variables like &#39;%max_connections%&#39;;</code></li>
<li>查看数据库当前连接数，并发数:<code>show status like &#39;Threads%&#39;;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Threads_cached : 代表当前此时此刻线程缓存中有多少空闲线程。</span><br><span class="line">Threads_connected :代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。</span><br><span class="line">Threads_created :代表从最近一次服务启动，已创建线程的数量。</span><br><span class="line">Threads_running :代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态，这里相对应的线程也是sleep状态。</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><ul>
<li>查看正在使用的数据库：<code>select database();</code></li>
<li>查看库中所有的表: <code>show tables;</code></li>
<li>查看表结构: <code>desc/describe 表名</code>;或：<code>show columns from table_name [from database_name];</code></li>
<li>查看表-列结构: <code>desc/describe 表名 列名;</code></li>
<li>查看表生成的DDL sql语句:<code>show create table tname;</code></li>
<li>查看库表信息：<code>SHOW TABLE STATUS [{FROM | IN} db_name] [LIKE &#39;pattern&#39; | WHERE expr]</code><figure class="highlight plain"><figcaption><span>字段含义</span></figcaption><table><tr><td class="code"><pre><span class="line">返回列	说明</span><br><span class="line">Name	表名称</span><br><span class="line">Engine	表的存储引擎</span><br><span class="line">Version	版本</span><br><span class="line">Row_format	行格式</span><br><span class="line">Rows	表中的行数。对于非事务性表，这个值是精确的，对于事务性引擎，这个值通常是估算的。</span><br><span class="line">Avg_row_length	平均每行的大下（字节）</span><br><span class="line">Data_length	表的数据量(单位：字节)</span><br><span class="line">Max_data_length	表可以容纳的最大数据量</span><br><span class="line">Index_length	索引占用磁盘的空间大小</span><br><span class="line">Data_free	标识已分配，但现在未使用的空间，并且包含了已被删除行的空间。</span><br><span class="line">Auto_increment	下一个Auto_increment的值</span><br><span class="line">Create_time	表的创建时间</span><br><span class="line">Update_time	表的最近更新时间</span><br><span class="line">Check_time	最近一次使用 check table 或myisamchk工具检查表的时间</span><br><span class="line">Collation	表的字符集和字符排序规则</span><br><span class="line">Checksum	如果启用，则对整个表的内容计算时的校验和</span><br><span class="line">Create_options	表创建时的其它</span><br><span class="line">Comment	表在创建是添加的注释说明</span><br></pre></td></tr></table></figure>
或者 <code>select * from information_schema.tables where TABLE_SCHEMA=&#39;库名&#39;</code></li>
</ul>
<h2 id="库、表"><a href="#库、表" class="headerlink" title="库、表"></a>库、表</h2><ul>
<li>显示数据库状态：<code>status;</code></li>
<li>退出/断开连接:<code>exit;或quit;或 \q;或ctrl+c;</code></li>
</ul>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p>字符集： 1.若没有显式设置，则自动使用服务器级的配置 ； 2.显式设置：在创建库时指定 ，如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span>  <span class="keyword">exists</span>  库名 <span class="keyword">default</span> <span class="keyword">charset</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
<p>查看 库信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.schemata <span class="keyword">where</span> schema_name = <span class="string">'test_sql'</span>; </span><br><span class="line"><span class="comment">-- def	test_sql	utf8	utf8_general_ci</span></span><br></pre></td></tr></table></figure>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><p>创建表时, 除了要给每个列指定对应的数据类型, 有时也需要给列添加约束。常见的约束有：主键约束、唯一约束、非空约束、外键约束。</p>
<h4 id="主键-primary-key-【主键索引，聚集索引】"><a href="#主键-primary-key-【主键索引，聚集索引】" class="headerlink" title="主键(primary key)【主键索引，聚集索引】"></a>主键(primary key)【主键索引，聚集索引】</h4><p>主键是数据表中，一行记录的唯一标识。比如学生的编号，人的身份证号;<br>当主键为数值时，为了方便维护，可以设置主键为自增（auto_increment）</p>
<h4 id="唯一-unique"><a href="#唯一-unique" class="headerlink" title="唯一(unique)"></a>唯一(unique)</h4><p>保证所约束的列必须是唯一的，即不能重复出现，例如：用户注册时，保存的用户名不可以重复。</p>
<blockquote>
<ul>
<li>约束 全称完整性约束，它是关系数据库中的对象，用来存放插入到一个表中一列数据的规则，用来确保数据的准确性和一致性。</li>
<li>索引 数据库中用的最频繁的操作是数据查询，索引就是为了加速表中数据行的检索而创建的一种分散的数据结构。可以把索引类比成书的目录，有目录的肯定比没有目录的书，更方便查找。</li>
<li>唯一约束 保证在一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一约束允许为 NULL，只是只能有一行。</li>
<li>唯一索引 不允许具有索引值相同的行，从而禁止重复的索引或键值。</li>
</ul>
</blockquote>
<p>在mysql 中唯一约束 与 唯一索引 一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 唯一约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> AUTO_INCREMENT  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> <span class="keyword">comment</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> AUTO_INCREMENT  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">TABLE</span>  <span class="string">`t2`</span>  <span class="keyword">ADD</span>  <span class="keyword">UNIQUE</span> (<span class="string">`username`</span> ) ;</span><br></pre></td></tr></table></figure>
<p>查看 ddl t1,t2均为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'非空约束'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'默认为空'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`username`</span> (<span class="string">`username`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</span><br></pre></td></tr></table></figure>

<h4 id="非空-not-null"><a href="#非空-not-null" class="headerlink" title="非空(not null)"></a>非空(not null)</h4><p>保证所约束的列必须是不为空的，即在插入记录时，该列必须要赋值，例如：用户注册时，保存的密码不能为空。<br>创建user表, 指定密码不能为空</p>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>外键是用于表和表之间关系的列</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increament  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span> <span class="keyword">comment</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span>,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 库名;</span><br></pre></td></tr></table></figure>

<h2 id="表、字段操作"><a href="#表、字段操作" class="headerlink" title="表、字段操作"></a>表、字段操作</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><ol>
<li>是否需要删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li>创建【推荐】<br>create table 表名 (字段设定列表) default charset=utf8 default collate=utf8_bin; <ul>
<li>字符集：1.若没有显式设置，则自动使用数据库级的配置 ；2.显式设置：在创建表时指定 </li>
<li>字段列表类型：查看下文</li>
<li>成功后，可以使用<code>desc 表名</code>或<code>show create table 表名</code>查看</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>(</span><br><span class="line">   <span class="string">`user_id`</span> <span class="built_in">INT</span>(<span class="number">20</span>) AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`user_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`user_age`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`regist_date`</span> <span class="built_in">DATE</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`user_id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span>=utf8_unicode_ci  <span class="keyword">COMMENT</span> <span class="string">'用户信息表'</span>;</span><br></pre></td></tr></table></figure>


<h3 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure>

<h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> [<span class="keyword">TO</span>|<span class="keyword">AS</span>] 新表名;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure>

<h3 id="表字段操作"><a href="#表字段操作" class="headerlink" title="表字段操作"></a>表字段操作</h3><h4 id="改表-加字段"><a href="#改表-加字段" class="headerlink" title="改表-加字段"></a>改表-加字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">COLUMN</span> new_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="改表-删段名"><a href="#改表-删段名" class="headerlink" title="改表-删段名"></a>改表-删段名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">drop</span> <span class="keyword">column</span> old_name;</span><br></pre></td></tr></table></figure>

<h4 id="改表-改字段名"><a href="#改表-改字段名" class="headerlink" title="改表-改字段名"></a>改表-改字段名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">change</span> <span class="keyword">column</span> old_name new_name <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">comment</span> <span class="string">'注释'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="改表-改字段类型或大小"><a href="#改表-改字段类型或大小" class="headerlink" title="改表-改字段类型或大小"></a>改表-改字段类型或大小</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">modify</span> <span class="keyword">column</span> column1  <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'注释'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>参看：<a href="https://www.cnblogs.com/bjlhx/p/11953939.html" target="_blank" rel="noopener">012-MySQL 索引添加以及优化说明</a></p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>001-mysql-主键设计</title>
    <url>/articles/20200205/dd81f687.html</url>
    <content><![CDATA[<p>摘要：MySQL InnoDB数据存储是以B+树索引方式存储<br>存储单元、mysql InnoDB-B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>

<h1 id="mysql知识储备"><a href="#mysql知识储备" class="headerlink" title="mysql知识储备"></a>mysql知识储备</h1><p>参看：<a href="http://blog.bjlhx.top/categories/db-mysql-core/">http://blog.bjlhx.top/categories/db-mysql-core/</a></p>
<ol>
<li>InnoDB为聚集主键类型的引擎，数据会按照主键进行排序</li>
<li>mysql 的索引是B+tree，聚集索引使用主键，没有主键默认生成一个隐式主键rowId，辅助索引保存的是主键</li>
<li>innodb 存储单元是页，每页 16k，数据类型过大，会跨页，溢出等</li>
<li>每张表都会有主键，如没有显式设置主键，则<br>（1）、表中的非空唯一索引作为主键<br>（2）、自动创建一个6字节大小的指针</li>
</ol>
<h1 id="主键定义"><a href="#主键定义" class="headerlink" title="主键定义"></a>主键定义</h1><p>表中经常有一个列或多列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。</p>
<h1 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h1><p>总原则：根据数据库表的具体使用范围来决定采用不同的表主键定义。</p>
<p>数据库设计的三大范式</p>
<ul>
<li><p>第一范式（1NF）：指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。<br>即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。</p>
</li>
<li><p>第二范式（2NF）：首先要满足它是1NF，另外还需要包含两部分内容：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。简而言之，第二范式就是非主属性非部分依赖于主关键字</p>
</li>
<li><p>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p>
</li>
</ul>
<p>反范式主键的设计原则</p>
<ul>
<li>主键应当是对用户没有意义的。业务上的‘主键’可以通过唯一键（Unique Key）或唯一索引（Unique Index）和其它约束条件实现</li>
<li>主键应该是单列的，以便提高连接和筛选操作的效率</li>
<li>不要更新主键。实际上，因为主键除了惟一地标识一行之外再没有其他的用途了，所以也就没有理由去对它更新。另外，主键的值通常不重用，意味着记录被删除后，该主键值不再使用</li>
<li>主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等</li>
<li>主键应当由计算机自动生成。</li>
</ul>
<p>反范式跟范式所要求的正好相反，在反范式的设计模式，可以允许适当的数据的冗余，用这个冗余去取操作数据时间的缩短。<br>本质上就是用空间来换取时间，把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联（手册中也有禁止三表以上 JOIN 的条款）。</p>
<p>但需要注意的是，采用代理主键是为了避免业务逻辑变化导致主键变更，以及提高 JOIN 效率等。但在实际查询中，数据查询还是需要通过业务上的唯一键进行匹配的，<br>而不应该将代理主键作为查询条件，尤其不能将代理主键作为查询条件输入项提供给用户。</p>
<p>总体来说，实际应用中应当具体问题具体分析，结合范式和反范式两种设计思想。<br>对数据一致性和完整性较高、而对查询效率要求并不严格的地方，应当更倾向于遵从范式；而类似分布式、高并发集群的场景，则应当更考虑反范式的设计方案。</p>
<h2 id="确保主键的无意义性"><a href="#确保主键的无意义性" class="headerlink" title="确保主键的无意义性"></a>确保主键的无意义性</h2><p>在开发过程中，有意义的字段例如“用户登录信息表”将“登录名”（英文名）作为主键，“订单表”中将“订单编号”作为主键，如此设计主键一般都是没什么问题，因为将这些主键基本不具有“意义更改”的可能性。</p>
<p>但是，也有一些例外的情况，例如“订单表”需要支持需求“订单可以作废，并重新生成订单，而且订单号要保持原订单号一致”，那将“订单编号”作为主键就满足不了要求了。</p>
<p>因此在使用具有实际意义的字段作为主键时，需要考虑是否存在这种可能性。</p>
<p>要用代理主键，不要使用业务主键。任何一张表，强烈建议不要使用有业务含义的字段充当主键。我们通常都是在表中单独添加一个整型的编号充当主键字段。</p>
<h2 id="采用整型主键"><a href="#采用整型主键" class="headerlink" title="采用整型主键"></a>采用整型主键</h2><p>主键通常都是整数，不建议使用字符串当主键。（如果主键是用于集群式服务，可以采用字符串类型）</p>
<h2 id="减少主键的变动"><a href="#减少主键的变动" class="headerlink" title="减少主键的变动"></a>减少主键的变动</h2><p>主键的值通常都不允许修改，除非本记录被删除。</p>
<h2 id="避免重复使用主键"><a href="#避免重复使用主键" class="headerlink" title="避免重复使用主键"></a>避免重复使用主键</h2><p>主键的值通常不重用，意味着记录被删除后，该主键值不再使用。</p>
<h2 id="主键字段定义区分"><a href="#主键字段定义区分" class="headerlink" title="主键字段定义区分"></a>主键字段定义区分</h2><p>主键不要直接定义成【id】，而要加上前缀，定义成【表名id】或者【表名_id】</p>
<h1 id="主键设计的常用方案"><a href="#主键设计的常用方案" class="headerlink" title="主键设计的常用方案"></a>主键设计的常用方案</h1><h2 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h2><ul>
<li><p>方案：数据库设置：AUTO_INCREMENT</p>
</li>
<li><p>使用场景：不拆分库的情况下，推荐使用</p>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利。</li>
<li>数字型，占用空间小，易排序，在程序中传递方便。<br>同样数据量的情况下，自增id主键的数据量是字符串主键的1/2，对于考虑成本的公司来说无疑是一件好事，并且数据量小对备份还原数据都有大大的好处。</li>
<li>Mysql会按照键值的大小进行顺序存放，如果设置自增id为主键，这个时候主键是按照一种紧凑的接近顺序写入的方式进行存储数据。<br>如果用其他字段作为主键的话，此时Mysql不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，<br>此时又要从磁盘上读回来，这增加了很多额外的开销，同时频繁的移动、分页操作造成了大量的碎片。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>不支持水平分片架构，水平分片的设计当中，这种方法显然不能保证全局唯一。</li>
<li>表锁<br>在MySQL5.1.22之前，InnoDB自增值是通过其本身的自增长计数器来获取值，该实现方式是通过表锁机制来完成的（AUTO-INC LOCKING）。<br>锁不是在每次事务完成后释放，而是在完成对自增长值插入的SQL语句后释放，要等待其释放才能进行后续操作。<br>比如说当表里有一个auto_increment字段的时候，innoDB会在内存里保存一个计数器用来记录auto_increment的值，当插入一个新行数据时，<br>就会用一个表锁来锁住这个计数器，直到插入结束。如果大量的并发插入，表锁会引起SQL堵塞。<br>在5.1.22之后，InnoDB为了解决自增主键锁表的问题，引入了参数innodb_autoinc_lock_mode：<br>0：通过表锁的方式进行，也就是所有类型的insert都用AUTO-inc locking（表锁机制）。<br>1：默认值，对于simple insert 自增长值的产生使用互斥量对内存中的计数器进行累加操作，对于bulk insert 则还是使用表锁的方式进行。<br>2：对所有的insert-like 自增长值的产生使用互斥量机制完成，性能最高，并发插入可能导致自增值不连续，可能会导致Statement 的 Replication 出现不一致，使用该模式，需要用 Row Replication的模式。</li>
<li>可能不连续</li>
<li>当系统与其他系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突。</li>
<li>如果其他系统主键不是数字型，会导致修改主键数据类型，导致其他相关表的修改。</li>
</ol>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。在UUID的算法中，可能会用到诸如网卡MAC地址，IP，主机名，进程ID等信息以保证其独立性。</p>
<ul>
<li><p>方案：mysql uuid()函数，应用程序UUID函数</p>
</li>
<li><p>使用场景：不推荐使用，针对mysql缺点过于严重</p>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>全局唯一性、安全性、可移植性。</li>
<li>能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响。</li>
<li>保证生成的ID不仅是表独立的，而且是库独立的，在你切分数据库的时候尤为重要</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>针对InnoDB引擎会徒增IO压力，InnoDB为聚集主键类型的引擎，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力。InnoDB主键索引和数据存储位置相关（簇类索引），uuid 主键可能会引起数据位置频繁变动，严重影响性能。</li>
<li>UUID长度过长，一个UUID占用128个比特（16个字节）。主键索引KeyLength长度过大，而影响能够基于内存的索引记录数量，进而影响基于内存的索引命中率，而基于硬盘进行索引查询性能很差。严重影响数据库服务器整体的性能表现。</li>
</ol>
<h2 id="自建的id生成器"><a href="#自建的id生成器" class="headerlink" title="自建的id生成器"></a>自建的id生成器</h2><p>当数据量比较大，又是分布式架构的时候，可能需要考虑各种分库分表方案了。<br>自建id生成器，可以保证全局唯一，可以参考snowflake的算法（18位）方案，具体实施也可以根据自身业务进行调整算法。其次需要考虑的就是服务的高可用。</p>
<h2 id="业务编号做主键"><a href="#业务编号做主键" class="headerlink" title="业务编号做主键"></a>业务编号做主键</h2><ul>
<li><p>优点<br>此方法就是采用实际业务中的唯一字段的“编号”作为主键设计，这在小型的项目中是推荐这样做的，因为这可以使项目比较简单化，</p>
</li>
<li><p>缺点：<br>但在使用中却可能带来一些麻烦，比如要进行编号修改”时，可能要涉及到很多相关联的其他表，后果很严重”;或“业务要求允许编号重复时”</p>
</li>
</ul>
<h2 id="max加1"><a href="#max加1" class="headerlink" title="max加1"></a>max加1</h2><ul>
<li><p>优点：<br>由于自动编号存在那些问题，采用自己生成，同样是数字型的，只是把自动增长去掉了，采用在Insert时，读取Max值后加一，这种方法可 以避免自动编号的问题，</p>
</li>
<li><p>缺点：<br>但也存在一个效率问题，如果记录非常大的话，那么Max()也会影响效率的;更严重的是并发性问题，如果同时有两人读到相同的Max后，加一后插入的ID值会重复。</p>
</li>
</ul>
<h2 id="自制加一"><a href="#自制加一" class="headerlink" title="自制加一"></a>自制加一</h2><ul>
<li><p>优点：<br>考虑Max加一的效率后，采用自制加一，也就是建一个特别的表，字段为：表名，当前序列值。这样在往表中插入值时，先从此表中找到相应表的最大值后加 一，进行插入，<br>也可能会存在并发处理，这个并发处理，我们可以采用lock线程的方式来避免，在生成此值的时，先Lock，取到值以后，再unLock出来，这样不会有两人同时生成了。<br>这比Max加一的速度要快多了。</p>
</li>
<li><p>缺点：<br>但同样存在一个问题：在与其他系统集成时，脱离了系统中的生成方法后，很麻 烦保证自制表中的最大值与导入后的保持一致，而且数字型都存在老数据的导入问题。<br>因此在“自制加一”中可以把主键设为字符型的。字符型的 自制加一我倒是蛮推荐的，应该字符型主键可以应付很多我们意想不到的情况。</p>
</li>
</ul>
<h1 id="主键的选取建议"><a href="#主键的选取建议" class="headerlink" title="主键的选取建议"></a>主键的选取建议</h1><p>此处的分布式主要指 分库分表。非应用分布式</p>
<ol>
<li><p>非分布式架构直接套用自增id做主键</p>
</li>
<li><p>小规模分布式架构用uuid或者自增id+步长做主键</p>
</li>
<li><p>大规模分布式架构用自建的id生成器做主键，参考twitter的[snowflake算法][2]</p>
</li>
</ol>
<p>（1）单实例或者单节点组：<br>经过500W、1000W的单机表测试，自增ID相对UUID来说，自增ID主键性能高于UUID，磁盘存储费用比UUID节省一半的钱。所以在单实例上或者单节点组上，使用自增ID作为首选主键。</p>
<p>（2）分布式架构场景：<br>20个节点组下的小型规模的分布式场景，为了快速实现部署，可以采用多花存储费用、牺牲部分性能而使用UUID主键快速部署；</p>
<p>20到200个节点组的中等规模的分布式场景，可以采用自增ID+步长的较快速方案。</p>
<p>200以上节点组的大数据下的分布式场景，可以借鉴类似twitter雪花算法构造的全局自增ID作为主键。</p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>11-InnoDB-事务隔离级别、ACID模型</title>
    <url>/articles/20200205/3890ccea.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。<br>理解为：事务对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。</p>
<p>同一行数据会有多个版本，某事务对该数据的修改并不会直接覆盖老版本，而是产生一个新版本和老版共存。<br>然后在该行追加两个虚拟的列，列就是进行数据操作的事务的ID（created_by_txn_id），是一个单调递增的ID；还有一个deleted_by_txn_id，将来用来做删除的。</p>
<p>那么在另一个事务在读取该行数据时，由具体的隔离级别来控制到底读取该行的哪个版本。同时，在读取过程中完全不加锁，除非用select * xxx for update强行加锁。</p>
<p>譬如read committed级别，每次读取，总是取事务ID最大的那个就好了。</p>
<p>对于Repeatable read，每次读取时，总是取事务ID小于等于当前事务的ID的那些数据记录。在这个范围内，如果某一数据有多个版本，则取最新的。</p>
<p>MVCC在mysql中的实现依赖的是undo log与read view</p>
<p>undo log记录某行数据的多个版本的数据；read view用来判断当前版本数据的可见性。</p>
<p>mysql就是用MVCC来实现读写分离不加锁的。</p>
<p>那么MVCC里多出来的那些版本的数据最终是要删除的，支持MVCC的数据库套路一般差不多，都会有一个后台线程来定时清理那些肯定没用的数据。只要一个数据的deleted_by_txn_id不为空，并且比当前还没结束的事务ID最小的一个还小，该数据就可以被清理掉了。在PostgreSQL中，该清理任务叫“vacuum”，在Innodb中，叫做“purge”。</p>
<h1 id="InnoDB-事务隔离级别"><a href="#InnoDB-事务隔离级别" class="headerlink" title="InnoDB 事务隔离级别"></a>InnoDB 事务隔离级别</h1><p>InnoDB的多版本并发控制是基于事务隔离级别实现的，而事务隔离级别则是依托前面提到的 Undo Log 实现的。<br>当读取一个数据记录时，每个事务会使用一个读视图(Read View)，读视图用于控制事务能读取到的记录的版本。</p>
<p>InnoDB的事务隔离级别分为：Read UnCommitted，Read Committed，Repeatable Read以及Serializable。<br>其中Serializable是基于锁实现的串行化方式，严格来说不是事务可见性范畴。</p>
<ul>
<li>Read Uncommitted：未提交读也称为脏读，它读取的是当前最新修改的记录，即便这个修改最后并未生效。</li>
<li>Read Committed：提交读。它基于的是当前事务内的语句开始执行时的最大的事务ID。如果其他事务修改同一个记录，在没有提交前，则该语句读取的记录还是不会变。<br>但是这种情况会产生不可重复读，即一个事务内多次读取同一条记录可能得到不同的结果(该记录被其他事务修改并提交了)。</li>
<li>Repeatable Read：可重复读。它基于的是事务开始时的读视图，直到事务结束。不读取其他新的事务对该记录的修改，保证同一个事务内的可重复读取。<br>InnoDB提供了 next-key lock来解决幻读问题，不过在一些特殊场景下，可重复读还是可能出现幻读的情况。在实际开发中影响不大。</li>
</ul>
<h1 id="ACID-模型"><a href="#ACID-模型" class="headerlink" title="ACID 模型"></a>ACID 模型</h1><p>事务有 ACID 四个属性， InnoDB 是支持事务的，它实现 ACID 的机制如下：</p>
<h2 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h2><p>innodb的原子性主要是通过提供的事务机制实现，与原子性相关的特性有：</p>
<ul>
<li>Autocommit 设置。</li>
<li>COMMIT 和 ROLLBACK 语句(通过 Undo Log实现)。</li>
</ul>
<h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>innodb的一致性主要是指保护数据不受系统崩溃影响，相关特性包括：</p>
<ul>
<li>InnoDB 的双写缓冲区(doublewrite buffer)。</li>
<li>InnoDB 的故障恢复机制(crash recovery)。</li>
</ul>
<h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>innodb的隔离性也是主要通过事务机制实现，特别是为事务提供的多种隔离级别，相关特性包括：</p>
<ul>
<li>Autocommit设置。</li>
<li>SET ISOLATION LEVEL 语句。</li>
<li>InnoDB 锁机制。</li>
</ul>
<h2 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h2><p>innodb的持久性相关特性：</p>
<ul>
<li>Redo log。</li>
<li>双写缓冲功能。可以通过配置项 innodb_doublewrite 开启或者关闭。</li>
<li>配置 innodb_flush_log_at_trx_commit。用于配置innodb如何写入和刷新 redo 日志缓存到磁盘。默认为1，表示每次事务提交都会将日志缓存写入并刷到磁盘。innodb_flush_log_at_timeout 可以配置刷新日志缓存到磁盘的频率，默认是1秒。</li>
<li>配置 sync_binlog。用于设置同步 binlog 到磁盘的频率，为0表示禁止MySQL同步binlog到磁盘，binlog刷到磁盘的频率由操作系统决定，性能最好但是最不安全。为1表示每次事务提交前同步到磁盘，性能最差但是最安全。MySQL文档推荐是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置为 1。</li>
<li>操作系统的 fsync 系统调用。</li>
<li>UPS设备和备份策略等。</li>
</ul>
<p>参考资料<br><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html</a><br><a href="http://ourmysql.com/archives/1228" target="_blank" rel="noopener">http://ourmysql.com/archives/1228</a><br><a href="https://www.jianshu.com/p/d4cc0ea9d097" target="_blank" rel="noopener">https://www.jianshu.com/p/d4cc0ea9d097</a><br><a href="https://zhuanlan.zhihu.com/p/103487968?utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103487968?utm_source=wechat_session</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>10-存储引擎层-innodb框架-内存架构</title>
    <url>/articles/20200205/ddb6eda9.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>


<h1 id="InnoDB-内存中的结构"><a href="#InnoDB-内存中的结构" class="headerlink" title="InnoDB 内存中的结构"></a>InnoDB 内存中的结构</h1><p>参看原理图 03-存储引擎层、InnoDB 架构</p>
<p><img src="/images/post/db-mysql/innodb-struct.webp" alt=""></p>
<p>内存中的结构主要包括 Buffer Pool，Change Buffer、Adaptive Hash Index以及 Log Buffer 四部分。</p>
<p>如果从内存上来看，Change Buffer 和 Adaptive Hash Index 占用的内存都属于 Buffer Pool，Log Buffer占用的内存与 Buffer Pool独立。</p>
<p>缓冲池缓存的数据包括Page Cache、Change Buffer、Data Dictionary Cache等，通常 MySQL 服务器的 80% 的物理内存会分配给 Buffer Pool。</p>
<p>基于效率考虑，InnoDB中数据管理的最小单位为页，默认每页大小为16KB，每页包含若干行数据。为了提高缓存管理效率，InnoDB的缓存池通过一个页链表实现，很少访问的页会通过缓存池的 LRU 算法淘汰出去。</p>
<p>InnoDB 的缓冲池页链表分为两部分：New sublist(默认占5/8缓存池) 和 Old sublist(默认占3/8缓存池，可以通过 innodb_old_blocks_pct修改，默认值为 37)，</p>
<p>其中新读取的页会加入到 Old sublist的头部，而 Old sublist中的页如果被访问，则会移到 New sublist的头部。</p>
<p>缓冲池的使用情况可以通过 <code>show engine innodb status</code> 命令查看。其中一些主要信息如下：</p>
<p>由于MySQL不同版本采用InnoDB引擎版本不同，5.6后对show engine innodb status信息进行了优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL版本	InnoDB引擎版本</span><br><span class="line">5.1.x	1.0.x版本（官方称为InnoDB Plugin）</span><br><span class="line">5.5.x	5.5（1.1.x版本），InnoDB被Oracle收购后</span><br><span class="line">5.6.x	5.6（1.2.x版本）</span><br><span class="line">5.7.x	5.7</span><br><span class="line">8.0.x	8.0</span><br></pre></td></tr></table></figure>
<p>show engine innodb status显示的不是当前状态，而是过去某个时间范围内InnoDB存储引擎的状态。</p>
<p>向右拉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Per second averages calculated from the last 59 seconds</span><br></pre></td></tr></table></figure>
<p>在显示前端可看到以上信息，代表查询的信息为过去59秒内每2秒的平均值。</p>
<p>show engine innodb status主要包括以下几个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BACKGROUND THREAD	后台Master线程</span><br><span class="line">SEMAPHORES	信号量信息</span><br><span class="line">LATEST DETECTED DEADLOCK	最近一次死锁信息，只有产生过死锁才会有</span><br><span class="line">TRANSACTIONS	事物信息</span><br><span class="line">FILE I&#x2F;O	IO Thread信息</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX	INSERT BUFFER和自适应HASH索引</span><br><span class="line">LOG	日志</span><br><span class="line">BUFFER POOL AND MEMORY	BUFFER POOL和内存</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO	如果设置了多个BUFFER POOL实例，这里显示每个BUFFER POOL信息。可通过innodb_buffer_pool_instances参数设置</span><br><span class="line">ROW OPERATIONS	行操作统计信息</span><br><span class="line">END OF INNODB MONITOR OUTPU	输出结束语</span><br></pre></td></tr></table></figure>

<h2 id="Buffer-pool"><a href="#Buffer-pool" class="headerlink" title="Buffer pool"></a>Buffer pool</h2><p>查看：BUFFER POOL AND MEMORY</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992 # 分配给InnoDB缓存池的内存(字节)</span><br><span class="line">Dictionary memory allocated 102398  # 分配给InnoDB数据字典的内存(字节)</span><br><span class="line">Buffer pool size   8191 # 缓存池的页数目</span><br><span class="line">Free buffers       7893 # 缓存池空闲链表的页数目</span><br><span class="line">Database pages     298  # 缓存池LRU链表的页数目</span><br><span class="line">Modified db pages  0    # 修改过的页数目</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>Innodb的这个缓存区就是Innodb_buffer_pool，当读取数据时，就会先从缓存中查看是否数据的页（page）存在，不存在的话才去磁盘上检索，查到后缓存到这个pool里。<br>同理，插入、修改、删除也是先操作缓存里数据，之后再以一定频率更新到磁盘上。控制刷盘的机制，叫做Checkpoint。</p>
<p><img src="/images/post/db-mysql/innodb_buffer_pool.png" alt=""></p>
<p>注意，左边那两个不在Innodb_buffer_pool里，是另外一块内存。只不过大部分的内存都属于Innodb_buffer_pool的。</p>
<p>mysql安装后，默认pool的大小是128M，可以通过show variables like ‘innodb_buffer_pool%’;命令查看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer_pool%'</span>;</span><br><span class="line"><span class="comment"># innodb_buffer_pool_dump_at_shutdown	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_dump_now	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_filename	ib_buffer_pool</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_instances	8</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_abort	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_at_startup	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_now	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_size	134217728</span></span><br></pre></td></tr></table></figure>
<p>可以通过show global status like ‘%innodb_buffer_pool_pages%’;  查看已经被占用的和空闲的。共计8000多个page。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%innodb_buffer_pool_pages%'</span>;</span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_data	7167</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_dirty	0</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_flushed	120861</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_free	1024</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_misc	1</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_total	8192</span></span><br></pre></td></tr></table></figure>

<p>所以如果数据很多，而pool很小，那么性能就好不了。</p>
<p>理论上来说，如果你给pool的内存足够大，够装下所有数据，要访问的所有数据都在pool里，那么你的所有请求都是走内存，性能将是最好的，和redis类似。</p>
<p>官方建议pool的空间设置为物理内存的50%-75%。</p>
<p>在mysql5.7.5之后，可以在mysql不重启的情况下动态修改pool的size，如果你设置的pool的size超过了1G的话，应该再修改一下Innodb_buffer_pool_instances=N，将pool分成N个pool实例，将来操作的数据会按照page的hash来映射到不同的pool实例。</p>
<p>这样可以大幅优化多线程情况下，并发读取同一个pool造成的锁的竞争。</p>
<h3 id="缓冲区LRU淘汰算法"><a href="#缓冲区LRU淘汰算法" class="headerlink" title="缓冲区LRU淘汰算法"></a>缓冲区LRU淘汰算法</h3><p>当pool的大小不够用了，满了，就会根据LRU算法（最近最少使用）来淘汰老的页面。最频繁使用的页在LRU列表的前端，最少使用的页在LRU列表的尾端。淘汰的话，就首先释放尾端的页。</p>
<p>InnoDB的LRU和普通的不太一样，Innodb的加入了midpoint位置的概念。最新读取到的页，并不是直接放到LRU列表的头部的，而是放到midpoint位置。<br>这个位置大概是LRU列表的5/8处，该参数由innodb_old_blocks_pct控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_old_blocks_pct%&#39;;</span><br><span class="line">innodb_old_blocks_pct	37</span><br></pre></td></tr></table></figure>
<p>如37是默认值，表示新读取的页插入到LRU尾端37%的位置。在midpoint之后的列表都是old列表，之前的是new列表，可以简单理解为new列表的页都是最活跃的数据。</p>
<p>为什么不直接放头部？因为某些数据扫描操作需要访问的页很多，有时候这些页仅仅在本次查询有效，以后就不怎么用了，并不算是活跃的热点数据。那么真正活跃的还是希望放到头部去，这些新的暂不确定是否真正未来要活跃。所以，这可以理解为预热。还引入了一个参数innodb_old_blocks_time用来表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p>
<p>重要的查询命令可以看到这些信息，show engine innodb status;<br>Database pages表示LRU列表中页的数量，pages made young显示了LRU列表中页移动到前端的次数，Buffer pool hit rate表示缓冲池的命中率，100%表示良好，该值小于95%时，需要考虑是否因为全表扫描引起了LRU列表被污染。里面还有其他的参数，可以自行查阅一下代表什么意思。</p>
<h3 id="Pool的主要空间"><a href="#Pool的主要空间" class="headerlink" title="Pool的主要空间"></a>Pool的主要空间</h3><p>其实更多的、对性能影响更大的是读缓存。毕竟多数数据库是读多写少。</p>
<p>读缓存主要数据是索引页和数据页，如果要读取的数据在pool里没有，那就去磁盘读，读到后的新页放到pool的3/8位置，后续根据情况再决定是否放到LRU列表的头部。</p>
<p>注意，最小单位是页，哪怕只读一条数据，也会加载整个页进去。如果是顺序读的话，刚好又在同一个页里，譬如读了id=1的，那么再读id=2的时，大概率直接从缓存里读。 </p>
<h2 id="BACKGROUND-THREAD"><a href="#BACKGROUND-THREAD" class="headerlink" title="BACKGROUND THREAD"></a>BACKGROUND THREAD</h2><p>InnoDB存储引擎的核心操作大部分都集中在Mater Thread后台线程中。</p>
<p>MySQL5.5版本之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 846676 1_second, 846675 sleeps, 84665 10_second, 17 background, 17 flush</span><br><span class="line">srv_master_thread log flush and writes: 854189</span><br></pre></td></tr></table></figure>
<p>MySQL 5.6之后对Master Thread进行了优化，去除了sleeps的信息，srv_active为之前的每秒的循环，srv_idle为每10秒的的循环，srv_shutdown为停止的循环，通常为0，只在MySQL关闭时才会增加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 3911776 srv_active, 0 srv_shutdown, 309625 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 4221384</span><br></pre></td></tr></table></figure>
<p>上面可以看出主循环每10秒进行了309625次，每秒进行了3911776次，每10秒的操作符合1：10。</p>
<p>负载低的情况下日志缓冲刷盘次数，4221384 ≈ 3911776+309625。</p>
<p>根据循环次数可大概判断当前数据库负载情况。如果每秒循环次数少，每10秒次数多，证明当前负载很低；如果每秒循环次数多，每10秒次数少，远大于10：1，证明当前负载很高。</p>
<h2 id="SEMAPHORES"><a href="#SEMAPHORES" class="headerlink" title="SEMAPHORES"></a>SEMAPHORES</h2><p>当前等待线程的列表及事件计数器，可以评估当前负载情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 58961200</span><br><span class="line">OS WAIT ARRAY INFO: signal count 125268732</span><br><span class="line">Mutex spin waits 770371493, rounds 6482840874, OS waits 20699077</span><br><span class="line">RW-shared spins 0, rounds 115276716, OS waits 14655922</span><br><span class="line">RW-excl spins 0, rounds 987115172, OS waits 12384598</span><br><span class="line">RW-sx spins 40484350, rounds 419545112, OS waits 4476477</span><br><span class="line">Spin rounds per wait: 115276716.00 RW-shared, 987115172.00 RW-excl, 10.36 RW-sx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OS WAIT ARRAY INFO	reservation count：表示InnoDB产生了多少次OS WAIT；</span><br><span class="line">                    signal count：表示进入OS WAIT的线程被唤醒次数</span><br><span class="line">Mutex(5.7后去除)	spins：空转次数，通过innodb_sync_spin_loops控制，超过则转到OS waits；</span><br><span class="line">                spin waits：spin线程无法获取锁而进入Spin wait；</span><br><span class="line">                rounds：spin wait进行轮询检查mutexes的次数；</span><br><span class="line">                OS waits：线程放弃spin wait进入挂起状态。</span><br><span class="line">RW-shared	RW-shared 共享锁</span><br><span class="line">RW-excl	RW-excl 排他锁</span><br><span class="line">RW-sx	5.7后新增；RW-sx 共享排他锁</span><br><span class="line">Spin rounds per wait	rounds &#x2F; spins &#x3D; 值</span><br></pre></td></tr></table></figure>

<p>要明白InnoDB如何处理互斥量(Mutexes)，以及什么是两步获得锁(two-step approach)。</p>
<ol>
<li>首先进程试图获得一个锁，如果此锁被它人占用。它就会执行所谓的spin wait，即所谓循环的查询“锁被释放了吗？”。</li>
<li>如果在循环过程中，一直未得到锁释放的信息，则其转入OS WAIT，即所谓线程进入挂起(suspended)状态。</li>
<li>直到锁被释放后，通过信号(singal)唤醒线程。</li>
</ol>
<p>Spin wait的消耗远小于OSwaits。Spin wait利用cpu的空闲时间，检查锁的状态，OS Wait会有所谓content switch，从CPU内核中换出当前执行线程以供其它线程使用。</p>
<p>所以应尽量减少OS waits，可以通过innodb_sync_spin_loops参数来平衡spin wait和os wait。Mutex信息可通过show engine innodb mutex查看。</p>
<h2 id="LATEST-DETECTED-DEADLOCK"><a href="#LATEST-DETECTED-DEADLOCK" class="headerlink" title="LATEST DETECTED DEADLOCK"></a>LATEST DETECTED DEADLOCK</h2><p>记录最近一次死锁信息，只有产生过死锁才会有记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">190425 18:00:13</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 231E7C5DF, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1248, 3 row lock(s)</span><br><span class="line">MySQL thread id 1346996, OS thread handle 0x7fd968454700, query id 760545285 10.10.x.x app_user updating</span><br><span class="line">DELETE </span><br><span class="line">    FROM db_0.table_0</span><br><span class="line">    WHERE ORDER_ID IN (  456787464 , 456787465 )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DF lock_mode X waiting</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 231E7C5DD, ACTIVE 0 sec starting index read, thread declared inside InnoDB 1</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">5 lock struct(s), heap size 1248, 4 row lock(s)</span><br><span class="line">MySQL thread id 1348165, OS thread handle 0x7fd96669f700, query id 760545283 10.10.x.x app_user updating</span><br><span class="line">DELETE </span><br><span class="line">    FROM db_0.table_0</span><br><span class="line">    WHERE ORDER_ID IN (  456787464 , 456787465 )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DD lock_mode X locks rec but not gap</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;;</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DD lock_mode X waiting</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;;</span><br><span class="line">*** WE ROLL BACK TRANSACTION （1）</span><br></pre></td></tr></table></figure>

<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。正常死锁会自动释放，innodb有一个内在的死锁检测工具，</p>
<p>当死锁超过一定时间后，会回滚其中一个事务，innodb_lock_wait_timeout可配置死锁等待超时时间。</p>
<ul>
<li><p>死锁在两情况下最容易产生：</p>
</li>
<li><p>高并发同时操作同一条数据</p>
</li>
</ul>
<p>存在主键和辅助索引，加锁顺序相反</p>
<p>避免死锁方法即降低并发，操作数据时使加锁顺序相同。  </p>
<h2 id="TRANSACTIONS"><a href="#TRANSACTIONS" class="headerlink" title="TRANSACTIONS"></a>TRANSACTIONS</h2><p>包含了InnoDB事务(transaction)的统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 2409176</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 2409171 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 31</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421224214038352, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421224214044736, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421224214039264, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 2409171, ACTIVE 1549 sec fetching rows, thread declared inside InnoDB 3871</span><br><span class="line">mysql tables in use 1, locked 0</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">MySQL thread id 653597, OS thread handle 140289889908480, query id 2528936 127.0.0.1 root Sending data</span><br><span class="line">SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; * FROM &#96;table&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trx id counter	当前事物ID</span><br><span class="line">Purge done for trx&#39;s	正在清理掉的transaction ID</span><br><span class="line">History list length	记录了undo spaces内未清掉的事务个数，Purge的原则是记录没有被其它事务继续使用。</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION	每个session的事物状态</span><br></pre></td></tr></table></figure>
<p>当前活跃的事物状态为ACTIVE，事物的详细信息，包括线程ID、执行时间、用户、SQL等。正在使用1个表，涉及锁的表0个。</p>
<h2 id="FILE-I-O"><a href="#FILE-I-O" class="headerlink" title="FILE I/O"></a>FILE I/O</h2><p>在InnoDB中大量使用了AIO（Async IO）来处理IO 请求，IO Thread主要是负责这些IO请求的回调处理，通过调用fsync()函数协调内存与磁盘之间的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for completed aio requests (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for completed aio requests (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 10 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 11 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 12 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 13 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 14 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 15 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 16 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 17 state: waiting for completed aio requests (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0, 0, 0, 0, 0] , aio writes: [0, 0, 0, 0, 0, 0, 0, 0] ,</span><br><span class="line">ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">15234061 OS file reads, 304461183 OS file writes, 73899457 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.24 writes&#x2F;s, 0.17 fsyncs&#x2F;s</span><br></pre></td></tr></table></figure>
<p>InnoDB1.0版本之前有4个IO线程，1.1后做了优化，Purge Thread从Master Thread独立出来，Purge Cleaner Thread从InnoDB1.2版本引入，都是为了减轻Master Thread的工作，提高CPU利用率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert buffer thread	合并插入缓冲，insert buffer维护非唯一辅助索引</span><br><span class="line">log thread	负责异步刷新事物日志</span><br><span class="line">read thread	预读，innodb_read_io_threads 默认4</span><br><span class="line">write thread	刷新脏页缓冲，innodb_write_io_threads 默认4</span><br><span class="line">purge thread	回收已经使用并分配的undo页，可设置多个</span><br><span class="line">purge cleaner Thread	刷新脏页</span><br></pre></td></tr></table></figure>
<p>显示各个I/O thread的pending operations,pending的log和buffer pool thread的fsync()调用；</p>
<ul>
<li>aio：代表的是异步IO(asynchronous I/O)；</li>
<li>OS file：显示了reads writes fsync() 调用次数。</li>
</ul>
<h2 id="Change-Buffer-INSERT-BUFFER-AND-ADAPTIVE-HASH-INDEX"><a href="#Change-Buffer-INSERT-BUFFER-AND-ADAPTIVE-HASH-INDEX" class="headerlink" title="(Change Buffer)INSERT BUFFER AND ADAPTIVE HASH INDEX"></a>(Change Buffer)INSERT BUFFER AND ADAPTIVE HASH INDEX</h2><h3 id="插入缓冲insert-buffer"><a href="#插入缓冲insert-buffer" class="headerlink" title="插入缓冲insert buffer"></a>插入缓冲insert buffer</h3><p>它是buffer_pool的一部分，用来做insert操作时的缓存的。</p>
<p>如b+tree，以及数据的存放格式，那么当新插入数据时，倘若直接就插入到b+ tree里，那么可能会比较缓慢，需要读取、找到要插入的地方，还要做树的扩容、校验、寻址、落盘等等一大堆操作。</p>
<p>在Innodb中，主键是行唯一标识，如果你的插入顺序是按照主键递增进行插入的，那么还好，它不需要磁盘的随机读取，找到了页，就能插，这样速度还是可以的。</p>
<p>然而，如果你的表上有多个别的索引（二级索引），那么当插入时，对于那个二级索引树，就不是顺序的了，它需要根据自己的索引列进行排序，这就需要随机读取了。<br>二级索引越多，那么插入就会越慢，因为要寻找的树更多了。还有，如果你频繁地更新同一条数据，倘若也频繁地读写磁盘，那就不合适了，最好是将多个对同一page的操作，合并起来，统一操作。</p>
<p>所以，Innodb设计了Insert Buffer，对于非聚簇索引的插入、更新操作，不是每次都插入到索引页中，而是先判断该二级索引页是否在缓冲池中，<br>若在，就直接插入，若不在，则先插入一个insert buffer里，再以一定的频率进行真正的插入到二级索引的操作，这时就可以聚合多个操作，一起去插入，就能提高性能。</p>
<p>然而，insert buffer需要同时满足两个条件时，才会被使用：</p>
<ul>
<li>索引是二级索引</li>
<li>索引不是unique</li>
</ul>
<p>注意，索引不能是unique，因为在插入缓冲时，数据库并不去查询索引页来判断插入的记录的唯一性，如果查找了，就又会产生随机读取。</p>
<p>insert buffer的问题是，在写密集的情况下，内存会占有很大，默认最大可以占用1/2的Innodb_buffer_pool的空间。<br>很明显，如果占用过大，就会对其他的操作有影响，譬如能缓存的查询页就变少了。可以通过IBUF_POOL_SIZE_PER_MAX_SIZE来进行控制。</p>
<h3 id="变更缓冲change-buffer"><a href="#变更缓冲change-buffer" class="headerlink" title="变更缓冲change buffer"></a>变更缓冲change buffer</h3><p>INSERT BUFFER即合并插入缓存，从innodb 1.0.x(MySQL5.5 之前)版本开始引入Change Buffer，是INSERT BUFFER升级版，即MySQL 5.1.x以上版本都支持，<br>不仅包括INSERT BUFFER，还包括UPDATE BUFFER、DELETE BUFFER、PURGE BUFFER。</p>
<p>也就是所有DML操作，都会先进缓冲区，进行逻辑操作，后面才会真正落地。</p>
<p>通过参数Innodb_change_buffering开始查看修改各种buffer的选项。可选值有inserts\deletes\purges\changes\all\none。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'Innodb_change_buffering%'</span>;</span><br><span class="line"><span class="comment">-- innodb_change_buffering	all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'Innodb_change_buffer_max_size'</span>;</span><br><span class="line"><span class="comment">-- innodb_change_buffer_max_size	25</span></span><br></pre></td></tr></table></figure>
<p>默认是所有操作都入buffer，参数是控制内存大小的，25代表最多使用1/4的缓冲池空间。</p>
<p>通常来说，InnoDB辅助索引不同于聚集索引的顺序插入，如果每次修改二级索引都直接写入磁盘，则会有大量频繁的随机IO。<br>Change buffer 的主要目的是将对 非唯一 辅助索引页的操作缓存下来，以此减少辅助索引的随机IO，并达到操作合并的效果。它会占用部分Buffer Pool 的内存空间。<br>在 MySQL5.5 之前 Change Buffer其实叫 Insert Buffer，最初只支持 insert 操作的缓存，随着支持操作类型的增加，改名为 Change Buffer。<br>如果辅助索引页已经在缓冲区了，则直接修改即可；如果不在，则先将修改保存到 Change Buffer。<br>Change Buffer的数据在对应辅助索引页读取到缓冲区时合并到真正的辅助索引页中。Change Buffer 内部实现也是使用的 B+ 树。</p>
<p>查看Change Buffer信息也可以通过 show engine innodb status 命令。更多信息见 <a href="https://mysqlserverteam.com/the-innodb-change-buffer/" target="_blank" rel="noopener">mysqlserverteam: the-innodb-change-buffer</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1356, free list len 149402, seg size 149404, 2004231 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1373793, delete mark 316276978, delete 5341003</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 2 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">193.03 hash searches&#x2F;s, 713.40 non-hash searches&#x2F;s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ibuf：size	已经合并页的数量</span><br><span class="line">free list len	空闲列表长度</span><br><span class="line">seg size	Insert Buffer大小</span><br><span class="line">merges	合并次数</span><br><span class="line">merged operations 	</span><br><span class="line">                    Change Buffer中每个操作次数；</span><br><span class="line">                    insert代表Insert Buffer;</span><br><span class="line">                    delete mark代表Delete Buffer；</span><br><span class="line">                    delete代表Purge Buffer;</span><br><span class="line">discarded operations	Change Buffer中无需合并的次数</span><br><span class="line">hash searches&#x2F;s	通过hash索引查询</span><br><span class="line">non-hash searches&#x2F;s	不能通过hash索引查询</span><br></pre></td></tr></table></figure>

<p>可以通过 innodb_change_buffering 配置是否缓存辅助索引页的修改，默认为 all，即缓存 insert/delete-mark/purge 操作<br>(注：MySQL 删除数据通常分为两步，第一步是delete-mark，即只标记，而purge才是真正的删除数据)。</p>
<p><img src="/images/post/db-mysql/changebuffer.webp" alt=""></p>
<h3 id="ADAPTIVE-HASH-INDEX"><a href="#ADAPTIVE-HASH-INDEX" class="headerlink" title="ADAPTIVE HASH INDEX"></a>ADAPTIVE HASH INDEX</h3><p>自适应哈希索引(AHI)查询非常快，一般时间复杂度为 O(1)，相比 B+ 树通常要查询 3~4次，效率会有很大提升。</p>
<p>innodb 通过观察索引页上的查询次数，如果发现建立哈希索引可以提升查询效率，则会自动建立哈希索引，称之为自适应哈希索引，不需要人工干预，可以通过 innodb_adaptive_hash_index 开启，MySQL5.7 默认开启。</p>
<p>考虑到不同系统的差异，有些系统开启自适应哈希索引可能会导致性能提升不明显，而且为监控索引页查询次数增加了多余的性能损耗，</p>
<p> MySQL5.7 更改了 AHI 实现机制，每个 AHI 都分配了专门分区，通过 innodb_adaptive_hash_index_parts配置分区数目，默认是8个，如前一节命令列出所示。</p>
<p>通过(Change Buffer)INSERT BUFFER 可以看到自适应哈希索引大小、使用情况、每秒使用自适应哈希索引搜索情况。<br>自适应HASH索引，由INNODB存储引擎控制，只适合等值查询，不适合范围查询。</p>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><p>事物日志的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 33859450169594</span><br><span class="line">Log flushed up to   33859450169564</span><br><span class="line">Pages flushed up to 33859450169210</span><br><span class="line">Last checkpoint at  33859450169201</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">15044267 log i&#x2F;o&#39;s done, 0.10 log i&#x2F;o&#39;s&#x2F;second</span><br></pre></td></tr></table></figure>
<p>InnoDB事物采用Write-Ahead log策略，即事物在提交时，先写重做日志，在修改页。</p>
<p>Write-Ahead Log：如果一个页在写入磁盘时，必须先将内存中小于该页LSN的日志先写入到磁盘中。</p>
<p>重做日志有LSN、每个页有LSN、Checkpoint也有LSN。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Log sequence number	最新产生的日志序列号</span><br><span class="line">Log flushed up to	已刷到磁盘的重做日志的日志号</span><br><span class="line">Pages flushed up to	已刷到磁盘的页的日志号</span><br><span class="line">Last checkpoint at	最后一次检查点位置，数据和日志一致的状态</span><br><span class="line">pending	当前挂起的日志读写操作</span><br></pre></td></tr></table></figure>
<p>LSN记录的是重做日志的总量，单位是字节。以下三种情况会将重做日志缓存刷到重做日志文件：</p>
<ul>
<li><p>Master Thread 每秒刷重做日志缓存到重做日志文件</p>
</li>
<li><p>innodb_flush_log_at_trx_commit=1时，控制Log Buffer如何写入和刷到磁盘，每次事务提交刷重做日志缓存到重做日志文件</p>
</li>
<li><p>重做日志缓冲池剩余空间小于1/2时，刷重做日志缓存到重做日志文件</p>
</li>
</ul>
<p>innodb_flush_log_at_trx_commit 说明：</p>
<ul>
<li>默认为1，表示每次事务提交都会将 Log Buffer 写入操作系统缓存，并调用配置的 “flush” 方法将数据写到磁盘。设置为 1 因为频繁刷磁盘效率会偏低，但是安全性高，最多丢失 1个 事务数据。而设置为 0 和 2 则可能丢失 1秒以上 的事务数据。</li>
<li>为 0 则表示每秒才将 Log Buffer 写入内核缓冲区并调用 “flush” 方法将数据写到磁盘。</li>
<li>为 2 则是每次事务提交都将 Log Buffer写入内核缓冲区，但是每秒才调用 “flush” 将内核缓冲区的数据刷到磁盘。</li>
</ul>
<p>注意，除了 MySQL 的缓冲区，操作系统本身也有内核缓冲区。</p>
<p>Log Buffer是 重做日志在内存中的缓冲区，大小由 innodb_log_buffer_size 定义，默认是 16M。</p>
<p>一个大的 Log Buffer可以让大事务在提交前不必将日志中途刷到磁盘，可以提高效率。如果你的系统有很多修改很多行记录的大事务，可以增大该值。</p>
<p><img src="/images/post/db-mysql/innodb_flush_log_at_trx_commit.png" alt=""></p>
<p>innodb_flush_log_at_timeout 可以配置刷新日志缓存到磁盘的频率，默认是1秒。注意刷磁盘的频率并不保证就正好是这个时间，可能因为MySQL的一些操作导致推迟或提前。<br>而这个 “flush” 方法并不是C标准库的 fflush 方法(fflush是将C标准库的缓冲写到内核缓冲区，并不保证刷到磁盘)，它通过 innodb_flush_method 配置的，默认是 fsync，即日志和数据都通过 fsync 系统调用刷到磁盘。</p>
<p>可以发现，InnoDB 基本每秒都会将 Log buffer落盘。而InnoDB中使用的 redo log 和 undo log，它们是分开存储的。<br>redo log在内存中有log buffer，在磁盘对应ib_logfile文件。而undo log是记录在表空间ibd文件中的，InnoDB为undo log会生成undo页，对undo log本身的操作（比如向undo log插入一条记录），也会记录redo log，因此undo log并不需要马上落盘。<br>而 redo log则通常会分配一块连续的磁盘空间，然后先写到log buffer，并每秒刷一次磁盘。redo log必须在数据落盘前先落盘(Write Ahead Log)，从而保证数据持久性和一致性。而数据本身的修改可以先驻留在内存缓冲池中，再根据特定的策略定期刷到磁盘。</p>
<h2 id="BUFFER-POOL-AND-MEMORY"><a href="#BUFFER-POOL-AND-MEMORY" class="headerlink" title="BUFFER POOL AND MEMORY"></a>BUFFER POOL AND MEMORY</h2><p>innodb_buffer_pool包含数据页、索引页、undo页、insert buffer、数据字典、自适应哈希索引、锁信息等。数据库缓冲池是通过LRU列表管理的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 19789774848</span><br><span class="line">Dictionary memory allocated 3944999</span><br><span class="line">Buffer pool size   1179504</span><br><span class="line">Free buffers       8192</span><br><span class="line">Database pages     1116347</span><br><span class="line">Old database pages 411925</span><br><span class="line">Modified db pages  3</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 74514305, not young 649973267</span><br><span class="line">0.21 youngs&#x2F;s, 0.17 non-youngs&#x2F;s</span><br><span class="line">Pages read 15233915, created 7356668, written 264739684</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.10 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 1116347, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[48]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total large memory allocated	为innodb 分配的总内存数(byte)</span><br><span class="line">Dictionary memory allocated	为innodb数据字典分配的内存数(byte)</span><br><span class="line">Buffer pool size	innodb_buffer_pool的页数量</span><br><span class="line">Free buffers	lru列表中的空闲页数量</span><br><span class="line">Database pages	lru列表中的非空闲页数量</span><br><span class="line">Old database pages	old子列表的页数量</span><br><span class="line">Modified db pages	脏页的数量</span><br><span class="line">Pending reads	挂起读的数量</span><br></pre></td></tr></table></figure>
<p>可以看到当前Buffer Pool Size共有1179504页，即1179504*16K。新读取到的页默认插入LRU列表的5/8的位置。</p>
<p>此值由innodb_old_blocks_pct控制，即前5/8称为new list，后面3/8的称为old list。</p>
<p>Pages made young 显示LRU列表中old list移到new list的次数，not young显示仍在old list的次数。</p>
<p>这两个值受innodb_old_blocks_time影响，此值为微秒。如果old list中超过30微秒不再读取，则记录not young，反之记录为Pages made young。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show global variables like &#39;%blocks%&#39;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| innodb_old_blocks_pct  | 37    |</span><br><span class="line">| innodb_old_blocks_time | 30    |</span><br><span class="line">+------------------------+-------+</span><br></pre></td></tr></table></figure>
<p>youngs/s,non-youngs/s，表示每秒这两类操作的次数。</p>
<p>Pages read,created,written，表示innodb被读取，创建，写入了多少页及每秒的次数。</p>
<p>Buffer pool hit rate，表示缓冲池命中率，如果低于95%需要具体排查。</p>
<p>Pages read ahead，表示页面预读，随机预读的每秒页数。</p>
<p>LRU中包含unzip_LRU，unzip_LRU是管理非16KB的压缩表。</p>
<h2 id="INDIVIDUAL-BUFFER-POOL-INFO"><a href="#INDIVIDUAL-BUFFER-POOL-INFO" class="headerlink" title="INDIVIDUAL BUFFER POOL INFO"></a>INDIVIDUAL BUFFER POOL INFO</h2><p>可通过innodb_buffer_pool_instances 来配置多个缓冲池实例，默认为1。可减少数据库内部资源竞争，增加并发处理能力。如果分配多个缓冲池实例，每个缓冲池大小为 innodb_buffer_pool_size / innodb_buffer_pool_instances 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   147438</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     139530</span><br><span class="line">Old database pages 51486</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 8790743, not young 77467460</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 1856892, created 916430, written 30727167</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 139530, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[6]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">---BUFFER POOL 3</span><br></pre></td></tr></table></figure>
<p>可以通过information_schema.INNODB_BUFFER_POOL_STATS视图查看每个buffer_pool实例的信息，MySQL默认一个page大小为16K，</p>
<p>可以得出POOL_SIZE * innodb_buffer_pool_instances * 16K = innodb_buffer_pool_size。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(root@localhost) [information_schema] &gt;select POOL_ID,POOL_SIZE,FREE_BUFFERS,DATABASE_PAGES,OLD_DATABASE_PAGES,MODIFIED_DATABASE_PAGES,PAGES_MADE_YOUNG,PAGES_NOT_MADE_YOUNG from information_schema.INNODB_BUFFER_POOL_STATS;</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br><span class="line">| POOL_ID | POOL_SIZE | FREE_BUFFERS | DATABASE_PAGES | OLD_DATABASE_PAGES | MODIFIED_DATABASE_PAGES | PAGES_MADE_YOUNG | PAGES_NOT_MADE_YOUNG |</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br><span class="line">|       0 |     90112 |            0 |          90109 |              33279 |                       0 |            18064 |            132278807 |</span><br><span class="line">|       1 |     90112 |            0 |          90109 |              33282 |                       0 |            18342 |            132086061 |</span><br><span class="line">|       2 |     90112 |            0 |          90110 |              33282 |                       0 |            17631 |            132149779 |</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br></pre></td></tr></table></figure>
<p>详细说明同上。</p>
<h2 id="ROW-OPERATIONS"><a href="#ROW-OPERATIONS" class="headerlink" title="ROW OPERATIONS"></a>ROW OPERATIONS</h2><p>显示了row 操作及其他一些统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;444943, Main thread ID&#x3D;139899621590784, state: sleeping</span><br><span class="line">Number of rows inserted 172887566, updated 227534242, deleted 56676133, read 709667077</span><br><span class="line">8.77 inserts&#x2F;s, 8.04 updates&#x2F;s, 0.00 deletes&#x2F;s, 10.92 reads&#x2F;s</span><br></pre></td></tr></table></figure>
<p>queries，表示innodb内核中有多少个线程，队列中有多少个线程。</p>
<p>read views open inside InnoDB，表示有多少个read view 被打开，一个read view 包含事物开始点数据库内容的MVCC快照。</p>
<p>Process ID=444943，表示内核的主线程状态。</p>
<p>Number of rows inserted、updated、deleted、read，表示多少行被插入，更新和删除，读取及每秒信息，可用于监控。</p>
<p>可通过以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(root@localhost) [(none)] &gt;show global status like &#39;Innodb_rows_%&#39;;</span><br><span class="line">+----------------------+-----------+</span><br><span class="line">| Variable_name        | Value     |</span><br><span class="line">+----------------------+-----------+</span><br><span class="line">| Innodb_rows_deleted  | 56676133  |</span><br><span class="line">| Innodb_rows_inserted | 172887566 |</span><br><span class="line">| Innodb_rows_read     | 709667077 |</span><br><span class="line">| Innodb_rows_updated  | 227534242 |</span><br><span class="line">+----------------------+-----------+</span><br><span class="line"></span><br><span class="line">(root@localhost) [(none)] &gt;show global status like &#39;Uptime&#39;;</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Variable_name | Value   |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Uptime        | 1757270 |</span><br><span class="line">+---------------+---------+</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB信息结束语。"><a href="#InnoDB信息结束语。" class="headerlink" title="InnoDB信息结束语。"></a>InnoDB信息结束语。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">如果看不到这行输出，可能是有大量事务或者有一个大的死锁截断了输出信息。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>09-存储引擎层-innodb框架-索引-使用B+树组织数据、实例查看数据</title>
    <url>/articles/20200205/190e6be3.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>


<h2 id="mysql-InnoDB-B-树组织数据、查询数据"><a href="#mysql-InnoDB-B-树组织数据、查询数据" class="headerlink" title="mysql InnoDB-B+树组织数据、查询数据"></a>mysql InnoDB-B+树组织数据、查询数据</h2><p>在MySQL中，InnoDB页的大小默认是16k，当然也可以通过参数设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_page_size&#39;;</span><br><span class="line">-- innodb_page_size	16384</span><br></pre></td></tr></table></figure>
<h3 id="方式一、直接按页存储【假想】"><a href="#方式一、直接按页存储【假想】" class="headerlink" title="方式一、直接按页存储【假想】"></a>方式一、直接按页存储【假想】</h3><p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是 1K，那么一个页可以存放 16 行这样的数据。</p>
<p>如果数据库按这样的方式存储，那么查找数据就成为一个问题。不知道要查找的数据存在哪个页中，每次查询都需要把所有的页遍历一遍，时间复杂度为 n。</p>
<h3 id="方式二、用-B-树的方式组织数据【实际】"><a href="#方式二、用-B-树的方式组织数据【实际】" class="headerlink" title="方式二、用 B+ 树的方式组织数据【实际】"></a>方式二、用 B+ 树的方式组织数据【实际】</h3><p>示例一、2层b+ tree</p>
<p><img src="source/images/post/db-mysql/ecengbtree.png" alt=""></p>
<p>这个树只有2层，首先每个page都有自己的唯一编号，将来就要通过编号来找对应的page。根页做为一个第一层的索引页，里面是不存在叶子数据（行数据）的，只存放Key，同时还包含了pageNo信息，用来将来去找对应的页。</p>
<p>所有的记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接（双向指针）。所以查询时，无论正序倒序，其实是一样的扫描速度。</p>
<p>每一层的最左边节点页面的最左边位置，会有一个Min记录，该记录由2部分组成，第一部分就是一个Min标记，代表这就是 最小值；第二部分是一个pageNo指针，指向下一层中最左边的记录。注意看根页的Min记录，就是这样的。而33号page的Min记录由于没有下一层了，所以没有pageNo指针。</p>
<p>可以看到，上一层的Key，在下一层对应的page中，也会重复存在，譬如Key=10的记录。但是，每个page，只有第一条数据会和上层有重复，其他的不会有重复。</p>
<p>每一个page还会有一个最大记录和最小记录，用来标记该page的边界，便于查询。</p>
<p>由此结构可以看到，做一次查询的耗时，每一层只需要一次内存级的二分查找，定位后就进入下一层，再一次二分查找。</p>
<p>譬如查询Key=11，那么可以定位到56号page，因为11小于78号page的最小值，之后找到56号page，在做一次二分查询。就能找到11。2层只需要2次IO，就能找到一条数据。3层3次，之前已经说过，3层和4层分别能存多少数据，这个查询效率其实是非常高的。</p>
<p>通过这样的方式，我们就知道了一颗树是怎么构成的了。</p>
<p>示例解说：</p>
<ol>
<li>B+树-组织数据<br><img src="/images/post/db-mysql/001/index-01.jpg" alt=""></li>
</ol>
<p>先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解这里一个页中只存放 3 条记录，实际情况可以存放很多）。</p>
<p>除了存放数据的页以外，还有存放键值+指针的页，如图中 page number=3 的页，该页存放键值和指向数据页的指针，这样的页由 N 个键值+指针组成。</p>
<p>当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。  </p>
<ol start="2">
<li>B+树-查询数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
id 是主键，我们通过这棵 B+ 树来查找，首先找到根页，怎么知道 user 表的根页在哪呢？</li>
</ol>
<p>其实每张表的根页位置在表空间文件中是固定的，即 page number=3 的页（后续说明）。</p>
<p>找到根页后通过二分查找法，定位到 id=5 的数据应该在指针 P5 指向的页中，那么进一步去 page number=5 的页中查找，同样通过二分查询法即可找到 id=5 的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5    zhao2   27</span><br></pre></td></tr></table></figure>
<p>小结：  InnoDB 中主键索引 B+ 树是如何组织数据、查询数据</p>
<p>InnoDB 存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在 B+ 树中叶子节点存放数据，非叶子节点存放键值+指针。</p>
<p>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。</p>
<h3 id="Page内详细结构"><a href="#Page内详细结构" class="headerlink" title="Page内详细结构"></a>Page内详细结构</h3><p><img src="/images/post/db-mysql/page.png" alt=""></p>
<p>page内的存储，共16K的空间,分为几个部分，文件管理头信息、页面头信息、页面尾信息、最小记录最大记录、用户记录、可重用空间、未使用空间、页面槽信息。</p>
<p>用户记录就是行数据，可重用就是曾经被分配过数据后来被删了，未使用就是没分配过的空间。</p>
<h4 id="文件管理头信息"><a href="#文件管理头信息" class="headerlink" title="文件管理头信息"></a>文件管理头信息</h4><p>它占用38个字节，里面存储的东西主要有:</p>
<ul>
<li>该页面的checkSum信息，校验文件是否被损坏的；</li>
<li>该页面在当前表空间的页面号（pageNo）；</li>
<li>当前页面的上一个页面的pageNo；</li>
<li>下一个页面的pageNo；</li>
<li>当前页面最后一次被修改时，对应日志的LSN值，与后面的日志系统有关；</li>
<li>当前页面的类型；</li>
<li>只有第0号页面会存一个LSN值，用来存储当前Innodb引擎最大的被flush的LSN值，将来做checkPoint时用；</li>
<li>标记属于哪个表空间的（避免多个表空间，有相同的pageNo的页）</li>
</ul>
<h4 id="页面头信息"><a href="#页面头信息" class="headerlink" title="页面头信息"></a>页面头信息</h4><ul>
<li>槽的个数；</li>
<li>未使用空间的指针；</li>
<li>存储的记录数，包括最大最小记录的管理；</li>
<li>已被删除的记录的链表的首指针；</li>
<li>已被标记删除的记录数；</li>
<li>最后被插入的记录的位置；</li>
<li>当前节点在b+ tree处于第几层，叶子就是0，往上就加1；</li>
</ul>
<h4 id="页面尾部："><a href="#页面尾部：" class="headerlink" title="页面尾部："></a>页面尾部：</h4><ul>
<li>这8个字节还是用来做完整性校验的。</li>
</ul>
<h4 id="页面重组"><a href="#页面重组" class="headerlink" title="页面重组"></a>页面重组</h4><p>一个页面会频繁的插入删除，在插入过程中，都会去已经删除的可重用链表去找合适的空间，如果放得下，就会放进去，放不下，另寻空间。<br>时间一长，就会有空间碎片产出，譬如累计的空闲空间还有很多呢，但就是找不到能放下一条新数据的合适空间。</p>
<p>那么带来的问题很明显，page增加，每个page存储数据量下降，磁盘占用很大，但存的数据并不多，IO数增加，性能下降。</p>
<p>如果是一张表的话，如果大量数据被删，就需要及时处理回收空间，可以通过一个空的alter命令，如alter table tablename engine innodb，就可以将表的空间给回收重组了。</p>
<p>对于页面也一样，在数据库向某一个页面插入时，如果找不到大小合适的空间，就会做一次页面重组操作。</p>
<p>重组的方式是，新建一个buffer pool页面，然后将老页面的数据一条一条插入到新页面，插入完成后，将老页面空间释放掉，再修改指针位置，指向新页面。</p>
<h2 id="mysql-InnoDB-B-树存储数据量"><a href="#mysql-InnoDB-B-树存储数据量" class="headerlink" title="mysql InnoDB-B+树存储数据量"></a>mysql InnoDB-B+树存储数据量</h2><h3 id="数据量估算"><a href="#数据量估算" class="headerlink" title="数据量估算"></a>数据量估算</h3><p><strong>以B+ 树高为 2为例计算</strong></p>
<p>假设 B+ 树高为 2，即存在一个根节点和若干个叶子节点，那么这棵 B+ 树的存放总记录数为：根节点指针数*单个叶子节点记录行数。</p>
<p>上文已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为 1K，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。</p>
<p>那么现在需要计算出非叶子节点能存放多少指针？假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。</p>
<p>一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。</p>
<p>可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。</p>
<p>根据同样的原理可以算出一个高度为 3 的 B+ 树可以存放：1170<em>1170</em>16=21902400 条这样的记录。</p>
<p>所以在 InnoDB 中 B+ 树高度一般为 1-3 层，它就能满足千万级的数据存储。</p>
<p>在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。</p>
<h3 id="InnoDB-主键索引-B-树的高度"><a href="#InnoDB-主键索引-B-树的高度" class="headerlink" title="InnoDB 主键索引 B+ 树的高度"></a>InnoDB 主键索引 B+ 树的高度</h3><p>上面通过推断得出 B+ 树的高度通常是 1-3，下面我们从另外一个侧面证明这个结论。</p>
<p>在 InnoDB 的表空间文件中，约定 page number 为 3 的代表主键索引的根页，而在根页偏移量为 64 的地方存放了该 B+ 树的 page level。</p>
<p>如果 page level 为 1，树高为 2，page level 为 2，则树高为 3。即 B+ 树的高度=page level+1；</p>
<p>查询系统表：page level。</p>
<p>在实际操作之前，可以通过 InnoDB 元数据表确认主键索引根页的 page number 为 3，也可以从《InnoDB 存储引擎》这本书中得到确认：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO</span><br><span class="line">FROM</span><br><span class="line">    information_schema.INNODB_SYS_INDEXES a,</span><br><span class="line">    information_schema.INNODB_SYS_TABLES b</span><br><span class="line">WHERE a.table_id &#x3D; b.table_id AND a.space &lt;&gt; 0;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blockchain_manager&#x2F;member	    PRIMARY	    22	3	6	3</span><br><span class="line">blockchain_manager&#x2F;member_group	PRIMARY	    23	3	7	3</span><br><span class="line">blockchain_manager&#x2F;permission	PRIMARY	    24	3	8	3</span><br><span class="line">blockchain_manager&#x2F;permission	idx_group	56	0	8	4</span><br></pre></td></tr></table></figure>
<p>可以看出数据库 blockchain_manager 下的 member 表、member 表、permission表主键索引根页的 page number 均为 3，而其他的二级索引 page number 为 4。</p>
<p>关于二级索引与主键索引的区别请参考 MySQL 相关书籍，</p>
<h2 id="实际操作查看"><a href="#实际操作查看" class="headerlink" title="实际操作查看"></a>实际操作查看</h2><h3 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h3><h4 id="测试表"><a href="#测试表" class="headerlink" title="测试表"></a>测试表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;table5hang&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<p>修改表名，依次创建 table15w、table500w、table1000w</p>
<h4 id="测试数据-添加"><a href="#测试数据-添加" class="headerlink" title="测试数据 添加"></a>测试数据 添加</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter //  <span class="comment">#定义标识符为双斜杠</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_procedure ; <span class="comment">#如果存在 my_procedure 存储过程则删除</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_procedure () <span class="comment">#创建无参存储过程</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> n <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> ; <span class="comment"># 申明变量</span></span><br><span class="line">    <span class="keyword">set</span> @execSql=<span class="string">'insert into table5hang(username,age)  values '</span>;</span><br><span class="line">    <span class="keyword">set</span> @execdata = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    WHILE n &lt; 6 DO</span><br><span class="line">        <span class="keyword">set</span> @execdata=<span class="keyword">concat</span>(@execdata,<span class="string">"("</span>,<span class="string">"'name-"</span>,n,<span class="string">"',"</span>,n%<span class="number">100</span>,<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">        if n%5=0</span><br><span class="line">        then</span><br><span class="line">            <span class="keyword">set</span> @execSql = <span class="keyword">concat</span>(@execSql,@execdata,<span class="string">";"</span>);</span><br><span class="line">            <span class="comment">#select @execSql;</span></span><br><span class="line">            <span class="keyword">prepare</span> stmt <span class="keyword">from</span> @execSql;</span><br><span class="line">            <span class="keyword">execute</span> stmt;</span><br><span class="line">            <span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br><span class="line">            <span class="keyword">commit</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">set</span> @execSql=<span class="string">'insert into table5hang (username,age)  values '</span>;</span><br><span class="line">            <span class="keyword">set</span> @execdata = <span class="string">''</span>;</span><br><span class="line">        ELSE</span><br><span class="line">            <span class="keyword">set</span> @execdata = <span class="keyword">concat</span>(@execdata,<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">SET</span> n = n + <span class="number">1</span> ; <span class="comment">#循环一次,i加一</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span> ; <span class="comment">#结束while循环</span></span><br><span class="line">    <span class="comment">#select count(*) from test_table;</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> my_procedure(); <span class="comment">#调用存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_procedure ; <span class="comment">#如果存在 my_procedure 存储过程则删除</span></span><br></pre></td></tr></table></figure>
<p>插入数据，依次修改表名：table15w、table500w、table1000w 以及插入条数</p>
<p>根据性能 500w、1000w 数据量的需要分批插入。</p>
<p>查看文件结构，mysql每次建库，会在data下创建以库名为名的文件夹，内部文件是表名，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-rw----  1    54B  1 31 11:36 db.opt</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table1000w.frm</span><br><span class="line">-rw-rw----  1   460M  1 31 12:41 table1000w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table15w.frm</span><br><span class="line">-rw-rw----  1    15M  1 31 11:54 table15w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table500w.frm</span><br><span class="line">-rw-rw----  1   236M  1 31 12:19 table500w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:40 table5hang.frm</span><br><span class="line">-rw-rw----  1    96K  1 31 11:51 table5hang.ibd</span><br></pre></td></tr></table></figure>

<p>因为主键索引 B+ 树的根页在整个表空间文件中的第 3 个页开始，所以可以算出它在文件中的偏移量：16384*3=49152（16384 为页大小）。</p>
<p>另外根据《InnoDB 存储引擎》中描述在根页的 64 偏移量位置前 2 个字节，保存了 page level 的值。</p>
<p>因此想要的 page level 的值在整个文件中的偏移量为：16384*3+64=49152+64=49216，前 2 个字节中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -s 49216 -n 10 table5hang.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 00 00 00 00 00 00 00 00 3c                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table15w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 01 00 00 00 00 00 00 00 3b                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table500w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 02 00 00 00 00 00 00 00 3a                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table1000w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 02 00 00 00 00 00 00 00 39                  </span><br><span class="line">000c04a</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>table5hang 表数据行数为 5 条，B+ 树高度为 1，<br>table15w   表数据行数为 15 万，B+ 树高度为 2，<br>table500w  表数据行数为 500 万，B+ 树高度为 3，<br>table1000w 表数据行数为 1000 万，B+ 树高度为 3。</p>
<p>500w、1000w 两个表树的高度都是 3。换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做 3 次 IO。<br>那么如果有一张表行数是一千万，那么他的 B+ 树高度依旧是 3，查询效率仍然不会相差太大。region 表只有 5 行数据，当然他的 B+ 树高度为 1。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">4230000</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1000w <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">4230000</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>08-存储引擎层-innodb框架-索引-树到B+树演变、聚集索引与非聚集索引</title>
    <url>/articles/20200205/4e769343.html</url>
    <content><![CDATA[<p>摘要：从树到B+树解释索引演变过程，聚集索引与非聚集索引</p>
<p>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。</p>
<p>索引在 MySQL 数据库中分三类：</p>
<ul>
<li>B+ 树索引</li>
<li>Hash 索引</li>
<li>全文索引</li>
</ul>
<p>B+ 树索引，由二叉查找树，平衡二叉树和 B 树这三种数据结构 演化来的。</p>
<a id="more"></a>

<h1 id="用树的概念理解mysql数据库"><a href="#用树的概念理解mysql数据库" class="headerlink" title="用树的概念理解mysql数据库"></a>用树的概念理解mysql数据库</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>树的基础：<a href="https://www.cnblogs.com/bjlhx/p/10870875.html" target="_blank" rel="noopener">006-数据结构-树形结构-二叉树、二叉查找树、平衡二叉查找树-AVL树</a></p>
<p>数据库表 对应 二叉查找树</p>
<p><img src="/images/post/db-mysql/002/erchachazhao.jpg" alt=""></p>
<p>从图中可以看到，为 user 表（用户信息表）建立了一个二叉查找树的索引。</p>
<p>图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。</p>
<p>二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。</p>
<p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p>
<ol>
<li>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来把当前节点&gt;的右子节点作为当前节点。</li>
<li>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</li>
<li>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</li>
</ol>
<p>利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，需要 6 次才能找到。</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>上面利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造【以5为根节点】：</p>
<p><img src="/images/post/db-mysql/002/pinghengerchashu.jpg" alt=""></p>
<p>可以看到二叉查找树变成了一个链表。如果需要查找 id=17 的用户信息，需要查找 7 次，也就相当于全表扫描了。</p>
<p>导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。</p>
<p>为了解决这个问题，需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树。</p>
<p>平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。</p>
<p>下面是平衡二叉树和非平衡二叉树的对比：</p>
<p><img src="/images/post/db-mysql/002/pinghengerchashu-2.jpg" alt=""></p>
<p>由平衡二叉树的构造可以发现第一张图中的二叉树其实就是一棵平衡二叉树。</p>
<p>平衡二叉树保证了树的构造是平衡的，当插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式,参看。</p>
<p>平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>因为内存的易失性。一般情况下，都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。</p>
<p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，应当尽量减少从磁盘中读取数据的次数。</p>
<p>另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。</p>
<p>如果能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那查找数据的时间也会大幅度降低。</p>
<p>如果用树这种数据结构作为索引的数据结构，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块。</p>
<p>平衡二叉树是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果要存储海量的数据呢</p>
<p>可以想象到二叉树的节点将会非常多，高度也会极其高，查找数据时也会进行很多次磁盘 IO，查找数据的效率将会极低！</p>
<p><img src="/images/post/db-mysql/002/btree-1.jpg" alt=""></p>
<p>为了解决平衡二叉树的这个弊端，应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。</p>
<p>B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树：</p>
<p>B树，<a href="https://www.cnblogs.com/bjlhx/p/10898059.html" target="_blank" rel="noopener">参看</a></p>
<p><img src="/images/post/db-mysql/002/btree-2.jpg" alt=""></p>
<p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有。</p>
<p>图中的每个节点称为页，页就是上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以这里叫做页更符合 MySQL 中索引的底层数据结构。</p>
<p>从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。</p>
<p>基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p>
<p>假如要查找 id=28 的用户信息，那么在上图 B 树中查找的流程如下：</p>
<ul>
<li>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么根据页 1 中的指针 p2 找到页 3。</li>
<li>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，根据页 3 中的指针 p2 找到页 8。</li>
<li>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><a href="https://www.cnblogs.com/bjlhx/p/10898373.html" target="_blank" rel="noopener">参看</a></p>
<p>B+ 树是对 B 树的进一步优化。看下 B+ 树的结构图：</p>
<p><img src="/images/post/db-mysql/002/btree-3.jpg" alt=""></p>
<p>根据上图看下 B+ 树和 B 树有什么不同：</p>
<p>①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p>
<p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。</p>
<p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p>
<p>另外，B+ 树的阶数是等于键值的数量的，如果 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。</p>
<p>一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p>
<p>②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。</p>
<p>那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p>
<p>上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p>
<p>其实上面的 B 树也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。</p>
<p>也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引。</p>
<p>通过上图可以看到，在 InnoDB 中，通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p>
<p>MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>
<h1 id="mysql聚集索引-VS-非聚集索引"><a href="#mysql聚集索引-VS-非聚集索引" class="headerlink" title="mysql聚集索引 VS 非聚集索引"></a>mysql聚集索引 VS 非聚集索引</h1><p>InnoDB数据文件本身就是索引文件，其索引分聚集索引和辅助索引，聚集索引的叶节点包含了完整的数据记录，辅助索引叶节点数据部分是主键的值，</p>
<p>除了空间索引外，InnoDB的索引实现基本都是 B+ 树，如图所示。</p>
<p>其中非叶子结点存储的是子页的最小的键值和子页的页号，叶子结点存储的是数据，数据按照索引键排序。</p>
<p>同一层的页之间用双向链表连接(前面提到的FIL Header中PREV PAGE 和 NEXT PAGE)，同一页内的记录用单向链表连接(Record Header中记录了下一条记录的偏移)。</p>
<p>每一页设置了两个虚拟记录Infimum和Supremum用于标识页的开始和结束。</p>
<p><img src="/images/post/db-mysql/bptreestruct.webp" alt=""></p>
<p>在InnoDB中根据辅助索引查询，如果除了主键外还有其他字段，则需要查询两遍，先根据辅助索引查询主键的值，然后再到主索引中查询得到记录。</p>
<p>此外，因为辅助索引的数据部分是主键值，主键不能过大，否则会导致辅助索引占用空间变大，用自增ID做主键是个不错的选择。</p>
<h2 id="聚集索引-VS-非聚集索引-概念"><a href="#聚集索引-VS-非聚集索引-概念" class="headerlink" title="聚集索引 VS 非聚集索引 概念"></a>聚集索引 VS 非聚集索引 概念</h2><p>在上面介绍 B+ 树索引的时候，提到了图中的索引其实是聚集索引的实现方式。</p>
<p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p>
<p>主要说明下 InnoDB 中的聚集索引和非聚集索引：</p>
<p>①聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使不创建主键，系统也会帮你创建一个隐式的主键。</p>
<p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p>
<p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，称之为聚集索引。</p>
<p>②非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p>
<p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，称为回表。</p>
<h2 id="利用聚集索引-和-非聚集索引-查找数据"><a href="#利用聚集索引-和-非聚集索引-查找数据" class="headerlink" title="利用聚集索引 和 非聚集索引 查找数据"></a>利用聚集索引 和 非聚集索引 查找数据</h2><p>聚簇索引和二级索引（非聚簇索引）</p>
<p>二级索引就是手工创建的非聚集索引，可以建多个，建在一个列或者多个列上。这些索引也会构成B+tree，和聚簇索引的区别就是它不需要存每行的详细数据，它的叶子节点只需要存primary key或（rowId）（当然还有主键索引所在磁盘的位置PageNo）。</p>
<p>将来能通过这个索引找到数据行的ID。要查数据时，就根据ID去聚簇索引那棵B+tree去查，这就是回表。</p>
<p>最后，索引是方便查询的，索引列的数据不适合放大的，它占用的空间一多，那么B+tree一层中能放的个数就越少。</p>
<p>索引列一多，插入就越慢，如果没有索引，插入一行时只需要对主键进行排序即可。如果有很多列都有索引，那么插入时，就要做很多次排序,以及多个B+tree的结构变化。</p>
<h3 id="利用聚集索引查找数据"><a href="#利用聚集索引查找数据" class="headerlink" title="利用聚集索引查找数据"></a>利用聚集索引查找数据</h3><p><img src="/images/post/db-mysql/002/btree-3.jpg" alt=""></p>
<p>聚集索引，表中的数据存储在其中。</p>
<p>现在假设要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">18</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt;<span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>其中 id 为主键，具体的查找过程如下：</p>
<p>①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。</p>
<p>从内存中读取到页 1，要查找这个 id&gt;=18 and id&lt;40 或者范围值，我们首先需要找到 id=18 的键值。</p>
<p>从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。</p>
<p>②要从页 3 中查找数据，需要拿着 p2 指针去磁盘中进行读取页 3。</p>
<p>从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。</p>
<p>③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。</p>
<p>将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。</p>
<p>此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。</p>
<p>因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。</p>
<p>可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。</p>
<p>④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</p>
<p>最终我们找到满足条件的所有数据，总共 12 条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)。</span><br></pre></td></tr></table></figure>
<p>具体的查找流程图：</p>
<p><img src="/images/post/db-mysql/002/jucu-chazhao.jpeg" alt=""></p>
<h3 id="利用非聚集索引查找数据"><a href="#利用非聚集索引查找数据" class="headerlink" title="利用非聚集索引查找数据"></a>利用非聚集索引查找数据</h3><p>上述表结构 只有主键 和 名称，扩展下表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name    luckyNum</span><br><span class="line">1   zs      23</span><br><span class="line">2   ls      7</span><br></pre></td></tr></table></figure>
<p>使用 luckyNum 建立非聚集索引</p>
<p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。</p>
<p><img src="/images/post/db-mysql/002/feijuji-1.jpeg" alt=""></p>
<p>如果要找到幸运数字为 33 的用户信息，对应的 sql 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> luckNum=<span class="number">33</span></span><br></pre></td></tr></table></figure>
<p>查找的流程跟聚集索引一样，最终会找到主键值 47，找到主键后,需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。</p>
<p><img src="/images/post/db-mysql/002/feijuji-chazhao.jpeg" alt=""></p>
<p>在 MyISAM 中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。</p>
<p>因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出）。<br>指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</p>
<p>参看地址：<a href="https://blog.51cto.com/14480698/2451603" target="_blank" rel="noopener">https://blog.51cto.com/14480698/2451603</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>07-存储引擎层-innodb框架-表空间-系统表空间</title>
    <url>/articles/20200205/da9f4def.html</url>
    <content><![CDATA[<p>摘要：系统表空间包含内容有：数据字典，双写缓冲，修改缓冲，undo日志，以及在系统表空间创建的表的数据和索引。</p>
<a id="more"></a>

<h1 id="表空间物理结构-页、区、段"><a href="#表空间物理结构-页、区、段" class="headerlink" title="表空间物理结构-页、区、段"></a>表空间物理结构-页、区、段</h1><p>可以看到，除了分配未使用的页外， UNDO_LOG，SYS, INDEX 页占据了不少的空间。</p>
<p>UNDO_LOG 页存储的是Undo log，SYS 页存储的是数据字典、回滚段、修改缓存等信息，INDEX 是索引页，TRX_SYS 页用于InnoDB的事务系统。</p>
<p>数据字典就是数据表的元信息，修改缓冲前面提到是为了提高IO性能也不再赘述，这里主要分析下 Undo 日志和双写缓冲。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 space-page-type-summary</span><br><span class="line"><span class="built_in">type</span>                count       percent     description         </span><br><span class="line">ALLOCATED           4392        90.30       Freshly allocated   </span><br><span class="line">UNDO_LOG            210         4.32        Undo <span class="built_in">log</span>            </span><br><span class="line">SYS                 141         2.90        System internal     </span><br><span class="line">INDEX               110         2.26        B+Tree index        </span><br><span class="line">INODE               7           0.14        File segment inode  </span><br><span class="line">FSP_HDR             2           0.04        File space header   </span><br><span class="line">TRX_SYS             1           0.02        Transaction system header</span><br><span class="line">IBUF_BITMAP         1           0.02        Insert buffer bitmap</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MySQL的MVCC(多版本并发控制)依赖Undo Log实现</p>
<p>MySQL的表空间文件 *.ibd 存储的是记录最新值，每个记录都有一个回滚指针(见前面图中的Roll Ptr)，指向该记录的最近一条Undo记录，</p>
<p>而每条Undo记录都会指向它的前一条Undo记录，如下图所示。默认情况下 undo log存储在系统表空间 ibdata1 中。</p>
<p>示例<br>这是最初的 插入后的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 -R 127 record-history</span><br><span class="line"><span class="comment"># Transaction   Type                Undo record</span></span><br><span class="line"><span class="comment"># (n/a)         insert              (id=1) → ()</span></span><br><span class="line"><span class="comment"># (base)</span></span><br></pre></td></tr></table></figure>
<p>执行一个更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table5hang <span class="keyword">set</span> age=<span class="number">12</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> table5hang <span class="keyword">set</span> age=<span class="number">13</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>再次查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 -R 127 record-history</span><br><span class="line"><span class="comment"># Transaction   Type                Undo record</span></span><br><span class="line"><span class="comment"># 29910         update_existing     (id=1) → (age=12)</span></span><br><span class="line"><span class="comment"># 29904         update_existing     (id=1) → (age=1)</span></span><br><span class="line"><span class="comment"># (n/a)         insert              (id=1) → ()</span></span><br><span class="line"><span class="comment"># (base)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，Undo Log 在事务执行过程中就会产生，事务提交后才会持久化，如果事务回滚了则Undo Log也会删除。</p>
<p>另外，删除记录并不会立即在表空间中删除该记录，而只是做个标记(delete-mark)，真正的删除则是等由后台运行的 purge 进程处理。</p>
<p>除了每条记录有Undo Log的列表外，整个数据库也会有一个历史列表，purge 进程会根据该历史列表真正删除已经没有再被其他事务使用的 delete-mark 的记录。</p>
<p>purge 进程会删除该记录以及该记录的 Undo Log。</p>
<h2 id="双写缓冲"><a href="#双写缓冲" class="headerlink" title="双写缓冲"></a>双写缓冲</h2><p>InnoDB的记录更新流程：先在Buffer Pool中更新，并将更新记录到 Redo Log 文件中，Buffer Pool中的记录会标记为脏数据并定期刷到磁盘。</p>
<p>由于InnoDB默认Page大小是16KB，而磁盘通常以扇区为单位写入，每次默认只能写入512个字节，无法保证16K数据可以原子的写入。</p>
<p>如果写入过程发生故障(比如机器掉电或者操作系统崩溃)，会出现页的部分写入(partial page writes)，导致难以恢复。</p>
<p>因为 MySQL 的重做日志采用的是物理逻辑日志，即页间是物理信息，而页内是逻辑信息，在发生页部分写入时，无法确认数据页的具体修改而导致难以恢复。</p>
<p>MySQL 的数据页在真正写入到表空间文件前，会先写到系统表空间文件的一段连续区域双写缓冲(Double-Write Buffer，默认大小为 2MB，128个页)并 fsync 落盘，</p>
<p>等双写缓冲写入成功后才会将数据页写到实际表空间的位置。</p>
<p>因为双写缓冲和数据页的写入时机不一致，如果在写入双写缓冲出错，可以直接丢弃该缓冲页，而如果是写入数据页时出错，则可以根据双写缓冲区数据恢复表空间文件。</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>002-cmd-hexdump进制文件查看工具</title>
    <url>/articles/20200203/653046b.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。</p>
<p>指令所在路径：/usr/bin/hexdump</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump: [-bcCdovx] [-e fmt] [-f fmt_file] [-n length] [-s skip] [file ...]</span><br></pre></td></tr></table></figure>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>此命令参数是Red Hat Enterprise Linux Server release 5.7下hexdump命令参数，不同版本Linux的hexdump命令参数有可能不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b              one-byte octal display           8进制显示</span><br><span class="line">-c              one-byte character display       ASCII显示</span><br><span class="line">-C              canonical hex+ASCII display       十六进制+ASCII显示</span><br><span class="line">-d              two-byte decimal display        两字节计算，显示为10进制方式</span><br><span class="line">-o              two-byte octal display         两字节计算，显示为8进制方式</span><br><span class="line">-x              two-byte hexadecimal display    两字节计算，显示为16进制方式</span><br><span class="line">-e format       format string to be used for displaying data   格式化输出</span><br><span class="line">-f format_file  file that contains format strings</span><br><span class="line">-n length       interpret only length bytes of input    输出多少个bytes的字符长度的内容</span><br><span class="line">-s offset       skip offset bytes from the beginning    输出文件的开始偏移量  【注意：偏移量从0开始的！】</span><br><span class="line">-v              display without squeezing similar lines    </span><br><span class="line">-V              output version information and exit</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li>帮助<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li>
<li>案例<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;test.txt</span><br><span class="line">ABCDEF    </span><br><span class="line">GHIJKM</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C test.txt</span><br><span class="line">00000000  41 42 43 44 45 46 0a 47  48 49 4a 4b 4d 0a 31 32  |ABCDEF.GHIJKM.12|</span><br><span class="line">00000010  33 34 35 36 0a                                    |3456.|</span><br><span class="line">00000015</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>跳过 7 个取6个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C -s 7 -n 6 test.txt</span><br><span class="line">00000007  47 48 49 4a 4b 4d                                 |GHIJKM|</span><br><span class="line">0000000d</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-shell-概述与命令行区别</title>
    <url>/articles/20200203/d189e05e.html</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>shell翻译成壳的意思，它是包裹在linux内核外层的，一个可通过一系列的linux命令对操作系统发出相关指令的人机界面。</p>
<p>shell可以通过其条件语句和循环语句等，把一系列linux命令结合在一起，形成一个相当于面向过程的程序，shell script，来实现一些较为复杂的功能。</p>
<p>总括，shell是linux命令集的概称，是属于命令行的人机界面。Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。<br>Shell既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。<br>Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。Shell 和Shell Script不是一回事，通常我们说的都是Shell Script。</p>
<p>由定义可知， shell相当于经过装饰的命令行，和命令行一样，都能操作linux。但是shell是面向过程的，相当于有了一定的逻辑和过程，而命令行只是单一的操作。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol>
<li>直接在命令行执行 就是在当前的shell环境下执行 比如涉及到一些环境变量的时候 必须在当前shell环境里执行</li>
</ol>
<p>在脚本里执行的话 脚本执行的时候 会fork一个子进程 所有操作都在子进程进行 如果涉及到一些在脚本里设置环境变量的东西 脚本结束了 环境变量也就消失了。 </p>
<p>这个修改环境变量的话，需要特别注意下。</p>
<ol start="2">
<li>shell可以重复执行一些命令。也可以把自己要重复执行的命令写到脚本里面执行。而命令行的话就需要一个一个的输入命令，相对而言麻烦一些。</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>06-存储引擎层-innodb框架-表空间-段、区、页与组织结构</title>
    <url>/articles/20200202/12fe7f8a.html</url>
    <content><![CDATA[<p>摘要：InnoDB表空间文件.ibd文件内部存储单元是页，初始大小为 96K，而InnoDB默认页大小为 16K。当然页大小也可以通过 innodb_page_size 配置为 4K, 8K…64K 等。</p>
<p>如果用二进制打开，以16K划分一页。在ibd文件中，0-16KB偏移量即为0号数据页，16KB-32KB的为1号数据页，以此类推。</p>
<a id="more"></a>

<h1 id="表空间物理结构-页、区、段"><a href="#表空间物理结构-页、区、段" class="headerlink" title="表空间物理结构-页、区、段"></a>表空间物理结构-页、区、段</h1><p>磁盘最小单位是512字节，操作系统是4KB，mysql里最小的是page（页面）有16K。</p>
<p>ibd就是放索引树的，但总不能一个树就摊在一个txt文档里，所以必须还要有一种文件组织结构。所有的数据都放在page里，用一种规则来把N个page连一起，让它们形成一些关联，才能便于查询，要先找到page，再找到page内的数据。</p>
<p>B+树是离不开页面page</p>
<p><img src="/images/post/db-mysql/006/tablespace.webp" alt=""></p>
<h2 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h2><p>段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。</p>
<p>表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。</p>
<p>InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。</p>
<p>创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据（分裂、增长、删除等），叶子段用来管理（存储）B+树叶子节点的数据，负责行数据的相关动作；</p>
<p>也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。一个段包含256个区(256M大小)。</p>
<h2 id="区-簇（extents）"><a href="#区-簇（extents）" class="headerlink" title="区/簇（extents）"></a>区/簇（extents）</h2><p>段是个逻辑概念，innodb引入了簇的概念，在代码中被称为extent；</p>
<p>簇是由64个连续的页组成的，每个页大小为16KB，即每个簇的大小为1MB硬盘空间。即默认大小为 1MB (64*16K)。</p>
<p>簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。</p>
<p>如果存储数据时，即往段里写入数据，就是往簇里写数据，簇是硬盘空间，当一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据，等于又多了一块64*16K的连续硬盘空间。</p>
<p>一个段所管理的空间大小是无限的，可一直扩展下去，但是扩展的最小单位就是簇。注意，每个簇是一块连续的硬盘空间，但多个簇之间可不是连续的。</p>
<p>同样，两个段之间，在硬盘上也没有什么关系。</p>
<h2 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h2><h3 id="页存储单元"><a href="#页存储单元" class="headerlink" title="页存储单元"></a>页存储单元</h3><p>磁盘扇区、文件系统、InnoDB 存储引擎都有各自的最小存储单元。存储数据的最小单位。</p>
<p><img src="/images/post/db-mysql/001/mysql-disk.jpg" alt=""></p>
<ul>
<li><p>磁盘扇区存储单元-扇区-512字节<br>在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是 512 字节</p>
</li>
<li><p>文件系统存储单元-块-4k<br>文件系统(例如 XFS/EXT4)他的最小单元是块，一个块的大小是 4K。<br>文件系统中一个文件大小只有 1 个字节，但不得不占磁盘上 4KB 的空间。[0k不占空间]<br><img src="/images/post/db-mysql/001/file-0k.jpg" alt="">  <img src="/images/post/db-mysql/001/file-1k.jpg" alt=""></p>
</li>
<li><p>InnoDB存储单元-页-16k<br>InnoDB 存储引擎也有自己的最小储存单元——页(Page)，一个页的大小是 16K。<br>InnoDB 的所有数据文件(后缀为 ibd 的文件)，他的大小始终都是 16384(16K)的整数倍。  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ll |grep ibd </span><br><span class="line">-rw…………    96K 10 31 11:22 innodb_index_stats.ibd</span><br><span class="line">-rw…………    96K 10 31 11:22 innodb_table_stats.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_master_info.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_relay_log_info.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_worker_info.ibd</span><br></pre></td></tr></table></figure>

<p>InnoDB有页（page）的概念，可以理解为簇的细化。页是InnoDB磁盘管理的最小单位。</p>
<h3 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h3><p>所有页的结构都是一样的，分为文件头(前38字节)，页数据和文件尾(后8字节)。页数据根据页的类型不同而不一样。</p>
<p>页的头尾除了一些元信息外，还有Checksum校验值，这些校验值在写入磁盘前计算得到，当从磁盘中读取时，重新计算校验值并与数据页中存储的对比，如果发现不同，则会导致 MySQL 崩溃。</p>
<p><img src="/images/post/db-mysql/page-struct.jpg" alt=""></p>
<h4 id="File-Header-记录页的一些头信息，共占用38字节，组成部分如"><a href="#File-Header-记录页的一些头信息，共占用38字节，组成部分如" class="headerlink" title="File Header 记录页的一些头信息，共占用38字节，组成部分如:"></a>File Header 记录页的一些头信息，共占用38字节，组成部分如:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_SPACE_OR_CHKSUM	4	当mysql4.0.14之前，值是0，之后该值代表页的checksum值</span><br><span class="line">FIL_PAGE_OFFSET	        4	表空间中页的偏移量。。如某独立表空间a.ibd的大小为1GB，如果页的大小为16KB，那么总共有65536个页。</span><br><span class="line">                            FILE_PAGE_OFFSET表示该页在所有页中的位置。若此表空间的ID为10，那么搜索页（10，1）就表示查找表a中的第二页</span><br><span class="line">FIL_PAGE_PREV	        4	该页的上一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_NEXT	        4	该页的下一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_LSN	        8	该页最后被修改的LSN日志序列位置（Log Sequence Number）</span><br><span class="line">FIL_PAGE_TYPE	        2	该页的类型，0x45BF为数据页,实际行记录的存储空间</span><br><span class="line">FIL_PAGE_FILE_FLUSH_LSN	8	独立表空间中为0，如在系统表空间表示一个页的定义，代表文件至少被更新到了该LSN值</span><br><span class="line">FIL_PAGE_ARCH_LOG_NO	4	从4.1开始，该页属于哪一个表空间</span><br></pre></td></tr></table></figure>

<h5 id="页类型【innodb存储引擎中】"><a href="#页类型【innodb存储引擎中】" class="headerlink" title="页类型【innodb存储引擎中】"></a>页类型【innodb存储引擎中】</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_INDEX          0x45BF  数据页，B+树叶节点，索引页的叶子结点的data就是数据，如聚集索引存储的行数据，辅助索引存储的主键值。</span><br><span class="line">FIL_PAGE_UNDO_LOG	    0x0002  Undo页（Undo Log Page）</span><br><span class="line">FIL_PAGE_INODE	        0x0003  索引节点</span><br><span class="line">FIL_PAGE_IBUF_FREE_LIST 0x0004  插入缓冲空闲列表页（Insert Buffer Free List）</span><br><span class="line">FIL_PAGE_TYPE_ALLOCATED 0x0000  最新分配</span><br><span class="line">FIL_PAGE_IBUF_BITMAP	0x0005  插入缓冲位图页（Insert Buffer Bitmap）。用于记录 change buffer的使用情况。</span><br><span class="line">FIL_PAGE_TYPE_SYS       0x0006  系统页（System Page）</span><br><span class="line">FIL_PAGE_TYPE_TRX_SYS   0x0007  事务数据页（Transaction system Page）</span><br><span class="line">FIL_PAGE_TYPE_FSP_HDR   0x0008  File Space Header，主要用于跟踪表空间，空闲链表、碎片页以及区等信息。</span><br><span class="line">FIL_PAGE_TYPE_XDES      0x0009  扩展描述也</span><br><span class="line">FIL_PAGE_TYPE_BLOB      0x000A  BLOB Page</span><br></pre></td></tr></table></figure>
<ul>
<li><p>FIL_PAGE_INODE：用于记录文件段(FSEG)的信息，每页有85个INODE entry，每个INODE entry占用192字节，用于描述一个文件段。每个INODE entry包括文件段ID、属于该段的区的信息以及碎片页数组。区信息包括 FREE(完全空闲的区), NOT_FULL(至少使用了一个页的区), FULL(没空闲页的区)三种类型的区的List Base Node(包含链表长度和头尾页号和偏移的结构体)。碎片页数组则是不同于分配整个区的单独分配的32个页。</p>
</li>
<li><p>FIL_PAGE_TYPE_FSP_HDR 页：用于存储区的元信息。<br>ibd文件的第一页 FSP_HDR 页通常就用于存储区的元信息，里面的256个 XDES(extent descriptors) 项存储了256个区的元信息，包括区的使用情况和区里面页的使用情况。</p>
<p>更多 参看 附表 </p>
</li>
</ul>
<h4 id="Page-Header：记录数据页的状态信息，共占56个字节，组成部分如图："><a href="#Page-Header：记录数据页的状态信息，共占56个字节，组成部分如图：" class="headerlink" title="Page Header：记录数据页的状态信息，共占56个字节，组成部分如图："></a>Page Header：记录数据页的状态信息，共占56个字节，组成部分如图：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">PAGE_N_DIR_SLOTS	2	在Page Directory中Slot的数量，初始值为2</span><br><span class="line">PAGE_HEAP_TOP	    2	堆中第一个记录的指针,记录在页中是根据堆的形式存放</span><br><span class="line">PAGE_N_HEAP	        2	堆中的记录数，初始值为2，但是第15位表示行记录格式</span><br><span class="line">PAGE_FREE	        2	指向可重用空间的首指针</span><br><span class="line">PAGE_GARBAGE	    2	已标记为删除（deleted_flag）的记录的字节数</span><br><span class="line">PAGE_LAST_INSERT	2	最后插入记录的位置</span><br><span class="line">PAGE_DIRECTION	    2	最后插入的方向，PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0X03),PAGE_SAME_PAGE(0X04),PAGE_NO_DIRECTION(0x05)</span><br><span class="line">PAGE_N_DIRECTION	2	一个方向上连续插入记录的数量</span><br><span class="line">PAGE_N_RECS	        2	该页中记录（User Record）的数量</span><br><span class="line">PAGE_MAX_TRX_ID	    8	修改该页的最大事务ID（仅在辅助索引中定义）</span><br><span class="line">PAGE_LEVEL	        2	该页在索引树中位置，0000代表叶子节点</span><br><span class="line">PAGE_INDEX_ID	    8	索引ID，表示该页属于哪个索引</span><br><span class="line">PAGE_BTR_SEG_LEAF	10	B+Tree叶子节点所在Leaf Node Segment的Segment Header（无关紧要）</span><br><span class="line">PAGE_BTR_SEG_TOP	10	B+Tree非叶子节点所在Non-Leaf Node Segment的Segment Header（无关紧要）</span><br></pre></td></tr></table></figure>

<h4 id="infimum和supermum-record"><a href="#infimum和supermum-record" class="headerlink" title="infimum和supermum record"></a>infimum和supermum record</h4><ul>
<li>每个数据页中都有两个虚拟的行记录，用来限定记录（User Record）的边界（Infimum为下界，Supremum为上界）</li>
<li>Infimum和Supremum在页被创建是自动创建，不会被删除</li>
<li>在Compact和Redundant行记录格式下，Infimum和Supremum占用的字节数是不一样的<br><img src="/images/post/db-mysql/insupermum.jpg" alt=""></li>
<li>5.1后有Compact（默认）和Redundant两种格式<ul>
<li>Compact行记录格式<br>设计目标为高效存放数据，行数据越多，性能越高。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变长字段长度列表    |   NULL标志位     |   记录头信息   |   列1数据    |   列2数据    |   ……  |</span><br></pre></td></tr></table></figure>
<ul>
<li>变长字段长度列表，按照列的顺序逆序放置。列长度小于255字节，用1字节表示，大于255字节，则用2个字节表示</li>
<li>NULL标志位，一个字节，表示对应列为NULL</li>
<li>记录头信息，5个字节，含义见下表</li>
<li>下面即为数据列，NULL不占用存储空间</li>
<li>每行除了用户定义的列，还有两个隐藏列，事务ID列（6字节）和回滚指针列（7字节），若没有定义主键，每行还会有一个6字节的RowID列<figure class="highlight plain"><figcaption><span>Compact行记录格式</span></figcaption><table><tr><td class="code"><pre><span class="line">名称          大小（bit） 描述</span><br><span class="line">（）          1           未知</span><br><span class="line">（）          1           未知</span><br><span class="line">deleted_flag  1         该行是否被删除</span><br><span class="line">min_rec_flag  1         为1，如果该记录是预先被定义为最小的记录</span><br><span class="line">n_owned       4         该记录拥有的记录数</span><br><span class="line">heap_no       13        索引堆中该条记录的排序记录</span><br><span class="line">record_type   3         记录类型 000&#x3D;普通 001&#x3D;B+树节点指针 010-Infimum 011&#x3D;Supremum 1xx&#x3D;保留</span><br><span class="line">next_recorder 16        页中下一条记录的相对位置</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Redundant行记录格式</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字段长度偏移列表    |   记录头信息   |   列1数据    |   列2数据    |   ……  |</span><br></pre></td></tr></table></figure>
<ul>
<li>字段长度偏移列表，按照列的顺序逆序放置。列长度小于255字节，用1字节表示，大于255字节，则用2个字节表示</li>
<li>记录头信息，固定占用6个字节，含义见下表。n_fields、1byte_offs_flag两个值值得注意</li>
<li>数据列，varchar的NULL值不占用存储空间，但是char值需要占用空间</li>
</ul>
<figure class="highlight plain"><figcaption><span>Compact行记录格式</span></figcaption><table><tr><td class="code"><pre><span class="line">名称          大小（bit） 描述</span><br><span class="line">（）          1           未知</span><br><span class="line">（）          1           未知</span><br><span class="line">deleted_flag  1         该行是否被删除</span><br><span class="line">min_rec_flag  1         为1，如果该记录是预先被定义为最小的记录</span><br><span class="line">n_owned       4         该记录拥有的记录数</span><br><span class="line">heap_no       13        索引堆中该条记录的排序记录</span><br><span class="line">lbyte_offs_flag 1       偏移列表为1字节还是2字节</span><br><span class="line">next_recorder 16        页中下一条记录的相对位置</span><br></pre></td></tr></table></figure>

<h4 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h4><ul>
<li>存储实际插入的行记录</li>
<li>在Page Header中PAGE_HEAP_TOP、PAGE_N_HEAP的HEAP，实际上指的是Unordered User Record List<ul>
<li>InnoDB不想每次都依据B+Tree键的顺序来插入新行，因为这可能需要移动大量的数据</li>
<li>因此InnoDB插入新行时，通常是插入到当前行的后面（Free Space的顶部）或者是已删除行留下来的空间</li>
</ul>
</li>
<li>为了保证访问B+Tree记录的顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表</li>
</ul>
<h4 id="Free-Space"><a href="#Free-Space" class="headerlink" title="Free Space"></a>Free Space</h4><ul>
<li>空闲空间，数据结构是链表，在一个记录被删除后，该空间会被加入到空闲链表中</li>
</ul>
<h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><ul>
<li>存放着行记录（User Record）的相对位置（不是偏移量）</li>
<li>这里的行记录指针称为Slot或Directory Slot，每个Slot占用2Byte</li>
<li>并不是每一个行记录都有一个Slot，一个Slot中可能包含多条行记录，通过行记录中n_owned字段标识</li>
<li>Infimum的n_owned总是1，Supremum的n_owned为[1,8]，User Record的n_owned为[4,8]</li>
<li>Slot是按照索引键值的顺序进行逆序存放（Infimum是下界，Supremum是上界），可以利用二分查找快速地定位一个粗略的结果，然后再通过next_record进行精确查找</li>
<li>B+Tree索引本身并不能直接找到具体的一行记录，只能找到该行记录所在的页<ul>
<li>数据库把页载入到内存中，然后通过Page Directory再进行二分查找</li>
<li>二分查找时间复杂度很低，又在内存中进行查找，这部分的时间基本开销可以忽略</li>
</ul>
</li>
</ul>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><ul>
<li>总共8 Bytes，为了检测页是否已经完整地写入磁盘</li>
<li>变量innodb_checksums，InnoDB从磁盘读取一个页时是否会检测页的完整性</li>
<li>变量innodb_checksum_algorithm，检验和算法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_END_LSN	8	前4Bytes与File Header中的FIL_PAGE_SPACE一致，后4Bytes与File Header中的FIL_PAGE_LSN的后4Bytes一致</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE 'innodb_checksums';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| innodb_checksums | ON    |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'innodb_checksum_algorithm'</span>;</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| innodb_checksum_algorithm | crc32 |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/images/post/db-mysql/index-page-extents1.jpg" alt=""></p>
<ol>
<li><p>每个簇里有64个页面，都会进行编号，页面就是最小的存储单元了。在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。</p>
</li>
<li><p>在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；</p>
<ul>
<li>一个页面16K，放主键如int型能放几千，放一行数据，如1K一行，能放十几行。</li>
<li>这里需要注意，一行数据尽量不要过大，一旦跨page，就会对性能产生影响。本来一个page就能查出来，结果每次要查2个page，那性能就丢了一倍。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><figcaption><span>官网</span></figcaption><table><tr><td class="code"><pre><span class="line">Pages, Extents, Segments, and Tablespaces</span><br><span class="line"></span><br><span class="line">Each tablespace consists of database pages. Every tablespace in a MySQL instance has the same page size. By default, all tablespaces have a page size of 16KB; you can reduce the page size to 8KB or 4KB by specifying the innodb_page_size option when you create the MySQL instance. You can also increase the page size to 32KB or 64KB. For more information, refer to the innodb_page_sizedocumentation.</span><br><span class="line"></span><br><span class="line">The pages are grouped into extents of size 1MB for pages up to 16KB in size (64 consecutive 16KB pages, or 128 8KB pages, or 256 4KB pages). For a page size of 32KB, extent size is 2MB. For page size of 64KB, extent size is 4MB. The “files” inside a tablespace are called segments in InnoDB. (These segments are different from the rollback segment, which actually contains many tablespace segments.)</span><br><span class="line"></span><br><span class="line">When a segment grows inside the tablespace, InnoDB allocates the first 32 pages to it one at a time. After that, InnoDB starts to allocate whole extents to the segment. InnoDB can add up to 4 extents at a time to a large segment to ensure good sequentiality of data.</span><br><span class="line"></span><br><span class="line">Two segments are allocated for each index in InnoDB. One is for nonleaf nodes of the B-tree, the other is for the leaf nodes. Keeping the leaf nodes contiguous on disk enables better sequential I&#x2F;O operations, because these leaf nodes contain the actual table data.</span><br><span class="line"></span><br><span class="line">Some pages in the tablespace contain bitmaps of other pages, and therefore a few extents in an InnoDB tablespace cannot be allocated to segments as a whole, but only as individual pages.</span><br></pre></td></tr></table></figure>

<h1 id="表空间ibd与页关系"><a href="#表空间ibd与页关系" class="headerlink" title="表空间ibd与页关系"></a>表空间ibd与页关系</h1><p>一个表，占用一个表空间，创建一个表空间时，至少有一个文件（0号文件），这个文件的第一个页面page，page_no=0，这个page中存储了这个表空间中，所有段、簇、页管理的入口。</p>
<p>InnoDB表空间文件.ibd文件内部存储单元是页，初始大小为 96K，而InnoDB默认页大小为 16K。当然页大小也可以通过 innodb_page_size 配置为 4K, 8K…64K 等。</p>
<p>如果用二进制打开，以16K划分一页。在ibd文件中，0-16KB偏移量即为0号数据页，16KB-32KB的为1号数据页，以此类推。</p>
<h2 id="ibd文件存储结构【页】"><a href="#ibd文件存储结构【页】" class="headerlink" title="ibd文件存储结构【页】"></a>ibd文件存储结构【页】</h2><ol>
<li>图形<br><img src="/images/post/db-mysql/ibdfile.webp" alt=""><br>更为抽象一点的<br><img src="/images/post/db-mysql/index-page-extents2.png" alt=""></li>
<li>sql查询<br>可以在 innodb_sys_tables 表中查到表t的表空间ID为 36，然后可以在 innodb_buffer_page查到所有页信息，一共4个页。<br>分别是 FSP_HDR, IBUF_BITMAP, INODE, INDEX。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table15w'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_buffer_page <span class="keyword">where</span> <span class="keyword">SPACE</span>=<span class="number">36</span>;</span><br></pre></td></tr></table></figure></li>
<li>实际文件结构：</li>
</ol>
<ul>
<li>第0页是 FSP_HDR 页，主要用于跟踪表空间，空闲链表、碎片页以及区等信息。</li>
<li>第1页是 IBUF_BITMAP 页，保存Change Buffer的位图。</li>
<li>第2页是 INODE 页，用于存储区和单独分配的碎片页信息，包括FULL、FREE、NOT_FULL 等页列表的基础结点信息(基础结点信息记录了列表的起始和结束页号和偏移等)，这些结点指向的是 FSP_HDR 页中的项，用于记录页的使用情况，它们之间关系如下图所示。</li>
<li>第3页开始是索引页 INDEX(B-tree node)，从 0xc000(每页16K) 开始，后面还有些分配的未使用的页。</li>
</ul>
<h1 id="表空间文件ibd-页类型-实操说明"><a href="#表空间文件ibd-页类型-实操说明" class="headerlink" title="表空间文件ibd-页类型-实操说明"></a>表空间文件ibd-页类型-实操说明</h1><h2 id="FSP-HDR-PAGE【File-Space-Header-Page】"><a href="#FSP-HDR-PAGE【File-Space-Header-Page】" class="headerlink" title="FSP_HDR PAGE【File Space Header Page】"></a>FSP_HDR PAGE【File Space Header Page】</h2><p>数据文件.ibd的第一个Page类型为FIL_PAGE_TYPE_FSP_HDR，在创建一个新的表空间时进行初始化(fsp_header_init)，</p>
<p>该page同时用于跟踪随后的256个Extent(约256MB文件大小)的空间管理，所以每隔256MB就要创建一个类似的数据页，类型为FIL_PAGE_TYPE_XDES ，XDES Page除了文件头部外，</p>
<p>其他都和FSP_HDR页具有相同的数据结构，可以称之为Extent描述页，每个Extent占用40个字节，一个XDES Page最多描述256个Extent。</p>
<p>FSP_HDR页的头部使用FSP_HEADER_SIZE个字节来记录文件的相关信息，具体的包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">FSP_SPACE_ID	4	该文件对应的space id</span><br><span class="line">FSP_NOT_USED	4	如其名，保留字节，当前未使用</span><br><span class="line">FSP_SIZE	4	当前表空间总的PAGE个数，扩展文件时需要更新该值（fsp_try_extend_data_file_with_pages）</span><br><span class="line">FSP_FREE_LIMIT	4	当前尚未初始化的最小Page No。从该Page往后的都尚未加入到表空间的FREE LIST上。</span><br><span class="line">FSP_SPACE_FLAGS	4	当前表空间的FLAG信息，见下文</span><br><span class="line">FSP_FRAG_N_USED	4	FSP_FREE_FRAG链表上已被使用的Page数，用于快速计算该链表上可用空闲Page数</span><br><span class="line">FSP_FREE	16	当一个Extent中所有page都未被使用时，放到该链表上，可以用于随后的分配</span><br><span class="line">FSP_FREE_FRAG	16	FREE_FRAG链表的Base Node，通常这样的Extent中的Page可能归属于不同的segment，用于segment frag array page的分配（见下文）</span><br><span class="line">FSP_FULL_FRAG	16	Extent中所有的page都被使用掉时，会放到该链表上，当有Page从该Extent释放时，则移回FREE_FRAG链表</span><br><span class="line">FSP_SEG_ID	8	当前文件中最大Segment ID + 1，用于段分配时的seg id计数器</span><br><span class="line">FSP_SEG_INODES_FULL	16	已被完全用满的Inode Page链表</span><br><span class="line">FSP_SEG_INODES_FREE	16	至少存在一个空闲Inode Entry的Inode Page被放到该链表上</span><br></pre></td></tr></table></figure>
<p>第一页的 前38字节</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C  -n 38 table5hang.ibd</span><br><span class="line">00000000  ff 64 a5 b7 00 00 00 00  00 00 00 00 00 00 00 00  |.d..............|</span><br><span class="line">00000010  00 00 00 00 80 eb 9d 23  00 08 00 00 00 00 00 00  |.......<span class="comment">#........|</span></span><br><span class="line">00000020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00000026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<p>通过 ：File Header 记录页的一些头信息 参看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_SPACE_OR_CHKSUM	4	ff 64 a5 b7：checksum值</span><br><span class="line">FIL_PAGE_OFFSET	        4	00 00 00 00：表空间中页的偏移量</span><br><span class="line">FIL_PAGE_PREV	        4	00 00 00 00：该页的上一个页</span><br><span class="line">FIL_PAGE_NEXT	        4	00 00 00 00：该页的下一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_LSN	        8	00 00 00 00 80 eb 9d 23：该页最后被修改的LSN日志序列位置（Log Sequence Number）</span><br><span class="line">FIL_PAGE_TYPE	        2	00 08：&#x3D; FSP_HDR 该页的类型，</span><br><span class="line">FIL_PAGE_FILE_FLUSH_LSN	8	00 00 00 00 00 00 00 00 ：独立表空间中为0</span><br><span class="line">FIL_PAGE_ARCH_LOG_NO	4	00 00 00 2c：&#x3D;2*16+12&#x3D;44 该页属于哪一个表空间，与上文sql 查询一致</span><br></pre></td></tr></table></figure>

<h2 id="IBUF-BITMAP-Page"><a href="#IBUF-BITMAP-Page" class="headerlink" title="IBUF_BITMAP Page"></a>IBUF_BITMAP Page</h2><p>第2个page类型为FIL_PAGE_IBUF_BITMAP，主要用于跟踪随后的每个page的change buffer信息，使用4个bit来描述每个page的change buffer信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">IBUF_BITMAP_FREE	2	使用2个bit来描述page的空闲空间范围：0（0 bytes）、1（512 bytes）、2（1024 bytes）、3（2048 bytes）</span><br><span class="line">IBUF_BITMAP_BUFFERED	1	是否有ibuf操作缓存</span><br><span class="line">IBUF_BITMAP_IBUF	1	该Page本身是否是Ibuf Btree的节点</span><br></pre></td></tr></table></figure>
<p>由于bitmap page的空间有限，同样每隔256个Extent Page之后，也会在XDES PAGE之后创建一个ibuf bitmap page。</p>
<p>offsets:16<em>1024</em>1=16384</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 16384 -n 38 table5hang.ibd</span><br><span class="line">00004000  a0 58 07 7e 00 00 00 01  00 00 00 00 00 00 00 00  |.X.~............|</span><br><span class="line">00004010  00 00 00 00 80 eb 93 80  00 05 00 00 00 00 00 00  |................|</span><br><span class="line">00004020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00004026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前 38也是  File Header<br>00 05 : FIL_PAGE_IBUF_BITMAP    0x0005  插入缓冲位图页（Insert Buffer Bitmap）。用于记录 change buffer的使用情况。 </p>
<h2 id="FIL-PAGE-INODE"><a href="#FIL-PAGE-INODE" class="headerlink" title="FIL_PAGE_INODE"></a>FIL_PAGE_INODE</h2><p>数据文件的第3个page的类型为FIL_PAGE_INODE，用于管理数据文件中的segement，每个索引占用2个segment，分别用于管理叶子节点和非叶子节点。</p>
<p>每个inode页可以存储FSP_SEG_INODES_PER_PAGE（默认为85）个记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_INODE_PAGE_NODE	12	INODE页的链表节点，记录前后Inode Page的位置，BaseNode记录在头Page的FSP_SEG_INODES_FULL或者FSP_SEG_INODES_FREE字段。</span><br><span class="line">Inode Entry 0	192	Inode记录</span><br><span class="line">Inode Entry 1	 	 </span><br><span class="line">……	 	 </span><br><span class="line">Inode Entry 84</span><br></pre></td></tr></table></figure>
<p>每个Inode Entry的结构如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_ID	8	该Inode归属的Segment ID，若值为0表示该slot未被使用</span><br><span class="line">FSEG_NOT_FULL_N_USED	8	FSEG_NOT_FULL链表上被使用的Page数量</span><br><span class="line">FSEG_FREE	16	完全没有被使用并分配给该Segment的Extent链表</span><br><span class="line">FSEG_NOT_FULL	16	至少有一个page分配给当前Segment的Extent链表，全部用完时，转移到FSEG_FULL上，全部释放时，则归还给当前表空间FSP_FREE链表</span><br><span class="line">FSEG_FULL	16	分配给当前segment且Page完全使用完的Extent链表</span><br><span class="line">FSEG_MAGIC_N	4	Magic Number</span><br><span class="line">FSEG_FRAG_ARR 0	4	属于该Segment的独立Page。总是先从全局分配独立的Page，当填满32个数组项时，就在每次分配时都分配一个完整的Extent，并在XDES PAGE中将其Segment ID设置为当前值</span><br><span class="line">……	……	 </span><br><span class="line">FSEG_FRAG_ARR 31	4	总共存储32个记录项</span><br></pre></td></tr></table></figure>

<p>offsets:16<em>1024</em>2=32768</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 32768 -n 38 table5hang.ibd</span><br><span class="line">00008000  86 d5 41 60 00 00 00 02  00 00 00 00 00 00 00 00  |..A ............|</span><br><span class="line">00008010  00 00 00 00 80 eb 9d 23  00 03 00 00 00 00 00 00  |.......<span class="comment">#........|</span></span><br><span class="line">00008020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00008026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前 38也是  File Header<br>00 03 : 索引节点 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_INODE_PAGE_NODE	12	INODE页的链表节点，记录前后Inode Page的位置，BaseNode记录在头Page的FSP_SEG_INODES_FULL或者FSP_SEG_INODES_FREE字段。</span><br><span class="line">Inode Entry 0	192	Inode记录</span><br><span class="line">Inode Entry 1	 	 </span><br><span class="line">……	 	 </span><br><span class="line">Inode Entry 84</span><br></pre></td></tr></table></figure>
<p>每个Inode Entry的结构如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_ID	8	该Inode归属的Segment ID，若值为0表示该slot未被使用</span><br><span class="line">FSEG_NOT_FULL_N_USED	8	FSEG_NOT_FULL链表上被使用的Page数量</span><br><span class="line">FSEG_FREE	16	完全没有被使用并分配给该Segment的Extent链表</span><br><span class="line">FSEG_NOT_FULL	16	至少有一个page分配给当前Segment的Extent链表，全部用完时，转移到FSEG_FULL上，全部释放时，则归还给当前表空间FSP_FREE链表</span><br><span class="line">FSEG_FULL	16	分配给当前segment且Page完全使用完的Extent链表</span><br><span class="line">FSEG_MAGIC_N	4	Magic Number</span><br><span class="line">FSEG_FRAG_ARR 0	4	属于该Segment的独立Page。总是先从全局分配独立的Page，当填满32个数组项时，就在每次分配时都分配一个完整的Extent，并在XDES PAGE中将其Segment ID设置为当前值</span><br><span class="line">……	……	 </span><br><span class="line">FSEG_FRAG_ARR 31	4	总共存储32个记录项</span><br></pre></td></tr></table></figure>


<h2 id="Index-索引页"><a href="#Index-索引页" class="headerlink" title="Index 索引页"></a>Index 索引页</h2><p>需要跳过3页面，即 49152，索引页 结构也符合基础页结构。</p>
<p><img src="/images/post/db-mysql/index-struct.webp" alt=""></p>
<p>同上述步骤类似</p>
<h3 id="FIL-Header（38字节-记录文件头信息。"><a href="#FIL-Header（38字节-记录文件头信息。" class="headerlink" title="FIL Header（38字节): 记录文件头信息。"></a>FIL Header（38字节): 记录文件头信息。</h3><p>offsets:16<em>1024</em>3=49152</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49152 -n 38 table5hang.ibd</span><br><span class="line">0000c000  3b 03 ff eb 00 00 00 03  ff ff ff ff ff ff ff ff  |;...............|</span><br><span class="line">0000c010  00 00 00 00 80 eb af c9  45 bf 00 00 00 00 00 00  |........E.......|</span><br><span class="line">0000c020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">0000c026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前4字节 3b 03 ff eb 是 checksum，接着4个 00 00 00 03 是页偏移值 3，即这是第2+1页。【数组下标方式，这是真实的第四页】</p>
<p>接着 4 字节是上一页偏移值，ff ff ff ff 第一个数据页 无上一页，接着 4 字节是下一页偏移值 ff ff ff ff 无下一页。</p>
<p>然后 8 字节 00 00 00 00 80 eb af c9 是日志序列号 LSN。</p>
<p>随后的 2 字节 45 bf 是页类型，代表是 INDEX 页。</p>
<p>接着 8 字节 00 00 00 00 00 00 00 00 表示被更新到的LSN，在 File-Per-Table 表空间中都是0。</p>
<p>然后 4 字节 00 00 00 2c 表示该数据页属于的表t的表空间ID是 0x2c(44)。 与上文sql 查询一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table5hang'</span></span><br></pre></td></tr></table></figure>

<h3 id="PageHeader-INDEX-Header（56字节-记录的是-INDEX-页的状态信息"><a href="#PageHeader-INDEX-Header（56字节-记录的是-INDEX-页的状态信息" class="headerlink" title="PageHeader-INDEX Header（56字节): 记录的是 INDEX 页的状态信息"></a>PageHeader-INDEX Header（56字节): 记录的是 INDEX 页的状态信息</h3><p>offsets:16<em>1024</em>3+38=49190</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49190 -n 56 table5hang.ibd</span><br><span class="line">0000c026  00 02 01 36 80 07 00 00  00 00 01 17 00 02 00 04  |...6............|</span><br><span class="line">0000c036  00 05 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">0000c046  00 00 00 3c 00 00 00 2c  00 00 00 02 00 f2 00 00  |...&lt;...,........|</span><br><span class="line">0000c056  00 2c 00 00 00 02 00 32                           |.,.....2|</span><br><span class="line">0000c05e</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">PAGE_N_DIR_SLOTS	2	00 02：在Page Directory中Slot的数量，初始值为2</span><br><span class="line">PAGE_HEAP_TOP	    2	01 36：堆中第一个记录的指针,记录在页中是根据堆的形式存放</span><br><span class="line">PAGE_N_HEAP	        2	80 07：堆中的记录数，初始值为2，但是第15位表示行记录格式</span><br><span class="line">PAGE_FREE	        2	00 00：指向可重用空间的首指针</span><br><span class="line">PAGE_GARBAGE	    2	00 00：已标记为删除（deleted_flag）的记录的字节数</span><br><span class="line">PAGE_LAST_INSERT	2	01 17：最后插入记录的位置</span><br><span class="line">PAGE_DIRECTION	    2	00 02：最后插入的方向，PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0X03),PAGE_SAME_PAGE(0X04),PAGE_NO_DIRECTION(0x05)</span><br><span class="line">PAGE_N_DIRECTION	2	00 04：一个方向上连续插入记录的数量</span><br><span class="line">PAGE_N_RECS	        2	00 05：该页中记录（User Record）的数量</span><br><span class="line">PAGE_MAX_TRX_ID	    8	00 00 00 00 00 00  00 00：修改该页的最大事务ID（仅在辅助索引中定义）</span><br><span class="line">PAGE_LEVEL	        2	00 00：该页在索引树中位置，0000代表叶子节点</span><br><span class="line">PAGE_INDEX_ID	    8	00 00 00 00 00 00 00 3c：索引ID，表示该页属于哪个索引</span><br><span class="line">PAGE_BTR_SEG_LEAF	10	00 00 00 2c 00 00 00 02 00 f2：B+Tree叶子节点所在Leaf Node Segment的Segment Header（无关紧要）</span><br><span class="line">PAGE_BTR_SEG_TOP	10	00 00 00 2c 00 00 00 02 00 32：B+Tree非叶子节点所在Non-Leaf Node Segment的Segment Header（无关紧要）</span><br></pre></td></tr></table></figure>
<p>PAGE_INDEX_ID = 3c =3*16+12=60  索引ID可以在information_schema.INNODB_SYS_INDEXES 中查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.INNODB_SYS_INDEXES </span><br><span class="line"><span class="keyword">where</span> TABLE_ID <span class="keyword">in</span> (<span class="keyword">SELECT</span> TABLE_ID <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table5hang'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index_id    name    table_id    type    n_fields    page_no space</span><br><span class="line">60          PRIMARY 58          3       1           3       44</span><br></pre></td></tr></table></figure>

<p>PAGE_BTR_SEG_LEAF和PAGE_BTR_SEG_TOP INDEX页中的根结点才有的，非根结点的为0。<br>前10字节 00 00 00 2c 00 00 00 02 00 f2 是叶子结点所在段的segment header，分别记录了叶子结点的表空间ID 0x24，INODE页的页号 2 和 INODE项偏移 0xf2。<br>后10字节 00 00 00 2c 00 00 00 02 00 32 是非叶子结点所在段的segment header，偏移分别是0xf2 和 0x32，即INODE页的前2个Entry，文件段ID分别是1和2。<br>FSEG Header中存储了该 INDEX 页的INODE项，INODE项里面则记录了该页存储所在的文件段以及文件段页的使用情况。对于 File-Per-Table情况下，每个单独的表空间文件的 FSP_HDR 页负责管理页使用情况。</p>
<p><img src="/images/post/db-mysql/fseg.webp" alt=""></p>
<h3 id="System-Records-26字节-infimum和supermum-record"><a href="#System-Records-26字节-infimum和supermum-record" class="headerlink" title="System Records(26字节)-infimum和supermum record"></a>System Records(26字节)-infimum和supermum record</h3><p>offset:16<em>1024</em>3+38+56 = 49246</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49246 -n 60 table5hang.ibd</span><br><span class="line">0000c05e  01 00 02 00 1c 69 6e 66  69 6d 75 6d 00 06 00 0b  |.....infimum....|</span><br><span class="line">0000c06e  00 00 73 75 70 72 65 6d  75 6d 06 00 00 00 10 00  |..supremum......|</span><br><span class="line">0000c07e  26 80 00 00 00 00 00 00  01 00 00 00 00 74 d0 9e  |&amp;............t..|</span><br><span class="line">0000c08e  00 00 01 57 01 10 6e 61  6d 65 2d 31              |...W..name-1|</span><br><span class="line">0000c09a</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 00 02 00 1c 69 6e 66 69 6d 75 6d 00 |.....infimum....|</span><br><span class="line">06 00 0b 00 00 73 75 70 72 65 6d 75 6d |..supremum......|</span><br></pre></td></tr></table></figure>
<p>每个 INDEX 页都有两条虚拟记录 infimum 和 supremum，用于限定记录的边界，各占 13 个字节。<br>其中记录头的5个字节分别标识了拥有记录的数目和类型(拥有记录数目是即后面页目录部分的owned值，当前页目录只有两个槽，infimum拥有记录数只有它自己为1，<br>而supremum拥有我们插入的5条记录和它自己，故为6)、下一条记录的偏移 0x1c=28 向后【当前位置】偏移 28个，即位置是 0xC062+0x1c=0xc07e 的后一个 0xco7f，这就是我们实际数据记录开始位置。<br>后面8个字节为 infimum + 空值，supremum类似，只是它下一条记录偏移为0。</p>
<h3 id="User-Records-1"><a href="#User-Records-1" class="headerlink" title="User Records"></a>User Records</h3><p>offset:16<em>1024</em>3+38+56 +26 = 49272</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49272 -n 1000 table5hang.ibd</span><br><span class="line">0000c078  06 00 00 00 10 00 26 80  00 00 00 00 00 00 01 00  |......&amp;.........|</span><br><span class="line">0000c088  00 00 00 74 d0 9e 00 00  01 57 01 10 6e 61 6d 65  |...t.....W..name|</span><br><span class="line">0000c098  2d 31 80 00 00 01 06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line">0000c0a8  00 00 00 00 02 00 00 00  00 74 d0 9e 00 00 01 57  |.........t.....W|</span><br><span class="line">0000c0b8  01 20 6e 61 6d 65 2d 32  80 00 00 02 06 00 00 00  |. name-2........|</span><br><span class="line">0000c0c8  20 00 26 80 00 00 00 00  00 00 03 00 00 00 00 74  | .&amp;............t|</span><br><span class="line">0000c0d8  d0 9e 00 00 01 57 01 30  6e 61 6d 65 2d 33 80 00  |.....W.0name-3..|</span><br><span class="line">0000c0e8  00 03 06 00 00 00 28 00  26 80 00 00 00 00 00 00  |......(.&amp;.......|</span><br><span class="line">0000c0f8  04 00 00 00 00 74 d0 9e  00 00 01 57 01 40 6e 61  |.....t.....W.@na|</span><br><span class="line">0000c108  6d 65 2d 34 80 00 00 04  06 00 00 00 30 ff 59 80  |me-4........0.Y.|</span><br><span class="line">0000c118  00 00 00 00 00 00 05 00  00 00 00 74 d0 9e 00 00  |...........t....|</span><br><span class="line">0000c128  01 57 01 50 6e 61 6d 65  2d 35 80 00 00 05 00 00  |.W.Pname-5......|</span><br><span class="line">0000c138  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">0000c458  00 00 00 00 00 00 00 00                           |........|</span><br><span class="line">0000c460</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>查看 行记录格式 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">from</span> test_innodb <span class="keyword">like</span> <span class="string">'table5hang'</span></span><br><span class="line"><span class="comment">--- Compact</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接下来是插入的记录。Compact 【变长字段长度列表 小于255 1字节，大于 255 2】</span><br><span class="line">06  1字节记录的是可变变量的长度06，因为我们记录中c的值是 name-5。</span><br><span class="line">00  1字节记录的是可为NULL的变量是否是NULL，这里不为 NULL，故为0。</span><br><span class="line">记录头：00 00 10 00 26</span><br><span class="line">    Compact行记录格式 头格式</span><br><span class="line">    00  </span><br><span class="line">    00 10 &#x3D; 10110</span><br><span class="line">    00 26 &#x3D; 下一记录相对位置</span><br><span class="line">    后面就是记录内容。第2条记录同理。这里的事务ID可以通过 select * from information_schema.innodb_trx 进行验证。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line">0000c078  06 00 00 00 10 00 26 80  00 00 00 00 00 00 01 00  |......&amp;.........|</span><br><span class="line">0000c088  00 00 00 74 d0 9e 00 00  01 57 01 10 6e 61 6d 65  |...t.....W..name|</span><br><span class="line">0000c098  2d 31 80 00 00 01 06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line"></span><br><span class="line"> 06 00 00 00 10 00 26 # 列长+null标记+记录头</span><br><span class="line"> 80 00 00 00 00 00 00 01   # 主键值1  bigint</span><br><span class="line"> 00 00 00 00 74 d0    # 事务ID</span><br><span class="line"> 9e 00 00 01 57 01 10 # 回滚指针</span><br><span class="line"> 6e 61 6d 65 2d 31    # username的值 name-1  6个字节</span><br><span class="line"> 80 00 00 01          # 列 age &#x3D;1  int 4字节</span><br><span class="line"> </span><br><span class="line">第二行</span><br><span class="line">                            06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line">0000c0a8  00 00 00 00 02 00 00 00  00 74 d0 9e 00 00 01 57  |.........t.....W|</span><br><span class="line">0000c0b8  01 20 6e 61 6d 65 2d 32  80 00 00 02 06 00 00 00  |. name-2........|</span><br><span class="line"></span><br><span class="line"> 06 00 00 00 18 00 26 # 第2条记录头</span><br><span class="line"> 80 00 00 00 00 00 00 02   # 主键值1  bigint</span><br><span class="line"> 00 00 00 00 74 d0    # 事务ID</span><br><span class="line"> 9e 00 00 01 57 01 20 # 回滚指针</span><br><span class="line"> 6e 61 6d 65 2d 32    # username的值 name-1  6个字节</span><br><span class="line"> 80 00 00 01          # 列 age &#x3D;1  int 4字节</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">![](&#x2F;images&#x2F;post&#x2F;db-mysql&#x2F;bptree.webp)</span><br><span class="line"></span><br><span class="line">### Page Directory(4字节)</span><br><span class="line"></span><br><span class="line">因为页目录的slot只有2个，每个slot占2字节，故页目录为 00 70 00 63 这4字节，存储的是相对于最初行的位置。</span><br><span class="line"></span><br><span class="line">其中 0xc063 正好是 infimum 记录的开始位置，而 0xc070 正好是 supremum 记录的开始位置。使用页目录进行二分查找，可以加速查询，详细见后面分析。</span><br><span class="line"></span><br><span class="line">offset:16*1024*4 - 4 - 8 &#x3D; 65524</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">hexdump -C -s 65524 -n 4 table5hang.ibd</span><br><span class="line">0000fff4  00 70 00 63                                       |.p.c|</span><br><span class="line">0000fff8</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<h3 id="FIL-Tail-8字节"><a href="#FIL-Tail-8字节" class="headerlink" title="FIL Tail (8字节)"></a>FIL Tail (8字节)</h3><p>offset:16<em>1024</em>4 - 8 = 65528</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 65528 -n 8 table5hang.ibd</span><br><span class="line">0000fff8  bd 11 4b e6 80 eb af c9                           |..K.....|</span><br><span class="line">00010000</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>其中 bd 11 4b e6 为 checknum，跟 FIL Header的checksum一样。【没有匹配上，需要继续查看资料】</p>
<p>后4字节80 eb af c9 与 FIL Header的LSN的后4个字节一致。</p>
<h2 id="通过-innodb-ruby-工具来分析表空间文件"><a href="#通过-innodb-ruby-工具来分析表空间文件" class="headerlink" title="通过 innodb_ruby 工具来分析表空间文件"></a>通过 innodb_ruby 工具来分析表空间文件</h2><p>mac安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ruby</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rubygems/rubygems.git</span><br><span class="line"><span class="built_in">cd</span> rubygems/bin/</span><br><span class="line">./gem install innodb_ruby</span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang space-page-type-regions</span><br><span class="line">start       end         count       <span class="built_in">type</span>                </span><br><span class="line">0           0           1           FSP_HDR             </span><br><span class="line">1           1           1           IBUF_BITMAP         </span><br><span class="line">2           2           1           INODE               </span><br><span class="line">3           3           1           INDEX               </span><br><span class="line">4           5           2           FREE (ALLOCATED)    </span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>查看具体数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 page-records</span><br><span class="line"><span class="comment"># Record 127: (id=1) → (username="name-1", age=1)</span></span><br><span class="line"><span class="comment"># Record 165: (id=2) → (username="name-2", age=2)</span></span><br><span class="line"><span class="comment"># Record 203: (id=3) → (username="name-3", age=3)</span></span><br><span class="line"><span class="comment"># Record 241: (id=4) → (username="name-4", age=4)</span></span><br><span class="line"><span class="comment"># Record 279: (id=5) → (username="name-5", age=5)</span></span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<h2 id="其他-XDES页"><a href="#其他-XDES页" class="headerlink" title="其他-XDES页"></a>其他-XDES页</h2><p>簇或者分区（extent）是段的组成元素，在文件头使用FLAG描述了创建表信息，除此之外其他部分的数据结构和XDES PAGE都是相同的，<br>使用连续数组的方式，每个XDES PAGE最多存储256个XDES Entry，每个Entry占用40个字节，描述64个Page（即一个Extent）。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">XDES_ID	8	如果该Extent归属某个segment的话，则记录其ID</span><br><span class="line">XDES_FLST_NODE	12(FLST_NODE_SIZE)	维持Extent链表的双向指针节点</span><br><span class="line">XDES_STATE	4	该Extent的状态信息，包括：XDES_FREE，XDES_FREE_FRAG，XDES_FULL_FRAG，XDES_FSEG，详解见下文</span><br><span class="line">XDES_BITMAP	16	总共16*8&#x3D; 128个bit，用2个bit表示Extent中的一个page，一个bit表示该page是否是空闲的(XDES_FREE_BIT)，另一个保留位，尚未使用（XDES_CLEAN_BIT）</span><br></pre></td></tr></table></figure>
<p>XDES_STATE表示该Extent的四种不同状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	Desc</span><br><span class="line">XDES_FREE(1)	存在于FREE链表上</span><br><span class="line">XDES_FREE_FRAG(2)	存在于FREE_FRAG链表上</span><br><span class="line">XDES_FULL_FRAG(3)	存在于FULL_FRAG链表上</span><br><span class="line">XDES_FSEG(4)	该Extent归属于ID为XDES_ID记录的值的SEGMENT。</span><br></pre></td></tr></table></figure>
<p>通过XDES_STATE信息，我们只需要一个FLIST_NODE节点就可以维护每个Extent的信息，是处于全局表空间的链表上，还是某个btree segment的链表上。</p>
<h2 id="文件维护"><a href="#文件维护" class="headerlink" title="文件维护"></a>文件维护</h2><p>从上文我们可以看到，InnoDB通过Inode Entry来管理每个Segment占用的数据页，每个segment可以看做一个文件页维护单元。Inode Entry所在的inode page有可能存放满，因此又通过头Page维护了Inode Page链表。</p>
<p>在ibd的第一个Page中还维护了表空间内Extent的FREE、FREE_FRAG、FULL_FRAG三个Extent链表；而每个Inode Entry也维护了对应的FREE、NOT_FULL、FULL三个Extent链表。这些链表之间存在着转换关系，以高效的利用数据文件空间。</p>
<p>注意区别：表空间中的链表管理的是整个表空间中所有的簇，包括满簇、半满簇及空闲簇，而段的iNode信息中管理的是属于自己段中的满簇、半满簇及空闲簇。</p>
<p>当创建一个新的索引时，实际上构建一个新的btree(btr_create)，先为非叶子节点Segment分配一个inode entry，再创建root page，并将该segment的位置记录到root page中，然后再分配leaf segment的Inode entry，并记录到root page中。当删除某个索引后，该索引占用的空间需要能被重新利用起来。</p>
<p>创建一个segment：</p>
<p>函数入口：fseg_create_general。</p>
<ol>
<li><p>根据空间id得到表空间头信息。</p>
</li>
<li><p>从得到的表空间头信息分配Inode:具体实现为读取文件头Page并加锁（fsp_get_space_header），然后开始为其分配Inode Entry(fsp_alloc_seg_inode)。</p>
<p> 为了管理Inode Page，在文件头存储了两个Inode Page链表，一个链接已经用满的inode page，一个链接尚未用满的inode page。如果当前Inode Page的空间使用完了，<br> 就需要再分配一个inode page，并加入到FSP_SEG_INODES_FREE链表上(fsp_alloc_seg_inode_page)。对于独立表空间，通常一个inode page就足够了。</p>
</li>
</ol>
<p>具体查找inode Page过程：首先判断FSP_SEG_INODES_FREE链表是否还有空闲页面，如果有，则从页面的数据存储位置开始扫描，没找一个Inode，先判断是否空闲（空闲表示其不归属任何segment，即FSEG_ID置为0）。<br>找到则返回。找到这个且这个Inode为这个页最后一个Inode.则该inode page中的记录用满了，就从FSP_SEG_INODES_FREE链表上转移到FSP_SEG_INODES_FULL链表。<br>如果FSP_SEG_INODES_FREE没有空闲的Inode页面，则重新分配一个inode页面，分配后把所有描述符里面的FSEG_ID置为0，重复上面过程。</p>
<ol start="3">
<li><p>给新分配的Inode设置SEG_ID. 这个ID号要从表空间头信息的FSP_SEG_ID作为当前segment的seg id写入到inode entry中。同时更新FSP_SEG_ID的值为ID+1，作为下一个段的ID号。</p>
</li>
<li><p>在完成inode entry的提取后，初始化这个Inode信息。把FSEG_NOT_FULL_N_USED置为0，初始化FSEG_FREE、FSEG_NOT_FULL，FSEG_FULL。</p>
</li>
<li><p>从这个段分配出一个页面。（这块逻辑不太懂）</p>
</li>
<li><p>分配好页面后，通过缓存找到段的首页面（页面号为page+index）。就将该inode entry所在inode page的位置及页内偏移量存储到段首页，10个字节的inode信息包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">FSEG_HDR_SPACE	4	描述该segment的inode page所在的space id （目前的实现来看，感觉有点多余…）</span><br><span class="line">FSEG_HDR_PAGE_NO	4	描述该segment的inode page的page no</span><br><span class="line">FSEG_HDR_OFFSET	2	inode page内的页内偏移量</span><br></pre></td></tr></table></figure>
<p>至此段就分配完成了，以后如果需要在这个段中分配空间，只需要找到其首页，然后根据对应的Inode分配空间。</p>
</li>
</ol>
<p>分配数据页函数 fsp_alloc_free_page</p>
<p>表空间Extent的分配函数fsp_alloc_free_extent。</p>
<p>对应的还有释放Segment 当我们删除索引或者表时，需要删除btree（btr_free_if_exists），先删除除了root节点外的其他部分(btr_free_but_not_root)，再删除root节点(btr_free_root)</p>
<p>由于数据操作都需要记录redo，为了避免产生非常大的redo log，leaf segment通过反复调用函数fseg_free_step来释放其占用的数据页。</p>
<h2 id="创建B-索引"><a href="#创建B-索引" class="headerlink" title="创建B+索引"></a>创建B+索引</h2><p>innodb的文件管理方式，核心目的是为了管理好B+索引。</p>
<p>ibd文件中真正构建起用户数据的结构是BTREE，在你创建一个表时，已经基于显式或隐式定义的主键构建了一个btree，其叶子节点上记录了行的全部列数据（加上事务id列及回滚段指针列）；</p>
<p>如果你在表上创建了二级索引，其叶子节点存储了键值加上聚集索引键值。所以书上贴一段创建B+索引的代码。网上找了5.6.15版本的。</p>
<p>这个函数就是创建一个B+树，只是概念上的，还没有真正的数据写入。</p>
<h1 id="页内-页目录"><a href="#页内-页目录" class="headerlink" title="页内-页目录"></a>页内-页目录</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(<span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>, ch <span class="built_in">varchar</span>(<span class="number">10</span>), <span class="keyword">key</span>(ch));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(ch) <span class="keyword">values</span>(<span class="string">'ab'</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个新的测试表 t2，有主索引 id 和 辅助索引 ch，分析 t2.ibd 文件可验证：</p>
<ul>
<li>对比没有辅助索引的表，表t2多一个INDEX页，用于存储辅助索引的根结点。</li>
<li>辅助索引的INDEX页也有两个系统记录 infimum 和 supremum。而用户记录内容格式跟前面分析基本一致，内容为辅助索引 ch 列的值 ab 和 主键值1。</li>
</ul>
<p>INDEX页内的记录是通过单向链表连接在一起的，遍历列表性能会比较差，而INDEX页的页目录就是为了加速记录搜索。</p>
<p>表 t2 中的页目录只有两项，分别是 0x63 和 0x70，即 99 和 112。</p>
<p>下面的ownedkey为这个页目录槽拥有的小于等于它的记录数目，显然 infimum 的ownedkey为 1，即只有它自己，没有key会比infimum小。</p>
<p>而 supremum 的owned是3，分别是我们插入的两条记录和它自己。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slot    offset  type          owned  key</span><br><span class="line">0       99      infimum       1       </span><br><span class="line">1       112     supremum      3</span><br></pre></td></tr></table></figure>
<p>每个页目录槽最少要包含4个记录，最多包含8个记录(包括它自己)。如果我们在表 t2 中另外插入 7 条记录，则会增加一个新的slot，即 id 为 4 的记录，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slot    offset  type          owned   key</span><br><span class="line">0       99      infimum       1       </span><br><span class="line">1       207     conventional  4       (i&#x3D;4)</span><br><span class="line">2       112     supremum      5</span><br></pre></td></tr></table></figure>
<p>下图是页目录结构图，可以通过页目录的二分查找提高页内数据的查询性能。</p>
<p><img src="/images/post/db-mysql/bptreepagestruct.webp" alt=""></p>
<p>参考：</p>
<p><a href="http://mysql.taobao.org/monthly/2016/02/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/02/01/</a></p>
<p>《MYSQL运维内参》<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html</a></p>
<p>链接：<a href="https://blog.csdn.net/bohu83/article/details/81086474" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/article/details/81086474</a><br><a href="http://mysql.taobao.org/monthly/2016/02/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/02/01/</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>05-存储引擎层-innodb框架-表空间-ibd</title>
    <url>/articles/20200202/20b74871.html</url>
    <content><![CDATA[<p>摘要：<br>innodb文件系统是由一些log和每个表的ibd（16K的整数倍）等文件组成的。内部结构如下。</p>
<a id="more"></a>

<h1 id="表空间-idb简述"><a href="#表空间-idb简述" class="headerlink" title="表空间-idb简述"></a>表空间-idb简述</h1><p>ibd是存表数据的，那么在计算机里，所有的存储都是有最小存储单元的。</p>
<p>在磁盘上，最小的单元是扇区，一个扇区是512字节，操作系统中最小单元是块（block），最小单位是4K。而innodb也有自己的最小存储单元——页（page），一页是16K。</p>
<p>这意味着一个文件放到电脑上，哪怕它是空的，也要占用4K，它占用的空间永远是4K的整数倍。</p>
<p>可以去查看每个ibd文件的大小，它永远是16384（16k）的整数倍。</p>
<p>后续说明索引加载表数据的前提，mysql的数据最小是16K，也就是哪怕你只取一条，可能还不到1K，那么mysql也会取出16K的数据。</p>
<p>因为“页”是最小单位。“页”还决定了b+ tree在某个高度下，能存放的数据量，为什么一个表存2万数据，和存1500万数据，查询速度一样。</p>
<h2 id="单个文件表空间-frm、ibd"><a href="#单个文件表空间-frm、ibd" class="headerlink" title="单个文件表空间-frm、ibd"></a>单个文件表空间-frm、ibd</h2><p>如果想让两个表共用一个数据文件的话,共用一个ibdata，可以通过<strong>innodb_file_per_table</strong>控制。默认每个表一个。</p>
<p>创建了一个数据库test_innodb，并且创建了几个表，可以在数据目录看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.opt</span><br><span class="line">table5hang.frm</span><br><span class="line">table5hang.ibd</span><br><span class="line">table15w.frm</span><br><span class="line">table15w.ibd</span><br><span class="line">table500w.frm</span><br><span class="line">table500w.ibd</span><br><span class="line">table1000w.frm</span><br><span class="line">table1000w.ibd</span><br></pre></td></tr></table></figure>
<p>当新建一个库时，首先文件系统上会多一个以库名命名的文件夹。里面有ibd、frm文件，每个表对应一个ibd文件。</p>
<ul>
<li><p>db.opt 保存了数据库test的默认字符集 utf8mb4 和校验方法utf8mb4_general_ci；<br>存储的是mysql的一些配置信息，如编码、排序的信息，如果在创建数据库时指定了一些非默认参数的话，也会存到该文件。</p>
</li>
<li><p>每个表会对应一个frm文件，一个ibd文件。</p>
<ul>
<li><p>frm文件是表结构，无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。<br>数据字典信息(InnoDB数据字典信息主要是存储在系统表空间ibdata1文件中，由于历史原因才在 t.frm 多保留了一份)</p>
</li>
<li><p>ibd是表的数据和索引，是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p>
</li>
</ul>
</li>
</ul>
<p>独立的表空间文件之存储对应表的B+树数据、索引和插入缓冲等信息，其余信息还是存储在默认表空间中。</p>
<p>这个文件所存储的内容主要就是B+树（索引），一个表可以有多个索引，也就是在一个文件中，可以存储多个索引，而如果一个表没有索引的话，用来存储数据的被称为聚簇索引，也就是说这也是一个索引。</p>
<h3 id="采用-File-Per-Table-的优缺点"><a href="#采用-File-Per-Table-的优缺点" class="headerlink" title="采用 File-Per-Table 的优缺点"></a>采用 File-Per-Table 的优缺点</h3><ul>
<li>优点：可以方便回收删除表所占的磁盘空间。如果使用系统表空间的话，删除表后空闲空间只能被 InnoDB 数据使用。TRUNCATE TABLE 操作会更快。<br>可以单独拷贝表空间数据到其他数据库(使用 transportable tablespace 特性)，可以更方便的观测每个表空间数据的大小。</li>
<li>缺点：fsync 操作需要作用的多个表空间文件，比只对系统表空间这一个文件进行fsync操作会多一些 IO 操作。此外，mysqld需要维护更多的文件描述符。</li>
</ul>
<h2 id="当新建库时，innodb内部操作"><a href="#当新建库时，innodb内部操作" class="headerlink" title="当新建库时，innodb内部操作"></a>当新建库时，innodb内部操作</h2><p>innodb存储引擎在存储设计上模仿了Oracle的存储结构，其数据是按照表空间进行管理的。</p>
<p>新建一个数据库时，innodb存储引擎会初始化一个名为ibdata1 的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表sys_tables、sys_columns、sys_indexes 、sys_fields等。</p>
<p>此外，还会存储用来保证数据完整性的回滚段数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了；</p>
<p>注：不同的表既可以共用一个ibd文件，也可以每个表自己一个ibd文件，默认是一个表一个。</p>
<p>虽然是一个表一个ibd，但这个ibd里只存储了该表的B+树数据、索引、插入缓存等信息，其余的信息如列、属性等信息还是存储在默认的ibdata1里面的。</p>
<figure class="highlight plain"><figcaption><span>官网介绍</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A data file that can hold data for one or more InnoDB tables and associated indexes.</span><br><span class="line"> </span><br><span class="line">The system tablespace contains the InnoDB data dictionary, and prior to MySQL 5.6 holds all other InnoDB tables by default.</span><br><span class="line"> </span><br><span class="line">The innodb_file_per_table option, enabled by default in MySQL 5.6 and higher, allows tables to be created in their own tablespaces.</span><br><span class="line"> </span><br><span class="line">File-per-table tablespaces support features such as efficient storage of off-page columns, table compression, and transportable tablespaces.</span><br><span class="line">See Section 14.7.4, “InnoDB File-Per-Table Tablespaces” for details.</span><br></pre></td></tr></table></figure>

<h2 id="ibd存储的数据"><a href="#ibd存储的数据" class="headerlink" title="ibd存储的数据"></a>ibd存储的数据</h2><p>该表的所有索引数据【聚集索引】。</p>
<p>这里使用了B+tree,B+ tree的叶子节点，就会存放所有的数据。整个表，其实就是一棵B+ tree，一个ibd就是1-N个b+ tree。N等于你的索引数量</p>
<p>当新建一个表时，会给表创建一个主键primary Key，然后这个key就带着整行数据占据着一块空间，作为B+ tree的一个叶子节点里元素。</p>
<p>可以理解为一个key-value键值对，key就是主键，value就是整行数据。如果你根本就没创建主键（不推荐），那innodb也会给你分配一个RowId来作为将来找它的主键，只是看不到。</p>
<p>这棵拥有全量数据的b+ tree，就是将来提供数据的树，一般来说，这棵树最大一般4层，3层就能存2千万数据了，4层能达到n个亿，将来通过主键查询时，通过2-4次IO就能找到数据行。这个索引树，即——聚簇索引。</p>
<h1 id="表空间-ibd内文件结构"><a href="#表空间-ibd内文件结构" class="headerlink" title="表空间-ibd内文件结构"></a>表空间-ibd内文件结构</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>04-存储引擎层-innodb框架-磁盘上的结构-表空间</title>
    <url>/articles/20200202/e9a15921.html</url>
    <content><![CDATA[<p>摘要：<br>物理存储， InnoDB 里的所有表数据，都以索引（聚簇索引+二级索引）的形式存储起来，索引包含了表数据。</p>
<a id="more"></a>

<h1 id="磁盘上的结构"><a href="#磁盘上的结构" class="headerlink" title="磁盘上的结构"></a>磁盘上的结构</h1><p>磁盘中的结构分为两大类：表空间和重做日志。</p>
<ul>
<li>表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。<br>系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等。</li>
<li>Redo日志：存储的就是 Log Buffer 刷到磁盘的数据。</li>
</ul>
<h2 id="innodb整体文件结构"><a href="#innodb整体文件结构" class="headerlink" title="innodb整体文件结构"></a>innodb整体文件结构</h2><p>物理存储文件结构中黑框里的就是innodb。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ibdata1</span><br><span class="line">ib_logfile0</span><br><span class="line">ib_logfile1</span><br></pre></td></tr></table></figure>
<p>有两个默认的日志文件，logfile0和logfile1，大小可以手工设定。</p>
<p>InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。另一部分是idb。</p>
<h3 id="InnoDB-表结构"><a href="#InnoDB-表结构" class="headerlink" title="InnoDB 表结构"></a>InnoDB 表结构</h3><p>InnoDB 与 MyISAM 不同，它在系统表空间存储数据字典信息，因此它的表不能像 MyISAM 那样直接拷贝数据表文件移动。</p>
<p>MySQL5.7 采用的文件格式是 Barracuda，它支持 COMPACT 和 DYNAMIC 这两种新的行记录格式。</p>
<p>创建表时可以通过 ROW_FORMAT 指定行记录格式，默认是 DYNAMIC。查看表信息，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table15w'</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">from</span> test_innodb <span class="keyword">like</span> <span class="string">'table15w'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: table15w</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 149641</span><br><span class="line"> Avg_row_length: 52</span><br><span class="line">    Data_length: 7880704</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 4194304</span><br><span class="line"> Auto_increment: 150001</span><br><span class="line">    Create_time: 2020-01-31 03:40:25</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment:</span><br></pre></td></tr></table></figure>
<p>InnoDB表使用上有一些限制，如一个表最多只能有64个辅助索引，一行大小不能超过65535等，组合索引不能超过16个字段等，一般应该不会突破限制，详细见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-restrictions.html" target="_blank" rel="noopener">innodb-restrictions</a>。</p>
<h3 id="InnoDB-表空间"><a href="#InnoDB-表空间" class="headerlink" title="InnoDB 表空间"></a>InnoDB 表空间</h3><p>表空间根据类型可以分为：系统表空间，File-Per-Table 表空间{即ibd}，常规表空间，Undo表空间，临时表空间等。</p>
<ul>
<li><p>系统表空间：包含内容有数据字典，双写缓冲，修改缓冲以及undo日志，以及在系统表空间创建的表的数据和索引。</p>
</li>
<li><p>常规表空间：类似系统表空间，也是一种共享的表空间，可以通过 CREATE TABLESPACE 创建常规表空间，多个表可共享一个常规表空间，也可以修改表的表空间。<br>注意：必须删除常规表空间中的表后才能删除常规表空间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">`ts1`</span> <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">'ts1.ibd'</span> <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c2 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t2 <span class="keyword">TABLESPACE</span>=innodb_file_per_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLESPACE</span> ts1;</span><br></pre></td></tr></table></figure></li>
<li><p>File-Per-Table表空间：MySQL InnoDB新版本提供了 innodb_file_per_table 选项，每个表可以有单独的表空间数据文件(.ibd)，而不是全部放到系统表空间数据文件 ibdata1 中。在 MySQL5.7 中该选项默认开启。</p>
</li>
<li><p>其他表空间：其他表空间中Undo表空间存储的是Undo日志。除了存储在系统表空间外，Undo日志也可以存储在单独的Undo表空间中。<br>临时表空间则是非压缩的临时表的存储空间，默认是数据目录的 ibtmp1 文件，所有临时表共享，压缩的临时表用的是 File-Per-Table 表空间。</p>
</li>
</ul>
<h1 id="innodb承上启下的结构"><a href="#innodb承上启下的结构" class="headerlink" title="innodb承上启下的结构"></a>innodb承上启下的结构</h1><p><img src="/images/post/db-mysql/005/innodb-jiegou.png" alt=""></p>
<p>Handler API是供mysql server层调用的，server层定义了一些接口，譬如insert、delete，具体怎么实现，是由每个存储引擎自己实现的。</p>
<p>以上图中间虚线为分界，上面的是逻辑层，每个访问都会产生事务，事务处理会产生锁（表锁、行锁），操作对象是表、索引、b+ tree。对数据页面的访问需要物理事务，为了读写一致性，需要读写锁（物理锁）。为了高效定位和管理“页”，需要用到文件管理系统。</p>
<p>这些都是基于逻辑的处理，再往下就是物理层。</p>
<p>在逻辑处理和磁盘文件之间，都是有一层缓存的，这里主要是日志缓冲区和innodb_buffer_pool。和其他常用的kafka、elasticsearch、rocksDB等等一样，要保持性能，必然都遵循相同或类似的规则，那就是写pageCache、顺序写磁盘，这是决定任何一个带存储功能的性能的关键点。</p>
<p>innodb_buffer_pool，未来能对性能起决定性作用的一个重要因子。决定读写速度的都是内存，只要要读的数据在内存里，它就比在磁盘上快。redis就是靠内存，mysql的数据缓存，就取决于innodb_buffer_pool。</p>
<p>缓冲层提供了高效的读写性能，再下面就是物理文件层了，是落到磁盘上的。</p>
<p>磁盘上重要的地方有REDO日志，和表数据（页）</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>03-存储引擎层、InnoDB 架构</title>
    <url>/articles/20200201/4ced7854.html</url>
    <content><![CDATA[<p>摘要：物理存储文件结构</p>
<a id="more"></a>

<h1 id="物理存储文件结构"><a href="#物理存储文件结构" class="headerlink" title="物理存储文件结构"></a>物理存储文件结构</h1><p><img src="/images/post/db-mysql/005/jiegou.png" alt=""></p>
<p>my.cnf，配置文件。</p>
<p>slow.log，记录慢查询日志，当语句执行时间超过参数long_query_time的值时，会被记录到该log，需要开启配置后才有。</p>
<p>error.log，记录错误和警告信息。</p>
<p>general.log，记录所有在数据库上执行的语句，可以用来追踪问题，文件增长很快，也很大，一般不会打开，需要要调试时可以打开。</p>
<p>系统默认库有4个，存储系统信息的，表名、列名、列属性等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">information_scherma</span><br><span class="line">mysql</span><br><span class="line">performance_scherma</span><br><span class="line">sys</span><br></pre></td></tr></table></figure>

<h1 id="InnoDB-架构"><a href="#InnoDB-架构" class="headerlink" title="InnoDB 架构"></a>InnoDB 架构</h1><p><img src="/images/post/db-mysql/innodb-struct.webp" alt=""></p>
<p>从上面第二张图可以看到，InnoDB 主要分为两大块：</p>
<ul>
<li>InnoDB In-Memory Structures【内存中的结构】</li>
<li>InnoDB On-Disk Structures【磁盘上的结构】</li>
</ul>
<p>InnoDB 使用日志先行策略，将数据修改先在内存中完成，并且将事务记录成重做日志(Redo Log)，转换为顺序IO高效的提交事务。</p>
<p>这里日志先行，说的是日志记录到数据库以后，对应的事务就可以返回给用户，表示事务完成。</p>
<p>但是实际上，这个数据可能还只在内存中修改完，并没有刷到磁盘上去。内存是易失的，如果在数据落地前，机器挂了，那么这部分数据就丢失了。</p>
<p>InnoDB 通过 redo 日志来保证数据的一致性。如果保存所有的重做日志，显然可以在系统崩溃时根据日志重建数据。</p>
<p>当然记录所有的重做日志不太现实，所以 InnoDB 引入了检查点机制。即定期检查，保证检查点之前的日志都已经写到磁盘，则下次恢复只需要从检查点开始。</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>02-Server服务层</title>
    <url>/articles/20200201/73b4253b.html</url>
    <content><![CDATA[<p>摘要：Server服务层聚集了mysql的最多的逻辑，包括了请求解析、查询缓存、语义分析、查询优化、各种计算函数、扫描记录、binlog、缓存、锁、内存管理等等。</p>
<a id="more"></a>

<h1 id="表对象缓存"><a href="#表对象缓存" class="headerlink" title="表对象缓存"></a>表对象缓存</h1><p><img src="/images/post/db-mysql/store.jpg" alt=""><br><img src="/images/post/db-mysql/004/zhixing.png" alt=""></p>
<p>创建一个表，设置列、列属性，索引等，并且指定好了存储引擎（默认innodb）。</p>
<h2 id="表结构缓存、表对象缓存"><a href="#表结构缓存、表对象缓存" class="headerlink" title="表结构缓存、表对象缓存"></a>表结构缓存、表对象缓存</h2><p>客户端发过来一个sql，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tableA <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>此时mysql获取到此请求，会先到查询缓存中查看，是不是执行过这个语句。缓存里key就是这个查询语句，如果查询缓存有，那么就直接返回value给客户端。这个查询缓存比较没有意义，新版8.0已经把它删掉了。</p>
<p>mysql收到请求后，会进行sql语句解析，会分析出，你是查询（插入、删除），哪个表（tableA、tableB），条件。然后先判断sql语句是否合法，假如你写了个selector * 那么就会报错。</p>
<p>解析出了表之后，要得到这个表的各种信息。</p>
<h3 id="一级表结构缓存"><a href="#一级表结构缓存" class="headerlink" title="一级表结构缓存"></a>一级表结构缓存</h3><p>要操作这个表，首先要找到这个表。先从缓存中（源码里的table_def_cache，是一个Hash结构）找，根据表名做为Key去找，由于是第一次访问这个表，缓存里没有。</p>
<p>那么会从System表里去找，mysql元数据里有每个表的定义，列信息等。找到这个表，就会构建出这个表的结构体TABLE_SHARE。</p>
<p>这个TABLE_SHARE是一个静态的、不允许修改的（在内存中）结构体TABLE_SHARE，并将其放入缓存中（一个Hash结构里，key就是表名+模式名）。</p>
<p>可以理解为一个java里的类，每个字段已经被赋了初始值。这个缓存是属于mysql server层的，与后面的存储引擎无关。里面保存了表名、库名、所有列信息、列默认值、表的字符集、对应的frm文件路径、对应的存储引擎、主键等。</p>
<p>注意，这个结构体就是一级缓存，它被所有用户共享，并且不可修改，从系统表被读入直到该表被修改或删除，这个缓存都会一直存在。</p>
<h3 id="二级表对象缓存"><a href="#二级表对象缓存" class="headerlink" title="二级表对象缓存"></a>二级表对象缓存</h3><p>表已经找到了，结构也已经被缓存了，此时还不能操作这个表。因为缺少一个表对象。</p>
<p>上面的TABLE_SHARE可以理解为一个模板类，包含了表的基本信息，能被所有用户共享。</p>
<p>但是里面还缺少一些信息，譬如不同用户对该表的权限、譬如存储引擎信息。那么要想操作这个表，就需要创建一个表对象来供当前用户（线程）使用。</p>
<p>创建表对象就是实例化的过程，每个用户独享一个实例，我们称之为table实例，不会影响其他用户。</p>
<p>创建的这个实例，里面有一个指向TABLE_SHARE的引用，用以获取基本信息，还有一些其他属性，譬如存储引擎层的信息也会被初始化（引擎的handler）。</p>
<p>表对象创建完毕后，就具备了和存储引擎交互的能力（通过handler）。创建后，也会放入缓存，供下次使用时避免反复创建实例。</p>
<p>mysql层与存储引擎层，就是从这里开始区分，table对象就是沟通的桥梁。对于各个存储引擎，需要提供公共的接口来供上层（mysql server）层来调用，并由各自的table实例来完成各自的操作。<br>譬如插入一条记录，就可以调用table实例中被初始化过的存储引擎的句柄接口函数ha_write_row，进行写入。</p>
<p>这个table实例在一次操作完成之后就不需要了，系统此时并没有将其释放掉，而是保存下来，用一个状态标志位标记一下，并且会调用handler.reset()来重置引擎表状态，目的是handler会被复用，如果不reset，可能导致信息错误。缓存后，当下次用户再访问时，就不需要重新实例化了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到，当你想操作一个表时，系统对于这个表，会有两层缓存。第一层是SHARE缓存，第二层就是实例化后的对象缓存Table。</p>
<ul>
<li>缓存淘汰策略，<ul>
<li>SHARE缓存只有在表结构定义改变时，才会被删除，但是倘若表巨多，SHARE缓存超出限制，也会淘汰那些不经常使用的SHARE。</li>
<li>第二层的实例缓存，也是有最大值的，超出后则开始淘汰。</li>
</ul>
</li>
</ul>
<p>涉及的参数变量有两个，table_open_cache和table_definition_cache，一些淘汰策略数值就是靠这两个参数来计算得到的。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>不同于某些数据库，一启动就加载了所有表信息。mysql是按需加载，由于mysql的插件式存储引擎，mysql做了两层的缓存模型，第二层才加载引擎的handler。</p>
<ul>
<li>优点：<br>按需加载，提高内存利用率，避免启动时加载所有表信息带来的内存占用。</li>
</ul>
<ul>
<li>缺点：<br>两层缓存带来了效率的损失，每个用户（线程）都要实例化table对象。<br>在并发情况下，有可能会实例化多个table对象，导致table_open_cache增长过快，导致淘汰掉其他的table对象。同时倘若table比较大，譬如有N多的列，那么会占用非常多的内存。</li>
</ul>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>01-网络连接层</title>
    <url>/articles/20200201/3a03a839.html</url>
    <content><![CDATA[<p>摘要：数据库三层架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网络层</span><br><span class="line">  ↓</span><br><span class="line">server层</span><br><span class="line">  ↓</span><br><span class="line">存储层</span><br></pre></td></tr></table></figure>
<p>存储层：mysql作为一个插件式的数据库，在存储层支持多种引擎，譬如默认的innodb，和之前版本默认的MyIsam。由不同的引擎提供相同的接口给server层调用，来完成数据的增删改查。</p>
<p>server层：是mysql比较复杂的地方，里面包含了大量的逻辑，譬如语义分析、查询优化、日志、缓存等等。</p>
<p>网络层：主要是提供socket连接。</p>
<a id="more"></a>

<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在mysql的网络层，主要关注3点</p>
<ol>
<li>Poll、Select模型</li>
<li>Max-connections</li>
<li>connection复用</li>
</ol>
<p>mysql在启动后，创建了socket server，绑定了3306端口，并对其进行监听。和java里的写法类似，用一个while循环来监听新来的connection，如果有了新连接，就创建一个新的连接线程去处理（不能超过max-connections）。</p>
<p>这种就是典型的BIO的模式，为每一个连接创建一个线程。并且，mysql在这里采用了IO多路复用，会有一个if语句来判断当前系统是否支持Poll模式，否则就走Select模型（各个系统默认都有实现）。</p>
<p>Poll模型和Select非常类似，只是少了1024个fd的限制，都是采用遍历数组轮询有没有新IO事件的方式，在连接数较少的情况下，性能优异，要好于epoll。</p>
<p>mysql基于BIO，本质上是不接受大量的socket连接的，所以设置了max-connections这个限制，超过设置的max，那么新来的连接会被拒绝。</p>
<p>那么，第一个问题，为什么是BIO，而不是可以承受更大连接数的NIO和AIO呢？是否用NIO就会更好呢？</p>
<h3 id="mysql的BIO"><a href="#mysql的BIO" class="headerlink" title="mysql的BIO"></a>mysql的BIO</h3><h4 id="bio和nio的区别"><a href="#bio和nio的区别" class="headerlink" title="bio和nio的区别"></a>bio和nio的区别</h4><p>在BIO模式下，调用read，如果发现没数据，就会Block住。</p>
<p>在NIO模式下，调用read，如果发现没数据，就会立刻返回-1, 并且errno被设为EAGAIN。</p>
<h5 id="基于NIO-IO多路复用的模式"><a href="#基于NIO-IO多路复用的模式" class="headerlink" title="基于NIO+IO多路复用的模式"></a>基于NIO+IO多路复用的模式</h5><p>server开发使用的web容器：tomcat、netty等，都是基于NIO+IO多路复用的模式，来大幅提升性能，承载高并发访问的。但是到了DB层，则使用hakiri、druid之类的线程池，开启10个线程去连接mysql，反复复用这个线程池。</p>
<p>NIO+IO多路复用，并不是指多个用户socket共享一个IO，从而使得服务端的socket数量大减。而是把多个socket连接，归并到一个进程进行管理，如用一个大数组来聚合起来，然后循环遍历这个数组，来一次性把多个连接的事件通知业务代码进行处理。<br>这样就大幅减少了server的压力，高效利用资源。</p>
<p>对mysql来说，一般都会有多个连接，毕竟并发肯定是要有的。不可能做个查询，也要大家一起排队等上一个人查询完。所以线程池和并发是一定的。</p>
<h5 id="mysql和web-Server区别"><a href="#mysql和web-Server区别" class="headerlink" title="mysql和web Server区别"></a>mysql和web Server区别</h5><p>Web请求，往往是无状态的，一问一答的时候居多，请求也往往比较短促，对于顺序性也不是十分严格，哪怕是后请求的响应比先请求的提前到，也是有可能的。</p>
<p>DB请求，DB采用session作为一个连接会话，这一个session里，SQL的执行必须是串行、同步、有序的，而不能是异步乱序的。原因是，一个session内可能有多个操作，增删改查、事务隔离，必须保证顺序不能乱。<br>DB维护这样一个session，是要花费远大于web Server处理一个请求的资源才能完成的。</p>
<p>对于DB来说，连接是非常耗资源的事情，限制连接数是非常有必要的。</p>
<p>注意，当连接mysql出问题时，随便加大应用服务的连接池和增大mysql的max-connection。不能改善mysql的性能。当进行非常密集的数据库操作时，连接池的数量对性能产生的巨大影响。</p>
<h4 id="为什么用BIO，而不是NIO。"><a href="#为什么用BIO，而不是NIO。" class="headerlink" title="为什么用BIO，而不是NIO。"></a>为什么用BIO，而不是NIO。</h4><p>原因是JDBC不支持，JDBC出现了20年，它是一个标准，在它被提出时，只有BIO模型，导致数据库驱动对JDBC的实现都是BIO的形式，mysql驱动connector早早地实现了JDBC标准，就是采用阻塞的方式。</p>
<p>当进行一个select查询，在查询没有完成之前，整个调用线程会被卡住，等到天荒地老也要等下去，绝不是一请求立马收到返回，然后等mysql回调你结果。</p>
<p>其实，也有人修改了mysql的协议，增加了NIO+多路复用的功能，最后失败，主要原因是mysql和web server功能意义都不一样，确切地说，90%的场景下，不需要一个NIO的数据库。</p>
<p>BIO+连接池，已经发展了很多年，大部分问题都已经解决，在目前的java环境中，是非常靠谱的方案。已经出现了很多优秀的连接池框架，你只需要配置好账号密码和连接池数量，就能很开心的使用mysql了。</p>
<p>从mysql的角度来说，客户端多是一些IO密集型的应用，应该在一个线程里频繁做大量IO操作，而不是说有大量的客户端来反复连接我。毕竟，mysql的用户是你写的几个程序应用，而web server的用户是海量的。</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>mysql能支撑的连接数是有限的，那么就需要应用程序来利用好连接池。对于连接池来说，就是做好这10个连接的管理就好。</p>
<p>对于mysql来说，管理好自己的所有连接也是很重要，哪些空闲的该休息就休息，让出资源，该复用就复用，避免创建太多线程。</p>
<h4 id="IO密集的时候，要减少连接数。"><a href="#IO密集的时候，要减少连接数。" class="headerlink" title="IO密集的时候，要减少连接数。"></a>IO密集的时候，要减少连接数。</h4><p>譬如要读写几千万数据，非常密集的IO操作，那么你可以尝试一下开启少量的mysql连接（和cpu的核数相同）和开启大量的连接（成百上千），来做同样的事。你会发现，更少的连接数，会给你带来几百倍的性能提升。</p>
<p>譬如，你有4辆车（4核），要从仓库里拉一大堆货物到另一个地方。如果只有4条路，简单操作，一个车走一路，反复折返跑。现在有了100条路，还是4个车，车要频繁的在100条路上来回切换，每条路都必须要走到。</p>
<p>线程间的轮转会耗费大量的资源，尤其在密集操作时。但是当不密集时，情况就变了，大量的线程处于休息状态，那么你即便多开了几个连接，CPU还是能很快的照顾到你，并没有什么大的影响。</p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>作为RPC的连接，内部rpc数据协议</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>008-模板-NexT-版权、打赏</title>
    <url>/articles/20200130/7021388e.html</url>
    <content><![CDATA[<p>摘要：文章底部版权、文章底部打赏</p>
<a id="more"></a>

<h1 id="文章底部版权"><a href="#文章底部版权" class="headerlink" title="文章底部版权"></a>文章底部版权</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Next7.2.0官方对版权声明的设置做出了大改动，在主题配置文件_config.yml中已经找不到设置版权声明的post_copyright选项</p>
<p>旧版本：Next下，设置post_copyright为true，或是修改themes/next/layout/_macro/post-copyright.swig文件，自定义版权声明样式</p>
<p>新版本：Next下，网上一片教程，没有post_copyright选项了，各种改代码。</p>
<h2 id="探究新版版权"><a href="#探究新版版权" class="headerlink" title="探究新版版权"></a>探究新版版权</h2><p>发现：themes/next/layout/_partials/post/post-copyright.swig 还是有版权定义。</p>
<p>查看版权配置文件：themes/next/layout/_macro/post.swig</p>
<p>打开，直接搜搜：post-copyright.swig，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.creative_commons.license and theme.creative_commons.post %&#125;</span><br><span class="line">  &#123;&#123; partial(&#39;_partials&#x2F;post&#x2F;post-copyright.swig&#39;) &#125;&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>查看样式什么时候导入：themes/next/source/css/_common/components/post/post.styl<br><code>@import &#39;post-copyright&#39; if (hexo-config(&#39;creative_commons.post&#39;));</code><br>即配置文件中 有creative_commons</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<h1 id="文章底部打赏"><a href="#文章底部打赏" class="headerlink" title="文章底部打赏"></a>文章底部打赏</h1><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><p>查看 源码 发现 reward，配置：reward_settings</p>
<ol>
<li><p>打赏图片增加<br>支付宝，微信获取付款图片<br>source/images/reward/bjlhx-wx.bmp<br>source/images/reward/bjlhx-wx.bmp</p>
</li>
<li><p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">一分也是爱，两分情更浓【还没有人赞赏，支持一下呗】</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/reward/bjlhx-wx.bmp</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/reward/bjlhx-zfb.bmp</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>002-github pages建站，绑定主题</title>
    <url>/articles/20200130/e012e91a.html</url>
    <content><![CDATA[<p>搭建属于自己的博客网站，这里使用 github pages建站，绑定主题</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>基于github建站，使用仓库存放静态代码</p>
<h2 id="基础储备"><a href="#基础储备" class="headerlink" title="基础储备"></a>基础储备</h2><p>github账号注册</p>
<p>git使用：<a href="https://www.cnblogs.com/bjlhx/category/993475.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/993475.html</a>　　</p>
<p><strong>基础步骤</strong></p>
<ul>
<li>Github Pages</li>
<li>Hexo 博客框架</li>
<li>部署</li>
<li>Next 主题</li>
</ul>
<p><strong>涉及三个仓库</strong></p>
<ul>
<li>静态代码部署仓库：username.github.io 作用：username 需要设置成每个人仓库自己的，主要是基于Github Pages 的 部署代码。</li>
<li>静态代码开发仓库：hexo-src.bjlhx15.github.io 作用：开发代码的仓库。</li>
<li>基于github评论仓库：ment.bjlhx15.github.io 作用：使用基于github issues机制的评论仓库</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Github-Pages使用"><a href="#Github-Pages使用" class="headerlink" title="Github Pages使用"></a>Github Pages使用</h2><p>Github Pages 其实本身就是 Github 提供的博客服务。 我们在 Github 中创建一个特定格式的 Repository，Github Pages 就会将里面的信息生成一个网页，展示出来。</p>
<p>创建仓库：username.github.io：</p>
<p>创建即可，访问：<a href="https://bjlhx15.github.io/" target="_blank" rel="noopener">https://bjlhx15.github.io/</a>  博客首页</p>
<h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p>Hexo：是一个博客框架。它把本地文件里的信息生成一个网页。</p>
<p>使用 Hexo 之前，需要先安装 Node.js 和 Git。检测安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>hexo安装：<code>npm install -g hexo-cli</code></p>
<p>查看：<code>hexo -v</code></p>
<p>备注：<a href="https://www.cnblogs.com/bjlhx/p/12239748.html" target="_blank" rel="noopener">006-node npm 报错 rollbackFailedOptional: verb npm-session</a></p>
<h3 id="框架结合源码"><a href="#框架结合源码" class="headerlink" title="框架结合源码"></a>框架结合源码</h3><p>在其他目录下使用：hexo init，下载代码，因为 init 初始化需要一个空目录，否则报错</p>
<p>github上新建一个仓库：hexo-src.bjlhx15.github.io.git，拉取到本地，将上述代码拷贝至在仓库中即可</p>
<p>npm install 安装依赖包</p>
<p>hexo g 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</p>
<p>hexo s 将生成的网页放在了本地服务器（server）</p>
<p><a href="https://blog.bjlhx.top/categories/hexo/">更多</a></p>
<h3 id="新建博客并发布"><a href="#新建博客并发布" class="headerlink" title="新建博客并发布"></a>新建博客并发布</h3><p>source/_posts 放置 XX.md 文章即可，执行hexo g、hexo s查看</p>
<p>发布，将生成的前端代码发布到：bjlhx15.github.io.git  仓库，注意不是2.3中的源码仓库 hexo-src</p>
<p>在根目录：_config.yml 下修改deploy：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#39;git&#39;</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;bjlhx15&#x2F;bjlhx15.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>输入 <code>npm install hexo-deployer-git --save</code> 安装 hexo-deployer-git 此步骤只需要做一次。</p>
<p>输入 <code>hexo d</code>，会将本地代码部署至 部署仓库地址</p>
<p>至此基础版本搭建完成：<a href="https://bjlhx15.github.io/" target="_blank" rel="noopener">https://bjlhx15.github.io/</a></p>
<h2 id="使用Next主题"><a href="#使用Next主题" class="headerlink" title="使用Next主题"></a>使用Next主题</h2><p>以 Next 为例。 大概思路就是把整个主题的文件克隆到我们的主题文件夹中。在配置文件中注明使用该主题。【更多】</p>
<ol>
<li>下载主题</li>
</ol>
<p>在hexo-src源码的根目录下：<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p>
<p>这样，该主题的文件就全部克隆到:   themes\next 下面。</p>
<ol start="2">
<li>切换主题<pre><code class="text"># theme: landscape  next
theme: next</code></pre>
访问<a href="https://bjlhx15.github.io" target="_blank" rel="noopener">https://bjlhx15.github.io</a>即可</li>
</ol>
<h1 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h1><pre><code>将：src 源码下载，使用idea，eclipse等打开
在：source/_posts 下分目录 编写文章即可</code></pre>]]></content>
      <categories>
        <category>build_site</category>
      </categories>
  </entry>
  <entry>
    <title>001-建站系统系列</title>
    <url>/articles/20200130/f87cfa7a.html</url>
    <content><![CDATA[<p>一步一步，搭建网站系统<br>域名申请与绑定、</p>
<p><a href="https://blog.bjlhx.top/categories/build-site/">build-site</a></p>
<a id="more"></a>

<h1 id="域名申请与绑定"><a href="#域名申请与绑定" class="headerlink" title="域名申请与绑定"></a>域名申请与绑定</h1><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p><a href="https://www.aliyun.com" target="_blank" rel="noopener">https://www.aliyun.com</a></p>
<p>控制台→域名，可以注册域名，top域名比较便宜，个人申请使用：bjlhx.top</p>
<p><a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="noopener">https://wanwang.aliyun.com/domain/</a>  首年1块</p>
<h3 id="CNAME-域名解析"><a href="#CNAME-域名解析" class="headerlink" title="CNAME 域名解析"></a>CNAME 域名解析</h3><p>主要是一个域名解析到另一个域名</p>
<h4 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h4><p><img src="/images/post/build_site/domain.png" alt=""></p>
<h4 id="站点根目录增加"><a href="#站点根目录增加" class="headerlink" title="站点根目录增加"></a>站点根目录增加</h4><p>文件：CNAME</p>
<p>内容：blog.bjlhx.top</p>
<p>等待10分钟，然后访问 <a href="http://blog.bjlhx.top/">http://blog.bjlhx.top/</a> 就能看到 <a href="http://bjlhx15.github.io" target="_blank" rel="noopener">http://bjlhx15.github.io</a> 一样的页面，证明绑定成功了。 </p>
<h3 id="IP解析"><a href="#IP解析" class="headerlink" title="IP解析"></a>IP解析</h3><p>域名解析到指定的IP，A记录</p>
]]></content>
      <categories>
        <category>build_site</category>
      </categories>
  </entry>
  <entry>
    <title>007-hero-config配置说明</title>
    <url>/articles/20200130/6fe23d4d.html</url>
    <content><![CDATA[<p>位于站点根目录下的 _config.yml 文件，可以直接用记事本打开进行编辑，文件中的具体配置项.<br>Site、URL、Directory、Writing、Home page setting、Category &amp; Tag、Date / Time format、Pagination、Extensions、Deployment</p>
<a id="more"></a>

<h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><p>网站的个性化描述，大家需要根据自己的实际情况认真填写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">title	网站标题</span><br><span class="line">subtitle	网站副标题</span><br><span class="line">description	网站描述</span><br><span class="line">keywords	网站关键字</span><br><span class="line">author	网站作者</span><br><span class="line">language	网站使用的语言，默认是en ，中文网站填zh-Hans</span><br><span class="line">timezone	网站使用的时区，默认为 计算机的预设置，可以不填</span><br></pre></td></tr></table></figure>

<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>关于博客文章 URL 的设置，一般不用进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">url	网站的网址</span><br><span class="line">root	网站的根目录， 也是存放文章的目录</span><br><span class="line">permalink	文章的链接格式 ，默认为 :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults	永久链接中每个段的默认值</span><br></pre></td></tr></table></figure>

<h1 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h1><p>关于文件夹的设置，也是一般不用进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">source_dir	资源文件夹 ，存放用户的资源文件，默认为 source</span><br><span class="line">public_dir	公用文件夹 ，存放生成的静态文件，默认为 public</span><br><span class="line">tag_dir	标签目录 ，默认为 tags</span><br><span class="line">archive_dir	档案目录 ，默认为 archives</span><br><span class="line">category_dir	分类目录 ，默认为 categories</span><br><span class="line">code_dir	代码目录 ，默认为 downloads&#x2F;code</span><br><span class="line">i18n_dir	i18n目录 ，默认为 :lang</span><br><span class="line">skip_render	储存站长验证文件，跳过指定文件的渲染</span><br></pre></td></tr></table></figure>

<h1 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h1><p>这里是比较常用的写作设置，可以根据自己的写作习惯随时进行调整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">new_post_name	文章的文件名格式，默认为 :title.md</span><br><span class="line">default_layout	预设的布局模板，默认为 post</span><br><span class="line">titlecase	标题是否使用首字母大写 ，默认为 false</span><br><span class="line">external_link	链接是否在新标签页中打开，默认为 true</span><br><span class="line">filename_case	将文件名转换为 1 小写 或 2 大写，默认为 0</span><br><span class="line">render_drafts	是否显示渲染草稿，默认为 false</span><br><span class="line">post_asset_folder	是否启用 Asset 文件夹，默认为 false</span><br><span class="line">relative_link	是否建立相对于根文件夹的链接，默认为 false</span><br><span class="line">future	是否显示未来文章，默认为 true</span><br><span class="line">highlight	代码块设置</span><br></pre></td></tr></table></figure>
<h2 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">enable	是否使用代码高亮 ，默认为 true</span><br><span class="line">line_number	是否显示行号 ，默认为 true</span><br><span class="line">auto_detect	是否自动检测语言 ，默认为 false</span><br><span class="line">tab_replace	tab 替代设置</span><br></pre></td></tr></table></figure>

<h1 id="Home-page-setting"><a href="#Home-page-setting" class="headerlink" title="Home page setting"></a>Home page setting</h1><p>首页设置，可以自己决定每页显示的文章数量和显示文章的顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">index_generator	主页设置</span><br></pre></td></tr></table></figure>

<p>index_generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">path	首页的根目录</span><br><span class="line">per_page	每页显示文章的数量，默认为 10</span><br><span class="line">order_by	显示文章的顺序，默认为 -date</span><br></pre></td></tr></table></figure>

<h1 id="Category-amp-Tag"><a href="#Category-amp-Tag" class="headerlink" title="Category &amp; Tag"></a>Category &amp; Tag</h1><p>这里是关于分类和标签的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">default_category	预设分类，默认为 uncategorized</span><br><span class="line">category_map	分类别名</span><br><span class="line">tag_map	标签别名</span><br></pre></td></tr></table></figure>

<h1 id="Date-Time-format"><a href="#Date-Time-format" class="headerlink" title="Date / Time format"></a>Date / Time format</h1><p>时间和日期的显示格式，一般没特殊要求的也不需要改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">date_format	日期格式，默认为 YYYY-MM-DD</span><br><span class="line">time_format	时间格式，默认为 HH:mm:ss</span><br></pre></td></tr></table></figure>

<h1 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h1><p>这里是分页设置，可以自己决定单个页面上显示的文章数量和分页目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">per_page	单个页面上显示的文章数量，默认为 10 ，用 0 表示禁用分页</span><br><span class="line">pagination_dir	分页目录，默认为 page</span><br></pre></td></tr></table></figure>

<h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><p>这里可以设置主题类型和插件，之后的文章讲到更换博客主题时需要进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">theme	博客使用的主题，默认为 landscape</span><br></pre></td></tr></table></figure>

<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>这里是关于网站部署的配置，常用的有部署类型和部署地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">deploy	网站部署配置</span><br></pre></td></tr></table></figure>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">type	网站部署类型</span><br><span class="line">repo	网站部署地址</span><br></pre></td></tr></table></figure>
<p><a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">【参考资料】</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>006-模板-NexT-三方服务-搜索、统计分析、评论</title>
    <url>/articles/20200129/f6f5115.html</url>
    <content><![CDATA[<p>包含了 站内搜索、埋点统计等，注意：凡是网络上写着改代码的配置，几乎都不用，一般都有人写好git能直接用npm了</p>
<a id="more"></a>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p>本地搜索不需要任何外部第三方服务，并且可以由搜索引擎额外索引。该搜索方法推荐给大多数用户。</p>
<p>通过在站点根目录中运行以下命令来安装hexo-generator-searchdb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>config配置</p>
<figure class="highlight plain"><figcaption><span>hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>

<h1 id="统计和分析"><a href="#统计和分析" class="headerlink" title="统计和分析"></a>统计和分析</h1><h2 id="1、分析-百度"><a href="#1、分析-百度" class="headerlink" title="1、分析-百度"></a>1、分析-百度</h2><ol>
<li>登录 <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度 分析</a>并找到网站代码获取页面。</li>
<li>将脚本ID复制到hm.js？之后，如下图：<br><img src="/images/post/hexo/analytics-baidu-id.png" alt="avatar"></li>
<li>配置<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Baidu Analytics ID</span><br><span class="line">baidu_analytics: your_id</span><br></pre></td></tr></table></figure>
代码检测是否成功，一般20分钟，可以看浏览器控制台 <a href="https://tongji.baidu.com/web/help/article?id=93&type=0" target="_blank" rel="noopener">代码手工检查攻略</a></li>
</ol>
<p>查看百度<a href="https://tongji.baidu.com/web/10000139146/homepage/index" target="_blank" rel="noopener">统计</a></p>
<h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><p>Hexo支持的评论比较多，Disqus、DisqusJS、LiveRe、Gitalk、Valine (China)、Changyan (China)<br>支持多个评论：Multiple Comment System Support<br>多说和网易云 不做了，其次畅言需要备案<br>Disqus，Hypercomments和LiveRe都是国外的，加载速度慢，甚至有被墙的可能，<br>valine 账户增加了 短信验证，实名认证等，需要个人信息 太多<br>Gitment 基于git的issues,由于 Next 更新，Gitment 已经预置了，所以不需要自己再添加代码。但是 作者 又不更新了，授权比较多,目前gitment.browser.js内使用授权，作者暂不维护<br>utterances 版本集成了utterances评论。这一工具原理和GITALK类似，但是索取的权限少，并且不用指定某个人来初始化。<em>推荐</em></p>
<ul>
<li>页面关闭评论<br><code>comments: false</code></li>
</ul>
<h2 id="utterances-【推荐】"><a href="#utterances-【推荐】" class="headerlink" title="utterances 【推荐】"></a>utterances <em>【推荐】</em></h2><p>源码<a href="https://github.com/theme-next/hexo-next-utteranc" target="_blank" rel="noopener">地址</a><br>首先来<a href="https://github.com/apps/utterances" target="_blank" rel="noopener">这里</a>为utterances在github上授权。<br>只有这样，才能让utterances有资格访问你的issue。还可指定utterances能够访问的仓库，可见其权限控制做的非常好。</p>
<p>授权完毕后，来到博客根目录，打开Git Bash，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save github:theme-next/hexo-next-utteranc</span><br></pre></td></tr></table></figure>
<p>后运行可能缺少依赖next-util ，原因是设置了<a href="https://www.cnblogs.com/bjlhx/p/12239748.html" target="_blank" rel="noopener">淘宝的 npm 源</a></p>
<p>打开主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Demo: https:&#x2F;&#x2F;utteranc.es&#x2F;  http:&#x2F;&#x2F;trumandu.github.io&#x2F;about&#x2F;</span><br><span class="line">utteranc:</span><br><span class="line">  enable: true</span><br><span class="line">  repo: #Github repo such as :TrumanDu&#x2F;comments</span><br><span class="line">  pathname: pathname</span><br><span class="line">  # theme: github-light,github-dark,github-dark-orange</span><br><span class="line">  theme: github-light</span><br><span class="line">  cdn: https:&#x2F;&#x2F;utteranc.es&#x2F;client.js</span><br></pre></td></tr></table></figure>

<h2 id="LiveRe"><a href="#LiveRe" class="headerlink" title="LiveRe"></a>LiveRe</h2><p>LiveRe是基于社交网站评论的内容平台，可帮助用户自由交流。</p>
<p>创建一个帐户或登录<a href="http://livere.com" target="_blank" rel="noopener">LiveRe</a>，单击安装按钮并选择免费的城市版本，然后单击立即安装按钮。</p>
<p>复制安装代码中的data-uid字段以获取LiveRe UID。</p>
<p>将获得的LiveRe UID添加到主题配置文件中的livere_uid部分，如下所示</p>
<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https:&#x2F;&#x2F;livere.com&#x2F;insight&#x2F;myCode (General web site)</span><br><span class="line">livere_uid: your_uid</span><br></pre></td></tr></table></figure>

<h2 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h2><p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。<br>支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>
<ol>
<li><p>github注册<br>首先要有github帐号<br>接着注册 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">OAuth Application</a>→<a href="https://github.com/settings/developers" target="_blank" rel="noopener">OAuth App</a><br>注册特别简单。之后能够查看 clientId,sercet等</p>
</li>
<li><p>引入gitment<br>在站点目录下，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save gitment</span><br></pre></td></tr></table></figure>
<p>打开主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true # 是否开启gitment评论系统</span><br><span class="line">  mint: true #</span><br><span class="line">  count: true # 是否显示评论数</span><br><span class="line">  lazy: true # 懒加载，设置为ture时需手动展开评论</span><br><span class="line">  cleanly: true # 是否隐藏&#39;Powered by ...&#39;</span><br><span class="line">  language: en # 语言，置空则随主题的语言</span><br><span class="line">  github_user: iamsea # Github用户名</span><br><span class="line">  github_repo: comment # 在Github新建一个仓库用于存放评论，这是仓库名</span><br><span class="line">  client_id: a6df579b14f7da8aAAAAc # 注册OAuth Application时生成</span><br><span class="line">  client_secret: 1f6568974d6f3ed28055d2243d05457f7eAAAAAAAA # 注册OAuth Application时生成</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https:&#x2F;&#x2F;github.com&#x2F;aimingoo&#x2F;intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure>
<p>github_repo # 在Github新建一个空仓库用于存放评论，这是仓库名</p>
</li>
<li><p>之后生成并且部署才会生效，本地有时没有效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>部署之后，有可能碰到 Not Found Error，先不要着急，等一段时间再看看。<br>之后文章底部会出现 初始化本文的评论页，点击初始化。</p>
</li>
</ol>
<h1 id="日历插件"><a href="#日历插件" class="headerlink" title="日历插件"></a>日历插件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save github:theme-next/theme-next-calendar</span><br><span class="line">``` </span><br><span class="line">在NexT的主题配置文件中添加配置</span><br><span class="line">``` text</span><br><span class="line">CloudCalendar:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  language: zh-CN</span><br><span class="line">  single: <span class="literal">true</span></span><br><span class="line">  root: /calendar/</span><br><span class="line">  calendarCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js</span><br><span class="line">  langCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js</span><br><span class="line">  <span class="comment">#disableSidebar: false</span></span><br></pre></td></tr></table></figure>
<p>即可使用。</p>
<p>此插件会在侧边栏的最下方添加一个日历。如侧边栏比较窄，视觉效果可能会稍差。此外，在低分辨率的屏幕上，增加日历会使侧边栏出现一个滚动条，可能会影响美观。</p>
<p>使用CDN的缺点是无法进行细节上的自定义配置，只能照着默认的来。如果想自己修改日历的颜色、位置等信息，请用这种方法安装，就可以自行修改文件。</p>
<h1 id="更多服务"><a href="#更多服务" class="headerlink" title="更多服务"></a>更多服务</h1><p><a href="https://theme-next.org/docs/third-party-services/" target="_blank" rel="noopener">third-party-services</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>005-模板-NexT-其他优化-页脚、菜单显示数量、代码块</title>
    <url>/articles/20200129/12b9aaef.html</url>
    <content><![CDATA[<p>关闭页脚的powered、hexo 首页文章只显示一部分、菜单显示数量、代码块</p>
<a id="more"></a>

<h1 id="关闭页脚的powered"><a href="#关闭页脚的powered" class="headerlink" title="关闭页脚的powered"></a>关闭页脚的powered</h1><p>进入：themes/next/_config.yml，找到footer 下 powered、theme 关闭即可</p>
<h1 id="hexo首页文章只显示一部分"><a href="#hexo首页文章只显示一部分" class="headerlink" title="hexo首页文章只显示一部分"></a>hexo首页文章只显示一部分</h1><p>方式一、Front-matter<br>在Front-matter中添加了描述并将其值设置为文章摘要，则默认情况下，NexT会将描述摘录为首页的前导文本。如果没有描述，则全部内容将为首页中的前导文字。<br>您可以通过在主题配置文件中将excerpt_description的值设置为false来禁用它。</p>
<p>方式二、在文章中加上<code>&lt;!--more--&gt;</code> 标记 ，该标记以后部分就不在显示了，只有展开全部才显示，这是hexo定义的。</p>
<p>方式三、插件【不推荐】</p>
<h1 id="菜单标签显示数值"><a href="#菜单标签显示数值" class="headerlink" title="菜单标签显示数值"></a>菜单标签显示数值</h1><p>在menu_settings如果设置icon: false则无图标，badges: true则标签都会显示数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true #默认是false</span><br></pre></td></tr></table></figure>

<h1 id="代码块设置"><a href="#代码块设置" class="headerlink" title="代码块设置"></a>代码块设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">  highlight_theme: normal</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: false</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: false</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>004-模板-NexT-菜单、侧栏、头像、阅读量</title>
    <url>/articles/20200129/8ecccc4b.html</url>
    <content><![CDATA[<p>Hexo 框架允许我们更换合适的主题，以便于构建不同风格的网站，这里介绍目前最常使用的一款主题之NexT</p>
<p>设置Scheme、设置动态背景、设置侧栏行为、设置菜单、设置头像、添加社交链接、添加文字统计功能、添加阅读量统计功能</p>
<a id="more"></a>
<h1 id="NexT-安装"><a href="#NexT-安装" class="headerlink" title="NexT 安装"></a>NexT 安装</h1><p>几个概念：</p>
<p>在使用 Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml</p>
<p>一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置</p>
<p>另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置</p>
<p>不同的主题会有不同的主题配置文件，由主题作者所提供</p>
<h2 id="下载-NexT"><a href="#下载-NexT" class="headerlink" title="下载 NexT"></a>下载 NexT</h2><p>在 站点根目录 中打开 git bash 窗口，使用如下命令下载 NexT 主题文件到 themes 目录 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line">或</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">或</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h2 id="启用-NexT"><a href="#启用-NexT" class="headerlink" title="启用 NexT"></a>启用 NexT</h2><p>打开 站点配置文件， 将 theme 选项的值改为 next，注意要在属性和值之间要加上一个空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>此时，登陆自己的站点，应该可以看到更改已经成功</p>
<h1 id="NexT-配置"><a href="#NexT-配置" class="headerlink" title="NexT 配置"></a>NexT 配置</h1><h2 id="设置Scheme"><a href="#设置Scheme" class="headerlink" title="设置Scheme"></a>设置Scheme</h2><p>Scheme 是用于 改变网站布局 的一个设置项，NexT 目前提供四种 Scheme：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Muse ：默认 Scheme，黑白主调，大量留白</span><br><span class="line">Mist：Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">Pisces：双栏 Scheme，小家碧玉的清新</span><br><span class="line">Gemini：新增 Scheme</span><br></pre></td></tr></table></figure>
<p>更改时，打开 主题配置文件，通过搜索关键字 Scheme Settings 定位，然后将使用的 scheme 打开注释即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h2 id="设置动态背景"><a href="#设置动态背景" class="headerlink" title="设置动态背景"></a>设置动态背景</h2><p>更改时，打开 主题配置文件，通过搜索关键字 Canvas-nest 定位，然后将 canvas_nest 的值改成 true 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure>


<h2 id="设置侧栏行为"><a href="#设置侧栏行为" class="headerlink" title="设置侧栏行为"></a>设置侧栏行为</h2><p>默认情况下，侧栏仅在文章页面（拥有目录列表时）才显示，并放置于右侧位置</p>
<p>可以通过修改 主题配置文件 中的 Sidebar Settings 字段控制侧栏的行为</p>
<p>（1）侧栏位置：position<br>left：靠左放置;<br>right：靠右放置;</p>
<p>（2）侧栏显示时机：display<br>post：默认行为，在文章页面（拥有目录列表时）显示;<br>always：在所有页面中都显示;<br>hide：在所有页面中都隐藏;<br>remove：完全移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">position: left</span><br><span class="line">#position: right</span><br><span class="line"></span><br><span class="line"># Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line">#  - post    expand on posts automatically. Default.</span><br><span class="line">#  - always  expand for all pages automatically</span><br><span class="line">#  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">#  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line">display: post</span><br><span class="line">#display: always</span><br><span class="line">#display: hide</span><br><span class="line">#display: remove</span><br></pre></td></tr></table></figure>


<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><p>（1）设置菜单项</p>
<p>打开 主题配置文件，搜索关键字 Menu Settings 进行定位，各个菜单项通过 # 注释开启或关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running the site in a subdirectory (e.g. domain.tld&#x2F;blog), remove the leading slash from link value (&#x2F;archives -&gt; archives).</span><br><span class="line"># Usage: &#96;Key: &#x2F;link&#x2F; || icon&#96;</span><br><span class="line"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span><br><span class="line"># Value before &#96;||&#96; delimeter is the target link.</span><br><span class="line"># Value after &#96;||&#96; delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>
<p>部分菜单项的功能描述如下：<br>home：主页;about：关于;tags：标签;categories：分类;archives：归档;</p>
<p>菜单具体 参看002</p>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>打开 主题配置文件， 搜索关键字 Sidebar Avatar 进行定位，将 avatar 的值设置成头像图片的链接地址即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class="line"># in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class="line">avatar: &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>头像图片的链接地址可以是：  </p>
<ul>
<li>完整的互联网地址：例如，<a href="https://www.example.com/avatar.jpg" target="_blank" rel="noopener">https://www.example.com/avatar.jpg</a></li>
<li>站点内的相对地址：例如，假设图片命名为 avatar.jpg，存放在 source/images/ 目录下，则链接地址可以写成 /images/avatar.jpg</li>
</ul>
<h2 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h2><p>打开 主题配置文件，搜索关键字 Social Links 进行定位，social 的值按 Key: permalink || icon 格式设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Social Links.</span><br><span class="line"># Usage: &#96;Key: permalink || icon&#96;</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before &#96;||&#96; delimeter is the target permalink.</span><br><span class="line"># Value after &#96;||&#96; delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;Forwhfang || Github</span><br><span class="line">  CSDN: https:&#x2F;&#x2F;blog.csdn.net&#x2F;wsmrzx || CSDN</span><br><span class="line">  cnblogs: https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wsmrzx || cnblogs</span><br></pre></td></tr></table></figure>


<h2 id="添加文字统计功能"><a href="#添加文字统计功能" class="headerlink" title="添加文字统计功能"></a>添加文字统计功能</h2><p>进入 站点根目录，打开 git bash 窗口，输入如下命令安装插件<br><code>pm install hexo-wordcount --save</code><br>然后打开 主题配置文件，进行如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;willin&#x2F;hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure>


<h2 id="添加阅读量统计功能"><a href="#添加阅读量统计功能" class="headerlink" title="添加阅读量统计功能"></a>添加阅读量统计功能</h2><p>在 主题配置文件 中修改 busuanzi_count 字段启用不蒜子统计功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_uv_footer: </span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_pv_footer: </span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure>
<p>【参考资料】</p>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">iissnan/hexo-theme-start</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="noopener">iissnan/hexo-theme-next</a></li>
<li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">third-party-services</a></li>
<li><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">hexo.io/plugins</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>003-模板-scaffolds、permalink永久链接</title>
    <url>/articles/20200129/5c36d9d6.html</url>
    <content><![CDATA[<p>模板以scaffolds/post.md为例，对updated、permalink等参数进行说明</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="scaffolds-post-md-说明"><a href="#scaffolds-post-md-说明" class="headerlink" title="scaffolds\post.md 说明"></a>scaffolds\post.md 说明</h2><p>打开.\scaffolds\post.md文件，默认参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>当我们在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new ABC</span><br></pre></td></tr></table></figure>
<p>则会在.\source_post\目录下产生一个ABC.md文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: ABC</span><br><span class="line">date: 2015-12-29 20:20:47</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="permalink设置"><a href="#permalink设置" class="headerlink" title="permalink设置"></a>permalink设置</h2><p>修改.\scaffolds\post.md，增加一个permalink属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">permalink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>让permalink为空，则Hexo会使用默认设置。默认设置是什么呢？就是你的根目录下的_config.yml中定义好的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;blog.bjlhx.top</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>
<p>:year表示年份，:month表示月份，:date表示日期。最终的展示效果为<a href="https://likianta.coding.me/2017/09/04/title/这种形式。" target="_blank" rel="noopener">https://likianta.coding.me/2017/09/04/title/这种形式。</a></p>
<p>方式一、可以把图中的斜杠改为短横线，效果会变成<a href="https://likianta.coding.me/2017-09-04/title/。" target="_blank" rel="noopener">https://likianta.coding.me/2017-09-04/title/。</a></p>
<p>方式二、将默认设置改成了permalink: :year/:category/:title，其最终的网址就是<a href="https://likianta.coding.me/2017/xx分组/xx标题。" target="_blank" rel="noopener">https://likianta.coding.me/2017/xx分组/xx标题。</a></p>
<p>分类设置:参看上文</p>
<p>另外需要注意的是，.\scaffolds\post.md中的permalink请一定要留空。</p>
<p>官网中虽然说.\scaffolds\post.md中的permalink内容可以覆盖根目录的默认设置，但实测发现会引起网址bug。</p>
<p>比如说你在.\scaffolds\post.md中修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :year:month&#x2F;:title</span><br></pre></td></tr></table></figure>

<p>Hexo会误把它当成一个字符串进行解析，结果就会生成：<a href="https://likianta.coding.me/2017/09/04/:year:month/:title/（一个错误的URL路径）。" target="_blank" rel="noopener">https://likianta.coding.me/2017/09/04/:year:month/:title/（一个错误的URL路径）。</a></p>
<p>不过如果我们在具体的文章中手动写上的话是不会报错的：</p>
<p>.\source_post\ABC.md:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 003-scaffolds.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">permalink: https:&#x2F;&#x2F;bjlhx.top&#x2F;2020&#x2F;01&#x2F;29&#x2F;ABC&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="Hexo-abbrlink生成唯一永久文章链接"><a href="#Hexo-abbrlink生成唯一永久文章链接" class="headerlink" title="Hexo-abbrlink生成唯一永久文章链接"></a>Hexo-abbrlink生成唯一永久文章链接</h3><p>hexo-next文章链接默认的生成规则是：:year/:month/:day/:title，是按照年、月、日、标题来生成的。</p>
<p>如果文章标题是中文的话，URL链接是也会是中文，</p>
<p>方案一、使用hexo-permalink-pinyin插件，将中文转英文</p>
<p>缺陷，比如修改了文章标题，重新hexo三连后，URL就变了，以前的文章地址变成了404。而且这样生成的URL层级也很深，不利于SEO。</p>
<p>方案二、Hexo-abbrlink</p>
<p>一、不用增加属性，也不用考虑分类中文化的问题。二、URL层级更短，更利于SEO。(一般SEO只爬三层)</p>
<p>在执行 <code>hexo g</code> 的时候根据 文件内的title 生成CRC，为了降低碰撞，建议文件内的title，date最好修改</p>
<p>并且 URL ：articles/:abbrlink.html 可设置为：<code>articles/:year:month:day/:abbrlink.html</code></p>
<ol>
<li>插件安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li>
<li>配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">articles/:year:month:day/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">    <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure>
生成的链接将会是这样的(官方样例)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br></pre></td></tr></table></figure>
生成完后，原md文件的Front-matter 内会增加abbrlink 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>002-命令new-页面分类标签</title>
    <url>/articles/20200129/1a1ce396.html</url>
    <content><![CDATA[<p>hexo new 命令使用：创建普通页面、创建”分类”选项、创建“标签”选项</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] title</span><br></pre></td></tr></table></figure>
<p>创建一个新文章。如果未提供布局，则Hexo将使用_config.yml中的default_layout: post。如果标题包含空格，请用引号引起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Option	Description</span><br><span class="line">-p, --path	Post path. Customize the path of the post.</span><br><span class="line">-r, --replace	Replace the current post if existed.</span><br><span class="line">-s, --slug	Post slug. Customize the URL of the post.</span><br></pre></td></tr></table></figure>
<h2 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h2><p>默认情况下，Hexo将使用标题定义文件的路径。对于页面，它将创建该名称的目录以及其中的index.md文件。使用–path选项覆盖该行为并定义文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">"About me"</span></span><br></pre></td></tr></table></figure>
<p>将创建源/about/me.md文件，文件的标题设置为“关于我”。 请注意，标题是必填项。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建普通页面"><a href="#创建普通页面" class="headerlink" title="创建普通页面"></a>创建普通页面</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br><span class="line">或</span><br><span class="line">hexo new post <span class="string">"My New Post 2"</span></span><br></pre></td></tr></table></figure>

<h2 id="创建”分类”选项"><a href="#创建”分类”选项" class="headerlink" title="创建”分类”选项"></a>创建”分类”选项</h2><h3 id="生成“分类”页并添加tpye属性"><a href="#生成“分类”页并添加tpye属性" class="headerlink" title="生成“分类”页并添加tpye属性"></a>生成“分类”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>成功后，会有路径提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="built_in">source</span>/categories/index.md</span><br></pre></td></tr></table></figure>
<p>打开 index.md 修改如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存关闭即可。主要是为了生存的分类有超链接，不执行此步，也会有分类，但是点击分类时候，没有超链接</p>
<h3 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h3><p>打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 002-分类标签.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h2 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h2><h3 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>成功后会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/<span class="built_in">source</span>/tags/index.md</span><br></pre></td></tr></table></figure>
<p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：<br>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-01-29 17:41:12</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h3 id="给文章添加“tags”属性"><a href="#给文章添加“tags”属性" class="headerlink" title="给文章添加“tags”属性"></a>给文章添加“tags”属性</h3><p>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的 - hexo - hexo分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 002-分类标签.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- hexo分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。</p>
<p>其实，这两个的设置几乎一样！可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。</p>
<p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo分类</tag>
      </tags>
  </entry>
  <entry>
    <title>001-命令-服务、生成、部署、清理</title>
    <url>/articles/20200129/82195907.html</url>
    <content><![CDATA[<p>初始化代码库：<code>hexo init</code>；<br>本地服务运行 ：<code>hexo s</code>；生成静态文件：<code>hexo g</code>；部署远程站点：<code>hexo d</code>；清理缓存：<code>hexo clean</code></p>
<a id="more"></a>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="初始化代码库"><a href="#初始化代码库" class="headerlink" title="初始化代码库"></a>初始化代码库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>下载代码，因为 init 初始化需要一个空目录，否则报错</p>
<h3 id="本地服务运行"><a href="#本地服务运行" class="headerlink" title="本地服务运行"></a>本地服务运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="部署远程站点"><a href="#部署远程站点" class="headerlink" title="部署远程站点"></a>部署远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">或</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="命令用于清理缓存文件，是一个比较常用的命令"><a href="#命令用于清理缓存文件，是一个比较常用的命令" class="headerlink" title="命令用于清理缓存文件，是一个比较常用的命令"></a>命令用于清理缓存文件，是一个比较常用的命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>更过官方帮助：<br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br><a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a><br><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a><br><a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a><br><a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">commands</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础</title>
    <url>/articles/20190526/26856f5b.html</url>
    <content><![CDATA[<p>第一个测试程序</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
