<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>004-java-事件-spring事件</title>
    <url>/articles/20210109/57a8108a.html</url>
    <content><![CDATA[<p>摘要：java事件模型<br>主要有四种</p>
<ol>
<li>观察者模式</li>
<li>java事件</li>
<li>spring事件-java事件的包装</li>
<li>分布式事件驱动-jms</li>
</ol>
<p>事件监听机制更关注于特定的事件,观察者模式更关注于变化,再根据具体变化作出不同的响应</p>
<a id="more"></a>

<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><a href="https://www.cnblogs.com/bjlhx/p/11545163.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/11545163.html</a></p>
<h1 id="java事件处理机制（自定义事件）"><a href="#java事件处理机制（自定义事件）" class="headerlink" title="java事件处理机制（自定义事件）"></a>java事件处理机制（自定义事件）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>java中的事件机制的参与者有3种角色：</p>
<ol>
<li><p>event object：事件状态对象，用于listener的相应的方法之中，作为参数，一般存在与listerner的方法之中</p>
</li>
<li><p>event source：具体的事件源，比如说，你点击一个button，那么button就是event source，要想使button对某些事件进行响应，你就需要注册特定的listener。</p>
</li>
<li><p>event listener：对每个明确的事件的发生，都相应地定义一个明确的Java方法。这些方法都集中定义在事件监听者（EventListener）接口中，这个接口要继承 java.util.EventListener。 实现了事件监听者接口中一些或全部方法的类就是事件监听者。</p>
</li>
</ol>
<p>伴随着事件的发生，相应的状态通常都封装在事件状态对象中，该对象必须继承自java.util.EventObject。事件状态对象作为单参传递给应响应该事件的监听者方法中。发出某种特定事件的事件源的标识是：遵从规定的设计格式为事件监听者定义注册方法，并接受对指定事件监听者接口实例的引用。</p>
<p>具体的对监听的事件类，当它监听到event object产生的时候，它就调用相应的方法，进行处理。</p>
<p>先看看jdk提供的event包：</p>
<p>public interface EventListener：所有事件侦听器接口必须扩展的标记接口。</p>
<p>public class EventObject extends Object implements Serializable ：所有事件状态对象都将从其派生的根类。 所有 Event 在构造时都引用了对象 “source”，在逻辑上认为该对象是最初发生有关 Event 的对象。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>发邮件，会触发 写数据库，写日志等操作</p>
<h3 id="常规逻辑"><a href="#常规逻辑" class="headerlink" title="常规逻辑"></a>常规逻辑</h3><ol>
<li>实现发送逻辑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSenderJdk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String to)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MailSender开始发送邮件"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写DB、写日志</span></span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实际发送<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSenderJdkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MailSenderJdk mailSenderJdk=<span class="keyword">new</span> MailSenderJdk();</span><br><span class="line">        mailSenderJdk.sendMail(<span class="string">"bjlhx15@163.com"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码耦合高，不易扩展</li>
</ol>
<h3 id="jdk事件逻辑"><a href="#jdk事件逻辑" class="headerlink" title="jdk事件逻辑"></a>jdk事件逻辑</h3><ul>
<li>增加事件源类，继承EventObject<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendJdkEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String to;  <span class="comment">//目的地</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MailSendJdkEvent</span><span class="params">(Object source, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>扩展事件监听接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MailSendJdkEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MailSendJdkEventListener</span><span class="params">(MailSendJdkEvent source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现事件监听接口<br>写DB<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendJdkEventListenerDb</span> <span class="keyword">implements</span> <span class="title">MailSendJdkEventListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MailSendJdkEventListener</span><span class="params">(MailSendJdkEvent source)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"write DB:"</span>+source.getTo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
写日志<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendJdkEventListenerLog</span> <span class="keyword">implements</span> <span class="title">MailSendJdkEventListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MailSendJdkEventListener</span><span class="params">(MailSendJdkEvent source)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"write log:"</span>+source.getTo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>事件管理类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector listeners;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adListener</span><span class="params">(MailSendJdkEventListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">            listeners = <span class="keyword">new</span> Vector();</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(MailSendJdkEventListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        listeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有的Listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(MailSendJdkEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Iterator iter = listeners.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            MailSendJdkEventListener listener = (MailSendJdkEventListener) iter.next();</span><br><span class="line">            listener.MailSendJdkEventListener(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>发送逻辑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSenderJdk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String to)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MailSender开始发送邮件"</span>);</span><br><span class="line"></span><br><span class="line">        MailManager manager = <span class="keyword">new</span> MailManager();</span><br><span class="line">        manager.adListener(<span class="keyword">new</span> MailSendJdkEventListenerDb());<span class="comment">// 给增加监听器</span></span><br><span class="line">        manager.adListener(<span class="keyword">new</span> MailSendJdkEventListenerLog());<span class="comment">// 给增加监听器</span></span><br><span class="line">        <span class="comment">// 触发</span></span><br><span class="line">        MailSendJdkEvent event = <span class="keyword">new</span> MailSendJdkEvent(<span class="keyword">this</span>, to);</span><br><span class="line">        manager.notifyListeners(event);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>输出<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MailSender开始发送邮件</span><br><span class="line">write DB:bjlhx15@163.com</span><br><span class="line">write log:bjlhx15@163.com</span><br><span class="line">over</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="spring事件机制"><a href="#spring事件机制" class="headerlink" title="spring事件机制"></a>spring事件机制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>spring事件发送监听涉及3个部分</p>
<ul>
<li>ApplicationEvent：继承EventObject，表示事件本身，自定义事件需要继承该类,可以用来传递数据,比如上述操作,我们需要将用户的邮箱地址传给事件监听器.</li>
<li>ApplicationEventPublisherAware：事件发送器,通过实现这个接口,来触发事件.也可以委托ApplicationContext 发送事件</li>
<li>ApplicationListener：实现了EventListener，事件监听器接口,事件的业务逻辑封装在监听器里面.也可以使用事件注解EventListener</li>
</ul>
<h2 id="异步配置"><a href="#异步配置" class="headerlink" title="异步配置"></a>异步配置</h2><p>springboot启动类注解：@EnableAsync<br>执行事件监听方法上：@Async</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><ul>
<li>事件源，继承ApplicationEvent<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String to;  <span class="comment">//目的地</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MailSendEvent</span><span class="params">(Object source,String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>事件监听<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendEventListenerDb</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MailSendEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MailSendEvent source)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"write DB:"</span> + source.getTo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendEventListenerLog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MailSendEvent source)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"write log:"</span> + source.getTo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>事件发送器<br>接口方式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSenderIface</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String to)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MailSender开始发送邮件"</span>);</span><br><span class="line">        MailSendEvent event = <span class="keyword">new</span> MailSendEvent(<span class="keyword">this</span>, to);</span><br><span class="line">        applicationEventPublisher.publishEvent(event);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
委托ApplicationContext<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;  <span class="comment">//容器事件由容器触发</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String to)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MailSender开始发送邮件"</span>);</span><br><span class="line">        MailSendEvent event = <span class="keyword">new</span> MailSendEvent(applicationContext,to);</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MailSenderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailSender mailSender;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    MailSenderIface mailSender;</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mailSender.sendMail(<span class="string">"bjlhx15@163.com"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>java-base</category>
      </categories>
  </entry>
  <entry>
    <title>003-spring容器之ApplicationContext</title>
    <url>/articles/20210109/ae0ddb33.html</url>
    <content><![CDATA[<p>摘要：<br>ApplicationContext：是spring继BeanFactory之外的另一个核心接口或容器，允许容器通过应用程序上下文环境创建、获取、管理bean。为应用程序提供配置的中央接口。在应用程序运行时这是只读的，但如果实现支持这一点，则可以重新加载。</p>
<p>一个ApplicationContext提供:</p>
<ul>
<li>访问应用程序组件的Bean工厂方法。从org.springframework.beans.factory.ListableBeanFactory继承。</li>
<li>以通用方式加载文件资源的能力。继承自org.springframe .core.io。ResourceLoader接口。—beanXML</li>
<li>向注册侦听器发布事件的能力。继承自ApplicationEventPublisher接口。</li>
<li>解析消息的能力，支持国际化。继承自MessageSource接口。</li>
<li>从父上下文继承。后代上下文中的定义总是优先级。例如，这意味着单个父上下文可以被整个web应用程序使用，而每个servlet都有自己独立于任何其他servlet的子上下文。<a id="more"></a>
<h1 id="接口依赖关系"><a href="#接口依赖关系" class="headerlink" title="接口依赖关系"></a>接口依赖关系</h1></li>
</ul>
<p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的身躯了。ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。</p>
<p><img src="/articles/20210109/ae0ddb33/00302.jpg" alt></p>
<h1 id="ApplicationContext子类接口"><a href="#ApplicationContext子类接口" class="headerlink" title="ApplicationContext子类接口"></a>ApplicationContext子类接口</h1><p>主要是：ConfigurableApplicationContext、WebApplicationContext</p>
<h2 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h2><p>该接口提供了根据配置创建、获取bean的一些方法，其中主要常用的实现包括：ClassPathXmlApplicationContext、FileSystemXmlApplicationContext等。提供了通过各种途径去加载实例化bean的手段。</p>
<h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><p>独立的XML应用程序上下文，从类路径中获取上下文定义文件，将普通路径解释为包含包路径的类路径资源名(例如，“mypackage / myresource.txt”)。<br>适用于测试工具以及嵌入在jar中的应用程序上下文。配置位置的默认值可以通过getConfigLocations重写，配置位置可以表示具体的文件，比如“/myfiles/context”。xml“或ant样式的模式，比如”/myfiles/*-context。参见org.springframework.util。模式细节的AntPathMatcher javadoc)。</p>
<p>注意：对于多个配置位置，后面的bean定义将覆盖前面加载的文件中定义的配置位置。可以利用这一点，通过额外的XML文件故意覆盖某些bean定义。</p>
<h3 id="FileSystemXmlApplicationContext"><a href="#FileSystemXmlApplicationContext" class="headerlink" title="FileSystemXmlApplicationContext:"></a>FileSystemXmlApplicationContext:</h3><p>独立的XML应用程序上下文，从文件系统或url获取上下文定义文件，将普通路径解释为相对的文件系统位置(例如，“mydir / myfile.txt”)。<br>适用于测试线束以及独立环境。<br>注意：普通路径总是被解释为相对于当前VM工作目录，即使它们以斜杠开头。(这与Servlet容器中的语义一致。)使用显式的“file:”前缀强制执行绝对文件路径。<br>配置位置的默认值可以通过getConfigLocations重写，配置位置可以表示具体的文件，比如“/myfiles/context”。xml“或ant样式的模式，比如”/myfiles/*-context。参见org.springframework.util。<br>模式细节的AntPathMatcher javadoc)。注意:对于多个配置位置，后面的bean定义将覆盖前面加载的文件中定义的配置位置。<br>可以利用这一点，通过额外的XML文件故意覆盖某些bean定义。这是一个简单的一站式应用程序上下文。考虑将GenericApplicationContext类与org.springframework.bean .factory.xml结合使用。用于更灵活的上下文</p>
<ul>
<li>ClassPathXmlApplicationContext  FileSystemXmlApplicationContext<br>一个是从类路径获取配置文件并进一步实例化bean，一个是从文件系统或url加载文件并进一步实例化bean。</li>
</ul>
<h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><h3 id="AnnotationConfigWebApplicationContext是WebApplicationContext实现，"><a href="#AnnotationConfigWebApplicationContext是WebApplicationContext实现，" class="headerlink" title="AnnotationConfigWebApplicationContext是WebApplicationContext实现，"></a>AnnotationConfigWebApplicationContext是WebApplicationContext实现，</h3><ul>
<li>它接受带注释的类作为输入—特别是@Configuration-annotated类，</li>
<li>也接受普通的@Component类和使用javax兼容JSR-330的类。注入注解。</li>
<li>允许逐个注册类(指定类名作为配置位置)以及类路径扫描(指定基本包作为配置位置)。</li>
<li>对于多个@Configuration类，后面的@Bean定义将覆盖前面加载的文件中定义的类。<ul>
<li>可以利用这一点，通过额外的配置类故意覆盖某些bean定义。提供了注册注解类和扫描注解类等操作：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(Class&lt;?&gt;... annotatedClasses) &#123;---注册一个或多个要处理的带注释的类。</span><br><span class="line">    Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);</span><br><span class="line">    this.annotatedClasses.addAll(Arrays.asList(annotatedClasses));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void scan(String... basePackages) &#123;---在指定的包中扫描类</span><br><span class="line">    Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">    this.basePackages.addAll(Arrays.asList(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="核心方法：loadBeanDefinitions"><a href="#核心方法：loadBeanDefinitions" class="headerlink" title="核心方法：loadBeanDefinitions"></a>核心方法：loadBeanDefinitions</h4></li>
</ul>
</li>
</ul>
<p><img src="/articles/20210109/ae0ddb33/00301.jpg" alt></p>
<h3 id="XmlWebApplicationContext"><a href="#XmlWebApplicationContext" class="headerlink" title="XmlWebApplicationContext"></a>XmlWebApplicationContext</h3><p>是WebApplicationContext实现，它从XML文档获取配置，默认情况下，配置将取自“/WEB-INF/applicationContext.xml” for the root context, and “/WEB-INF/test-servlet。对于具有名称空间“test-servlet”的上下文(类似于对于具有servlet-name“test”的DispatcherServlet实例)。</p>
<h1 id="在springboot中获取Bean"><a href="#在springboot中获取Bean" class="headerlink" title="在springboot中获取Bean"></a>在springboot中获取Bean</h1><h2 id="直接注入"><a href="#直接注入" class="headerlink" title="直接注入"></a>直接注入</h2><p>使用@Autowired，当然通过context也可以getbean操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4Controller</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将容器注入进来</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/c"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//获取所有的bean名称，并打印输出</span></span><br><span class="line">        String[] beanDefinitionNames = <span class="keyword">this</span>.context.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.asList(beanDefinitionNames));</span><br><span class="line">        <span class="comment">//返回逻辑视图名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"demo2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-ApplicationContextAware接口"><a href="#实现-ApplicationContextAware接口" class="headerlink" title="实现 ApplicationContextAware接口"></a>实现 ApplicationContextAware接口</h2><p>实现 ApplicationContextAware接口并重写setApplicationContext方法来进行容器获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ApplicationContext对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringBeanUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Title</span>: getBeanByName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: TODO  通过bean的名字来获取Spring容器中的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBeanByName</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            System.out.println(beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="普通bean加入springboot容器"><a href="#普通bean加入springboot容器" class="headerlink" title="普通bean加入springboot容器"></a>普通bean加入springboot容器</h1><p>springboot也是一个spring容器。以下是把Bean注入到容器</p>
<p>示例注入类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoinBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUserService <span class="title">getUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(IUserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ImportResource-导入xml"><a href="#ImportResource-导入xml" class="headerlink" title="@ImportResource 导入xml"></a>@ImportResource 导入xml</h2><p>在resources下像往常一样编写xml配置文件，在springboot启动类加上@importResource注解并在value数组里指明配置文件的位置，即可把spring容器和springboot容器整合一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(&#123;</span><br><span class="line">        <span class="string">"classpath:spring-config.xml"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Configuration和-Bean"><a href="#Configuration和-Bean" class="headerlink" title="@Configuration和@Bean"></a>@Configuration和@Bean</h2><pre><code>上一种方法的弊端是如果存在多个xml配置文件则需要在@ImportResource中引入多个注解。所以springboot推荐使用基于@Configuration注解的形式去替代xml文件来向spring容器添加bean。

从Spring3.0起@Configuration开始逐渐用来替代传统的xml配置文件。@Configuration继承自@Component，spring会把标注了@Configuration的对象管理到容器中。除此之外还要在某一个方法加上@Bean，该方法的返回对象被当做bean交给容器，该bean的名称为方法的名称。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> helloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给容器添加组件"</span>);</span><br><span class="line">        helloService helloService = <span class="keyword">new</span> helloService();</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用注解组件-类级别注解-加包扫描的方式注入Bean"><a href="#使用注解组件-类级别注解-加包扫描的方式注入Bean" class="headerlink" title="使用注解组件-类级别注解,加包扫描的方式注入Bean"></a>使用注解组件-类级别注解,加包扫描的方式注入Bean</h2><p>如果使用组件注解需要搭配@ComponentScan，该注解会指定需要扫描的包，扫描以后，路径内所有带有组件注解的类都将被注册进IOC容器当中</p>
<p>@Component：定义一个Bean</p>
<p>以下几个注解功能都和@Component相同，一般用于特定位置，便于区分。</p>
<p>@Controller/RestController：定义一个Bean，用于标识控制器，其中@RestController包含了@ResponseBody注解，用于Rest风格接口的开发</p>
<p>@Service等</p>
<h2 id="使用-Import注解"><a href="#使用-Import注解" class="headerlink" title="使用@Import注解"></a>使用@Import注解</h2><p>SpringBoot的@Import注解可以用于为容器中注册Bean</p>
<p>有三种使用方法：</p>
<ol>
<li><p>直接@Import某个类，将这个类添加到IOC容器中,@Import注解需要和@Configuration结合使用才能生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>( &#123; A<span class="class">.<span class="keyword">class</span>,<span class="title">B</span>.<span class="title">class</span> &#125; )</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现了ImportSelector接口的实现类</p>
<ul>
<li>如果想根据某些属性进行判断是否导入某个Bean，则可以在@Import中传入实现了@ImportSelector的实现类</li>
<li>在执行时，@Import如果判断出传入的是实现了@ImportSelecor接口的实现类，就会调用该类中的selectImport方法，判断需要导入的configuration<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        &#x2F;&#x2F;返回值为String数组类型，实际值应该是注入Bean类的全类名。</span><br><span class="line">        return new String[]&#123;&quot;com.github.bjlhx15.common.springdemo.springcontainer.domain.auto.TestJoinBean&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>( &#123; MyImportSelector<span class="class">.<span class="keyword">class</span> &#125; )</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>导入实现了@ImportBeanDefinitionRegistrar接口的实现类</p>
<ul>
<li>在执行时，会调用该类中的registerBeanDefinitions方法，通过参数中的BeanDefinitionRegistry可以进行Bean的注册<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以从importingClassMetadata和registry对象获取一些上下文信息进行其他业务逻辑的判断</span></span><br><span class="line">        <span class="keyword">boolean</span> b1 = registry.containsBeanDefinition(<span class="string">"com.github.bjlhx15.common.springdemo.springcontainer.domain.auto.TestJoinBeann"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(b1)&#123;</span><br><span class="line">            registry.registerBeanDefinition(<span class="string">"Class"</span>, <span class="keyword">new</span> RootBeanDefinition(Class<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>( &#123; MyImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span> &#125; )</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="手工装载"><a href="#手工装载" class="headerlink" title="手工装载"></a>手工装载</h2><p>Spring容器初始化时，从资源中读取到bean的相关定义后，保存在BeanDefinitionMap，在实例化bean的操作就是依据这些bean的定义来做的，而在实例化之前，Spring允许我们通过自定义扩展来改变bean的定义，定义一旦变了，后面的实例也就变了，而beanFactory后置处理器，即BeanFactoryPostProcessor就是用来改变bean定义的。</p>
<h3 id="手工装载-实现BeanDefinitionRegistryPostProcessor接口"><a href="#手工装载-实现BeanDefinitionRegistryPostProcessor接口" class="headerlink" title="手工装载-实现BeanDefinitionRegistryPostProcessor接口"></a>手工装载-实现BeanDefinitionRegistryPostProcessor接口</h3><p>BeanDefinitionRegistryPostProcessor继承了BeanFactoryPostProcessor接口，BeanFactoryPostProcessor的实现类在其postProcessBeanFactory方法被调用时，可以对bean的定义进行控制，因此BeanDefinitionRegistryPostProcessor的实现类一共要实现以下两个方法：</p>
<p>BeanFactoryPostProcessor可以修改各个注册的Bean，BeanDefinitionRegistryPostProcessor可以动态将Bean注册：</p>
<ul>
<li><p>void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException：</p>
<ul>
<li>该方法的实现中，主要用来对bean定义做一些改变。</li>
</ul>
</li>
<li><p>void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException：</p>
<ul>
<li>该方法用来注册更多的bean到spring容器中。BeanDefinitionRegistry提供了如下操作BeanDefinition，判断、注册、移除等方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManualRegistBeanUtil2</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry beanDefinitionRegistry;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry1)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个bean的定义类的对象</span></span><br><span class="line"><span class="comment">//        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(clazz);</span></span><br><span class="line">        <span class="comment">// 将Bean 的定义注册到Spring环境</span></span><br><span class="line">        beanDefinitionRegistry=beanDefinitionRegistry1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// bean的名字为key, bean的实例为value</span></span><br><span class="line">        Map&lt;String, Object&gt; beanMap = configurableListableBeanFactory.getBeansWithAnnotation(AutoDiscoverClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个bean的定义类的对象</span></span><br><span class="line">        RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(clazz);</span><br><span class="line">        <span class="comment">// 将Bean 的定义注册到Spring环境</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"testService"</span>, rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ManualRegistBeanUtil2 registerBeanUtil2;</span><br><span class="line"><span class="comment">//代码中</span></span><br><span class="line">registerBeanUtil2.registerBean(TestJoinBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">TestJoinBean bean = context.getBean(TestJoinBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(bean);</span><br><span class="line">System.out.println(bean.getUserService());</span><br></pre></td></tr></table></figure>



<h3 id="手工装载-ConfigurableApplicationContext获取工厂"><a href="#手工装载-ConfigurableApplicationContext获取工厂" class="headerlink" title="手工装载-ConfigurableApplicationContext获取工厂"></a>手工装载-ConfigurableApplicationContext获取工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManualRegistBeanUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">registerBean</span><span class="params">(ConfigurableApplicationContext applicationContext, String name, Class&lt;T&gt; clazz, Object... args)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(clazz);</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            beanDefinitionBuilder.addConstructorArgValue(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionBuilder.getRawBeanDefinition();</span><br><span class="line"></span><br><span class="line">        BeanDefinitionRegistry beanFactory = (BeanDefinitionRegistry) applicationContext.getBeanFactory();</span><br><span class="line">        beanFactory.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ManualRegistBeanUtil.registerBean(applicationContext, <span class="string">"test"</span>, TestJoinBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">TestJoinBean bean = context.getBean(TestJoinBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(bean);</span><br><span class="line">System.out.println(bean.getUserService());</span><br></pre></td></tr></table></figure>

<h3 id="手工装载-GenericApplicationContext"><a href="#手工装载-GenericApplicationContext" class="headerlink" title="手工装载-GenericApplicationContext"></a>手工装载-GenericApplicationContext</h3><p>有的时候在有类型后需要将现有某个类装载到spring容器托管中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GenericApplicationContext gac;</span><br><span class="line"><span class="comment">//代码中</span></span><br><span class="line">gac.registerBean(TestJoinBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">TestJoinBean bean = context.getBean(TestJoinBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>注入后的名称为 类全名：com.github.bjlhx15.common.springdemo.springcontainer.domain.auto.TestJoinBean</p>
<p>如果使用这种注入 TestJoinBean ，这里如有有依赖注入应该怎么使用，经测试使用Autowired,可以注入使用，如有初始化的信息要卸载哪里</p>
<h2 id="类初始化顺序-依赖注入使用时需要在PostConstruct注解中使用"><a href="#类初始化顺序-依赖注入使用时需要在PostConstruct注解中使用" class="headerlink" title="类初始化顺序-依赖注入使用时需要在PostConstruct注解中使用"></a>类初始化顺序-依赖注入使用时需要在PostConstruct注解中使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CtorAutoPostSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CtorAutoPostSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数:"</span> + iUserService);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    IUserService iUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"PostConstruct:"</span> + iUserService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"构造代码块:"</span> + iUserService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块:不能获取普通属性"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类实例化过程：静态代码块&gt;构造代码块&gt;构造函数&gt;@Autowired&gt;@PostConstruct</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">静态代码块:不能获取普通属性</span><br><span class="line">构造代码块:null</span><br><span class="line">构造函数:null</span><br><span class="line">PostConstruct</span><br><span class="line">PostConstruct:com.github.bjlhx15.common.springdemo.event.service.impl.UserServiceImpl@146dcfe6</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java-spring-bean</category>
      </categories>
  </entry>
  <entry>
    <title>009-permalink永久链与image不显示问题</title>
    <url>/articles/20210109/4eaf081e.html</url>
    <content><![CDATA[<p>摘要：文章底部版权、文章底部打赏</p>
<a id="more"></a>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="永久链"><a href="#永久链" class="headerlink" title="永久链"></a>永久链</h2><p><a href="#">配置</a></p>
<h2 id="asset-image配置"><a href="#asset-image配置" class="headerlink" title="asset-image配置"></a>asset-image配置</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>配置_config.yml里面的post_asset_folder:false这个选项设置为true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>主要是为了和文章创建同名的文件夹放图片</p>
<h3 id="图片插件安装"><a href="#图片插件安装" class="headerlink" title="图片插件安装"></a>图片插件安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<h1 id="问题与方案"><a href="#问题与方案" class="headerlink" title="问题与方案"></a>问题与方案</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果永久链使用标题，此问题不存在</p>
<p>永久链配置使用了:abbrlink 以及使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">articles/:year:month:day/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">    <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure>

<p>这时候原标题为 “009-permalink永久链与image不显示问题” 会变成 “4eaf081e”</p>
<p>但是文章内图片链接没有变。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径为%d/xxx/xxx需要对其做兼容处理。通过判断当前版本是否等于3的版本做不同的路径分割。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="JS自己修改"><a href="#JS自己修改" class="headerlink" title="JS自己修改"></a>JS自己修改</h3><p>找到：node_modules/hexo-asset-image/index.js</p>
<p>在代码的函数前加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br></pre></td></tr></table></figure>

<p>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class="line">  var config &#x3D; hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">    var link &#x3D; data.permalink;</span><br><span class="line">    var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>002-Spring、SpringMVC和SpringBoot框架</title>
    <url>/articles/20210109/509d5c14.html</url>
    <content><![CDATA[<p>摘要：</p>
<ul>
<li>Spring<br>Spring是一个开源容器框架，可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。其核心就是控制反转(IOC),和面向切面(AOP),简单的说就是一个分层的轻量级开源框架。</li>
<li>SpringMVC<br>Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。SpringMVC是一种web层mvc框架，用于替代servlet（处理|响应请求，获取表单参数，表单校验等。SpringMVC是一个MVC的开源框架，SpringMVC=struts2+spring，springMVC就相当于是Struts2加上Spring的整合。</li>
<li>SpringBoot<br>Springboot是一个微服务框架，延续了spring框架的核心思想IOC和AOP，简化了应用的开发和部署。Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题—&gt;习惯大于约定。</li>
</ul>
<p>spring mvc &lt; spring &lt; springboot</p>
<a id="more"></a>

<h1 id="spring的原理和组成"><a href="#spring的原理和组成" class="headerlink" title="spring的原理和组成"></a>spring的原理和组成</h1><p>Spring为简化我们的开发工作，封装了一系列的开箱即用的组件功能模块，包括：Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test等。</p>
<p><img src="/articles/20210109/509d5c14/00201.jpg" alt></p>
<h1 id="springmvc的原理和组成"><a href="#springmvc的原理和组成" class="headerlink" title="springmvc的原理和组成"></a>springmvc的原理和组成</h1><p>SpringMVC是属于SpringWeb里面的一个功能模块（SpringWebMVC）。专门用来开发SpringWeb项目的一种MVC模式的技术框架实现。其原理如下：</p>
<p><img src="/articles/20210109/509d5c14/00202.png" alt></p>
<p>MVC：Model（模型）、VIew（视图）、Controller（控制器）；</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes</span>(&#123;WebApplicationInitializer<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringServletContainerInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        Iterator var4;</span><br><span class="line">        <span class="keyword">if</span> (webAppInitializerClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var4 = webAppInitializerClasses.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">                Class&lt;?&gt; waiClass = (Class)var4.next();</span><br><span class="line">                <span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">waiClass</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        initializers.add((WebApplicationInitializer)ReflectionUtils.accessibleConstructor(waiClass, <span class="keyword">new</span> Class[<span class="number">0</span>]).newInstance());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Failed to instantiate WebApplicationInitializer class"</span>, var7);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">            servletContext.log(<span class="string">"No Spring WebApplicationInitializer types detected on classpath"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            servletContext.log(initializers.size() + <span class="string">" Spring WebApplicationInitializers detected on classpath"</span>);</span><br><span class="line">            AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">            var4 = initializers.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">                WebApplicationInitializer initializer = (WebApplicationInitializer)var4.next();</span><br><span class="line">                initializer.onStartup(servletContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过SpringServletContainerInitializer来负责对容器启动时的相关组件的初始化，在web这个jar包下面有个meta-inf目录，下面有个services目录，下面有个javax.servlet.ServletContainerInitializer文件，里面指明了SpringServletContainerInitializer</li>
<li>到底要初始化哪些组件是通过Servlet规范中所提供的注解handlesTypes来指定的</li>
<li>在SpringServletCOntainerInitializer中，其HandlesTYpes注解则明确指定为了WebApplicationInitializer.class类型作为onStartup方法的第一个参数</li>
<li>在SpringServletContainerIntializer的onStartup方法中，则主要是完成了一些验证与组件装配的工作</li>
<li>在SpringServletCOntainerInitializer的onStartup方法中，由于某些容器并未遵循Servlet规范，导致虽然明确指定了HandlesTYpe注解的类型为webApplicationInitializer.class类型，但还是可能会存在将一些非法类型传递过来的情况，所以该方法还对传递过来的具体类型进行了细致的判断，只有符合条件的类型才会被纳入到List<webApplicationInitializer>集合中</webApplicationInitializer></li>
<li>当以上判断完成之后，LIst<WebApplicationInitializer>就是接下来需要进行初始化的组件了，</WebApplicationInitializer></li>
<li>最后，通过遍历LIst<WebApplicationInitializer>列表，取出其中的每一个webApplicationInitializer对象，调用这些对象的onStartup方法，完成组件的启动初始化工作</WebApplicationInitializer></li>
</ol>
<p>小结：SpringServletContainerInitializer在整个初始化过程中，其扮演的角色实际上是委托或者是代理的角色，真正完成初始化工作的是一个个的webApplicationInitializer实现类</p>
<h1 id="springboot原理和特性"><a href="#springboot原理和特性" class="headerlink" title="springboot原理和特性"></a>springboot原理和特性</h1><h2 id="springboot应用的容器初始化过程"><a href="#springboot应用的容器初始化过程" class="headerlink" title="springboot应用的容器初始化过程"></a>springboot应用的容器初始化过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomcatStarter</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(TomcatStarter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ServletContextInitializer[] initializers;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Exception startUpException;</span><br><span class="line"></span><br><span class="line">	TomcatStarter(ServletContextInitializer[] initializers) &#123;</span><br><span class="line">		<span class="keyword">this</span>.initializers = initializers;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (ServletContextInitializer initializer : <span class="keyword">this</span>.initializers) &#123;</span><br><span class="line">				initializer.onStartup(servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">this</span>.startUpException = ex;</span><br><span class="line">			<span class="comment">// Prevent Tomcat from logging and re-throwing when we know we can</span></span><br><span class="line">			<span class="comment">// deal with it in the main thread, but log for information here.</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">				logger.error(<span class="string">"Error starting Tomcat context. Exception: "</span></span><br><span class="line">						+ ex.getClass().getName() + <span class="string">". Message: "</span> + ex.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Exception <span class="title">getStartUpException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.startUpException;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于一个springboot应用来说，它并没有使用SpringServletContainerInitializer来进行容器的初始化，而是使用了TomcatStarter进行的。</li>
<li>TomcatStarter存在三点因素使得它无法通过SPI机制进行初始化：它没有不带参数的构造方法，它的声明并非public，其所在jar包并没有META-INF.services目录，当然也不存在名为javax.servlet.sertvletContainerInitialezer的文件了</li>
<li>综上，TomcatStarter并非通过SPI机制进行的查找和实例化</li>
<li>本质上，TOmcatStarter是通过spring boot框架new出来的</li>
<li>与SpringServletContainerInitializer类似，TomcatStarter在容器的初始化过程中也是扮演着一个委托或者是代理的角色，真正执行的初始化动作实际上是由它所持有的ServletContextInitializer的onStartup方法来完成的</li>
</ol>
<h3 id="核心流程图"><a href="#核心流程图" class="headerlink" title="核心流程图"></a>核心流程图</h3><p><img src="/articles/20210109/509d5c14/00205.jpg" alt></p>
<p>Spring-boot容器启动流程总体可划分为2部分：</p>
<ol>
<li><p>执行注解：扫描指定范围下的bean、载入自动配置类对应的bean加载到IOC容器。</p>
</li>
<li><p>main方法中具体SpringAppliocation.run()，全流程贯穿SpringApplicationEvent,有6个子类：</p>
<ul>
<li>ApplicationEnvironmentPreparedEvent</li>
<li>ApplicationFailedEvent.class</li>
<li>ApplicationPreparedEvent.class</li>
<li>ApplicationReadyEvent.class</li>
<li>ApplicationStartedEvent.class</li>
<li>ApplicationStartingEvent.class</li>
</ul>
</li>
</ol>
<h2 id="Spring-Boot中的一些特点："><a href="#Spring-Boot中的一些特点：" class="headerlink" title="Spring Boot中的一些特点："></a>Spring Boot中的一些特点：</h2><ul>
<li>创建独立的spring应用。</li>
<li>嵌入Tomcat, JettyUndertow 而且不需要部署他们。</li>
<li>提供的“starters” poms来简化Maven配置</li>
<li>尽可能自动配置spring应用。</li>
<li>提供生产指标,健壮检查和外部化配置</li>
<li>绝对没有代码生成和XML配置要求。</li>
</ul>
<h1 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h1><p><img src="/articles/20210109/509d5c14/00203.png" alt></p>
<p>springmvc和springboot应用组件之间的对应关系：</p>
<ol>
<li>springServletContainerInitializer对应于TomcatStarter</li>
<li>webApplicationInitializer对应于ServletContextInitializer</li>
</ol>
]]></content>
      <categories>
        <category>java-spring-bean</category>
      </categories>
  </entry>
  <entry>
    <title>003-java-验证码Kaptcha</title>
    <url>/articles/20210108/a53d4816.html</url>
    <content><![CDATA[<p>摘要：保Kaptcha 是一个可高度配置的实用验证码生成工具，可自由配置的选项如：</p>
<ul>
<li>验证码的字体</li>
<li>验证码字体的大小</li>
<li>验证码字体的字体颜色</li>
<li>验证码内容的范围(数字，字母，中文汉字！)</li>
<li>验证码图片的大小，边框，边框粗细，边框颜色</li>
<li>验证码的干扰线</li>
<li>验证码的样式(鱼眼样式、3D、普通模糊、…)<a id="more"></a>

</li>
</ul>
<h1 id="Kaptcha-详细配置表"><a href="#Kaptcha-详细配置表" class="headerlink" title="Kaptcha 详细配置表"></a>Kaptcha 详细配置表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kaptcha.border	图片边框，合法值：yes , no	yes</span><br><span class="line">kaptcha.border.color	边框颜色，合法值： r,g,b (and optional alpha) 或者 white,black,blue.	black</span><br><span class="line">kaptcha.image.width	图片宽	200</span><br><span class="line">kaptcha.image.height	图片高	50</span><br><span class="line">kaptcha.producer.impl	图片实现类	com.google.code.kaptcha.impl.DefaultKaptcha</span><br><span class="line">kaptcha.textproducer.impl	文本实现类	com.google.code.kaptcha.text.impl.DefaultTextCreator</span><br><span class="line">kaptcha.textproducer.char.string	文本集合，验证码值从此集合中获取	abcde2345678gfynmnpwx</span><br><span class="line">kaptcha.textproducer.char.length	验证码长度	5</span><br><span class="line">kaptcha.textproducer.font.names	字体	Arial, Courier</span><br><span class="line">kaptcha.textproducer.font.size	字体大小	40px.</span><br><span class="line">kaptcha.textproducer.font.color	字体颜色，合法值： r,g,b 或者 white,black,blue.	black</span><br><span class="line">kaptcha.textproducer.char.space	文字间隔	2</span><br><span class="line">kaptcha.noise.impl	干扰实现类	com.google.code.kaptcha.impl.DefaultNoise</span><br><span class="line">kaptcha.noise.color	干扰 颜色，合法值： r,g,b 或者 white,black,blue.	black</span><br><span class="line">kaptcha.obscurificator.impl	</span><br><span class="line">    图片样式：&lt;br &#x2F;&gt;水纹 com.google.code.kaptcha.impl.WaterRipple &lt;br &#x2F;&gt;</span><br><span class="line">    鱼眼 com.google.code.kaptcha.impl.FishEyeGimpy &lt;br &#x2F;&gt;</span><br><span class="line">    阴影 com.google.code.kaptcha.impl.ShadowGimpy </span><br><span class="line">com.google.code.kaptcha.impl.WaterRipple</span><br><span class="line">kaptcha.background.impl	背景实现类	com.google.code.kaptcha.impl.DefaultBackground</span><br><span class="line">kaptcha.background.clear.from	背景颜色渐变，开始颜色	light grey</span><br><span class="line">kaptcha.background.clear.to	背景颜色渐变， 结束颜色	white</span><br><span class="line">kaptcha.word.impl	文字渲染器	com.google.code.kaptcha.text.impl.DefaultWordRenderer</span><br><span class="line">kaptcha.session.key	session key	KAPTCHA_SESSION_KEY</span><br><span class="line">kaptcha.session.date	session date	KAPTCHA_SESSION_DATE</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="bean注入"><a href="#bean注入" class="headerlink" title="bean注入"></a>bean注入</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 验证码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"captchaProducer"</span> <span class="attr">class</span>=<span class="string">"com.google.code.kaptcha.impl.DefaultKaptcha"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.google.code.kaptcha.util.Config"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 这里的颜色只支持标准色和rgb颜色，不可使用十六进制的颜色 --&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 是否有边框 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.border"</span>&gt;</span>no<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码文本字符颜色 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.textproducer.font.color"</span>&gt;</span>black<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码图片宽度 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.image.width"</span>&gt;</span>92<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码图片高度 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.image.height"</span>&gt;</span>36<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码文本字符大小 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.textproducer.font.size"</span>&gt;</span>24<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- session中存放验证码的key键 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.session.key"</span>&gt;</span>code<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码噪点颜色 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.noise.color"</span>&gt;</span>white<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码文本字符间距 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.textproducer.char.space"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码样式引擎 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.obscurificator.impl"</span>&gt;</span>com.google.code.kaptcha.impl.ShadowGimpy<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码文本字符长度 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.textproducer.char.length"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 验证码文本字体样式 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"kaptcha.textproducer.font.names"</span>&gt;</span>宋体,楷体,微软雅黑<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultKaptcha</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] captcha = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将生成的验证码保存在session中</span></span><br><span class="line">            String createText = defaultKaptcha.createText();</span><br><span class="line">            request.getSession().setAttribute(<span class="string">"rightCode"</span>, createText);</span><br><span class="line">            BufferedImage bi = defaultKaptcha.createImage(createText);</span><br><span class="line">            ImageIO.write(bi, <span class="string">"jpg"</span>, out);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        captcha = out.toByteArray();</span><br><span class="line">        response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-store"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">        response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line">        response.setContentType(<span class="string">"image/jpeg"</span>);</span><br><span class="line">        ServletOutputStream sout = response.getOutputStream();</span><br><span class="line">        sout.write(captcha);</span><br><span class="line">        sout.flush();</span><br><span class="line">        sout.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校对验证码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/check"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">check</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        ModelAndView model = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        String rightCode = (String) request.getSession().getAttribute(<span class="string">"rightCode"</span>);</span><br><span class="line">        String tryCode = request.getParameter(<span class="string">"tryCode"</span>);</span><br><span class="line">        System.out.println(<span class="string">"rightCode:"</span> + rightCode + <span class="string">" ———— tryCode:"</span> + tryCode);</span><br><span class="line">        <span class="keyword">if</span> (!rightCode.equals(tryCode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(<span class="keyword">new</span> AbstractMap.SimpleEntry(<span class="keyword">false</span>, <span class="string">"验证码错误,请再输一次!"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(<span class="keyword">new</span> AbstractMap.SimpleEntry(<span class="keyword">true</span>, <span class="string">"ok"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java-base</category>
      </categories>
  </entry>
  <entry>
    <title>001-web容器、Spring容器、SpringMVC容器的关系</title>
    <url>/articles/20210108/1c366cf8.html</url>
    <content><![CDATA[<p>摘要：</p>
<ul>
<li>springmvc和spring都是容器，容器就是管理对象的地方，例如Tomcat，就是管理servlet对象的。</li>
<li>springMVC容器和spring容器，就是管理bean对象的地方，springmvc就是管理controller对象的容器，spring就是管理service和dao的容器。</li>
<li>一般在springmvc的配置文件里配置的扫描路径就是controller的路径，而spring的配置文件里自然配的就是service和dao的路径。<a id="more"></a>

</li>
</ul>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet是JavaEE规范的一种，主要是为了扩展Java作为Web服务的功能，统一接口。由其他内部厂商如tomcat，jetty内部实现web的功能。如一个http请求到来：<br>容器将请求封装为servlet中的HttpServletRequest对象，调用init（），service（）等方法输出response,由容器包装为httpresponse返回给客户端的过程。</p>
<p><img src="/articles/20210108/1c366cf8/00103.webp" alt></p>
<p>在Servlet规范中，提供了ServletContext,ServletRequest,ServletResponse,Filter等诸多接口。<br>基本类图和调用关系如下：<br><img src="/articles/20210108/1c366cf8/00104.webp" alt></p>
<p><img src="/articles/20210108/1c366cf8/00105.webp" alt></p>
<p>接口的作用，生命周期和使用：</p>
<h2 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h2><ul>
<li>作用：用于处理请求（service方法）</li>
<li>生命周期：加载实例化、初始化、处理客户端请求、销毁。<br> 加载实例化主要是交由web容器完成，而其他三个阶段则对应Servlet的init、service和destroy方法。<br> Servlet对象被创建出来后需要对其进行初始化操作，初始化工作可以放在以ServletConfig类型为参数的ini方法中，<br> ServletConfig为web.xml配置文件中配置的对应的初始化参数，由web容器完成web.xml配置读取并封装成ServletConfig对象；<br> 当Servlet初始化完成后，开始接受客户端的请求，这些请求被封装成ServletRequest类型的请求对象和ServletResponse类型的响应对象，<br> 通过service方法处理请求并响应客户端；当一个Servlet需要从web容器中移除时，就会调用对应的destroy方法用于释放所有的资源，<br> 并且调用destroy方法之前要保证所有正在执行service方法的线程都完成执行。</li>
<li>使用：servlet规范中定义了GenericServlet接口，定义了通用，协议独立的servlet,他们的子接口HttpServlet就是用来处理http请求的Servlet,根据http协议扩展了不同方式的请求处理方法，如doPost,doGet.</li>
</ul>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>Servlet与Servlet容器之间直接通信的接口,一个web应用只独有一个ServletContext.</p>
<ul>
<li>作用：<ul>
<li>用于在web应用范围内存取共享数据,如setAttribute(String name, Object object)，getAttribute()</li>
<li>获取当前Web应用的资源，如getContextPath()</li>
<li>获取服务器端的文件系统资源，如getResourceAsStream()</li>
<li>输出日志，如log(String msg) ： 向Servlet的日志文件中写日志</li>
<li>在具体ServletContext 实现中，提供了添加Servlet，Filter,Listener到ServletContext里面的方法</li>
</ul>
</li>
<li>生命周期：和web应用的生命周期一样</li>
<li>使用：一般由web容器实现，如tomcat</li>
</ul>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><ul>
<li>作用：用于Web容器对请求和响应做统一处理，例如统一改变HTTP请求内容和响应内容，它可以作用在某个Servlet或一组Servlet</li>
<li>生命周期：加载实例化、初始化（init）、处理客户端请求(doFilter)、销毁(destroy)</li>
<li>使用：在doFilter方法中调用chain.doFilter(request, response)之前的代码可用来做一些请求校验，之后代码可用来做一些响应包装。</li>
</ul>
<h2 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h2><p>封装了客户端请求的所有信息，如果使用HTTP协议通信则包括HTTP协议的请求行和请求头。HTTP协议对应请求对象类型是HttpServletRequest类</p>
<ul>
<li>作用：<ul>
<li>获取HTTP协议请求头部，如getHeader、getHeaders</li>
<li>获取请求路径，如getContextPath、getServletPath</li>
<li>获取cookie的方法，如getCookies</li>
<li>获取session的方法，如getSession,session是存储在服务器内存中，返回响应的时候会写入浏览器一个sessionId的cookie，用来标示这一个会话</li>
</ul>
</li>
<li>生命周期：只在servlet的service方法或过滤器的doFilter方法作用域内有效，除非启用了异步处理调用了ServletRequest接口对象的startAsync方法，此时request对象会一直有效，直到调用AsyncContext的complete方法。另外，web容器通常会为了性能而不销毁ServletRequest接口的对象，而是重复利用ServletRequest接口对象。</li>
</ul>
<h2 id="ServletResponse"><a href="#ServletResponse" class="headerlink" title="ServletResponse"></a>ServletResponse</h2><p>Servlet通过ServletResponse对象来生成响应结果。</p>
<ul>
<li>作用：定义了一系列与生成响应结果相关的方法，如:<ul>
<li>setCharacterEncoding() —— 设置相应正文的字符编码。响应正文的默认字符编码为ISO-8859-1；</li>
<li>setContentLength() —— 设置响应正文的长度；</li>
<li>setBufferSize() —— 设置用于存放响应正文数据的缓冲区的大小</li>
<li>getBufferSize() —— 获得用于存放响应正文数据的缓冲区的大小；</li>
<li>reset() —— 清空缓冲区内的正文数据，并且清空响应状态代码及响应头</li>
<li>resetBuffer() —— 仅仅清空缓冲区的正文数据，不清空响应状态代码及响应头；</li>
<li>flushBuffer() —— 强制性地把缓冲区内的响应正文数据发送到客户端；</li>
<li>isCommitted() —— 返回一个boolean类型的值，如果为true，表示缓冲区内的数据已经提交给客户，即数据已经发送到客户端；</li>
<li>getOutputStream() —— 返回一个ServletOutputStream对象，Servlet用它来输出二进制的正文数据；</li>
<li>getWriter() —— 返回一个PrinterWriter对象，Servlet用它来输出字符串形式的正文数据；</li>
</ul>
</li>
</ul>
<p>为了提高输出数据的效率，ServletOutputStream和PrintWriter首先把数据写到缓冲区内。当缓冲区内的数据被提交给客户后，ServletResponse的isComitted方法返回true。</p>
<ul>
<li>生命周期：ServletResponse接口只在Servlet的service方法或过滤器的doFilter方法作用域内有效，除非它关联的ServletResponse接口调用了startAsync方法启用异步处理，此时ServletResponse接口会一直有效，直到调用AsyncContext的complete方法。另外，web容器通常会为了性能而不销毁ServletResponse接口对象，而是重复利用ServletResponse接口对象。</li>
</ul>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>当触发某个事件，如servlet context初始化完成时，需要做一些事情，servlet规范中定义了若干个Listener用于监听这些事件。</p>
<ul>
<li>作用：用于对特定对象的生命周期和特定事件进行响应处理，主要用于对Session,request,context等进行监控。<ul>
<li>监听域对象自身的创建和销毁的事件监听器<ul>
<li>ServletContextListener：ServletContext的创建和销毁：contextInitialized方法和contextDestroyed方法，作为定时器、加载全局属性对象、创建全局数据库连接、加载缓存信息等</li>
<li>HttpSessionListener：HttpSession的创建和销毁：sessionCreated和sessionDestroyed方法，可用于统计在线人数、记录访问日志等</li>
<li>ServletRequestListener： ServletRequest的创建和销毁：requestInitialized和requestDestroyed方法</li>
</ul>
</li>
<li>监听域对象中的属性的增加和删除的事件监听器<ul>
<li>ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener接口。</li>
<li>实现方法：attributeAdded、attributeRemoved、attributeReplaced</li>
</ul>
</li>
<li>监听绑定到HttpSeesion域中的某个对象的状态的事件监听器(创建普通JavaBean)<ul>
<li>HttpSession中的对象状态：绑定→解除绑定；钝化→活化</li>
<li>实现接口及方法：HttpSessionBindingListener接口(valueBound和valueUnbound方法)、HttpSessionActivationListener接口(sessionWillPassivate和sessionDidActivate方法)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="web容器-tomcat"><a href="#web容器-tomcat" class="headerlink" title="web容器-tomcat"></a>web容器-tomcat</h1><h2 id="web容器使用spring管理bean"><a href="#web容器使用spring管理bean" class="headerlink" title="web容器使用spring管理bean"></a>web容器使用spring管理bean</h2><p>  web容器是管理servlet，以及监听器(Listener)和过滤器(Filter)的。这些都是在web容器的掌控范围里。但他们不在spring和springmvc的掌控范围里。<br>  因此，我们无法在这些类中直接使用Spring注解的方式来注入我们需要的对象，是无效的，web容器是无法识别的。</p>
<p>  但我们有时候又确实会有这样的需求，比如在容器启动的时候，做一些验证或者初始化操作，这时可能会在监听器里用到bean对象；又或者需要定义一个过滤器做一些拦截操作，也可能会用到bean对象。<br>  那么在这些地方怎么获取spring的bean对象呢？下面我提供两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">　　ApplicationContext context = (ApplicationContext) sce.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); </span><br><span class="line">　　UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">　　WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(sce.getServletContext()); </span><br><span class="line">　　UserService userService = (UserService) webApplicationContext.getBean(<span class="string">"userService"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：以上代码有一个前提，那就是servlet容器在实例化ConfigListener并调用其方法之前，要确保spring容器已经初始化完毕！而spring容器的初始化也是由Listener（ContextLoaderListener）完成，<br>因此只需在web.xml中先配置初始化spring容器的Listener，然后在配置自己的Listener。</p>
<h2 id="Servlet、spring核心关系图"><a href="#Servlet、spring核心关系图" class="headerlink" title="Servlet、spring核心关系图"></a>Servlet、spring核心关系图</h2><p><img src="/articles/20210108/1c366cf8/00101.jpg" alt></p>
<ul>
<li>web容器中有servlet容器，spring项目部署后存在spring容器和springmvc容器。其中spring控制service层和dao层的bean对象。springmvc容器控制controller层bean对象。</li>
<li>servlet容器控制servlet对象。项目启动是，首先 servlet初始化，初始化过程中通过web.xml中spring的配置加载spring配置，初始化spring容器和springmvc容器。待容器加载完成。servlet初始化完成，则完成启动。</li>
<li>HTTP请求到达web容器后，会到达Servlet容器，容器通过分发器分发到具体的spring的Controller层。执行业务操作后返回结果。</li>
</ul>
<p><img src="/articles/20210108/1c366cf8/00102.jpg" alt>   </p>
<p>小结：</p>
<ul>
<li>Tomcat在启动时给每个Web应用创建一个全局的上下文环境，这个上下文就是ServletContext，其为后面的Spring容器提供宿主环境。</li>
<li>Tomcat在启动过程中触发容器初始化事件，Spring的ContextLoaderListener会监听到这个事件，它的contextInitialized方法会被调用，在这个方法中，Spring会初始化全局的Spring根容器，这个就是Spring的IoC容器，IoC容器初始化完毕后，Spring将其存储到ServletContext中，便于以后来获取。</li>
<li>Tomcat在启动过程中还会扫描Servlet，一个Web应用中的Servlet可以有多个，以SpringMVC中的DispatcherServlet为例，这个Servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个Servlet请求。</li>
<li>Servlet一般会延迟加载，当第一个请求达到时，Tomcat&amp;Jetty发现DispatcherServlet还没有被实例化，就调用DispatcherServlet的init方法，DispatcherServlet在初始化的时候会建立自己的容器，叫做SpringMVC 容器，用来持有Spring MVC相关的Bean。同时，Spring MVC还会通过ServletContext拿到Spring根容器，并将Spring根容器设为SpringMVC容器的父容器，请注意，Spring MVC容器可以访问父容器中的Bean，但是父容器不能访问子容器的Bean， 也就是说Spring根容器不能访问SpringMVC容器里的Bean。说的通俗点就是，在Controller里可以访问Service对象，但是在Service里不可以访问Controller对象。   </li>
</ul>
<p>tomcat等容器其实就是web服务的实现，暴露端口，按照特定资源URL找到处理的servlet。然后处理请求。<br>web.xml其实tomcat在启动时候需要加载的配置欢迎页、Filter、Listener、Servlet等类的定义。当然不止加载这些东西，这些东西是需要加载到JVM堆内存中实例化的对象。</p>
<h2 id="Tomcat启动时加载资源三个阶段"><a href="#Tomcat启动时加载资源三个阶段" class="headerlink" title="Tomcat启动时加载资源三个阶段"></a>Tomcat启动时加载资源三个阶段</h2><ul>
<li>第一阶段：JVM相关资源<ul>
<li>$JAVA_HOME/jre/lib/ext/*.jar</li>
<li>系统classpath环境变量中的<em>.jar和</em>.class </li>
</ul>
</li>
<li>第二阶段：Tomcat自身相关资源<ul>
<li>$CATALINA_HOME/common/classes/*.class  </li>
<li>$CATALINA_HOME/commons/endorsed/*.jar   </li>
<li>$CATALINA_HOME/commons/i18n/*.jar   </li>
<li>$CATALINA_HOME/common/lib/*.jar   </li>
<li>$CATALINA_HOME/server/classes/*.class   </li>
<li>$CATALINA_HOME/server/lib/*.jar   </li>
<li>$CATALINA_BASE/shared/classes/*.class   </li>
<li>$CATALINA_BASE/shared/lib/*.jar </li>
</ul>
</li>
<li>第三阶段：Web应用相关资源<ul>
<li>具体应用的webapp目录: /WEB-INF/classes/*.class   </li>
<li>具体应用的webapp: /WEB-INF/lib/*.jar<br>在tomcat目录${CATALINA_HOME}/conf下和web应用目录${CATALINA_HOME}/webapps/WebDemo(WebDemo为web应用名)下都有web.xml这个文件，但是内容不一样。</li>
</ul>
</li>
</ul>
<p>Tomcat在激活、加载、部署web应用时，会解析加载${CATALINA_HOME}/conf目录下所有web应用通用的web.xml，然后解析加载web应用目录中的WEB-INF/web.xml。<br>其实根据他们的位置，我们就可以知道，conf/web.xml文件中的设定会应用于所有的web应用程序，而某些web应用程序的WEB-INF/web.xml中的设定只应用于该应用程序本身。</p>
<p>如果没有WEB-INF/web.xml文件，tomcat会输出找不到的消息，但仍然会部署并使用web应用程序，servlet规范的作者想要实现一种能迅速并简易设定新范围的方法，以用作测试，因此，这个web.xml并不是必要的，不过通常最好还是让每一个上线的web应用程序都有一个自己的WEB-INF/web.xml。</p>
<p>web.xml中可以配置web应用名称，图标，描述，ServletContext上下文参数，Fliter配置，Listener配置，Servlet配置，会话超时配置，MIME类型配置等等。</p>
<h1 id="spring和springmvc"><a href="#spring和springmvc" class="headerlink" title="spring和springmvc"></a>spring和springmvc</h1><h2 id="springmvc配置"><a href="#springmvc配置" class="headerlink" title="springmvc配置"></a>springmvc配置</h2><p>spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.github.bjlhx15.controller"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="spring配置"><a href="#spring配置" class="headerlink" title="spring配置"></a>spring配置</h2><p>applicationContext-service.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描包加载Service实现类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.github.bjlhx15.service"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.github.bjlhx15"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="spring容器和springmvc容器关系"><a href="#spring容器和springmvc容器关系" class="headerlink" title="spring容器和springmvc容器关系"></a>spring容器和springmvc容器关系</h2><pre><code>spring容器和springmvc容器的关系是父子容器的关系。   </code></pre><ul>
<li><p>spring容器是父容器，springmvc是子容器。在子容器里可以访问父容器里的对象，但是在父容器里不可以访问子容器的对象，</p>
</li>
<li><p>说的通俗点就是，在controller里可以访问service对象，但是在service里不可以访问controller对象</p>
<p>所有的bean，都是被spring或者springmvc容器管理的，他们可以直接注入。<br>然后springMVC的拦截器也是springmvc容器管理的，所以在springmvc的拦截器里，可以直接注入bean对象。如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/employee/**"</span> &gt;</span><span class="tag">&lt;/<span class="name">mvc:mapping</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.core.shiro.LoginInterceptor"</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="web容器和spring容器结合"><a href="#web容器和spring容器结合" class="headerlink" title="web容器和spring容器结合"></a>web容器和spring容器结合</h1><h2 id="web容器servlet到springmvc的servlet"><a href="#web容器servlet到springmvc的servlet" class="headerlink" title="web容器servlet到springmvc的servlet"></a>web容器servlet到springmvc的servlet</h2><p><img src="/articles/20210108/1c366cf8/00106.webp" alt></p>
<p>其中FrameworkServlet会和Spring的ApplicationContext联系起来，它实现了ApplicationContextAware接口。</p>
<p><img src="/articles/20210108/1c366cf8/00107.webp" alt> </p>
]]></content>
      <categories>
        <category>java-spring-bean</category>
      </categories>
  </entry>
  <entry>
    <title>002-springboot测试-Mockito服务层测试</title>
    <url>/articles/20210107/1a42b9be.html</url>
    <content><![CDATA[<p>摘要：002-springboot测试-Mockito服务层测试</p>
<ul>
<li>使用实际真实接口数据测试</li>
<li>使用Mock接口数据测试</li>
<li>使用Mock接口数据、以及真实接口测试</li>
</ul>
<a id="more"></a>

<h1 id="什么是Mockito"><a href="#什么是Mockito" class="headerlink" title="什么是Mockito"></a>什么是Mockito</h1><pre><code>Mockito是一个java测试框架，它提供mock的创建，验证，打桩。在测试中，可能会依赖外部资源，比如数据库等，mockito可以模拟这些数据，进行测试。</code></pre><h2 id="打桩"><a href="#打桩" class="headerlink" title="打桩"></a>打桩</h2><p>就是模拟一些函数调用的反应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mockito.when(list.get(1)).thenReturn(3); &#x2F;&#x2F; 含义遇到 list.get(1) 等于 3 不执行内部</span><br><span class="line">Assert.assertEquals(list.get(1),3);</span><br></pre></td></tr></table></figure>
<ul>
<li>可以进行多次打桩，但是以最后一次为准。</li>
<li>一次打桩，可多次调用</li>
</ul>
<h2 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mockito.when(list.get(Mockito.anyInt())).thenReturn(&quot;hi&quot;);&#x2F;&#x2F;只要传入任何int，返回hi</span><br><span class="line">Assert.assertEquals(&quot;hi&quot;,list.get(1));&#x2F;&#x2F;hi</span><br><span class="line">Assert.assertEquals(&quot;hi&quot;,list.get(999));&#x2F;&#x2F;hi</span><br><span class="line">Mockito.when(list.contains(Mockito.isA(One.class))).thenReturn(true);&#x2F;&#x2F;只要传入String类型，就返回hello</span><br><span class="line">Assert.assertTrue(list.contains(&quot;hello&quot;));&#x2F;&#x2F;hello</span><br><span class="line">Assert.assertTrue(list.contains(1));&#x2F;&#x2F;发生错误</span><br></pre></td></tr></table></figure>

<p>参数匹配器是为了更加灵活的进行验证和打桩，可以自定义</p>
<h2 id="Mockito工具常用注解"><a href="#Mockito工具常用注解" class="headerlink" title="Mockito工具常用注解"></a>Mockito工具常用注解</h2><p>有些函数需要处理某个服务的返回结果，而在对函数单元测试的时候，又不能启动那些服务</p>
<ul>
<li>@Mock：对函数的调用均执行mock（即虚假函数），不执行真正部分。</li>
<li>@Spy：对函数的调用均执行真正部分。</li>
<li>@InjectMocks：创建一个实例，简单的说是这个Mock可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。<ul>
<li>@Mock出的对象会被注入到@InjectMocks对象中</li>
<li>它会把上下文中你标记为@Spy和@Mock的对象都自动注解进去。相当于把实现类中的私有成员属性给偷梁换柱</li>
<li>注意当前没有问题了 但是service包含了多个既有真正实现也有mock的需要使用反射注入 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReflectionTestUtils.setField(service, &quot;departService&quot;, departService);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>Mockito中的Mock和Spy都可用于拦截那些尚未实现或不期望被真实调用的对象和方法，并为其设置自定义行为。二者的区别在于Mock不真实调用，Spy会真实调用。</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="真实数据"><a href="#真实数据" class="headerlink" title="真实数据"></a>真实数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)//调用<span class="title">Spring</span>单元测试类</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= DemoApplication<span class="class">.<span class="keyword">class</span>) //加载<span class="title">Spring</span>配置文件</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserServiceImplTest01RealData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"lhx"</span>);</span><br><span class="line">        user.setAge(<span class="number">202</span>);</span><br><span class="line"></span><br><span class="line">        service.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全部mock数据"><a href="#全部mock数据" class="headerlink" title="全部mock数据"></a>全部mock数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)//调用<span class="title">Spring</span>单元测试类</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= &#123;<span class="string">"classpath*:spring-config-mybatis-jd-dev.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplTest02MockData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> IDepartService departService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper mapper ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUserAndDepart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"lhx"</span>);</span><br><span class="line">        user.setAge(<span class="number">202</span>);</span><br><span class="line">        String userStr = JSON.toJSONString(user);</span><br><span class="line">        when(service.insertUser(user))</span><br><span class="line">                .thenReturn(<span class="number">1</span>);</span><br><span class="line">        when(departService.insert(user))</span><br><span class="line">                .thenReturn(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = service.insertUserAndDepart(user);</span><br><span class="line">        Assert.assertEquals(<span class="number">2</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="部分mock数据、部分真实接口"><a href="#部分mock数据、部分真实接口" class="headerlink" title="部分mock数据、部分真实接口"></a>部分mock数据、部分真实接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= DemoApplication<span class="class">.<span class="keyword">class</span>) //加载<span class="title">Spring</span>配置文件</span></span><br><span class="line"><span class="class">@<span class="title">Transactional</span></span></span><br><span class="line"><span class="class">@<span class="title">Rollback</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserServiceImplTest03PartMockPartReal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> IDepartService departService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">        ReflectionTestUtils.setField(service, <span class="string">"departService"</span>, departService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUserAndDepart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"lhx"</span>);</span><br><span class="line">        user.setAge(<span class="number">202</span>);</span><br><span class="line"></span><br><span class="line">        when(departService.insert(user))</span><br><span class="line">                .thenReturn(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        when(mapper.insert(user))</span></span><br><span class="line"><span class="comment">//                .thenReturn(1);</span></span><br><span class="line">        <span class="keyword">int</span> i = service.insertUserAndDepart(user);</span><br><span class="line">        Assert.assertEquals(<span class="number">2</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法名	描述</span><br><span class="line">Mockito.mock(classToMock)	模拟对象</span><br><span class="line">Mockito.verify(mock)	验证行为是否发生</span><br><span class="line">Mockito.when(methodCall).thenReturn(value1).thenReturn(value2)	触发时第一次返回value1，第n次都返回value2</span><br><span class="line">Mockito.doThrow(toBeThrown).when(mock).[method]	模拟抛出异常。</span><br><span class="line">Mockito.mock(classToMock,defaultAnswer)	使用默认Answer模拟对象</span><br><span class="line">Mockito.when(methodCall).thenReturn(value)	参数匹配</span><br><span class="line">Mockito.doReturn(toBeReturned).when(mock).[method]	参数匹配（直接执行不判断）</span><br><span class="line">Mockito.when(methodCall).thenAnswer(answer))	预期回调接口生成期望值</span><br><span class="line">Mockito.doAnswer(answer).when(methodCall).[method]	预期回调接口生成期望值（直接执行不判断）</span><br><span class="line">Mockito.spy(Object)	用spy监控真实对象,设置真实对象行为</span><br><span class="line">Mockito.doNothing().when(mock).[method]	不做任何返回</span><br><span class="line">Mockito.doCallRealMethod().when(mock).[method] &#x2F;&#x2F;等价于Mockito.when(mock.[method]).thenCallRealMethod();	调用真实的方法</span><br><span class="line">reset(mock)	重置mock</span><br></pre></td></tr></table></figure>

<h1 id="MockitoJUnitRunner-与-SpringRunner-SpringJUnit4ClassRunner-说明"><a href="#MockitoJUnitRunner-与-SpringRunner-SpringJUnit4ClassRunner-说明" class="headerlink" title="MockitoJUnitRunner 与 SpringRunner(SpringJUnit4ClassRunner)说明"></a>MockitoJUnitRunner 与 SpringRunner(SpringJUnit4ClassRunner)说明</h1><h2 id="MockitoJUnitRunner"><a href="#MockitoJUnitRunner" class="headerlink" title="MockitoJUnitRunner"></a>MockitoJUnitRunner</h2><ul>
<li>特别适用于Mockito测试框架</li>
<li>当您希望将测试集中在单个类上并避免在依赖项上调用方法时（而是调用易于配置的模拟/虚拟），Mockito框架可以帮助模拟依赖项。 </li>
<li>以上是mockito的用途，但有关此运行的更多内容 - 来自文档：“保持测试清洁并改善调试体验”。“Runner是完全可选的 - 还有其他方法可以让@Mock工作”。来源 - <a href="https://static.javadoc.io/org.mockito/mockito-core/2.6.8/org/mockito/junit/MockitoJUnitRunner.html" target="_blank" rel="noopener">https://static.javadoc.io/org.mockito/mockito-core/2.6.8/org/mockito/junit/MockitoJUnitRunner.html</a></li>
</ul>
<h2 id="基于SpringJUnit4ClassRunner"><a href="#基于SpringJUnit4ClassRunner" class="headerlink" title="基于SpringJUnit4ClassRunner"></a>基于SpringJUnit4ClassRunner</h2><ul>
<li>特别适用于弹簧框架</li>
<li>当需要加载spring上下文（创建spring bean，执行依赖注入等）时，用于集成测试。  </li>
<li>在集成测试中，您可能无法对依赖项进行尽可能多的模拟，但您可以在同一测试中执行这两项操作。  </li>
<li>当您想要测试加载弹簧上下文或者可能从服务/高级别一直测试到较低级别（如使用单个测试的数据访问）时，集成测试非常有用。</li>
</ul>
<p>在某些情况下，您可能希望同时使用它们 - 比如集成测试，您还希望模拟某些依赖项（可能是它们进行远程调用）。不幸的是你不能使用两个@RunWiths<br>可以参看上述第三种：部分mock数据、部分真实接口</p>
<h1 id="RunWith-MockitoJUnitRunner-class-vs-MockitoAnnotations-initMocks-this"><a href="#RunWith-MockitoJUnitRunner-class-vs-MockitoAnnotations-initMocks-this" class="headerlink" title="@RunWith(MockitoJUnitRunner.class) vs MockitoAnnotations.initMocks(this)"></a>@RunWith(MockitoJUnitRunner.class) vs MockitoAnnotations.initMocks(this)</h1><p>MockitoJUnitRunner 和 initMocks(this) 都可以为UT提供框架使用的自动验证</p>
<ul>
<li>在单元测试中使用@Mock, @Spy, @InjectMocks等注解时，需要进行初始化后才能使用</li>
<li>若在单元测试类中使用了@RunWith(SpringJUnit4ClassRunner.class) 就不能再使用@RunWith(SpringJUnit4ClassRunner.class)，可以使用 MockitoAnnotations.initMocks(this) 来代替</li>
<li>MockitoAnnotations.initMocks(this)，其中this就是单元测试所在的类，在initMocks函数中Mockito会根据类中不同的注解（如@Mock, @Spy等）创建不同的mock对象，即初始化工作</li>
</ul>
<h1 id="参看文章"><a href="#参看文章" class="headerlink" title="参看文章"></a>参看文章</h1><p><a href="https://blog.csdn.net/gentlezuo/article/details/108293961" target="_blank" rel="noopener">1</a></p>
]]></content>
      <categories>
        <category>java-spring-test</category>
      </categories>
  </entry>
  <entry>
    <title>001-springboot测试-MockMvc控制层测试</title>
    <url>/articles/20210107/4f18d467.html</url>
    <content><![CDATA[<p>摘要：springboot测试-MockMvc</p>
<a id="more"></a>

<h1 id="什么是Mock"><a href="#什么是Mock" class="headerlink" title="什么是Mock"></a>什么是Mock</h1><pre><code>在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。</code></pre><h1 id="为什么使用Mock对象"><a href="#为什么使用Mock对象" class="headerlink" title="为什么使用Mock对象"></a>为什么使用Mock对象</h1><p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p>
<p>在以下情况可以采用模拟对象来替代真实对象：</p>
<ul>
<li>真实对象的行为是不确定的（例如，当前的时间或温度）；</li>
<li>真实对象很难搭建起来；</li>
<li>真实对象的行为很难触发（例如，网络错误）；</li>
<li>真实对象速度很慢（例如，一个完整的数据库，在测试之前可能需要初始化）；</li>
<li>真实的对象是用户界面，或包括用户界面在内；</li>
<li>真实的对象使用了回调机制；</li>
<li>真实对象可能还不存在；</li>
<li>真实对象可能包含不能用作测试（而不是为实际工作）的信息和方法。</li>
<li>使用Mockito一般分三个步骤：1、模拟测试类所需的外部依赖；2、执行测试代码；3、判断执行结果是否达到预期；</li>
</ul>
<h1 id="MockMvc"><a href="#MockMvc" class="headerlink" title="MockMvc"></a>MockMvc</h1><p>MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p>
<p>接口MockMvcBuilder，提供一个唯一的build方法，用来构造MockMvc。主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder，分别对应两种测试方式，即独立安装和集成Web环境测试（并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。MockMvcBuilders提供了对应的创建方法standaloneSetup方法和webAppContextSetup方法，在使用时直接调用即可。</p>
<h1 id="SpringBoot中使用"><a href="#SpringBoot中使用" class="headerlink" title="SpringBoot中使用"></a>SpringBoot中使用</h1><h2 id="jar引入"><a href="#jar引入" class="headerlink" title="jar引入"></a>jar引入</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><a href="https://github.com/bjlhx15/common.git" target="_blank" rel="noopener">github地址</a> </p>
<ul>
<li>demo简述待测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/postjson"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPostJsonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">insert</span><span class="params">(@RequestBody User record)</span> </span>&#123;</span><br><span class="line">        System.out.println(JSON.toJSONString(record));</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(userService.insertUser(record));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写基础测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SpringBoot1.4版本之前用的是SpringJUnit4ClassRunner.class</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//<span class="title">SpringBoot1</span>.4版本之前用的是@<span class="title">SpringApplicationConfiguration</span>(<span class="title">classes</span> </span>= Application<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= &#123;<span class="string">"classpath*:spring-*.xml"</span>&#125;)      <span class="comment">//加载Spring配置文件 方式</span></span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = DemoApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//测试环境使用，用来表示测试环境使用的<span class="title">ApplicationContext</span>将是<span class="title">WebApplicationContext</span>类型的</span></span><br><span class="line"><span class="class">@<span class="title">WebAppConfiguration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserBaseControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;        <span class="comment">//SpringMVC提供的Controller测试类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化方式一、对于controller有依赖的 无法注入</span></span><br><span class="line">        <span class="comment">// mockMvc = MockMvcBuilders.standaloneSetup(new UserPostJsonController()).build();</span></span><br><span class="line">        <span class="comment">// 实例化方式二、对于controller有依赖的 可以注入</span></span><br><span class="line">         mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"lhx"</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        String userStr = JSON.toJSONString(user);</span><br><span class="line">        mockMvc</span><br><span class="line">                .perform(MockMvcRequestBuilders.post(<span class="string">"/user/postjson/insert"</span>)</span><br><span class="line">                        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                        .content(userStr)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andReturn()</span><br><span class="line">                .getResponse().getContentAsString();  <span class="comment">//将相应的数据转换为字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>说明<ul>
<li>mockMvc.perform   执行一个请求。</li>
<li>MockMvcRequestBuilders.get(“XXX”) 构造一个请求，post等</li>
<li>ResultActions.param   添加请求传值<ul>
<li>请求为 get 可以使用</li>
<li>请求为 post application/x-www-form-urlencoded 可以使用</li>
<li>请求为 post application/json 需要使用 ResultActions.contentType(MediaType.APPLICATION_JSON_UTF8) 以及 ResultActions.content(userStr)</li>
</ul>
</li>
<li>ResultActions.accept(MediaType.APPLICATION_JSON))  设置返回类型</li>
<li>ResultActions.andExpect   添加执行完成后的断言 如是状态码 200 MockMvcResultMatchers.status().isOk()</li>
<li>ResultActions.andDo       添加一个结果处理器，表示要对结果做点什么事情<ul>
<li>比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。</li>
</ul>
</li>
<li>ResultActions.andReturn表示执行完成后返回相应的结果。</li>
</ul>
</li>
</ul>
<p>注意事项：如果使用DefaultMockMvcBuilder进行MockMvc实例化时需在SpringBoot启动类上添加组件扫描的package的指定，否则会出现404。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ComponentScan(basePackages &#x3D; &quot;com.github.bjlhx15&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="常用测试示例"><a href="#常用测试示例" class="headerlink" title="常用测试示例"></a>常用测试示例</h2><ul>
<li><p>通用头配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@Profile(&#123;&quot;dev&quot;,&quot;dev-fesco&quot;&#125;) &#x2F;&#x2F;环境变量</span><br><span class="line">&#x2F;&#x2F;SpringBoot1.4版本之前用的是SpringJUnit4ClassRunner.class</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">&#x2F;&#x2F;SpringBoot1.4版本之前用的是@SpringApplicationConfiguration(classes &#x3D; Application.class)</span><br><span class="line">&#x2F;&#x2F;@ContextConfiguration(locations &#x3D; &#123;&quot;classpath*:spring-*.xml&quot;&#125;)      &#x2F;&#x2F;加载Spring配置文件 方式</span><br><span class="line">@SpringBootTest(classes &#x3D; DemoApplication.class)</span><br><span class="line">&#x2F;&#x2F;测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">&#x2F;&#x2F;配置事务的回滚,对数据库的增删改都会回滚, Spring框架中（Spring4.2以后），@TransactionConfiguration已经标注为过时的注解</span><br><span class="line">@Rollback </span><br><span class="line">@Transactional</span><br></pre></td></tr></table></figure></li>
<li><p>通用初始化构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    protected WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;        &#x2F;&#x2F;SpringMVC提供的Controller测试类</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 实例化方式一、对于controller有依赖的 无法注入</span><br><span class="line">&#x2F;&#x2F;        mockMvc &#x3D; MockMvcBuilders.standaloneSetup(new UserPostJsonController()).build();</span><br><span class="line">        &#x2F;&#x2F; 实例化方式二、对于controller有依赖的 可以注入</span><br><span class="line">         mockMvc &#x3D; MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常规测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.andExpect(model().attributeExists(&quot;user&quot;)) &#x2F;&#x2F;验证存储模型数据  </span><br><span class="line">.andExpect(view().name(&quot;user&#x2F;view&quot;)) &#x2F;&#x2F;验证viewName  </span><br><span class="line">.andExpect(forwardedUrl(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;user&#x2F;view.jsp&quot;))&#x2F;&#x2F;验证视图渲染时forward到的jsp  </span><br><span class="line">.andExpect(status().isOk())&#x2F;&#x2F;验证状态码  </span><br><span class="line">.andDo(print()); &#x2F;&#x2F;输出MvcResult到控制台</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到MvcResult自定义验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MvcResult result &#x3D; mockMvc.perform(get(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;, 1))&#x2F;&#x2F;执行请求  </span><br><span class="line">        .andReturn(); &#x2F;&#x2F;返回MvcResult  </span><br><span class="line">Assert.assertNotNull(result.getModelAndView().getModel().get(&quot;user&quot;)); &#x2F;&#x2F;自定义断言</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证请求参数绑定到模型数据及Flash属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockMvc.perform(post(&quot;&#x2F;user&quot;).param(&quot;name&quot;, &quot;zhang&quot;)) &#x2F;&#x2F;执行传递参数的POST请求(也可以post(&quot;&#x2F;user?name&#x3D;zhang&quot;))  </span><br><span class="line">            .andExpect(handler().handlerType(UserController.class)) &#x2F;&#x2F;验证执行的控制器类型  </span><br><span class="line">            .andExpect(handler().methodName(&quot;create&quot;)) &#x2F;&#x2F;验证执行的控制器方法名  </span><br><span class="line">            .andExpect(model().hasNoErrors()) &#x2F;&#x2F;验证页面没有错误  </span><br><span class="line">            .andExpect(flash().attributeExists(&quot;success&quot;)) &#x2F;&#x2F;验证存在flash属性  </span><br><span class="line">            .andExpect(view().name(&quot;redirect:&#x2F;user&quot;)); &#x2F;&#x2F;验证视图</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件上传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte[] bytes &#x3D; new byte[] &#123;1, 2&#125;;  </span><br><span class="line">mockMvc.perform(fileUpload(&quot;&#x2F;user&#x2F;&#123;id&#125;&#x2F;icon&quot;, 1L).file(&quot;icon&quot;, bytes)) &#x2F;&#x2F;执行文件上传  </span><br><span class="line">        .andExpect(model().attribute(&quot;icon&quot;, bytes)) &#x2F;&#x2F;验证属性相等性  </span><br><span class="line">        .andExpect(view().name(&quot;success&quot;)); &#x2F;&#x2F;验证视图</span><br></pre></td></tr></table></figure>
</li>
<li><p>json验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockMvc.perform(post(&quot;&#x2F;user&quot;)  </span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON).content(requestBody)  </span><br><span class="line">        .accept(MediaType.APPLICATION_JSON)) &#x2F;&#x2F;执行请求  </span><br><span class="line">        .andExpect(content().contentType(MediaType.APPLICATION_JSON)) &#x2F;&#x2F;验证响应contentType  </span><br><span class="line">        .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.id&quot;).value(1)); &#x2F;&#x2F;使用Json path验证JSON</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Callable  </span><br><span class="line">    MvcResult result &#x3D; mockMvc.perform(get(&quot;&#x2F;user&#x2F;async1?id&#x3D;1&amp;name&#x3D;zhang&quot;)) &#x2F;&#x2F;执行请求  </span><br><span class="line">            .andExpect(request().asyncStarted())  </span><br><span class="line">            .andExpect(request().asyncResult(CoreMatchers.instanceOf(User.class))) &#x2F;&#x2F;默认会等10秒超时  </span><br><span class="line">            .andReturn();  </span><br><span class="line">      </span><br><span class="line">    mockMvc.perform(asyncDispatch(result))  </span><br><span class="line">            .andExpect(status().isOk())  </span><br><span class="line">            .andExpect(content().contentType(MediaType.APPLICATION_JSON))  </span><br><span class="line">            .andExpect(jsonPath(&quot;$.id&quot;).value(1));</span><br></pre></td></tr></table></figure></li>
<li><p>post json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String userStr &#x3D; JSON.toJSONString(user);</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(&quot;&#x2F;user&#x2F;postjson&#x2F;insert&quot;)</span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">        .content(userStr)</span><br><span class="line">        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">        .andDo(MockMvcResultHandlers.print())</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">        .andReturn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>post form</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(&quot;&#x2F;user&#x2F;postform&#x2F;insert&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">&#x2F;&#x2F;                        .content(userStr)   &#x2F;&#x2F;这种无效</span><br><span class="line">                .param(&quot;name&quot;, &quot;lhx&quot;)</span><br><span class="line">                .param(&quot;age&quot;, &quot;30&quot;)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andReturn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>get</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;user&#x2F;postform&#x2F;insert&quot;)</span><br><span class="line">        .param(&quot;name&quot;, &quot;lhx&quot;)</span><br><span class="line">        .param(&quot;age&quot;, &quot;30&quot;)</span><br><span class="line">        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">        .andDo(MockMvcResultHandlers.print())</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">        .andReturn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockMvc &#x3D; webAppContextSetup(wac)  </span><br><span class="line">            .defaultRequest(get(&quot;&#x2F;user&#x2F;1&quot;).requestAttr(&quot;default&quot;, true)) &#x2F;&#x2F;默认请求 如果其是Mergeable类型的，会自动合并的哦mockMvc.perform中的RequestBuilder  </span><br><span class="line">            .alwaysDo(print())  &#x2F;&#x2F;默认每次执行请求后都做的动作  </span><br><span class="line">            .alwaysExpect(request().attribute(&quot;default&quot;, true)) &#x2F;&#x2F;默认每次执行后进行验证的断言  </span><br><span class="line">            .build();  </span><br><span class="line">      </span><br><span class="line">    mockMvc.perform(get(&quot;&#x2F;user&#x2F;1&quot;))  </span><br><span class="line">            .andExpect(model().attributeExists(&quot;user&quot;));</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h1 id="参看文章"><a href="#参看文章" class="headerlink" title="参看文章"></a>参看文章</h1><p><a href="https://blog.csdn.net/wo541075754/article/details/88983708" target="_blank" rel="noopener">SpringBoot基础之MockMvc单元测试</a></p>
]]></content>
      <categories>
        <category>java-spring-test</category>
      </categories>
  </entry>
  <entry>
    <title>002-java-通过包路径、类型查找接口实现</title>
    <url>/articles/20210105/7c99785d.html</url>
    <content><![CDATA[<p>摘要：保存成两个小数</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>java-base</category>
      </categories>
  </entry>
  <entry>
    <title>012-大型重构</title>
    <url>/articles/20210102/497fab79.html</url>
    <content><![CDATA[<p>摘要：“interface”。容易被理解、使用的接口，是开发良好面向对象软件的关键</p>
<a id="more"></a>

<h1 id><a href="#" class="headerlink" title></a></h1><p>12.1 Tease Apart Inheritance （梳理并分解继承体系） 362<br>12.2 Convert Procedural Design to Objects （将过程化设计转化为对象设计） 368<br>12.3 Separate Domain from Presentation （将领域和表述/显示分离） 370<br>12.4 Extract Hierarchy （提炼继承体系） 375</p>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>011-处理概括关系</title>
    <url>/articles/20210102/605a8a20.html</url>
    <content><![CDATA[<p>摘要：generalization，即集成关系</p>
<a id="more"></a>

<h1 id="PullUpField（字段上移）"><a href="#PullUpField（字段上移）" class="headerlink" title="PullUpField（字段上移）"></a>PullUpField（字段上移）</h1><ul>
<li>两个子类具有相同字段，移至超类</li>
</ul>
<h1 id="PullUpMethod（函数上移）"><a href="#PullUpMethod（函数上移）" class="headerlink" title="PullUpMethod（函数上移）"></a>PullUpMethod（函数上移）</h1><ul>
<li>在各个子类产生完全相同结果的函数移至超类</li>
</ul>
<h1 id="PullUpConstructorBody（构造函数本体上移）"><a href="#PullUpConstructorBody（构造函数本体上移）" class="headerlink" title="PullUpConstructorBody（构造函数本体上移）"></a>PullUpConstructorBody（构造函数本体上移）</h1><ul>
<li>子类通用构造函数移至超类</li>
</ul>
<h1 id="PushDownMethod（函数下移）"><a href="#PushDownMethod（函数下移）" class="headerlink" title="PushDownMethod（函数下移）"></a>PushDownMethod（函数下移）</h1><ul>
<li>超类中某个函数至于部分子类有关，将这个函数移到相关的那些子类中</li>
</ul>
<h1 id="PushDownField（字段下移）"><a href="#PushDownField（字段下移）" class="headerlink" title="PushDownField（字段下移）"></a>PushDownField（字段下移）</h1><ul>
<li>超类中某个字段至于部分子类有关，将这个字段移到相关的那些子类中</li>
</ul>
<h1 id="ExtractSubclass（提炼子类）"><a href="#ExtractSubclass（提炼子类）" class="headerlink" title="ExtractSubclass（提炼子类）"></a>ExtractSubclass（提炼子类）</h1><ul>
<li>类中的某些特性只被某些实例用到，新建一个子类，将特性写入新建的子类</li>
</ul>
<h1 id="Extract-Superclass-提炼超类"><a href="#Extract-Superclass-提炼超类" class="headerlink" title="Extract Superclass (提炼超类)"></a>Extract Superclass (提炼超类)</h1><ul>
<li>两个类具有相似特性，为两个雷建立一个超类，将特性移至超类</li>
</ul>
<h1 id="Extract-Interface-提炼接口"><a href="#Extract-Interface-提炼接口" class="headerlink" title="Extract Interface (提炼接口)"></a>Extract Interface (提炼接口)</h1><ul>
<li>若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。将相同的子集提炼到一个独立接口中。</li>
</ul>
<h1 id="Collapse-Hierarchy-（折叠继承体系）"><a href="#Collapse-Hierarchy-（折叠继承体系）" class="headerlink" title="Collapse Hierarchy （折叠继承体系）"></a>Collapse Hierarchy （折叠继承体系）</h1><ul>
<li>超类和子类之之间无太大区别。合成一个。</li>
</ul>
<h1 id="FormTemplateMethod（塑造模板函数）"><a href="#FormTemplateMethod（塑造模板函数）" class="headerlink" title="FormTemplateMethod（塑造模板函数）"></a>FormTemplateMethod（塑造模板函数）</h1><ul>
<li>有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作细节上有所不同。</li>
<li>将这些操作分别放进地理函数，并保持他们都有相同的签名，于是原函数也就变得相同了，然后将原函数移至超类</li>
</ul>
<h1 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h1><ul>
<li>q:某个子类使用超类接口中的一部分，或者是根本不需要继承而来的数据。</li>
<li>a:在子类中新建一个字段用以保存超类；调整子类函数，令他改而委托超类；然后去掉两者之间的继承关系</li>
</ul>
<h1 id="Replace-Delegation-with-Inheritance-（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance-（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance （以继承取代委托）"></a>Replace Delegation with Inheritance （以继承取代委托）</h1><ul>
<li>在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。</li>
<li>a:让委托类继承受委托类</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>010-简化函数调用</title>
    <url>/articles/20210102/ad0652f2.html</url>
    <content><![CDATA[<p>摘要：“interface”。容易被理解、使用的接口，是开发良好面向对象软件的关键</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>良好的接口，只向用户展现必须展现的东西。如果一个接口暴露了过多的细节，需要将不必要暴露的东西隐藏起来，从而改进接口的质量</li>
<li>所有数据都应该隐藏起来。</li>
<li>所有可以隐藏的函数都应该被隐藏起来。hide method、remove setting method　　</li>
</ul>
<p>修改函数名称。最简单、最重要。名称是程序写作者、阅读者交流的关键工具</p>
<ul>
<li>只要能理解一段程序的功能，就应该大胆使用rename method，将自己所知道的东西传达给他人</li>
<li>在适当时机，修改变量名称、类名称</li>
</ul>
<p>函数参数：add parameter、remove parameter</p>
<ul>
<li>对象技术，可以保持参数列的简短</li>
<li>preserve whole object：来自同一个对象的多个值被当作参数传递</li>
<li>introduce parameter object：对象不存在，创建一个参数对象</li>
<li>replace parameter with method：函数参数来自该函数可获取的一个对象=》避免传递参数</li>
<li>replace parameter with explicit method：参数被用来在条件表达式中做选择依据</li>
<li>parameter method：为数个相似函数添加参数，将它们合并到一起</li>
</ul>
<p>警告：</p>
<ul>
<li><p>并发编程往往需要使用较长的参数列，可以保证传递给函数的参数都是不可修改的。</p>
<ul>
<li>例如：内置对象、值对象一定是不可变的</li>
<li>可以使用不可变对象取代这样的长参数列。但必须对此类重构保持谨慎</li>
</ul>
</li>
<li><p>separate query from modifier：明确地将“修改对象状态”的函数和“查询对象状态”的函数分开设计</p>
</li>
<li><p>replace constructor with factory method：不需要知道搞糟函数要创建的对象属于哪个类</p>
</li>
<li><p>encapsulate downcast：将向下转型封装隐藏起来，避免让用户做那种动作</p>
</li>
<li><p>replace error code with exception：以错误代码表示程序异常</p>
</li>
<li><p>replace exception with test：测试</p>
</li>
</ul>
<h2 id="rename-method：修改函数名"><a href="#rename-method：修改函数名" class="headerlink" title="rename method：修改函数名"></a>rename method：修改函数名</h2><ul>
<li>问题：函数的名称未能揭示函数的用途</li>
<li>解决：修改函数名称</li>
<li>动机：</li>
<li>提倡的编程风格：将复杂的处理过程分解成小函数<ul>
<li>做不好=》费尽周折，却弄不清楚这些小函数各自的用途</li>
<li>解决关键：给函数起个好名字。准确表达它的用途（将函数上的注释变成函数名称）</li>
</ul>
</li>
<li>一个函数名称不能很好表达其用途，应该立即修改。<ul>
<li>代码首先是为人写的，其次才是为计算机而写。而人需要良好命名的函数</li>
<li>起个好名称并不容易，需要经验。要想成为一个真正的编程高手，起名的水平至关重要，函数签名中的其他部分也同样重要</li>
</ul>
</li>
<li>如果重新安排参数顺序，能够提高代码的清晰度，大胆去做。可运用add parameter、remove parameter</li>
<li>做法：</li>
<li>检查函数签名：是否被超类、子类实现过。<ul>
<li>是：针对每份实现分别进行下列步骤</li>
</ul>
</li>
<li>声明一个新函数，将其命名为新名称。将旧函数的代码复制到新函数中，进行适当调整</li>
<li>修改旧函数，让其调用新函数</li>
<li>找出旧函数的所有引用点，改而调用新函数</li>
<li>删除旧函数<ul>
<li>如果旧函数是该类public接口的一部分，可能无法安全地删除它。这种情况下，将其保留在原处，并标记为deprecated（不建议使用）</li>
</ul>
</li>
<li>注意：添加、去除某个参数，过程大致相同</li>
</ul>
<h2 id="add-parameter：添加参数"><a href="#add-parameter：添加参数" class="headerlink" title="add parameter：添加参数"></a>add parameter：添加参数</h2><ul>
<li>问题：某个函数需要从调用端得到更多信息</li>
<li>解决：为此函数添加一个对象参数，让该对象带进函数所需信息</li>
<li>动机：</li>
<li>必须修改一个函数，修改后的函数需要一些过去没有的信息=》需要给该函数添加一个参数</li>
<li>不使用本重构的时机：除了添加参数外，还有其他的选择<ul>
<li>只要可能，其他选择都比添加参数要好：不会增加参数列的长度</li>
<li>过长的参数列是bad smell：程序员很难记住这么多参数=》data clumps</li>
<li>提问：<ul>
<li>能从已有参数中得到需要的信息？</li>
<li>能通过某个函数提供所需信息？</li>
<li>需要将这些信息用于何处？此函数是否应该属于用改该信息的哪个对象所有</li>
<li>针对现有参数，加入新参数是否合适？是否可以使用intruduce parameter object</li>
</ul>
</li>
<li>并非绝对不要添加参数。但是，在添加参数之前必须要了解其他选项</li>
</ul>
</li>
<li>做法：类似add parameter、remove parameter<ul>
<li>检查函数签名是否被超类、子类实现过？是：针对每份分别实现下列步骤</li>
<li>声明一个新函数。名称与原函数同，只是添加新参数；将旧函数的代码复制到新函数中<ul>
<li>如果需要添加的参数不止一个，将其一次性添加进去比较容易</li>
</ul>
</li>
<li>修改旧函数，令其调用新函数<ul>
<li>可以给参数提供任意值。一般会给对象参数提供null；给内置型参数提供一个明显非正常值；数值型参数，建议使用0以外的值，这样比较容易将其认出来</li>
</ul>
</li>
<li>找出旧函数的所有引用点，将其修改为对新函数的引用，删除旧函数<ul>
<li>如果旧函数是该类public接口的一部分，可能无法安全地删除它。这种情况下，将其保留在原处，并标记为deprecated（不建议使用）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="remove-parameter：移除参数"><a href="#remove-parameter：移除参数" class="headerlink" title="remove parameter：移除参数"></a>remove parameter：移除参数</h2><ul>
<li>问题：函数本体不再需要某个参数</li>
<li>解决：将该参数去除</li>
<li>动机：</li>
<li>可能经常添加参数，却往往不愿意去掉它们：无论如何，多余的参数不会引起任何问题，而且以后可能用得上<ul>
<li>恶魔的诱惑</li>
<li>参数代表着函数所需的信息，不同的参数值有不同的意义。</li>
<li>函数调用者必须为每一个参数操心该传什么东西进去。如果不去掉多余参数，就是让每一位用户多费一份心。很不划算，且“去除参数”是非常简单的一项重构</li>
</ul>
</li>
<li>多态函数，情况有所不同，不能去除原有函数：可能多态函数的另一份（或多份）实现会使用这个参数，此时就不能去除它。</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>009-简化条件表达式</title>
    <url>/articles/20210102/642a4d3f.html</url>
    <content><![CDATA[<p>摘要：条件逻辑可能十分复杂</p>
<ul>
<li>decompose conditional：将一个复杂的条件逻辑分成若干个小块。使得“分支逻辑”、“操作细节”分离</li>
<li>consolidate conditional expression：代码中多处测试有相同结果</li>
<li>consolidate duplicate conditional fragment：去掉条件代码中的重复成分</li>
<li>为了让条件表达式也遵循“单一出口原则”，往往向其中加入控制标记。<ul>
<li>不特别在意“一个函数一个出口的教条，使用replace nested conditional with cuard clauses标示出那些特殊情况，使用remove control flag去除那些讨厌的限制</li>
</ul>
</li>
<li>面向对象程序的条件表达式通常比较少（较之过程化程序而言）：很多条件行为都被多态机制处理掉了。<ul>
<li>多态的好处：调用者无需了解条件行为的细节=》条件的扩展更容易</li>
</ul>
</li>
<li>replace conditional with polymorphism：将switch语句替换为多态</li>
<li>introduce null object：去除对于null值的校验。多态的一种十分有用且鲜为人知的用途<a id="more"></a>

</li>
</ul>
<h1 id="decompose-conditional：分解条件表达式"><a href="#decompose-conditional：分解条件表达式" class="headerlink" title="decompose conditional：分解条件表达式"></a>decompose conditional：分解条件表达式</h1><ul>
<li>问题：有一个复杂的条件语句（if-then-else）</li>
<li>解决：从if-then-else三个段落中分别提炼出独立的函数</li>
<li>动机：<ul>
<li>复杂的条件逻辑：最常导致复杂度上升的地点之一<ul>
<li>必须编写代码来检查不同的条件分支，根据不同的分支做不同的事情=》导致相当长的函数。</li>
<li>大型函数自身会使代码的可读性下降+条件逻辑会使代码更难阅读</li>
</ul>
</li>
<li>在带有复杂条件逻辑的函数中，代码（包括检查条件分支的代码、真正实现功能的代码）会告诉你法僧的事情。但是，常常让人弄不清楚为什么会发生这样的事=》代码的可读性的确大大降低了</li>
<li>任何大块头代码，都可以分解为多个独立函数。根据每一小块代码的用途，为分解而得的新函数命名，更清楚地表达自己的意图</li>
<li>对于条件逻辑，每个分支条件分解成新函数：突出条件逻辑，更清楚地表明每个分支的作用，突出每个分支的原因</li>
</ul>
</li>
<li>做法：<ul>
<li>将if-then-else中的每一个段落都提炼出来，构成一个独立函数</li>
<li>如果发现嵌套的条件逻辑，会先观察是否可以使用replace nested conditional with guard clauses。如果不行，才开始分解其中的每一个条件</li>
</ul>
</li>
<li>注意：<ul>
<li>有的分支条件往往非常短，看上去似乎没有提炼分支的必要。</li>
<li>尽管这些条件往往很短，在代码意图、代码自身之间往往存在不小的差距。提炼分支能够更好地表达自己的用途，提炼出来的函数可读性更高（就像一段注释那样清楚而明白）</li>
</ul>
</li>
</ul>
<h1 id="consolidate-conditional-expression：合并条件表达式"><a href="#consolidate-conditional-expression：合并条件表达式" class="headerlink" title="consolidate conditional expression：合并条件表达式"></a>consolidate conditional expression：合并条件表达式</h1><ul>
<li>问题：有一系列条件测试，都得到相同结果</li>
<li>解决：将这些测试合并为一个条件表达式，并将这个条件表达式提炼成一个独立的函数</li>
<li>动机：<ul>
<li>一串条件检查，检查条件各不相同，最终行为却一致<ul>
<li>立即用“逻辑或”、“逻辑与”将它们合并为一个条件表达式</li>
</ul>
</li>
<li>合并条件表达式的原因：<ul>
<li>1.合并后的条件代码：“实际上只有一次条件检查，只不过有多个并列条件需要检查而已”=》使这一次检查的用意更清晰<br>  合并前、合并后的代码有着相同的效果，但原先代码传达出的信息：“这里有一些各自独立的条件测试，只是恰好同时发生”</li>
<li>2.为使用extract method做好准备。将检查条件提炼成一个独立函数，对于理清代码十分有用：把描述“做什么”的语句换成了“为什么这样做”</li>
</ul>
</li>
<li>不要合并的理由：<ul>
<li>1.如果检查彼此独立，不应该视为同一次检查，就不要使用本重构项。代码已经清楚表达出自己的意义</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>确定这些条件语句没有副作用：有副作用不能使用本项重构</li>
<li>使用适当的逻辑操作符，将一系列相关条件表达式合并为一个</li>
<li>对合并后的条件表达式实施“extract method”，提炼成一个独立函数，并以函数名称表达该语句所检查的条件<ul>
<li>某些情况下，需要同时使用逻辑与、逻辑或、逻辑非，最终得到的条件表达式可能很复杂：先使用extract method将表达式的一部分提炼出来，从而使整个表达式变得简单一些</li>
<li>如果所观察的部分只是对条件进行检查并返回一个值，就可以使用三元操作符，将这一部分变成一条return语句。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="consolidate-dupulicate-conditional-fragment：合并重复的条件片段"><a href="#consolidate-dupulicate-conditional-fragment：合并重复的条件片段" class="headerlink" title="consolidate dupulicate conditional fragment：合并重复的条件片段"></a>consolidate dupulicate conditional fragment：合并重复的条件片段</h1><ul>
<li>问题：在条件表达式的每个分支上有着相同的一段代码</li>
<li>解决：将这段重复代码搬移到条件表达式之外。</li>
<li>动机：<ul>
<li>一组体哦阿健表达式的所有分支都执行了相同的某段代码：将这段代码搬移到表达式的外面=》更清楚地表明：那些东西随条件的变化而变化、那些东西保持不变</li>
</ul>
</li>
<li>做法：<ul>
<li>鉴别出“执行方式不随条件变化而变化”的代码</li>
<li>将共同代码移到条件表达式之外<ul>
<li>如果这些共同代码位于条件表达式的中断=》观察共同代码之前、之后改变了什么。如果的确有所改变，应该首相将共同代码向前、向后移动，移至条件表达式的起始处、尾端。</li>
<li>共同代码不止一条，首先使用extract method将共同代码提炼到一个独立函数中</li>
</ul>
</li>
</ul>
</li>
<li>注意：<ul>
<li>可以使用同样的手法来对待异常。如果在try-catch都执行了同一段代码，则将这段重复代码移到final区段</li>
</ul>
</li>
</ul>
<h1 id="remove-control-flag：移除控制标记"><a href="#remove-control-flag：移除控制标记" class="headerlink" title="remove control flag：移除控制标记"></a>remove control flag：移除控制标记</h1><ul>
<li>问题：在一系列布尔表达式中，某个变量带有“控制标记control flag”的作用</li>
<li>解决：用break 、return语句取代控制标记</li>
<li>动机：<ul>
<li>条件表达式中，常常看到：判断何时停止条件检查的控制标记</li>
<li>带来的麻烦&gt;带来的遍历。</li>
<li>使用control flag的原因：结构话编程原则，每个子程序只能有一个入口、一个出口<ul>
<li>赞同“单一入口”原则。</li>
<li>但，“单一出口”原则会在代码中加入讨厌的控制标记，大大降低条件表达式的可读性=》break、continue。用它们跳出复杂的条件语句</li>
</ul>
</li>
<li>去掉control flag：条件语句的真正用途会清晰很多</li>
</ul>
</li>
<li>做法：<ul>
<li>找出跳出这段逻辑的控制标记值</li>
<li>找出对标记变量赋值的语句，代以恰当的break、congtinue（对control flag最显而易见的方法）</li>
</ul>
</li>
<li>注意：<ul>
<li>未能提供break、continue语句的编程语言中<ul>
<li>extract method，整段逻辑提炼到一个独立函数中</li>
<li>找出跳出这段逻辑的控制标记值</li>
<li>找出对标记变量赋值的语句，代以恰当的return语句</li>
</ul>
</li>
<li>即使在支持break、congtinue语句的编程语言中，通常也优先考虑上述第二个方案。<ul>
<li>return语句可以非常清楚地表示：不再执行该函数中的其他任何代码</li>
</ul>
</li>
<li>注意标记变量，是否会影响这段逻辑的最后结果。<ul>
<li>如果有，使用break语句之后还得保留控制标记值。如果已经将这段逻辑提炼成一个独立函数，也可以将控制标记值放在return中返回</li>
</ul>
</li>
<li>既是控制标记，也是运算结果。将与次变量有关的代码，提炼到一个独立函数中，用return取代控制标记变量</li>
<li>如果以此办法处理带有，有副作用的函数，会出现问题。先以separate query from modifier将函数副作用分离出去</li>
</ul>
</li>
</ul>
<h1 id="replace-nested-conditional-with-guard-clauses：以卫语句取代嵌套条件表达式"><a href="#replace-nested-conditional-with-guard-clauses：以卫语句取代嵌套条件表达式" class="headerlink" title="replace nested conditional with guard clauses：以卫语句取代嵌套条件表达式"></a>replace nested conditional with guard clauses：以卫语句取代嵌套条件表达式</h1><ul>
<li>问题：函数中的条件逻辑使人难以看清正常的执行路径</li>
<li>解决：用卫语句表现所有特殊情况</li>
<li>动机：<ul>
<li>条件表达式，通常有两种情况：<ul>
<li>1.所有分支属于正常行为：应该用if-else-的条件表达式</li>
<li>2.只有一种是正常行为，其他都是不常见的情况。不常见的条件单独检查；为真时，立刻从函数中返回。<ul>
<li>单独检查，常被称为“卫语句guard clauses”</li>
</ul>
</li>
</ul>
</li>
<li>精髓：给某一条分支以特别的重视。<ul>
<li>if-then-else结构，对if、else的重视时同等的。</li>
<li>guard clauses：这种情况很罕见，如果真的发生了，请做一些整理工作，然后退出</li>
</ul>
</li>
<li>“每个函数只能有一个入口、一个出口”<ul>
<li>编程语言会强制，保证每个函数只有一个入口。</li>
<li>“单一出口”这个规则，没那么有用。保持代码清晰才是关键。如果单一出口能使函数更清楚易读，就使用单一出口；否则，不必这么做<ul>
<li>嵌套条件代码，往往由那些深心“每个函数只能由一个出口”的程序员写出。此条规则太简单粗暴了。如果对函数剩余部分不再由兴趣，应该立即退出。引导阅读者去看一个没有用的else区段，只会妨碍他们的理解</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>对于每个检查，放进一个guard clauses。卫语句要不从函数中返回，要不就抛出一个异常<ul>
<li>如果所有卫语句都导致相同的结果，请使用 consolidate conditional expressions</li>
</ul>
</li>
</ul>
</li>
<li>注意：<ul>
<li>常常可以将条件表达式反转，从而实现replace nested conditional with guard clauses。</li>
<li>推荐在guard clauses内返回一个明确的值，可以一目了然地看到guard clauses返回的失败结果。这是也会考虑使用replace magic number with symbolic constant</li>
</ul>
</li>
</ul>
<h1 id="replace-conditional-with-polymorphism：以多态取代条件表达式"><a href="#replace-conditional-with-polymorphism：以多态取代条件表达式" class="headerlink" title="replace conditional with polymorphism：以多态取代条件表达式"></a>replace conditional with polymorphism：以多态取代条件表达式</h1><ul>
<li>问题：条件表达式，是根据对象类型的不同，而选择不同的行为</li>
<li>解决：将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</li>
<li>动机：<ul>
<li>多态的好处：根据需要对象的不同类型，而采取不同的行为。多态，使你不必编写明显的条件表达式<ul>
<li>类型码的switch语句、基于类型名称的if-then-else语句，在面向对象程序中很少出现</li>
</ul>
</li>
<li>同一组条件条件表达式在程序许多地点出现，那使用多态的收益是最大的<ul>
<li>使用条件表达式时，如果项添加一种新类型，就必须查找并更新所有条件表达式。</li>
<li>如果改用多态，只需建立一个新的子类，并在其中提供适当的函数就行了。</li>
<li>类的用户不需要了解这个子类，就大大降低了系统各部分之间的依赖，使系统升级更容易</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>使用replace conditional with polymorphism之前，首先必须由一个继承结构。</li>
<li>建立继承结构由两种选择：<ul>
<li>replace type code with subclasses：简单，应尽可能使用这一种</li>
<li>replace type code with state/strategy：对象创建之后修改类型码；或者，要重构的类已经有了子类</li>
<li>如果若干switch语句针对的是同一个类型码，只需针对这个类型码建立一个继承结构就行了</li>
</ul>
</li>
<li>如果要处理的条件表达式是一个更大函数中的一部分。首先，对条件表达式进行分析，然后使用extract method将其提炼到一个独立函数去</li>
<li>如果由必要，使用move method、将条件表达式放置到继承结构的顶端</li>
<li>任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新建函数中，并对其进行适当调整<ul>
<li>可能需要将超类中某些private字段声明为protected</li>
</ul>
</li>
<li>超类中删掉条件表达式内被复制了的分支</li>
<li>将超类中容纳条件表达式的函数声明为抽象函数</li>
</ul>
</li>
</ul>
<h1 id="intruduce-null-object：引入null对象"><a href="#intruduce-null-object：引入null对象" class="headerlink" title="intruduce null object：引入null对象"></a>intruduce null object：引入null对象</h1><ul>
<li>问题：需要再三检查某对象是否为null </li>
<li>解决：将null值替换为null对象</li>
<li>动机：</li>
<li>多态的最根本好处：不必再向对象询问“你是什么类型”。而后根据得到的答案调用对象的某个行为。只管调用该行为就是了，其他的一切，多态机制会为你安排妥当</li>
<li>当某个字段内容为null时，多态可扮演另一个较不直观，亦较不为人所知的用途<ul>
<li>解决：每次向一个对象发送一个消息之前，总是要检查对象是否存在。此类检查出现很多次，造成大量的重复代码</li>
<li>null object==miss object。不让实例变量被设为null，而是插入各式各样的空对象，都知道如何正确的显示自己=》拜托大量过程化的代码<ul>
<li>mock test object：使用此原理。便于模块化开发、测试。</li>
<li>missing bin：虚构的箱仓。自己不带任何数据，总值为0.<ul>
<li>箱仓：指集合，用来保存某些资薪值，并常常需要对各个资薪值进行加和、遍历</li>
</ul>
</li>
<li>系统几乎从来不会因为空对象而被破坏。null object对所有外界请求的相应和真实对象一样=》系统行为总是正常的</li>
<li>并非总是好事儿。有时会造成问题侦测、查找上的困难。因为从来没有任何东西被破坏。<ul>
<li>只要认真检查，就会发现空对象有时出现在不该出现的地方</li>
</ul>
</li>
<li>空对象一定是常量，它们的任何成分都不会发生变化。可以使用singleton模式来实现=》任何时候，只要请求一个miss<strong>对象，得到的一定是miss</strong>的唯一实例</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>为源类建立一个子类，使其行为就像是源类的null版本。在源类、null子类中都加上isnull（），前者返回false，后者返回true。<ul>
<li>有帮助的做法：建立一个nullable接口，将isnull（）放入其中，让源类实现这个接口：昭告大家，这里使用了空对象</li>
<li>也可以创建一个测试接口，专门用来检查对象是否为null：无法修改null对象的</li>
<li>工厂函数：专门用来创建null**对象=》用户不必知道空对象的存在</li>
</ul>
</li>
<li>找出所有“索求对象却获得一个null”的地方。修改这些地方，使其获得一个null对象</li>
<li>找出所有“将源对象与null作比较”的地方。修改这些地方，使其调用isnull（）<ul>
<li>每次只处理一个源对象、其客户程序，编译、测试后，再处理另一个源对象</li>
<li>可以在“不该出现null”的地方放上一些断言，确保null不再出现</li>
<li>大多数情况，需要做大量的替换工作（视null对象的使用频率来决定），很凌乱、恼人</li>
<li>实现nullable接口的对象：（aCustomer is null）来判断</li>
</ul>
</li>
<li>找出这样的程序点：如果对象不是null，做A动作，否则做B动作<ul>
<li>在null类中覆写A动作，使其行为和B动作相同</li>
<li>使用被覆写的动作，删除“对象是否等于null”的条件测试</li>
</ul>
</li>
</ul>
</li>
<li>注意：<ul>
<li>只有当大多数（不是所有）客户代码，都要求空对象做出相同响应时，这样的行为搬移才有意义。<ul>
<li>任何用户如果需要空对象做出不同相应，仍然可以使用isnull（）函数来测试，只要大多数客户端都要求空对象做出相同响应，就可以调用默认的null行为，自己也就受益匪浅了</li>
</ul>
</li>
<li>使用本项重构时，可以有几种不同的空对象（例如：没有顾客、不知顾客名的顾客），针对不同情况建立不同的空对象类。<ul>
<li>有时候空对象也可以携带数据：不知名顾客的使用记录……，查出顾客姓名后，将账单寄给他</li>
<li>本质上是特例模式special case：比null object模式更大的模式。<ul>
<li>某个类的特殊情况，有着特殊行为</li>
<li>例如：浮点数：有“正无穷大”、“负无穷大”、“NaN”……</li>
<li>价值：可以降低“错误处理”开销。NaN做浮点运算，结果是个NaN。与“空对象的访问函数通常返回另一个空对象”同   理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="intruduce-assertion：引入断言"><a href="#intruduce-assertion：引入断言" class="headerlink" title="intruduce assertion：引入断言"></a>intruduce assertion：引入断言</h1><ul>
<li>问题：某一段代码需要对程序状态做出某种假设</li>
<li>解决：以断言明确某种假设</li>
<li>动机：<ul>
<li>只有当某个条件为真时，该段代码才能正常运行。例如：平方根计算只对正值才能进行……</li>
<li>这样的假设通常并没有在代码中明确表现出来，必须阅读整个算法才能看出。有时会以注释写出这样的假设=》更好的技术：使用断言，明确表明这些假设</li>
<li>断言是一个条件表达式，应该总为真。如果失败，表示程序员犯了错误<ul>
<li>断言的失败应该导致一个非受控异常unchecked exception。</li>
<li>断言绝对不能被系统的其他部分使用。</li>
<li>实际上，程序最后的成品，往往将断言统统删除=》标记“某些东西是断言”，很重要</li>
</ul>
</li>
<li>断言，可以作为交流、调试的辅助。<ul>
<li>交流角度上，断言可以帮助程序阅读者，理解代码所做的假设（代码正确运行的必要条件）</li>
<li>调试角度上，断言可以在距离bug最近的地方抓住它们</li>
<li>=》编写自我测试代码时，断言在调试方面的帮助变得不那么重要了。但，仍要非常看重断言在交流方面的价值</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>如果程序不犯错，断言就应该不会对系统运行造成任何影响=》加入断言，不会影响程序的行为<ul>
<li>如果反写代码假设某个条件始终为真。就加入一个断言，明确说明这种情况</li>
<li>可以新建一个Assert类，用于处理各种情况下的断言</li>
</ul>
</li>
<li>不要滥用断言。不要使用它来检查“你认为应该为真”的条件，请只用它来检查“一定必须为真”的条件<ul>
<li>滥用断言，可能会造成难以维护的重复逻辑。</li>
<li>在一段逻辑中加入断言是有好处的：迫使你重新考虑这段代码的约束条件</li>
<li>如果不满足这些约束条件，程序也可以正常运行=》断言不会带来任何帮助，只会把代码变得混乱，可能妨碍以后的修改</li>
</ul>
</li>
<li>应该常常问自己：如果断言所只是的约束条件不能满足，代码是否仍能正常运行？如果可以，将断言删掉</li>
<li>断言中的重复代码。和其他任何的地方的重复diamagnetic一样不好闻，大胆使用extract method（去重、更清楚说明函数用途）去掉那些重复代码。</li>
</ul>
</li>
<li>注意：</li>
<li>断言可以被轻松拿掉=》不可能影响最终成品的性能。</li>
<li>编写一个辅助类（例如：Assert类）是有帮助的。<ul>
<li>缺点：断言参数中的任何表达式不论什么情况，都一定会被执行一遍。</li>
<li>阻止它的唯一办法：如果Assert.ON是个常量，编译器就会对其进行检查。如果==false，就不会再执行表达式后半段代码<ul>
<li>加此语句有些丑陋，嗯对程序源宁可仅仅使用Assert.isTrue()函数。在项目结束前，过滤掉使用断言的每一行diamagnetic</li>
</ul>
</li>
</ul>
</li>
<li>Assert类应该有很对个函数，函数名称应该帮助程序员理解其功用。<ul>
<li>isTrue()、equals()、shouldNeverReachHere()……</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>008-重新组织数据</title>
    <url>/articles/20210102/28ec1893.html</url>
    <content><![CDATA[<p>摘要：对象应该直接访问其中的数据，还是通过访问函数来访问？  </p>
<ul>
<li>常选择“直接访问”方式，任何时候进行这项重构（self encapsulate field）都是很简单的</li>
<li>eplace value with object:将“哑”数据变成善表达的对象</li>
<li>hange value to reference：有太多地方需要这一类对象，可用此方法将其变为引用对象</li>
<li>eplace array with object：看到一个数组的行为方式很像一个数据结构。将数组变成对象，从而使这个数据结构更清晰地显露出来。move method，为这个对象加入相应行为，真正的好处才得以体现</li>
<li>eplace magic number with symbolic constant：处理魔法数（带有特殊含义的数字）</li>
<li>hange unidirectional association to bidirectional：将对象之间的单向关联变成双向关联</li>
<li>hange bidirectional association to undirectional：将双向关联变成单向关联</li>
<li>uplicate Observed data：GUI类处理不该其处理的业务：将处理业务逻辑的行为移到合适的领域类去，需要在领域类中保存这些逻辑的相关数据。一般，不喜欢重复数据，但这是一个意外，这里的重复数据不可避免</li>
<li>ncapsulate field：封装类中公开的数据</li>
<li>ncapsulate collection：封装类中公开的集合。集合有其特殊协议</li>
<li>eplace recorde with data class：如果一整条记录都被裸露在外</li>
<li>ype code：类型码，特殊数值。“与实例所属之类型相关的某些东西”。通常以枚举形式出现。通常以static final 整数实现。</li>
<li>eplace type code with class：应用于：用来表现某种信息，且不会改变所属类型的行为。可以提供更好的类型检查和更好的平台(在未来方便地将相关的行为添加进去)</li>
<li>eplace type code with subclasses :如果当前类型的行为受到类型码的影响</li>
<li>eplace type code with state/strategy:更复杂的情况<a id="more"></a>

</li>
</ul>
<h1 id="self-encapsulate-field：自封装字段"><a href="#self-encapsulate-field：自封装字段" class="headerlink" title="self encapsulate field：自封装字段"></a>self encapsulate field：自封装字段</h1><ul>
<li>问题：直接访问一个字段，但是字段之间的耦合关系逐渐变得笨拙</li>
<li>解决：为这个字段建立取值、设值函数，并且只以这些函数来访问字段</li>
<li>动机：<ul>
<li>“间接访问变量”。好处：子类可以通过覆写一个函数，改变获取数据的途径；支持更灵活的数据管理方式（延迟初始化）</li>
<li>“直接访问变量”。好处：代码比较容易阅读。</li>
<li>通常，先使用直接访问方式，直到这种方式会带来麻烦，接着转而使用间接访问方式。重构给了改变主意的自由</li>
<li>使用 self encapsulate field：<ul>
<li>想访问超类中的一个字段，却又想在子类中将这个变量的访问改为一个计算后的值</li>
<li>“字段的自我封装” 只是第一步。完成自我封装之后，可以在子类中根据自己的需要随意覆写set/get函数</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>可以暂时将字段改名，让编译器帮助查找引用点</li>
<li>将字段声明为private</li>
</ul>
</li>
</ul>
<h1 id="replace-data-value-with-object-以对象取代数据值"><a href="#replace-data-value-with-object-以对象取代数据值" class="headerlink" title="replace data value with object:以对象取代数据值"></a>replace data value with object:以对象取代数据值</h1><ul>
<li>问题：有一个数据项，需要与其他数据、行为一起使用才有意义</li>
<li>解决：将数据项变成对象</li>
<li></li>
<li>动机：<ul>
<li>开发初期，往往决定以简单的数据项表示简单的情况。随着开发的进行，发现这些简单数据项不再简单。散发duplicate code/feature envy的代码坏味道，则需要将数据值变成对象</li>
<li>例：开始，用字符串表示“电话号码”。随后，电话号码需要“格式化”、“抽取区号”之类的特殊行为。</li>
</ul>
</li>
<li>做法：<ul>
<li>为待替换数值新建一个类，在其中声明一个final字段，类型和源类中的待替换数据类型一样；在新类中加入这个字段的取值函数；新类中加上一个接受此字段为参数的构造函数</li>
<li>将源类中的待替换数值字段的类型改为新建的类</li>
<li>修改源类的该字段的取值函数，令其调用新类的取值函数</li>
<li>如果源类构造函数中用到这个待替换字段（多半是赋值动作），就修改构造函数，令其改用新类的构造函数来对字段进行赋值</li>
<li>修改源类中的待替换字段的设值函数，令其为新类创建一个实例（值对象应该是不可修改的内容。可以避免一些讨厌的别名问题）</li>
<li>可能需要对新类使用change value to reference</li>
</ul>
</li>
</ul>
<h1 id="change-value-to-reference-将值对象改为引用对象"><a href="#change-value-to-reference-将值对象改为引用对象" class="headerlink" title="change value to reference:将值对象改为引用对象"></a>change value to reference:将值对象改为引用对象</h1><ul>
<li>问题：从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象</li>
<li>解决：将这个值对象变为引用对象</li>
<li>动机：<ul>
<li>引用对象：可以直接==，来验证对象同一性</li>
<li>值对象：覆写equal()、hashCode()</li>
<li>应用：确保对任何一个对象的修改，都能影响到所有引用此对象的地方。需要将此对象变成一个引用对象</li>
</ul>
</li>
<li>做法：<ul>
<li>使用replace constructor with factory method</li>
<li>决定由什么对象负责提供访问新对象的途径<ul>
<li>可能是一个静态字典，或一个注册表对象</li>
<li>可以使用多个对象作为新对象的访问点</li>
</ul>
</li>
<li>决定这些引用对象应该预先创建好，还是应该动态创建<ul>
<li>如果引用对象是预先创建好的，且必须从内存中将其读取出来。就需确保它们在被需要的时候能够被及时加载</li>
</ul>
</li>
<li>修改工厂函数，令它返回引用对象<ul>
<li>如果对象是预先创建好的，需要考虑：万一有人索取一个其实并不存在的对象，要如何处理错误</li>
<li>可能希望对工厂函数使用rename method，使其传达：它返回的是一个既存对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="change-reference-to-value：将引用对象改为值对象"><a href="#change-reference-to-value：将引用对象改为值对象" class="headerlink" title="change reference to value：将引用对象改为值对象"></a>change reference to value：将引用对象改为值对象</h1><ul>
<li>问题：一个引用对象，很小，且不可变，且不易管理</li>
<li>解决：将其变成一个值对象</li>
<li>动机：<ul>
<li>引用对象开始变得难以使用。<ul>
<li>引用对象必须被某种方式控制，总是必须向其控制者请求适当的引用对象</li>
<li>可能造成内存区域之间错综复杂的关联</li>
<li>在分步系统、并发系统中，不可变的值对象特别有用，无需考虑它们的同步问题</li>
</ul>
</li>
<li>值对象的一个非常重要的特性：不可变<ul>
<li>保证了，可以放心地以多个对象表示同一事物</li>
<li>不代表不能改变。如果要改变，需要用新的对象来取代现有对象，而不是在现有对象上修改。值对象自身不能修改，但是可以修改其他对象与值对象之间的关系</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>检查重构目标是否为不可变对象，或是否可修改为不可变对象<ul>
<li>如果改对象目前还不是不可变的，使用remove setting method，直到其成为不可变的为止</li>
<li>如果无法将对象修改为不可变的，就放弃使用本项重构</li>
</ul>
</li>
<li>建立equal()、hashcode()。这两个函数的修改必须同时进行，负责依赖hash的任何集合对象（hashtable、hashset、hashmap……）都可能产生意外行为</li>
<li>考虑是否可以删除工厂函数，并将构造函数声明为public</li>
</ul>
</li>
<li>注意：要把一个引用对象变成值对象，关键动作：检查是否不可变。<ul>
<li>如果不是，就不能使用本项重构。</li>
<li>可变的值对象会造成烦人的别名问题</li>
</ul>
</li>
</ul>
<h1 id="replace-array-with-object：以对象取代数值"><a href="#replace-array-with-object：以对象取代数值" class="headerlink" title="replace array with object：以对象取代数值"></a>replace array with object：以对象取代数值</h1><ul>
<li>问题：由一个数值，各元素各自代表不同的东西、</li>
<li>解决：以对象替换数组。对于数组中的每个元素，以一个字段来表示</li>
</ul>
<h1 id="change-unidirectional-association-to-bidirectional将单向关联改为双向关联"><a href="#change-unidirectional-association-to-bidirectional将单向关联改为双向关联" class="headerlink" title="change unidirectional association to bidirectional将单向关联改为双向关联"></a>change unidirectional association to bidirectional将单向关联改为双向关联</h1><ul>
<li>场合：两个类·····都需要使用双方特性，但其间只有一条单向连接</li>
<li>方式：添加一个反向指针，并使修改函数能够同时更新两条连接</li>
<li>动机：<ul>
<li>开发初期，可能会在两个类之间建立一条单向连接，使其中一个类可以引用另一个类。随着时间推移，引用类需要得到其引用者，以便进行某些处理。即需要一个反向指针</li>
<li>指针是一种单向连接，不可能反向操作。可以绕道而行，耗费一些计算时间，成本还算合理，然后在被引用类中建立一个函数专门负责此行为</li>
<li>有时候绕过这个问题并不容易，此时需要建立双向引用关系，即反向指针</li>
<li>如果使用不当，反向指针很容易造成混乱；但只要习惯了这种手法，其实并不复杂</li>
<li>反向指针，不好实现。在熟练运用前，应该有相应的测试。</li>
<li>通常不会花心思测试访问函数，因为普通访问函数的风险没有高到需要测试的地步。但本重构要求测试访问函数，是极少数需要添加测试的重构手法之一</li>
</ul>
</li>
<li>做法：<ul>
<li>在被引用类中增加一个字段，用以保存反向指针</li>
<li>决定由哪个类：引用端？被引用端？ 控制关联关系<ul>
<li>如果两者都是引用对象，而其间的关联是“一对多”关系。那么就由“拥有单一引用”的那一方（N）承担“控制者”角色。</li>
<li>如果某个对象是组成另一对象的不见，那么由后者负责控制关联关系</li>
<li>如果两者都是引用对象，而关联关系是“多对多”关系，那么随便其中一个对象来控制关联关系都无所谓</li>
</ul>
</li>
<li>在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途。<ul>
<li>尽量降低可见程度：最小范围内可见</li>
</ul>
</li>
<li>如果既有的修改函数在控制端，让它负责更新反向指针</li>
<li>如果既有的修改函数在被控端，就在控制端及那里一个控制函数，并让既有的修改函数调用这个新建的控制函数<ul>
<li>基本形式：先让对方删除指向你的指针，再将你的指针指向一个新对象，最后让那个新对象把它的指针指向你</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="change-bidirectional-association-to-unidirectional将双向关联改为单向关联"><a href="#change-bidirectional-association-to-unidirectional将双向关联改为单向关联" class="headerlink" title="change bidirectional association to unidirectional将双向关联改为单向关联"></a>change bidirectional association to unidirectional将双向关联改为单向关联</h1><ul>
<li>场合：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性</li>
<li>方式：去除不必要的关联</li>
<li>动机：<ul>
<li>双向关联很有用，但是必须为其付出代价。维护双向关联；确保对象被正确创建、删除而增加的复杂度；很多程序员并不习惯使用双向关联，往往成为错误之源</li>
<li>大量的双向连接也很容易造成“僵尸对象”：某个对象本来应该已经死亡，却仍然保留在系统中，因为对其的引用还没有完全清除</li>
<li>双向关联迫使两个类直接有了依赖：对其中任一个类的任何修改，都可能引发另一个类的变化。如果两个类位于不同的包，这种依赖就是包与包之间的相依。过多的跨包依赖会造成紧耦合系统，使得任何一点小小改动都可能造成许多无法预知的后果</li>
<li>只有真正需要双向关联的时候，才应该使用它，如果发现双向关联不再存在价值，就应该去掉其中不必要的一条关联</li>
</ul>
</li>
<li>做法：<ul>
<li>找出“想去除的指针”的字段，检查它的每一个用户，判断时候可以去除改指针<ul>
<li>不但要检查直接访问点，也要检查调用这些直接访问点的函数</li>
<li>考虑有无可能不通过指针取得被引用的对象。如果有可能，就可以对取值函数使用substitute algorithm，从而让客户在没有指针的情况先也可以使用改取值函数</li>
<li>对于使用该字段的所有函数，考虑将被引用对象作为参数传进去</li>
</ul>
</li>
<li>如果客户使用了取值函数，先运用self encapsulate field将待删除字段自我封装起来，然后使用substitute algorithm对付取值函数，令它不再使用该字段</li>
<li>如果客户并未使用取值函数，直接修改待删除字段的所有被引用点，改以其他途径获得该字段所保存的对象</li>
<li>如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段<ul>
<li>如果有许多地方对次字段赋值，先运用self encapsulate field使这些地点改用同一赋值函数。而后将这个设值函数的本体清空。接着就可将此字段、设值函数、及其所有调用全部移除</li>
</ul>
</li>
</ul>
</li>
<li>注意：<ul>
<li>最困呐的地方：检查可行性。如果知道本重构是安全的，则重构手法自身十分简单。</li>
</ul>
</li>
</ul>
<h1 id="replace-magic-number-with-symbolic-constant：以字面常量取代魔法值"><a href="#replace-magic-number-with-symbolic-constant：以字面常量取代魔法值" class="headerlink" title="replace magic number with symbolic constant：以字面常量取代魔法值"></a>replace magic number with symbolic constant：以字面常量取代魔法值</h1><h1 id="encapsualte-collection-封装集合"><a href="#encapsualte-collection-封装集合" class="headerlink" title="encapsualte collection 封装集合"></a>encapsualte collection 封装集合</h1><ul>
<li>场合：有一个函数返回一个集合</li>
<li>方式：让这个函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数</li>
<li>动机：<ul>
<li>集合的处理方式应该和其他种类的数据略有不同。</li>
<li>取值函数不该返回集合本身：这将会让用户得以修改集合内容，而集合拥有者却一无所知；对用户暴露过多对象内部的数据接口信息</li>
<li>如果一个取值函数确实需要返回多个值，应该避免用户直接操作对象内所保存的集合，并隐藏对象内与用户无关的数据结构。</li>
<li>不应该为整个集合提供一个设值函数，但应该为集合加上添加、移除元素的函数。集合拥有者可以控制集合元素的添加、移除</li>
<li>降低集合拥有者、用户间的耦合度<br>做法：</li>
</ul>
</li>
<li>为集合加上添加、移除元素的函数</li>
<li>将保存集合的字段初始化为一个空集合</li>
<li>找出集合设值函数的所有调用者。修改那个设值函数，使其使用上述新建立的“添加、移除元素”的函数；也可以直接修改调用端，让其使用上述新建立的“添加、移除元素”的函数<ul>
<li>两种情况下，需要用到集合设值函数：1、集合为空；2、准备将原有集合替换为另一个集合时</li>
<li>也能用rename method，为集合设值函数改名，从set<strong><em>()改为initialize</em></strong>()或replace***()</li>
</ul>
</li>
<li>找出所有“通过取值函数，获得集合，并修改其内容的函数”，逐一修改这些函数，改用述新建立的“添加、移除元素”的函数</li>
<li>修改取值函数本身，使其返回该集合的一个只读副本</li>
<li>找出取值函数的所有用户，找出应该存在与集合所属对象内的代码。用extract method、remove method将代码移到宿主对象去</li>
<li>修改现有取值函数的名字，添加一个新的取值函数，使其返回一个枚举。找出旧取值函数的所有被使用点，改用新取值函数<ul>
<li>跨步过大，可使用rename method修改原有取值函数的名称；再建立一个新取值函数，用以返回枚举；最后再修改所有调用者，使其调用新取值函数。<h1 id="replace-type-code-with-subclasses：以子类取代类型码"><a href="#replace-type-code-with-subclasses：以子类取代类型码" class="headerlink" title="replace type code with subclasses：以子类取代类型码"></a>replace type code with subclasses：以子类取代类型码</h1></li>
</ul>
</li>
<li>问题：有一个不可变的类型码，会影响类的行为</li>
<li>解决：以子类取代这个类型码</li>
<li>动机：<ul>
<li>面对的类型码不会影响宿主类的行为，使用replace type code with class来处理。</li>
<li>如果类型码会影响宿主类的行为，最好的办法是借助多态来处理变化行为<ul>
<li>一般，这种情况的标志就是向switch这样的表达式、if-then-else结构……检查类型码的值，根据不同的值执行不同的动作。应该以replace conditional with polymorphism进行重构。</li>
<li>为了能够顺利进行那样的重构，首先应该将类型码替换为可拥有多态行为的继承体系。这样的一个继承体系应该以类型码的宿主类为基类，并针对每一种类型码各建立一个子类</li>
</ul>
</li>
<li>为了建立这样的一个继承体系，最简单的方法：replace type code with subclasses。以类型码的宿主类为基类，针对每种类型码建立相应的子类</li>
<li>以下情况不能这么做：1.类型码值在对象创建之后发生了改变；2.由于某些原因，类型码宿主类已经有了子类。<ul>
<li>使用replace type code with state/stragegy</li>
</ul>
</li>
<li>replace type code with subclasses：主要作用是搭建一个舞台，让replace conditional with polymorphism得以一展身手。</li>
<li>如果宿主类中并美哟出现条件表达式，replace type code with class 更合适，风险更低</li>
<li>使用replace type code with subclasses另一个原因：宿主类中出现了“只与具备特定类型码之对象有关”的特性。可以使用push down method、push down field将这些特性推到合适的子类去，以彰显只与特定情况相关这一事实</li>
<li>replace type code with subclasses好处：把“对不同行为的了解”从类用户那儿转移到了类自身。如果需要再加入新的行为变化，只需添加一个子类就行了。如果没有多态机制，就必须找到所有条件表达式，并逐一修改它们=》如果未来还有可能加入新行为，这项重构将特别有价值</li>
</ul>
</li>
<li>做法：<ul>
<li>使用self encapsulate field将类型码自我封装起来<ul>
<li>如果类型码被传递给构造函数，就需要将构造函数换成工厂函数</li>
</ul>
</li>
<li>为类型码的每一个数值建立一个相应的子类。在每个子类中覆写类型码的取值函数，使其返回相应的类型码值<ul>
<li>这个值被硬编码于return中（例如：return 1）.看起来很肮脏，但只是权益之计，当所有case子句都被替换后，问题就解决了</li>
</ul>
</li>
<li>每建立一个新的子类，编译并测试</li>
<li>从超类中删掉保存类型码的字段，将类型码访问函数声明为抽象函数</li>
<li>注意：避免使用switch语句。这里只有一处用到switch语句，并且只用于决定创建何种对象，这样的switch语句是可以接受的</li>
</ul>
</li>
</ul>
<h1 id="replace-type-code-with-state-strategy"><a href="#replace-type-code-with-state-strategy" class="headerlink" title="replace type code with state/strategy"></a>replace type code with state/strategy</h1><ul>
<li>问题：有一个类型码，会影响类的行为，但无法通过继承手法消除它</li>
<li>解决：以状态对象取代类型码</li>
<li>动机：<ul>
<li>与replace type code with subclasses很相似。但如果“类型码值在对象生命周期中发生变化”或“其他原因使得宿主类不能被继承”，可以使用本重构（使用state模式、strategy模式）</li>
<li>state模式、strategy模式非常相似，无论选择其中哪一个，重构过程都是相同的。“选择哪一个模式”并非问题关键所在，只需要选择更合适特定情境的模式就行了<ul>
<li>strategy模式适合：在本项重构之后再以replace conditional with polymorphism简化一个算法</li>
<li>state模式适合：搬移与状态相关的数据，而且把新建对象视为一种变迁状态</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>selfe encapsulate field将类型码自我封装起来</li>
<li>新建一个类，根据类型码的用途为它命名，就是一个状态对象</li>
<li>为这个新类添加子类，每个子类对应一种类型码<ul>
<li>比起逐一添加，一次性加入所有必要的子类可能更简单写</li>
</ul>
</li>
<li>在超类中建议一个抽象的查询函数，用以返回类型码。在每个子类中覆写该函数，返回确切的类型码</li>
<li>在源类中建立一个字段，用以保存新建的状态对象</li>
<li>调整源类中负责铲鲟类型码的函数，将查询动作状态转发给状态对象</li>
<li>调整源类中为类型码设值的函数，将一个恰当的状态对象子类赋值给“保存状态对象”的那个字段</li>
</ul>
</li>
</ul>
<h1 id="replace-subclass-with-field：以字段取代子类"><a href="#replace-subclass-with-field：以字段取代子类" class="headerlink" title="replace subclass with field：以字段取代子类"></a>replace subclass with field：以字段取代子类</h1><ul>
<li>问题：各个子类的唯一差别，只在“返回常量数据”的函数身上</li>
<li>解决：修改这些函数，使其返回超类中的某个（新增）字段，然后销毁子类</li>
<li>动机：<ul>
<li>建立子类的目的：为了增加新特性、变化其行为。</li>
<li>有一种变化行为被称为“常量函数”constant method，会返回一个硬编码的值。<ul>
<li>有其用途，可以让不同的子类中的同一个访问函数返回不同的值。可以在超类中将访问函数声明为抽象函数，并在不同的子类中让它返回不同的值</li>
</ul>
</li>
<li>尽管常量函数有其用途，但若子类中只有常量函数，实在没有足够的存在价值。可以在超类中设计一个与常量函数返回值相应的字段，从而完全去除这样的子类=》避免因继承而带来的额外的复杂性</li>
</ul>
</li>
<li>做法：<ul>
<li>对所有子类使用replace constructor with factory method</li>
<li>如果有任何代码直接引用子类，令它改而引用超类</li>
<li>针对每个常量函数，在超类中声明一个final 字段</li>
<li>为超类声明一个protected构造函数，用以初始化这些新增字段</li>
<li>新建、修改子类构造函数，使其调用超类的新增构造函数</li>
<li>在超类中实现所有常量函数，令其返回相应字段值，然后将函数从子类中删掉</li>
<li>inline method将子类构造函数内联到超类的工厂函数中</li>
<li>删除子类</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>007-在对象之间搬移特性</title>
    <url>/articles/20210102/bcb5204a.html</url>
    <content><![CDATA[<p>摘要：对象设计过程中，“决定把责任放在哪儿”，即使不是最重要的事儿，也是最重要的事情之一</p>
<ul>
<li>move field=》move method简单的移动对象行为</li>
<li>类往往因为承担过多的责任而变得臃肿不堪。extract class 将一部分责任分离出去。</li>
<li>一个类变得太“不负责任”，inline class将其融入另一个类</li>
<li>一个类使用了另一个类，hide delegate，将这种关系隐藏起来</li>
<li>隐藏委托类，导致拥有者的接口经常变化，remove middle man</li>
<li>当不能访问某个类的源码，又想把其他责任移进这个不可修改的类时，introduce foreign method、introduce local extension；想加入的只是1、2个函数，使用introduce foreign method；否则使用introduce local extension<a id="more"></a>

</li>
</ul>
<h1 id="move-method：搬移函数"><a href="#move-method：搬移函数" class="headerlink" title="move method：搬移函数"></a>move method：搬移函数</h1><ul>
<li>有一个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用</li>
<li>在该函数最常引用的类中，建立一个有着类似行为的新函数，将旧函数变成一个单纯的委托函数，或将旧函数完全移除<ul>
<li>机：</li>
</ul>
</li>
<li>move method：重构理论的支柱。如果一个类有太多行为；一个类与另一个类有太多合作而形成高度耦合</li>
<li>可使系统中的类更简单，这些类最终也更干净利落地实现系统交付的任务</li>
<li>迹象：<ul>
<li>使用另一个类的次数比使用自己所驻对象的次数还多</li>
<li>一旦移动了一些字段，就该做这样的检查</li>
<li>一旦发现有可能搬移的函数，就会观察调用它的那一段、它调用的那一段，以及继承体系中它的任何一个重定义函数</li>
<li>根据“这个函数与哪个对象的交流比较多”，决定其移动路径</li>
</ul>
</li>
<li>如果不能肯定是否应该移动一个函数，就继续观察其他函数。移动其他函数往往会让这项决定变得容易一些。</li>
<li>做法：<ul>
<li>检查源类中被源函数所使用的一切特性（包括字段、函数），考虑是否该被搬移</li>
<li>如果某个特性另被多个函数使用了，可以考虑将使用该特性的所有函数全都一并搬移。有时候，搬移一组函数比逐一搬移简单些</li>
<li>检查源类的子类、超类，看看是否有该函数的其他声明。如果出现其他声明，获取无法进行搬移，除非目标类也同样表现出多态性</li>
<li>如果目标函数使用了源类中的特性，需要决定如何从目标函数引用源对象。如果目标类中没有相应的引用机制，将把源对象的引用当作参数，传递给新建立的目标函数</li>
<li>如果源函数包含异常处理，需判断逻辑上应该由哪个类来处理这一异常。如果应该由源类来负责，就把异常处理留在原地</li>
<li>决定如何重源函数正确引用目标对象。<ul>
<li>可能会有一个现成的字段、函数帮助取得目标对象。如果没有，则轻松建立一个这样的函数</li>
<li>如果不行，在源类中新建一个字段来保存目标对象，可能是一个永久性的修改，也可以是暂时的。因为后继的其他重构可能将新建字段去掉</li>
</ul>
</li>
<li>修改源函数，使之成为一个纯委托函数</li>
<li>决定是否删除源函数，或将它当作一个委托函数保留下来。如果经常要在源对象中引用目标函数，将源函数作为委托函数保留下来会比较简单</li>
<li>每修改一个引用点，就编译测试一次，也可以通过一次“查找/替换”改掉所有引用点</li>
<li>如果源类有多个特性，会将源对象传递给目标函数。如果目标函数需要太多源类特性，就需进一步重构。通常，会分解目标函数，并将其中一部分回源类</li>
</ul>
</li>
</ul>
<h1 id="move-feild：搬移字段"><a href="#move-feild：搬移字段" class="headerlink" title="move feild：搬移字段"></a>move feild：搬移字段</h1><ul>
<li>某个字段被其所驻类之外的另一个类更多地用到</li>
<li>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段</li>
<li>动机：<ul>
<li>在类之间移动状态、行为，是重构过程中必不可少的措施</li>
<li>随着系统发展，会发现自己需要新的类，并需要将现有的工作责任拖到新的类中。在这个星期看似合理而正确的设计决策，到了下一个星期可能不再正确</li>
<li>如果发现，对于一个字段，再其所驻类之外的另一个类中有更多函数使用了它，就会考虑搬移这个字段。</li>
<li>“使用”：可能通过设置/取值函数间接进行的</li>
<li>也可能移动该字段的用户（某个函数），这取决于是否需要保持接口不受变化。如果这些函数看上去很适合呆在原地，就只搬移字段</li>
<li>extract class 使，也可能需要搬移字段。先搬移字段，再搬移函数</li>
</ul>
</li>
<li>做法：<ul>
<li>如果字段的访问级别使public，使用encapsulate field将其封装起来。</li>
<li>如果有可能移动哪些频繁访问该字段的函数；或如果有许多函数访问某个字段。先使用 self encapsulate field</li>
<li>在目标类中建立与源字段相同的字段，同时建立相应的设值/取值函数</li>
<li>决定如何在源对象中引用目标函数。<ul>
<li>首先，看是否有一个现成的字段、函数可以帮助得到目标对象。</li>
<li>如果没有，就看能否轻易建立这样一个函数。</li>
<li>如果不行，在源类中新建一个字段来存放目标对象，可能使一个永久性的修改，但也可以是暂时的。后续的重构可能会把这个新建字段除掉</li>
</ul>
</li>
<li>将所有对源字段的引用，替换为对某个目标函数的调用<ul>
<li>如果需要读取该变量，就把对源字段的引用替换为对目标取值函数的调用</li>
<li>如果需要对该变量赋值，就把对源字段的引用替换为对设值函数的调用</li>
<li>如果源字段不是private，就必须在源类的所有子类中查找源字段的引用点，并进行相应替换　</li>
<li>self encapsulate field使之可以小步前进。如果需要对类做许多处理，保持小步前进是有帮助的<ul>
<li>使用 self encapsulate field 使我得以更轻松使用move method将函数搬移到目标类中。如果待搬移函数引用了字段的访问函数，那些引用点是无需修改的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="extract-class：提炼类"><a href="#extract-class：提炼类" class="headerlink" title="extract class：提炼类"></a>extract class：提炼类</h1><ul>
<li>某个类做了应该由两个类做的事</li>
<li>建立一个新类，将相关的字段、函数从旧类搬移到新类</li>
<li>动机：<ul>
<li>一个类应该是一个清楚的抽象，处理一些明确的责任，在实际共迚，类会不断成长、扩展。加入一些功能、数据。-     - 　　给某个类添加一项责任时，会觉得不值得为这项责任分离出一个单独的类。随着责任不断增加，这个类会变得过分复杂。很快，类就会变成一团乱麻</li>
<li>类中含有大量函数、数据。导致类太大，不易理解。</li>
<li>需要考虑那些部分可以分离出去，并将其分离到一个单独的类中</li>
<li>如果某些数据、函数总是一起出现，魔偶写数据经常同时变化，甚至彼此相依，就应该将其分离出去</li>
<li>？：如果搬移了某些字段、函数，会发生什么？其他字段、函数是否因此变得无意义？开发后期，类的子类化。</li>
<li>如果发现子类化只影响类的部分特性；某些特性需要以一种方式来子类化，某些特征则需要以另一种方式子类话=》分解原来的类</li>
</ul>
</li>
<li>做法：<ul>
<li>决定如何分解类所负的责任</li>
<li>建立一个新类，用以表现从旧类中分离出来的责任。如果旧类剩下的责任与旧类名不符，为旧类更名</li>
<li>建立“从旧类访问新类”的连接关系。有可能需要一个双向连接，但在真正需要它之前，不要建立“从新类通往旧类”的连接</li>
<li>对搬移的每个字段，运用move field，每次搬移后，编译、测试。</li>
<li>move method将必要函数搬移到新类。先搬移较低层函数（“被其他函数调用”多余“调用其它函数”者），再搬移较高层函数。每次搬移后，编译、测试</li>
<li>检查，精简每个类的接口。如果建立的是双向连接，检查是否可将其改为单向连接</li>
<li>决定是否公开新类。如果需要公开，决定其为引用对象？不可变的值对象？<ul>
<li>如果选择公开新类，允许任何对象修改新类对象的任何部分。需要考虑公开带来的危险，尤其是set value。新类成为引用对象，应考虑使用change value to reference</li>
<li>如果不允许任何人不通过源类就修改新类。可将新类设为不可修改的，或为其提供一个不可修改的接口；或者复制一个新类对象，将复制得到的新对象传递给用户。可能会造成一定程度的迷惑，让人误以为可以修改新类对象值（同一个对象被传递给多个用户，可能再用户之间造成别名问题）</li>
</ul>
</li>
<li>extract class，改善并发程序的一种常用技术，可使你为提炼后的两个类分别加锁，如果不需要同时锁定连个对象，就不必这样做。<ul>
<li>有一定的危险性。如果需要确保两个对象被同时锁定，就面临事务问题，需要使用其他类型的共享锁。这是个复杂领域，比一般情况需要更繁重的机制。</li>
<li>事务很有实用性，但编写事务管理程序则超出了大多数程序员的职责范围</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="inline-class-将类内联化"><a href="#inline-class-将类内联化" class="headerlink" title="inline class 将类内联化"></a>inline class 将类内联化</h1><ul>
<li>某个类没有做太多事情</li>
<li>将这个类的所有特性搬移到另一个类中，然后移除源类</li>
<li>动机：<ul>
<li>与extract class相反。</li>
<li>如果一个类不再承担足够责任，不再有单独存在的理由（通常，此前的重构动作移走了这个类的责任）</li>
<li>挑选“萎缩类”的最频繁用户，以inline class 手法将“萎缩类”塞进另一个类中</li>
</ul>
</li>
<li>做法：<ul>
<li>再目标类声明源类的public协议，并将其中所有函数委托至源类。如果“以一个独立接口表示源类函数”更合适，就应该再内联之前，先试用extract interface</li>
<li>修改所有源类引用点，改而引用目标类。将源类声明为private，在斩断包之外的所有引用可能。同时修改源类的名称，可使编译器帮助捕捉到所有对于源类的隐藏引用点</li>
<li>编译，测试</li>
<li>move field、move method将源类的特性全部搬移到目标类</li>
</ul>
</li>
</ul>
<h1 id="hide-delegate：隐藏委托关系"><a href="#hide-delegate：隐藏委托关系" class="headerlink" title="hide delegate：隐藏委托关系"></a>hide delegate：隐藏委托关系</h1><ul>
<li>客户通过一个委托类来调用另一个对象</li>
<li>在服务类上建立客户所需的所有函数，用以隐藏委托关系。　</li>
<li>动机：<ul>
<li>“封装”，即使不是对象的最关键特征，也是最关键特征之一。<ul>
<li>意味着：每一个对象都应该尽可能少了解系统的其他部分。</li>
<li>一旦发生变化，需要了解这一变化的对象就会比较少，会使变化比较容易进行。</li>
</ul>
</li>
<li>字段虽然可以声明为public，但应该隐藏对象的字段</li>
<li>如果某个客户先通过服务对象的字段得另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系<ul>
<li>万一委托关系发生变化，客户也得相应变化。</li>
<li>可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖</li>
<li>即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及客户</li>
</ul>
</li>
<li>对于某些、全部客户，可能有必要先使用extract class。一旦对所有客户都隐藏了委托关系，就不再需要在服务对象的接口中公开被委托的对象</li>
</ul>
</li>
<li>做法：<ul>
<li>对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数</li>
<li>调整客户，令其只调用服务对象提供的函数<ul>
<li>如果使用者、委托服务提供者不在同一包，考虑修改委托函数的访问权限，让客户得以在包之外调用它</li>
</ul>
</li>
<li>如果将来不再有任何客户需要用图7-1的受托类，便可移除服务对象中的相关访问函数</li>
</ul>
</li>
</ul>
<h1 id="remove-middle-man-：移除中间人"><a href="#remove-middle-man-：移除中间人" class="headerlink" title="remove middle man ：移除中间人"></a>remove middle man ：移除中间人</h1><ul>
<li>某个类做了过多的简单委托动作。</li>
<li>让客户直接调用受托类</li>
<li>动机：<ul>
<li>封装的代价：每当客户要使用受委托类的新特性时，必须再服务端添加一个简单委托函数。<ul>
<li>随着受托类的特性（功能）越来越多，这一过程让人痛苦不已</li>
<li>服务类完全变成了一个“中间人”。此时应该让客户直接调用受托类</li>
</ul>
</li>
<li>很难说什么程度的隐藏才是合适的。<ul>
<li>hide delegate、remove middle man：可根据系统运行过程中不断进行调整。随着系统的变化，“合适的隐藏程度”这个尺度也在相应改变</li>
<li>重构的意义在于：永远不必说对不起：只要把出问题的地方修补好就行了。</li>
</ul>
</li>
<li>也可能保留一部分委托关系。<ul>
<li>可能希望对某些客户隐藏委托关系，并让另一些用户直接使用受托对鞋。</li>
<li>基于这些原因，一些简单的委托关系（及对应的委托函数），也可能被留在原地</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>建立一个函数，用以获得受委托对象</li>
<li>对每个受委托函数，在服务类中删除该函数，并让需要调用该函数的客户转为调用受委托对象。 </li>
</ul>
</li>
</ul>
<h1 id="introduce-foreign-method：引入外加函数"><a href="#introduce-foreign-method：引入外加函数" class="headerlink" title="introduce foreign method：引入外加函数"></a>introduce foreign method：引入外加函数</h1><ul>
<li>需要为提供服务的类增加一个函数，但无法修改这个类</li>
<li>在客户类中建立一个函数，并以第一参数的形式传入一个服务类实例</li>
<li>动机：<ul>
<li>正在使用一个类，为你提供了需要的所有服务。而后又需要一项新服务，这个类却无法供应。</li>
<li>可自行添加一个新函数；如果无法添加，则在客户端编码，补足你要的那个函数</li>
<li>如果客户类的功能只使用一次这项功能一次，那么额外编码工作没什么大不了，甚至可能根本不需要原本提供服务的那个类</li>
<li>然而，如果需要多次使用这个函数，就得不断重复这些代码。重复代码是软件万恶之源。重复的代码应该被抽出来放进同一个函数中。</li>
<li>在本项重构时，如果你以外加函数实现一项功能，那就是一个明确的信号：这个函数原本应该在提供服务的类中实现</li>
<li>如果发现自己为一个服务类建立了大量的外加函数，或者发现许多类都需要同样的外加函数，就不应该再使用本项重构，而应该使用Introduce local extension</li>
<li>外加函数终归时权宜之计。如果又可能，仍然应该将这些函数搬移到它们的理想家园。</li>
<li>　　如果由于代码所有权的原因，使你无法做这样的搬移，就把外加函数交给服务类的拥有者，请他帮你再服务类中实现这个函数</li>
</ul>
</li>
<li>做法：<ul>
<li>在客户类中建立一个函数，用来提供你需要的功能。<ul>
<li>这个函数不应该调用客户类的任何特性。如果需要一个值，把该值当作参数传给它。便于将来迁移函数</li>
</ul>
</li>
<li>以服务类实例作为该函数的第一个参数</li>
<li>将函数注释为：“外加函数（foreign method），应在服务类实现”<ul>
<li>这样一来，如果将来有机会将外加函数搬移到服务类中，便可轻松找出这些外加函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="introduce-local-extension：引入本地扩展"><a href="#introduce-local-extension：引入本地扩展" class="headerlink" title="introduce local extension：引入本地扩展"></a>introduce local extension：引入本地扩展</h1><ul>
<li>需要为服务类提供一些额外函数，但无法修改这个类</li>
<li>建立一个新类，使他包含这些额外函数，让这个扩展成为源类的子类，或包装类</li>
<li>动机：<ul>
<li>类的作者无法预知未来，常常没能为你预先准备一些有用的函数。<ul>
<li>如果可以修改源码，最好的办法使直接加入自己需要的函数</li>
<li>无法修改源码，如果只需要一两个函数，可以使用introduce foreign method。</li>
<li>如果需要的额外函数超过两个，外加函数就很难控制它们了。需要将这些函数组织在一起，放到一个恰当的地方</li>
</ul>
</li>
<li>为了达到这个目的，两种标准对象技术：子类化subclassing、包装wrapping。统称为本地扩展。<ul>
<li>本地扩展：是一个独立的类，但也是被扩展类的子类型。提供源类的一切特性，同时额外添加新特性。</li>
<li>在任何使用源类的地方都可以使用本地扩展取而代之</li>
<li>本地扩展，使你得以坚持“函数、数据应该被统一封装”的原则。如果一直把本该放在扩展类中的代码零散地放置于其他类中，最终只会让其他类变得过分复杂，并使得其中的函数难以被复用</li>
</ul>
</li>
<li>在子类、包装类之间做选择，通常首选子类。工作量较少<ul>
<li>添加子类最大的障碍在于，必须在对象创建期实施。如果可以接管对象创建过程，当然没有问题；但如果想在对象创建之后再使用本地扩展就有问题了</li>
<li>子类化方案，必须产生一个子类对象。这种情况下，如果有其他对象引用了旧对象，就同时有两个对象保存了原数据。如果原数据是不可修改的，则不会有问题，可以放心复制；如果原数据允许被修改，问题就会出现：一个修改动作无法同时改变两个副本</li>
<li>使用包装类时，对本地扩展的修改会波及原对象，反之亦然。</li>
</ul>
</li>
<li>包装类有一个特殊问题：如何处理“接受原始类实例为参数”的函数。由于无法改变原始类，只能做到一个方向上的兼容：包装类上的函数可以接受包装类，或原始类；但原始类的函数只能接受原始类对象，不能接受包装类对象<ul>
<li>覆写的目的时为了向用户隐藏包装类的存在。这是一个好策略，因为包装类的用户的确不应该关心包装类的存在，的确应该可以同样的地对待包装类、原始类</li>
<li>但是，完全无法隐藏包装类的存在，因为某些系统所提供的函数（例如equals()）会出问题。</li>
<li>可以在包装类中覆写equals()，但这样做时危险的，尽管达到了我们的目的，但在系统的其他部分都认为equals()符合交换律：包装类实例equals(被包装类实例)，被包装类实例equals(包装类实例)。违反这一规则，容易使人遭受一大堆莫名其妙的错误</li>
<li>要避免这样的尴尬境地，唯一的办法就是修改被包装类。但如果可以修改，何必进行此项重构</li>
<li>在这种情况下，只能向用户公开“我进行了包装”这一事实。推荐使用一个新函数equal<strong>()来实现相等性检查。亦可重载equal</strong>()，一个接受被包装实例，一个接受包装实例。就不必检查未知对象的类型了</li>
<li>子类化方案中就没有这样的问题，只要不覆写原函数就行。如果覆写了原始类中的函数，那么寻找函数时，就会被搞得晕头转向。一般，不建议在扩展类中覆写原始类的函数，只会添加新函数</li>
</ul>
</li>
</ul>
</li>
<li>做法：<ul>
<li>建立一个扩展类，将它作为原始类的子类，或包装类</li>
<li>在扩展类中加入转型构造函数<ul>
<li>“转型构造函数”：“接受原对象作为参数”的构造函数。</li>
<li>如果采用子类化方案，转型构造函数应该调用适当的超类构造函数</li>
<li>如果采用包装类方案，转型构造函数应该将它得到的传入参数以实例变量的形式保存起来，用作接受委托的原对象</li>
</ul>
</li>
<li>在扩展类中加入新特性</li>
<li>根据需要，将原对象替换为扩展对象</li>
<li>将针对原始类定义的所有外加函数搬移到扩展类中</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>006-重构列表、重新组织函数.md</title>
    <url>/articles/20210102/b2e2e8ae.html</url>
    <content><![CDATA[<p>摘要：重构列表、重新组织函数</p>
<a id="more"></a>

<h1 id="重构列表"><a href="#重构列表" class="headerlink" title="重构列表"></a>重构列表</h1><h2 id="寻找引用点"><a href="#寻找引用点" class="headerlink" title="寻找引用点"></a>寻找引用点</h2><ul>
<li>盲目查找、替换，出错机会高。不同类中使用相同的函数名称；同一个类中使用名称相同、签名不同的函数。</li>
<li>直接删除旧的部分，让编译器帮你找出引用点。好处：编译器会找到所有引用点。</li>
<li>问题：<ul>
<li>被删除部分在继承体系张声明不止一次，编译器也会被迷惑（覆写多次的函数）。如果在一个继承体系中，先利用文本查找工具，检查是否由其他类声明了你正在处理的哪个函数</li>
<li>编译器可能太慢，使工作失去效率。先用文本查找工具，编译器可复查：先观察这一部分运用情况</li>
<li>编译器无法找到通过反射机制而得到的引用点。小心使用反射。使用文本查找工具，测试分量加重；通常建议只编译，不测试，因为编译器通常会捕捉到可能的错误；使用反射，所有的便利都没有了，必须为许多编译搭配测试。</li>
<li>某些Java开发环境，可使用菜单选项来查找引用点，而不是使用文本查找工具，因为这些开发环境并不以文本文件保存代码，而是使用一个内置数据库。</li>
</ul>
</li>
</ul>
<h2 id="重构成熟度"><a href="#重构成熟度" class="headerlink" title="重构成熟度"></a>重构成熟度</h2><ul>
<li>基本技巧：小步前进，频繁测试</li>
<li>让重构手法适应你自己的情况。“使用某个重构手法”不同于“将它浓缩成可重复的做法步骤”</li>
<li>前提：单进程软件。<ul>
<li>单进程：永远不必操心频繁调用某个函数，因为函数的调用成本很低</li>
<li>分布式：函数往返必须被减至最低限度。</li>
</ul>
</li>
<li>引入设计模式，设计模式为重构行为提供了目标，模式和重构之间有着一种与生俱来的关系。<ul>
<li>例如：replace type code with state/strategy、form template method </li>
<li>模式：希望到达的目标；重构：到达之路</li>
</ul>
</li>
<li>重构仅仅是一个起点，尽管不完美，但是有用</li>
<li>发展属于自己的重构手法，使用自己的创造力</li>
</ul>
<h1 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h1><h2 id="问题源于：long-method"><a href="#问题源于：long-method" class="headerlink" title="问题源于：long method"></a>问题源于：long method</h2><ul>
<li>包含太多信息，而信息又被函数错综复杂的逻辑掩盖，不易鉴别。</li>
<li>解决：</li>
<li>extract method：一段代码提取出来，放进一个单独函数中<ul>
<li>最大困难：处理局部遍历。临时变量则是其中一个主要的困难源头</li>
<li>解决：<ul>
<li>repalce temp with query：去掉所有可去掉的临时变量</li>
<li>split temporary variable：使临时变量变得比较容易替换</li>
<li>replace method with method object:临时变量太混乱，可分解哪怕最混乱的函数，代价则是引入一个新的类</li>
<li>remove assignments to parameters：在函数内赋值给参数</li>
</ul>
</li>
</ul>
</li>
<li>inline method：相反，将一个函数调用动作替换为该函数本体。</li>
<li>substitute algorithm：引入更清晰的算法</li>
</ul>
<h2 id="extract-method：提炼函数"><a href="#extract-method：提炼函数" class="headerlink" title="extract method：提炼函数"></a>extract method：提炼函数</h2><p>一段代码可以被组织在一起并独立出来</p>
<ul>
<li>针对：<ul>
<li>一个过长的函数</li>
<li>一段需要注释，才能让人理解用途的代码</li>
</ul>
</li>
<li>简短、命名良好的函数：<ul>
<li>函数粒度小，被复用机会大</li>
<li>高层函数读起来就像一系列注释</li>
<li>函数的细粒度，覆写也更容易。</li>
<li>只有能给小型函数很好地命名时，它们才能真正起作用=》需要在函数名称上下点功夫。</li>
</ul>
</li>
<li>函数的长度：关键在于函数名称、函数本体之间的语义距离。<ul>
<li>如果提炼可以强化代码的清晰度，那就去做。就算函数名称比提炼出来的代码还长，也无所谓。</li>
</ul>
</li>
<li>做法：<ul>
<li>创造一个新函数，根据函数的意图来命名：以“做什么”来命名，而不是以“怎样做”命名。</li>
<li>即使想要提炼的代码非常简单（一条消息，一个函数调用），只要新函数的名称能够以更好方式昭示代码意图，也应该提炼它。如果想不出一个更有意义的名称，就别动</li>
<li>将提炼出的代码从源函数复制到新建的目标函数中</li>
<li>仔细检查提炼出的代码，看是否引用了“作用域限于源函数”的变量，包括局部变量、源函数参数</li>
<li>检查被提炼的代码段，看看是否有任何局部变量的值被它改变。<ul>
<li>如果一个临时变量值被修改了，看是否可以将被提炼的代码段处理为一个查询，并将结果赋值给相关变量</li>
<li>如果很难这样做，或被修改的变量不止一个，就不能仅仅将这段代码原封不动地提炼出来。使用 split temporary variable,再尝试提炼；或使用 replace temp with query 将临时变量消灭掉</li>
</ul>
</li>
<li>将被提炼代码段中需要读取的局部变量，当作参数传给目标函数</li>
<li>处理完所有局部变量之后，进行编译</li>
<li>在源函数中，将被提炼代码段替换为对目标函数的调试<ul>
<li>如果将任何临时变量移到目标函数中，请检查它们原本的声明式是否在被提炼代码段的外围。如果是，则可以删除这些声明式了</li>
</ul>
</li>
<li>编译、测试</li>
</ul>
</li>
</ul>
<h2 id="inline-method：内联函数"><a href="#inline-method：内联函数" class="headerlink" title="inline method：内联函数"></a>inline method：内联函数</h2><h2 id="inline-temp：内联临时变量"><a href="#inline-temp：内联临时变量" class="headerlink" title="inline temp：内联临时变量"></a>inline temp：内联临时变量</h2><ul>
<li>有一个临时变量，只被一个简单表达式赋值一次，妨碍了其他重构手法。</li>
<li>解决：将所有对该变量的引用动作，替换为对它赋值的那个表达式自身</li>
<li>情境：<ul>
<li>多半作为replace temp with query的一部分使用，所以真正的动机出现在后者那儿</li>
<li>唯一单独使用inline temp，发现某个临时变量被赋予某个函数调用的返回值。一般这样的临时变量不会有任何危害，可以放心地把它留在那儿。如果这个临时变量妨碍了其他的重构手法，可以使用extract method内联化。</li>
</ul>
</li>
<li>做法：<ul>
<li>检查给临时变量赋值的语句，确保等号右边的表达式没有副作用</li>
<li>如果临时变量未被声明为final，就将它声明为final，然后编译。（可以检查该临时变量是否真的只被赋值一次）</li>
<li>找到该临时变量的所有引用点，将其替换为“为临时变量赋值”的表达式</li>
<li>每次修改后，编译并测试</li>
<li>修改完所有的引用点之后，删除该临时变量的声明、赋值语句</li>
<li>编译、测试</li>
</ul>
</li>
</ul>
<h2 id="replace-temp-with-query：以查询取代临时变量"><a href="#replace-temp-with-query：以查询取代临时变量" class="headerlink" title="replace temp with query：以查询取代临时变量"></a>replace temp with query：以查询取代临时变量</h2><ul>
<li>以一个临时变量保存某一表达式的运算结果</li>
<li>解决：将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用</li>
<li>动机：<ul>
<li>临时变量的问题：它们是暂时的，而且只能在所属函数内使用。</li>
<li>由于临时变量只在所属函数内可见，会驱使你写出更长的函数。</li>
<li>如果将临时变量替换为一个查询，那么同一个类中的所有函数都将获得这份信息。有助于为此类编写更为清晰的代码</li>
<li>replace temp with query 往往是运用extract method之前必不可少的一个步骤。局部变量会使代码难以被提炼，应尽可能将其替换为查询式</li>
<li>简单：临时变量只被赋值一次，或赋值给临时变量的表达式不受其他条件影响</li>
<li>复杂：需要先运用split temporary variable、separate query from modifier使情况变得简单一些，然后再替换临时变量。</li>
<li>如果想替换的临时变量是用来收集结果的，需要将某些程序逻辑复制到查询函数去</li>
</ul>
</li>
<li>做法：<ul>
<li>如果某个临时变量被赋值超过一次，使用split temporary variable将其分割成多个变量</li>
<li>确保提炼出的函数无副作用。即函数并不修改任何对象内容，如果有副作用，进行seperate query from modifler</li>
<li>性能：不要担心性能问题，9/10不会有任何影响。真有影响，可以再优化时期解决。代码组织良好，往往可以发现更有效的优化方案，如果没有进行重构，好的优化方案就可能与你失之交臂。如果性能实在太糟，将临时变量放回去也是很容易的</li>
</ul>
</li>
</ul>
<h2 id="introduce-explaining-variable：引入解释性变量"><a href="#introduce-explaining-variable：引入解释性变量" class="headerlink" title="introduce explaining variable：引入解释性变量"></a>introduce explaining variable：引入解释性变量</h2><ul>
<li>有一个复杂的表达式</li>
<li>将该表达式（或其中一部分）的结果放进一个临时变量，以此临时变量名称来解释表达式用途</li>
<li>动机：<ul>
<li>表达式非常复杂，难以阅读。临时变量可以帮助将表达式分解为较为容易管理的形式</li>
<li>条件逻辑中，特别有价值：将每个条件子句提炼出来，用良好命名的临时变量来解释对应条件子句的意义</li>
<li>较长的算法中，用临时变量来解释每一步运算的意义</li>
<li>不常用，尽量使用extract method来解释一段代码的意义。临时变量只有再所处的那个函数中才有意义，局限性较大，函数则可以在对象的整个声明周期都有用，且可被其他对象使用</li>
<li>当局部变量使用extract method难以进行时，使用introduce explaining variable</li>
</ul>
</li>
<li>做法：<ul>
<li>如果被替换的这一部分在代码中重复出现，可以每一次一个，逐一替换</li>
</ul>
</li>
</ul>
<h2 id="split-temporary-variable：分解临时变量"><a href="#split-temporary-variable：分解临时变量" class="headerlink" title="split temporary variable：分解临时变量"></a>split temporary variable：分解临时变量</h2><ul>
<li>某个临时变量被赋值超过一次，既不是循环变量，也不被用于收集计算结果。</li>
<li>解决：针对每次赋值，创造一个独立、应对的临时变量</li>
<li>动机：<ul>
<li>临时变量有各种不同用途，某些用途会很自然地导致临时变量被多次赋值。“循环变量”、“结果收集变量”</li>
<li>临时变量用于保存一段冗长代码的运算结果，以便稍后使用。这种临时变量应只被赋值一次。对超过一次，意味着在函数中承担了一个以上的责任。</li>
<li>如果临时变量承担了多个责任，应该被替换、分解为多个临时变量，每个变量只承担一个责任。否则会令代码阅读者糊涂</li>
</ul>
</li>
<li>做法：<ul>
<li>如果稍后的赋值语句【i=i+某表达式】。意味着是个“结果收集变量”=&gt;不要分解它。“结果收集变量”的作用通常是累加、字符串接合、写入流、向集合添加元素</li>
</ul>
</li>
</ul>
<h2 id="remove-assignments-to-parameters：移除对参数的赋值"><a href="#remove-assignments-to-parameters：移除对参数的赋值" class="headerlink" title="remove assignments to parameters：移除对参数的赋值"></a>remove assignments to parameters：移除对参数的赋值</h2><ul>
<li>代码对一个参数进行赋值。</li>
<li>以一个临时变量取代该参数的位置。</li>
<li>动机：<ul>
<li>对参数赋值，意味着改变参数，使其指向另一个对象的引用。</li>
<li>如果在“被传入对象”身上进行操作，则不是问题</li>
<li>使用“out 参数”的，可以不必遵循这条规则。但应尽力避免</li>
</ul>
</li>
<li>缺点：<ul>
<li>降低了代码的清晰度，混用了按值传递、按引用传递，这两种参数传递方式。</li>
<li>按值传递，对参数的任何修改，不会对调用端造成任何影响；按引用传递，会产生影响</li>
<li>在函数本体内，只以参数表示：被传递进来的东西，代码会清晰很多。此用法在所有语言中都表现出相同语义</li>
</ul>
</li>
<li>做法：<ul>
<li>不要对参数赋值：可使用remove assignments to parameters来避免</li>
<li>如果代码是“按引用传递”的，请在调用端检查调用后是否还使用了这个参数</li>
<li>要检查有多少个按引用传递的参数被赋值后又被使用</li>
<li>请尽量以return方式返回一个值。如果需返回的值不止一个，看是否可把需返回的大堆数据变成一个单一对象，或干脆为每个返回值设计对应的一个独立函数</li>
<li>可为参数加上final关键词，使之遵循“不对参数赋值”，这一惯例。</li>
<li>不建议使用，对于提高函数清晰度没有太大的帮助。</li>
<li>通常用在较长的函数中，帮助检查参数是否被修改</li>
</ul>
</li>
</ul>
<h2 id="replace-method-with-method-object：以函数对象取代函数"><a href="#replace-method-with-method-object：以函数对象取代函数" class="headerlink" title="replace method with method object：以函数对象取代函数"></a>replace method with method object：以函数对象取代函数</h2><ul>
<li>有一个大型函数，其中对局部变量的使用，使人无法采用extract method</li>
<li>做法：<ul>
<li>将这个函数放进一个单独对象中，这样局部变量就成了对象内的字段。然后可以在同一个对象中，将这个大型函数分解为多个小型函数</li>
</ul>
</li>
<li>动机：<ul>
<li>小型函数优美动人。只要将相对对立的代码从大型函数中提炼出来，可以大大提高代码的可读性</li>
<li>局部变量的存在会增加函数的分解难度。如果一个函数中局部变量泛滥成灾，想分解这个函数是非常困难的</li>
<li>replace temp with query 可以帮助减轻这一负担。但有时候会发现根本无法拆解一个需要拆解的函数</li>
<li>replace method with method object 将所有局部变量都变成函数对象的字段=》对这个新对象使用extract method 创造出新函数，从而将原来的大型函数拆解变短</li>
</ul>
</li>
<li>做法：<ul>
<li>建立一个新类，根据待处理函数的用途为此类命名</li>
<li>在新类中建立一个final字段，用以保存原先大型函数所在的对象。即“源对象”。针对源函数的每个临时变量，每个参数在新类中建立一个对应的字段保存</li>
<li>在新类中建立一个构造函数，接受源对象、源函数的所有参数作为参数</li>
<li>在新类中建立一个compute()函数</li>
<li>将原函数中的代码赋值到compute()函数，对需要调用源对象的任何函数，通过源对象字段调用</li>
<li>编译</li>
<li>将旧函数的函数本体替换为这样一条语句“创建上述新类的一个新对象，而后调用其中的compute()函数”</li>
<li>所有的局部变量都变成了字段，可以任意分解这个大型函数，不必传递任何参数</li>
</ul>
</li>
</ul>
<h2 id="substitute-algorithm：替换算法"><a href="#substitute-algorithm：替换算法" class="headerlink" title="substitute algorithm：替换算法"></a>substitute algorithm：替换算法</h2><ul>
<li>把某个算法替换为另一个更清晰的算法</li>
<li>将函数本体替换为另一个算法</li>
<li>动机：<ul>
<li>解决问题有好几种方法，某些方法会比另一些简单，算法也是如此</li>
<li>如果做一件事儿，可以有更清晰的方式，应该以比较清晰的方式取代复杂的方式　　</li>
<li>随着对问题有更多理解，往往发现在原先的做法之外，有更简单的解决方案，就需要改变原先的算法</li>
<li>如果开始使用程序库，而其中提供的某些功能、特性与你自己的代码重复，则需要改变原先的算法</li>
<li>“重构”可以将一些复杂的东西分解为较简单的小块，但有时必须壮士断腕，删掉整个算法，代之以较为简单的算法</li>
<li>有时想要修改原先的算法，让其做一件与原先略有差异的事。可以先把原先的算法替换为一个较易修改的算法，后续的修改会轻松许多</li>
<li>使用此项重构手法之前，先确定自己已经尽可能分解了原先函数。替换一个巨大、复杂的算法是非常困难的，只有先将它分解为较简单的小型函数，然后才可很有把握的进行算法替换工作</li>
</ul>
</li>
<li>做法：<ul>
<li>对于每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同。可以帮助看到哪个测试用例出现麻烦，以及出现了怎样的麻烦</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>005-构筑测试体系</title>
    <url>/articles/20210102/3c568e55.html</url>
    <content><![CDATA[<p>摘要：编写优良的测试程序，可以极大提高编程速度，即使不进行重构也一样。<br>请构筑一个良好的bug检测器，并经常运行它，对任何开发工作都大有裨益，这是重构的前提。</p>
<a id="more"></a>

<h1 id="自测试代码的价值"><a href="#自测试代码的价值" class="headerlink" title="自测试代码的价值"></a>自测试代码的价值</h1><ul>
<li>类应该包含自己的测试代码。每个类都应该有一个测试函数，用来测试自己这个类</li>
<li>确保所有测试都完全自动化，让它们检查自己的测试结果：将所期望的输出放进测试代码中，然后做出一个比较，可避免人工检测</li>
<li>可以在每次编译之后都进行测试，可以大大提高生产性能</li>
<li>构筑的类能够自我测试&amp;&amp;可频繁运行测试</li>
<li>编写测试代码的时机：<ul>
<li>最有用：在开始编程之前，当需要添加特性的时候，先写相应测试代码<ul>
<li>编写测试代码，就是回答此功能需要做些什么</li>
<li>使你把注意力集中于接口而非实现</li>
<li>为工作安上一个明确的结束标志，一旦测试代码正常运行，工作就结束了</li>
</ul>
</li>
</ul>
</li>
<li>极限编程：频繁测试是其重要一环。极限编程者都是十分专注的测试者。它们希望尽可能快速开发软件，也知道测试可让他们尽可能快速地前进</li>
<li>重构：必须编写测试代码。</li>
<li>方式：<ul>
<li>testing main：惯用手法。每个类都应该有一个用于测试的main()。这是一个合理的习惯，但可能不好操控。问题：很难轻松运行多个测试</li>
<li>建立一个独立类用于测试，并在一个框架中运行它，使测试工作更轻松</li>
</ul>
</li>
</ul>
<h1 id="junit测试框架"><a href="#junit测试框架" class="headerlink" title="junit测试框架"></a>junit测试框架</h1><ul>
<li>框架简单，却可以让你进行测试所需的所有事情</li>
<li>assert():扮演自动测试角色</li>
<li>建议：<ul>
<li>频繁运行测试。每次编译，请将测试也考虑进去，每天至少执行每个测试一次</li>
<li>重构过程中，可以只运行少数几项测试，主要用来检查当下正在开发、整理的代码</li>
</ul>
</li>
<li>测试机制可以运行，的确测试了它该测试的东西（断言的合理使用）</li>
<li>功能：捕捉失败&amp;&amp;捕捉错误异常。出现形式不同，排除过程也不同</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul>
<li>目的：提高程序员的生产率</li>
<li>高度局部化的东西，每个测试类都隶属于单一包</li>
<li>能够测试其他包的接口。除此以外，将假设其他包一切正常</li>
<li>重构时，更多地依赖单元测试</li>
</ul>
<h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><ul>
<li>保证软件能正常运作。</li>
<li>从客户角度保证质量，并不关心程序员的生产力。</li>
<li>应该由一个喜欢寻找bug的独立团队开发，且应使用重量级工具、技术来帮助自己开发良好的功能测试</li>
<li>一般，尽可能将整个系统当作一个黑箱。只观察特定输入导致的数据变化</li>
<li>功能测试，往往以其他工具辅助进行</li>
<li>一旦发现错误：<ul>
<li>修改代码，排除错误</li>
<li>添加一个单元测试，暴露bug</li>
</ul>
</li>
<li>每当收到bug报告，都应先编写一个单元测试，使bug浮现出来。如果出现其他相关失败，编写更多的测试。用单元测试来盯住bug，并确保单元测试不会由漏网之鱼</li>
</ul>
<h1 id="添加更多测试"><a href="#添加更多测试" class="headerlink" title="添加更多测试"></a>添加更多测试</h1><ul>
<li>观察类该做的所有事情，针对任何一项功能的任何一种可能失败的情况，进行测试。不仅仅是测试所有public函数</li>
<li>测试是一种风险驱动的行为。测试的目的是希望找出现在、未来可能出现的错误。=》不会去测试那些仅仅读、写一个字段的访问函数，太简单，不太可能出错</li>
<li>注意：撰写过多测试，结果往往测试量反而不够。</li>
<li>哪怕只做一点点测试，你也可从中受益</li>
<li>测试要诀：测试你最担心出错的部分，才能从测试工作中得到最大利益。<ul>
<li>编写未臻完善的测试并运行，好过对完美测试的无尽等待</li>
</ul>
</li>
<li>测试技巧：<ul>
<li>寻找边界条件<ul>
<li>考虑可能出错的边界条件，将测试火力集中在那儿</li>
<li>包括寻找特殊的、可能导致测试失败的情况。文件相关的：第一个字符、最后一个字符、空文件……</li>
</ul>
</li>
<li>测试扮演“程序公敌”的角色。积极思考如何破坏代码。这种思考可以提高生产力。</li>
<li>检查预期的错误是否如期出现。例如，关闭文件流后，再次读取。<ul>
<li>当事情被认为应该出错时，别忘记检查是否抛出了预期的异常。</li>
</ul>
</li>
<li>测试类愈来愈多，可以生成另外一个类，专门包含由其他测试类所组成的测试套件，以便拥有一个主控的“测试类</li>
</ul>
</li>
<li>任何测试都不能证明一个程序没有bug。但一旦重构，可以更好地理解整个程序，从而找出更多bug<ul>
<li>不要因为测试无法不着所有bug就不写测试，测试的确可以捕捉大多数bug</li>
</ul>
</li>
<li>测试可以提高编程速度。其目的都是保证你能够测试所有情况的一切组合</li>
<li>应该把测试集中在可能出错的地方。观察代码，看哪儿复杂？观察函数，看哪儿可能出错？<ul>
<li>当测试数量到达一定程度之后，继续增加测试带来的效益会曾宪递减事态，而非持续递增；如果试图编写太多测试，可能会因工作量太大而气馁，最后什么也写不成；</li>
</ul>
</li>
</ul>
<h1 id="面向对象的测试"><a href="#面向对象的测试" class="headerlink" title="面向对象的测试"></a>面向对象的测试</h1><ul>
<li>继承、多态会让测试变得比较困难。=》将有很多组合需要测试</li>
<li>不总时测试所有可能组合。尽量测试每个类，可以大大减少各种组合所造成的风险。</li>
<li>“花合理的时间抓出大多数bug”，好过“穷尽一生抓出所有bug”　　</li>
</ul>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><ul>
<li>与产品代码之间的区别：可以放心复制、编辑测试代码</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>004-代码的坏味道-不健康代码</title>
    <url>/articles/20210102/c4155470.html</url>
    <content><![CDATA[<p>摘要：何为不健康的代码</p>
<a id="more"></a>

<h1 id="DuplicatedCode（重复代码）"><a href="#DuplicatedCode（重复代码）" class="headerlink" title="DuplicatedCode（重复代码）"></a>DuplicatedCode（重复代码）</h1><ul>
<li>一个以上地点看到相同的程序结构：提炼新函数</li>
<li>同一个类的两个函数含有相同的表达式：：提炼新函数</li>
<li>两个互为兄弟的子类内含有相同表达式：分别提炼代码，推入超类。不完全相同的，将相似部分和差异部分分割</li>
<li>两个毫不相关的类：考虑方法提取、继承</li>
</ul>
<h1 id="LongMethod（过长函数）"><a href="#LongMethod（过长函数）" class="headerlink" title="LongMethod（过长函数）"></a>LongMethod（过长函数）</h1><ul>
<li>活的好，活的长</li>
<li>程序愈长愈难以理解</li>
<li>“间接层”所能带来的全部利益：解释能力、共享能力、选择能力，都是由小型函数支持的</li>
<li>让小函数容易理解的真正关键在于一个好名字</li>
<li>更积极地分解函数</li>
<li>原则：<ul>
<li>当需要以注释来说明点儿什么的时候，将需要说明的东西写进一个独立函数中，并以用途（非实现手法）来命名</li>
<li>可以对一组甚至一行代码做这件事儿，哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，也该毫不犹豫地这么做</li>
<li>关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离</li>
<li>99%的场合里，要把函数变小，只需使用方法提取：找到函数中适合集中在一起的部分，将它们提炼出来，形成一个新的函数</li>
<li>如果函数内有大量的参数、临时变量，会对函数提炼形成阻碍。</li>
<li>避免将许多参数、临时变量当作参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升</li>
<li>运用replace temp with query来消除这些临时元素</li>
<li>introduce parameter object和preserve whole object,则可将过长的参数变得简洁</li>
<li>如果还是有太多临时变量、参数，则使用杀手锏：replace method with method object</li>
<li>如何确定该提炼哪一段代码？<ul>
<li>寻找注释：<ul>
<li>可以指出代码用途、实现手法之间的语义距离。</li>
<li>注释是在提醒你，可将这段代码替换成一个函数，且可以在注释的基础上为这个函数命名</li>
<li>就算只有一行代码，如果需要以注释来说明，也值得将其提炼到独立函数去</li>
</ul>
</li>
<li>条件表达式、循环：<ul>
<li>使用decompose conditional处理条件表达式</li>
<li>循环，将循环和其内的代码提炼到一个独立函数中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="large-class-过大的类"><a href="#large-class-过大的类" class="headerlink" title="large class 过大的类"></a>large class 过大的类</h1><ul>
<li>缺点：拥有太多实例变量、拥有太多代码</li>
<li>解决：<ul>
<li>extract class：将几个变量一起提炼至新类内。提炼时，应该选择类内彼此相关的变量。通常，如果类内的数个变量有着相同的前缀、字尾，一位着有机会把它们提炼到某个组件内。</li>
<li>extract subclass：同理，适合作为一个子类。</li>
<li>提炼方法：代码重复、混乱</li>
<li>extract interface：确定客户端如何使用它们，为每一种方式提炼出一个接口</li>
<li>独立领域对象：如果是个GUI类，可能需要把数据、行为移到一个独立的领域对象去</li>
<li>duplicate observe data：两边各保留一些重复数据，并保持两边同步。</li>
</ul>
</li>
</ul>
<h1 id="long-parameter-list-过长参数列"><a href="#long-parameter-list-过长参数列" class="headerlink" title="long parameter list 过长参数列"></a>long parameter list 过长参数列</h1><ul>
<li>把函数所需的所有东西，都以参数传递进去。除此之外只能选择全局数据，而全局数据是邪恶的东西</li>
<li>对象技术改变了这一情况：如果手上没有所需的东西，总可以叫另一个对象给你</li>
<li>有了对象，只需要给它足够的、让函数能从中获得自己所需的东西就行了。</li>
<li>函数需要的东西多半可以在函数的宿主类中找到。</li>
<li>面向对象中的函数，参数列通常比在传统程序中短很多</li>
<li>缺点：<ul>
<li>难以理解，太多参数会造成前后不一致，不易使用；</li>
<li>一旦需要更多数据，不得不修改它。如果将对象传递给函数，大多数修改都没有必要。</li>
</ul>
</li>
<li>解决：<ul>
<li>replace parameter with method：如果向已有对象发出一条请求就可以取代一个参数。已有对象：可能是类内的一个字段，也可能是另一个参数</li>
<li>preserve whole object：将来自同一对象的一堆数据收集起来，并以改对象替换它们</li>
<li>introduce parameter object：如果某些数据缺乏合理的对象归属，为它们制造一个“参数对象”</li>
<li>例外：不希望造成”被调用对象“与”较大对象“间的某种依赖关系，这时将数据从对象中拆解出来，单独作为参数也很合理。但需注意其所引发的代价。如果参数列太长、变化太频繁，就需要重新考虑自己的依赖结构了</li>
</ul>
</li>
</ul>
<h1 id="divergent-change-发散式变化"><a href="#divergent-change-发散式变化" class="headerlink" title="divergent change 发散式变化"></a>divergent change 发散式变化</h1><ul>
<li>易修改，相关性尽量减少</li>
<li>一个类受多种变化的影响</li>
<li>解决：<ul>
<li>divergent change：某个类因为不同的原因在不同的方向上发生变化。</li>
<li>extract class：针对某一外界变化的所有相应修改，都只应发生在单一类中，而这个新类内的所有内容都应反应此变化。应该找出某特定原因而造成的所有变化</li>
</ul>
</li>
<li>目的：使“外界变化”与“需要修改的类”趋于一一对应</li>
</ul>
<h1 id="shotgun-surgery-散弹式修改"><a href="#shotgun-surgery-散弹式修改" class="headerlink" title="shotgun surgery 散弹式修改"></a>shotgun surgery 散弹式修改</h1><ul>
<li>如果每遇到某种变化，都必须在许多不同的类内做出许多小的修改</li>
<li>需要修改的代码散步四处，不但很难找到它们，也很容易忘记某个重要的修改。</li>
<li>一种变化引发多个类相应修改</li>
<li>解决：<ul>
<li>move method、move field：将所有需要修改的代码放进同一个类。</li>
<li>inline class：把一系列相关行为放进同一个类，可能会造成少量divergent change，但可以轻易处理</li>
</ul>
</li>
<li>目的：使“外界变化”与“需要修改的类”趋于一一对应</li>
</ul>
<h1 id="feature-envy-依恋情节"><a href="#feature-envy-依恋情节" class="headerlink" title="feature envy 依恋情节"></a>feature envy 依恋情节</h1><ul>
<li>将数据、对数据的操作行为，包装在一起</li>
<li>解释：函数对某个类的兴趣搞过对自己所处类的兴趣，数据依恋</li>
<li>解决：<ul>
<li>move method：将函数移到应该去的地方</li>
<li>extract method + move method：函数中有一部分受依恋之苦</li>
<li>一个函数往往会用到几个类的功能，究竟该被置于何处？判断哪个类拥有最多被此函数使用的数据。可先用extract method将函数分解为数个较小函数，并分别置于不同地点</li>
</ul>
</li>
<li>根本原则：<ul>
<li>将总是一起变化的东西放在一起。</li>
<li>数据和引用这些数据的行为总是一起变化的，也有例外</li>
<li>如果例外出现，就搬移那些行为，保持变化只在一地发生</li>
</ul>
</li>
</ul>
<h1 id="data-clumps-数据泥团"><a href="#data-clumps-数据泥团" class="headerlink" title="data clumps 数据泥团"></a>data clumps 数据泥团</h1><ul>
<li>很多地方看到相同的三四项数据：两个类中相同的字段；许多函数签名中相同的参数</li>
<li>绑定在一起出现的数据，应该拥有数据它们自己的对象</li>
<li>解决：<ul>
<li>extract class：将一起出现的数据，提炼到一个独立对象中</li>
<li>introduce parameter object、preserve whole object：将注意力转移到函数签名上。将很多参数列缩短，简化函数调用</li>
<li>不必在意Data clumps上只用上新对象的一部分字段，只要以新对象取代两个、更多字段，就值回票价。</li>
<li>判断依据：删掉众多数据中的一项，其他数据没有因而失去意义。如果它们不再有意义，则是明确信号，应该为它们产生一个新对象。</li>
</ul>
</li>
<li>好处：<ul>
<li>减少字段、参数个数</li>
<li>一旦拥有新对象，就可以着手找寻feature envy，帮你指出能够移至新类中的种种程序行为</li>
</ul>
</li>
</ul>
<h1 id="primitive-obsession-基本类型偏执"><a href="#primitive-obsession-基本类型偏执" class="headerlink" title="primitive obsession 基本类型偏执"></a>primitive obsession 基本类型偏执</h1><ul>
<li>结构类型数据：将数据组织成有意义的形式</li>
<li>基本类型数据：构成结构类型的积木块</li>
<li>结构总会带来额外的开销，可能代表着数据库中的表，如果只为做一两件事而创建结构类型也可能显得麻烦。</li>
<li>对象的最大价值：模糊了横亘于基本数据、体积较大的类之间的界限。可以轻松编写出与语言基本类型无异的小型类</li>
<li>新手通常不愿意在小任务上运用小对象</li>
<li>解决：<ul>
<li>replace data value with object：将原本单独存在的数据值替换为对象，从而走出传统的窟窿，进入炙手可热的对象世界<ul>
<li>例如：结合数值和币种的money 类；由起始值、结束值组成的range类；电话号码或邮政编码……特殊字符串</li>
</ul>
</li>
<li>replace type code with class、replace type code with state/strategy：有与类型码相关的条件表达式</li>
<li>extract class：有一组总是被放在一起的字段</li>
<li>intruduce parameter object:参数列看到基本型数据</li>
<li>replace array  with object：从数组中挑选数据</li>
</ul>
</li>
</ul>
<h1 id="switch-statements-switch代码块"><a href="#switch-statements-switch代码块" class="headerlink" title="switch statements switch代码块"></a>switch statements switch代码块</h1><ul>
<li>少用switch、case语句。本质上都是在重复</li>
<li>可用多态来优雅解决</li>
<li>switch语句长根据类型码进行选择，要的是“与该类型码相关的函数、类”</li>
<li>解决：<ul>
<li>多态</li>
</ul>
</li>
</ul>
<h1 id="parallel-inheritance-hierarchies-平行继承体系"><a href="#parallel-inheritance-hierarchies-平行继承体系" class="headerlink" title="parallel inheritance hierarchies 平行继承体系"></a>parallel inheritance hierarchies 平行继承体系</h1><ul>
<li>特殊的shotgun surgery</li>
<li>每当为某个类增加一个子类，必须为另一个类相应增加一个子类</li>
<li>特征：某个继承体系的类名称前缀与另一个继承体系的类名称前缀完全相同</li>
<li>解决：<ul>
<li>让一个继承体系的实例引用另一个继承体系的实例&amp;&amp;move method、move field。将引用端的继承体系消弭于无形</li>
</ul>
</li>
</ul>
<h1 id="lazy-class-冗赘类"><a href="#lazy-class-冗赘类" class="headerlink" title="lazy class 冗赘类"></a>lazy class 冗赘类</h1><ul>
<li>所创建的每一个类都需要有人去理解它，维护它，这些工作都是要花钱的</li>
<li>如果一个类的所得不值其身价，就应该消失</li>
<li>场景：<ul>
<li>某个类原本对得起自己的身价，但重构使其缩水，不再承担那么多的责任</li>
<li>开发者事前规划了某些变化，并添加一个类来应付这些变化，但变化实际没有发生</li>
</ul>
</li>
<li>解决：<ul>
<li>collapse hierarchy：如果某些子类没有足够的工作</li>
<li>inline class：几乎没用的组件</li>
</ul>
</li>
</ul>
<h1 id="speculative-generality-夸夸其他未来性"><a href="#speculative-generality-夸夸其他未来性" class="headerlink" title="speculative generality 夸夸其他未来性"></a>speculative generality 夸夸其他未来性</h1><ul>
<li>“我想总有一天需要做这事儿”。企图以各式各样的钩子、特殊情况来处理一些非必要的事情。</li>
<li>造成系统更难理解、维护</li>
<li>如果所有装置会被用到，就值得这么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧</li>
<li>解决：<ul>
<li>collapse hierarchy：某个抽象类没有太大作用</li>
<li>inline class：除去不必要的委托</li>
<li>remove parameter：函数的某些参数未被用上</li>
<li>rename method：函数名称带有多余的抽象意味</li>
<li>测试用例：如果函数、类的唯一用户是测试用例，则为speculative generality。如果发现这样的函数、类，请把它们连同测试用例一并删除。但如果它们的用途是帮助测试用例检测正当功能，必定刀下留人。</li>
</ul>
</li>
</ul>
<h1 id="temporary-field-令人迷惑的暂时字段"><a href="#temporary-field-令人迷惑的暂时字段" class="headerlink" title="temporary field 令人迷惑的暂时字段"></a>temporary field 令人迷惑的暂时字段</h1><ul>
<li>某个实例变量仅为某种特定情况而设。</li>
<li>这样的代码让人不易理解。通常认为对象在所有时候都需要它的所有变量</li>
<li>在变量未被使用的情况下，猜测当初的设置目的，会让人发疯的</li>
<li>解决：<ul>
<li>extract class：把所有和这个变量相关的代码，都放进这个新家<ul>
<li>如果类中有一个复杂算法，需要好几个变量，往往导致temporary field的出现。</li>
<li>由于实现者不希望传递一长串参数，所以将这些参数都放进字段中。</li>
<li>但这些字段只有使用改算法时才有效，其他情况只会让人迷惑</li>
<li>extract class：将这些变量和其相关函数提炼到一个独立类中，提炼后的新对象将是一个函数对象</li>
</ul>
</li>
<li>intruduce null objec：变量不合法的情况下，创建一个null对象，避免写出条件式代码</li>
</ul>
</li>
</ul>
<h1 id="message-chains-过度耦合的消息链"><a href="#message-chains-过度耦合的消息链" class="headerlink" title="message chains 过度耦合的消息链"></a>message chains 过度耦合的消息链</h1><ul>
<li>消息链：对象传递性请求</li>
<li>特征：代码中可能是一长串的getthis{}或一长串的临时变量</li>
<li>意味着客户代码将于查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应的修改</li>
<li>解决：<ul>
<li>hide delegate：在消息链的不同位置进行这种重构手法。<ul>
<li>理论上，可以重构消息链上的任何一个对象，但这么做往往会把一系列对象intermediate object都变成middle man</li>
<li>通常，更好的选择是，先观察消息链最终得到的对象是用来干什么的，看看能否使用extract method把使用该对象的代码提炼到一个独立函数中，再运用move method将这个函数推入消息链</li>
<li>如果这条链上的某个对象有多位用户打算添加此消息链的一部分，就加一个函数来做这件事</li>
</ul>
</li>
<li>注意：不是任何函数链都是坏味道</li>
</ul>
</li>
</ul>
<h1 id="middle-man-中间人"><a href="#middle-man-中间人" class="headerlink" title="middle man 中间人"></a>middle man 中间人</h1><ul>
<li>过度运用委托：某个类有一半的函数都委托给其他类</li>
<li>解决：<ul>
<li>remove middle man：直接和真正负责的对象打交道</li>
<li>inline method：如果这样“不干实事”的函数只有少数几个，将其放进调用端。</li>
<li>replace delegation with inheritance：如果middle man 还有其他行为，将其变成实责对象。即可扩展原对象的行为，又不必负担那么多的委托动作</li>
</ul>
</li>
</ul>
<h1 id="inappropriate-intimacy-过度亲密"><a href="#inappropriate-intimacy-过度亲密" class="headerlink" title="inappropriate intimacy 过度亲密"></a>inappropriate intimacy 过度亲密</h1><ul>
<li>两个类过于亲密，花费太多时间去探究彼此的private成分。</li>
<li>对于类，希望尽量保持独立</li>
<li>继承往往造成过度亲密：子类对超类的了解总是超过超类的主观愿望</li>
<li>解决：<ul>
<li>move method、move field：划清界限，减少亲密度</li>
<li>change bidirectional association to unidirectional：让其中一个类脱离另一个类</li>
<li>extract class：将两者共同点提炼到一个安全地点，并使用新类</li>
<li>hide delegate：让另一个类来传递关系</li>
<li>replace inheritance with delegation：继承造成的过度亲密，让子类独自生活，离开继承体系</li>
</ul>
</li>
</ul>
<h1 id="alternative-classes-with-different-interfaces-异曲同工的类"><a href="#alternative-classes-with-different-interfaces-异曲同工的类" class="headerlink" title="alternative classes with different interfaces 异曲同工的类"></a>alternative classes with different interfaces 异曲同工的类</h1><ul>
<li>解决：<ul>
<li>rename method：两个函数做着同一件事，有着不同的签名。根据用途为其重新命名</li>
<li>remove method：将某些行为移入类，直到两者的函数功能不同为止</li>
<li>extract superclass：防止重复而冗余的移入代码</li>
</ul>
</li>
</ul>
<h1 id="incomplete-library-class-不完美的类库"><a href="#incomplete-library-class-不完美的类库" class="headerlink" title="incomplete library class 不完美的类库"></a>incomplete library class 不完美的类库</h1><ul>
<li>库作者没有未卜先知的能力&amp;&amp;需求不明确，导致库往往构造的不够好，往往不可能让我们修改其中的类来完成我们希望完成的工作。</li>
<li>解决：<ul>
<li>introduce foreign method：如果只想修改库类的一两个函数</li>
<li>intruduce local extension：想要添加一大堆额外的行为</li>
</ul>
</li>
</ul>
<h1 id="data-class-纯粹的数据类"><a href="#data-class-纯粹的数据类" class="headerlink" title="data class 纯粹的数据类"></a>data class 纯粹的数据类</h1><ul>
<li>拥有一些字段，以及用于访问（读写）一些字段的函数。除此之外，一无是处</li>
<li>这样的类，只是一种不会说话的数据容器，几乎一定被其他类过分细碎地操控着</li>
<li>data class就像一个小孩子，起点很好，但若要让它们像成熟的对象那样参与整个系统的工作，它们就必须承担一定责任</li>
<li>解决：<ul>
<li>encapsulate field：类中早期拥有public字段。在别人注意之前将其封装起来</li>
<li>encapsulate collection：如果类内含容器类字段，且没有得到恰当的封装</li>
<li>remove setting method：对于不该被其他类修改的字段</li>
<li>move method：找出取值、设值函数被其他类运用的地点，将调用行为搬移到data class 中</li>
<li>extract method：无法搬移整个函数，则残生一个可搬移的函数。</li>
<li>hide method：将取值、设值函数隐藏起来</li>
</ul>
</li>
</ul>
<h1 id="refused-bequest-被拒绝的继承"><a href="#refused-bequest-被拒绝的继承" class="headerlink" title="refused bequest 被拒绝的继承"></a>refused bequest 被拒绝的继承</h1><ul>
<li>子类应该继承超类的函数、数据。</li>
<li>如果子类不想、不需要继承所有的函数、数据，仅需要其中的一部分？</li>
<li>不建议的传统做法：（起码不建议每次都这么做）<ul>
<li>为子类新建一个兄弟类</li>
<li>push down mehtod、push down field 把所有用不到的函数下推给那个兄弟</li>
<li>最终，超类只持有子类共享的东西。达到“所有的超类，应该是抽象的”</li>
</ul>
</li>
<li>经常利用继承来复用一些行为，并发现可以很好地应用于日常工作。但这也是一种坏味道，但气味通常不那么强烈</li>
<li>建议：<ul>
<li>如果refused bequest引起困惑。问题，请遵循传统忠告，但不必每次都这么做。十有八九这种坏味道很淡，</li>
<li>如果子类复用了超类的行为（实现），却不愿意支持超类的接口，refused bequest的坏味道就会变得浓烈。</li>
<li>拒绝继承超类的实现，可以不介意；但如果拒绝继承超类的接口，必须重视。</li>
<li>replace inheritance with delegation：即使不愿意继承接口，也不要胡乱修改继承体系。</li>
</ul>
</li>
</ul>
<h1 id="comments-过多的注释"><a href="#comments-过多的注释" class="headerlink" title="comments 过多的注释"></a>comments 过多的注释</h1><ul>
<li>comments不是一种坏味道，是一种好味道</li>
<li>但，人们常用Comments来作为除臭剂。</li>
<li>常见情境：一段代码，有长长的注释。而注释之所以存在，是因为代码很糟糕。</li>
<li>comments可以带我们找到上面所提到的各种坏味道。找到坏味道之后，用各种重构手法去除坏味道。完成之后，常发现：注释已经变得多余了，因为代码已经说清楚说明了一切</li>
<li>解决：<ul>
<li>extract method：注释来解释一块代码做了什么</li>
<li>rename method：如果函数已经提炼出来，但还是需要注释来解释其行为</li>
<li>introduce assertion：如果需要注释说明某些系统的需求规格</li>
</ul>
</li>
<li>建议：<ul>
<li>当感觉需要撰写注释时，请先尝试重构，试着让所有的注释都变得多余</li>
</ul>
</li>
<li>注释的良好运用情境：（信息可以帮助将来的修改者，尤其是那些健忘的人）<ul>
<li>不知道该做什么：用来记录将来的打算</li>
<li>标记并无十足把握的区域</li>
<li>写下自己“为什么做某某事”</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>003-重构原则</title>
    <url>/articles/20210102/1d5fb0cc.html</url>
    <content><![CDATA[<p>摘要：</p>
<ul>
<li>何谓重构</li>
<li>为何重构</li>
<li>何时重构</li>
<li>怎么对经理说</li>
<li>重构的难题</li>
<li>重构与设计</li>
<li>重构与性能</li>
<li>重构起源何处<a id="more"></a>

</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="何为重构"><a href="#何为重构" class="headerlink" title="何为重构"></a>何为重构</h2><ul>
<li>名词定义1：对软件内部结构的一种调整，目的是爱不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本</li>
<li>动词定义：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构</li>
</ul>
<h2 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h2><ul>
<li>改进软件设计</li>
<li>使软件更容易理解</li>
<li>帮助找到Bug</li>
<li>提高编程速度</li>
</ul>
<h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><ul>
<li>三次法则：事不过三，三则重构</li>
<li>添加功能时重构：帮助理解需要修改的代码，理清代码结构；新特性的添加会更快速、流畅</li>
<li>修补错误：代码更具可读性；没清晰到让人一眼看出bug</li>
<li>复审代码：开发团队中传播知识，传递经验，获得建议；和团队进行设计复审：UML示意图展示设计，CRC卡展示软件情节；和单个开发者进行代码复审</li>
</ul>
<h2 id="需要重构的代码"><a href="#需要重构的代码" class="headerlink" title="需要重构的代码"></a>需要重构的代码</h2><ul>
<li>难以阅读的</li>
<li>逻辑重复的</li>
<li>添加新行为使需要修改已有代码的</li>
<li>带复杂逻辑条件的</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>易阅读</li>
<li>易修改</li>
<li>所有逻辑在唯一地点指定</li>
<li>新的改动不会危机现有行为</li>
<li>尽可能简单表达逻辑条件</li>
</ul>
<h2 id="间接层是一把双刃剑"><a href="#间接层是一把双刃剑" class="headerlink" title="间接层是一把双刃剑"></a>间接层是一把双刃剑</h2><ul>
<li>将大型对象拆成多个小型对象，将大型函数拆成多个小型函数</li>
<li>缺点：一个东西分两份，增加管理难度；<ul>
<li>多个委托依次依赖，程序难以阅读</li>
</ul>
</li>
<li>优点：<ul>
<li>父类、子类：允许逻辑共享</li>
<li>分开解释意图和实现</li>
<li>隔离变化</li>
<li>封装条件逻辑：多态消息</li>
</ul>
</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>程序与数据库结构紧密耦合</li>
<li>数据迁移：数据库结构改变</li>
<li>数据库模型复杂，难以控制<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3></li>
<li>对象模型和数据库模型间插入一个分割层，隔离两个模型各自的变化。<ul>
<li>缺点：增加系统复杂性</li>
<li>优点：带来很大的灵活性</li>
</ul>
</li>
<li>面向对象数据库：提供不同版本的对象间的自动迁移宫娥能</li>
</ul>
<h2 id="修改接口"><a href="#修改接口" class="headerlink" title="修改接口"></a>修改接口</h2><ul>
<li>接口，修改要特别谨慎。一旦被修改，任何事情都有可能发生</li>
<li>对象，可以允许分开修改软件模块的实现和接口，可以安全地修改对象内部实现而不影响他人</li>
<li>影响：被“找不到，或找到不能修改”的代码使用，会成为问题。即，已发布的接口</li>
<li>已发布的接口修改：旧接口调用新接口，并标记为deprecated</li>
<li>尽量少发布接口，不要公开太多的接口。在强调代码所有权上做出适当让步</li>
<li>发布接口有代价，除非真的有必要</li>
<li>不要过早发布接口</li>
<li>在throw子句中增加一个异常</li>
</ul>
<h2 id="何时不该重构"><a href="#何时不该重构" class="headerlink" title="何时不该重构"></a>何时不该重构</h2><ul>
<li>代码太混乱，不如重写一个来的简单：代码无法正常运作，或无法稳定运作</li>
<li>折中办法：“大块头软件”重构封装为良好的小型组件，逐一对组件做出“重构、重建”的决定</li>
<li>项目接近最后期限，避免重构。为时已晚。</li>
<li>重构确实可以提高生产力。如果最后没有足够的时间，通常表示应早该进行重构</li>
</ul>
<h2 id="重构与设计"><a href="#重构与设计" class="headerlink" title="重构与设计"></a>重构与设计</h2><ul>
<li>互补关系</li>
<li>预先设计，避免返工成本</li>
<li>重构改变了预先设计的角色，不必确保预先设计一定是正确无误的，只需要一个足够合理的解决方案即可</li>
<li>重构让日后的修改成本不在高昂</li>
<li>软件设计得以简化。足够灵活、可靠的解决方案，成本难以估算；所有可能变化的地点都建立灵活性，会使整个系统的复杂度大大提高；最后可能这些灵活性毫无必要</li>
<li>重构是另一途径，来应付变化的风险。只需考虑：将一个简单的解决方案重构成一个灵活方案的难度？一般都“相当容易”</li>
<li>重构：更简单的设计，不损失灵活性，降低设计过程的难度和压力</li>
</ul>
<h2 id="重构与性能"><a href="#重构与性能" class="headerlink" title="重构与性能"></a>重构与性能</h2><ul>
<li>不赞成为了提高设计的纯洁性而忽视性能，不将性能寄托在更快的硬件上</li>
<li>重构，可能使软件运行更慢，也可使软件的性能优化更容易</li>
<li>除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：首先写出可调的软件，然后调整他以求获得足够的速度</li>
<li>编写快速软件的方法：</li>
</ul>
<ol>
<li>时间预算法。<ul>
<li>多用于性能要求极高的实时系统。</li>
<li>分解设计时做好预算，给每个组件预先分配一定的资源（包括时间和执行轨迹），每个组件绝对不能超过自己的预算，就算拥有组件之间调度预配时间的机制也不行。</li>
<li>此方法，高度重视性能</li>
</ul>
</li>
<li>持续关注法。<ul>
<li>要求任何程序员在任何时间做任何事，都设法保持系统的高性能</li>
<li>通常没有太大作用，视角通常太狭隘。</li>
<li>修改只是为了提高性能，通常会使程序难以维护，继而减缓开发速度</li>
<li>一视同仁的优化所有代码。90%的优化都是白费劲，代码很少被执行，没达到应有的效果。需要对程序有清楚的认识</li>
</ul>
</li>
<li>90%统计数据<ul>
<li>编写构造良好的程序，不能对性能投以特别的关注，直至进入性能优化阶段（通常在开发后期）</li>
<li>首先，用一个度量工具来监控程序的运行，得到哪些地方消耗大量的时间、空间，找出性能热点所在的代码</li>
<li>注意力集中在性能热点上，较少的工作量可得到较好的成果</li>
<li>保持谨慎，应小幅度进行修改，每一步都需编译、测试、再次度量。如果性能没有提高，则撤销此次修改</li>
<li>保持“发现热点，去除热点”，直至得到满意的性能</li>
</ul>
</li>
</ol>
<ul>
<li>构造良好的程序的帮助</li>
</ul>
<ol>
<li>较充裕的时间进行性能调整。构造良好的代码，可帮助更快速地添加功能，有更多的时间用在性能问题上（准确的度量则保证将时间投资在恰当的地方）</li>
<li>构造良好的程序，在性能分析时有更细的粒度。度量工具将你带到范围较小的程序段落中，性能调整更容易些。代码更加清晰，则帮助理解自己的选择，更清楚那些调整起关键作用。</li>
</ol>
<ul>
<li>短期看，重构可能使软件变慢，但优化阶段的软件性能调整容易，最终更易得到较好的效果。</li>
</ul>
<h2 id="重构缘起何处"><a href="#重构缘起何处" class="headerlink" title="重构缘起何处"></a>重构缘起何处</h2><ul>
<li>优秀的程序员肯定至少会花一些时间来清理自己的代码。</li>
<li>简洁的代码比杂乱无章的代码更容易修改</li>
<li>知道自己几乎无法一开始就写出简洁的代码</li>
<li>重构可以提高生产力，对于开发灵活高效的框架很有帮助</li>
<li>重构使一门非常重要的技术，对生产性能、产品质量带来很大的影响</li>
</ul>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>006-mysql-如何使用MySQL一个表中的字段更新另一个表中字段</title>
    <url>/articles/20210101/f669f815.html</url>
    <content><![CDATA[<p>摘要：006-mysql-如何使用MySQL一个表中的字段更新另一个表中字段</p>
<a id="more"></a>

<h1 id="查看MYSQL数据库中所有用户"><a href="#查看MYSQL数据库中所有用户" class="headerlink" title="查看MYSQL数据库中所有用户"></a>查看MYSQL数据库中所有用户</h1><h2 id="方式一、join"><a href="#方式一、join" class="headerlink" title="方式一、join"></a>方式一、join</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> personal a <span class="keyword">inner</span> <span class="keyword">join</span> user_info b  <span class="keyword">on</span> a.user_id = b.id </span><br><span class="line"><span class="keyword">set</span> a.create_time = b.createtime;</span><br></pre></td></tr></table></figure>

<h2 id="方式二、where条件"><a href="#方式二、where条件" class="headerlink" title="方式二、where条件"></a>方式二、where条件</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> personal a , user_info b</span><br><span class="line"><span class="keyword">set</span> a.create_time = b.createtime</span><br><span class="line"><span class="keyword">where</span> a.user_id = b.id;</span><br></pre></td></tr></table></figure>

<h2 id="方式三、子查询"><a href="#方式三、子查询" class="headerlink" title="方式三、子查询"></a>方式三、子查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> personal a </span><br><span class="line"><span class="keyword">set</span> a.create_time = (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> user_info b <span class="keyword">where</span> b.id = a.user_id);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>002-重构入门案例</title>
    <url>/articles/20210101/3fe3f9a6.html</url>
    <content><![CDATA[<p>摘要：重构入门案例</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>示例：影片出租店应用程序，计算每一位顾客的消费金额并打印详单。操作者告诉程序：顾客租客哪些影片、租期多长，程序便根据租赁时间和影片类型计算出费用。</p>
<p>影片分为三类：普通片、儿童片、新片。除了计算费用还要为常客计算积分，积分会根据足片种类是否为新片而有不同。</p>
<h1 id="Ver01-示例-简单逻辑思维，没有扩展"><a href="#Ver01-示例-简单逻辑思维，没有扩展" class="headerlink" title="Ver01 示例-简单逻辑思维，没有扩展"></a>Ver01 示例-简单逻辑思维，没有扩展</h1><ol>
<li>使用几个类表达上述<ul>
<li>Movie(影片类)：数据类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHILDRENS = <span class="number">2</span>; <span class="comment">//儿童</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REGULAR = <span class="number">0</span>; <span class="comment">//常客</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW_RELEASE = <span class="number">1</span>;<span class="comment">// 新片</span></span><br><span class="line">    <span class="keyword">private</span> String _title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _priceCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, <span class="keyword">int</span> priceCode)</span> </span>&#123;</span><br><span class="line">        _title = title;</span><br><span class="line">        _priceCode = priceCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriceCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _priceCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriceCode</span><span class="params">(<span class="keyword">int</span> priceCode)</span> </span>&#123;</span><br><span class="line">        _priceCode = priceCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Rental(租赁类) 表示某个顾客租了一部影片<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rental</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movie _movie; <span class="comment">// 影片</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _daysRented; <span class="comment">// 租期</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rental</span><span class="params">(Movie movie, <span class="keyword">int</span> daysRented)</span> </span>&#123;</span><br><span class="line">        _movie = movie;</span><br><span class="line">        _daysRented = daysRented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDaysRented</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _daysRented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Movie <span class="title">getMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _movie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Customer(顾客) 数据以及相应的访问函数。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String _name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> Vector _rentals = <span class="keyword">new</span> Vector(); <span class="comment">// 租借记</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRental</span><span class="params">(Rental arg)</span> </span>&#123;</span><br><span class="line">        _rentals.addElement(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalAmount = <span class="number">0</span>; <span class="comment">// 总消费金。</span></span><br><span class="line">        <span class="keyword">int</span> frequentRenterPoints = <span class="number">0</span>; <span class="comment">// 常客积点</span></span><br><span class="line">        Enumeration rentals = _rentals.elements();</span><br><span class="line">        String result = <span class="string">"Rental Record for "</span> + getName() + <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">double</span> thisAmount = <span class="number">0</span>;</span><br><span class="line">            Rental each = (Rental) rentals.nextElement(); <span class="comment">// 取得一笔租借记。</span></span><br><span class="line">            <span class="comment">// determine amounts for each line</span></span><br><span class="line">            <span class="keyword">switch</span> (each.getMovie().getPriceCode()) &#123; <span class="comment">// 取得影片出租价格</span></span><br><span class="line">                <span class="keyword">case</span> Movie.REGULAR: <span class="comment">// 普通片</span></span><br><span class="line">                    thisAmount += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (each.getDaysRented() &gt; <span class="number">2</span>)</span><br><span class="line">                        thisAmount += (each.getDaysRented() - <span class="number">2</span>) * <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Movie.NEW_RELEASE: <span class="comment">// 新片</span></span><br><span class="line">                    thisAmount += each.getDaysRented() * <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Movie.CHILDRENS: <span class="comment">// 儿童。</span></span><br><span class="line">                    thisAmount += <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">if</span> (each.getDaysRented() &gt; <span class="number">3</span>)</span><br><span class="line">                        thisAmount += (each.getDaysRented() - <span class="number">3</span>) * <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add frequent renter points （累计常客积点。</span></span><br><span class="line">            frequentRenterPoints++;</span><br><span class="line">            <span class="comment">// add bonus for a two day new release rental</span></span><br><span class="line">            <span class="keyword">if</span> ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE)</span><br><span class="line">                    &amp;&amp; each.getDaysRented() &gt; <span class="number">1</span>)</span><br><span class="line">                frequentRenterPoints++;</span><br><span class="line">            <span class="comment">// show figures for this rental（显示此笔租借记录）</span></span><br><span class="line">            result += <span class="string">"\t"</span> + each.getMovie().getTitle() + <span class="string">"\t"</span></span><br><span class="line">                    + String.valueOf(thisAmount) + <span class="string">"\n"</span>;</span><br><span class="line">            totalAmount += thisAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add footer lines（结尾打印）</span></span><br><span class="line">        result += <span class="string">"Amount owed is "</span> + String.valueOf(totalAmount) + <span class="string">"\n"</span>;</span><br><span class="line">        result += <span class="string">"You earned "</span> + String.valueOf(frequentRenterPoints)</span><br><span class="line">                + <span class="string">" frequent renter points"</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>单元测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(<span class="string">"John"</span>);</span><br><span class="line">        String title = <span class="string">"Titanic"</span>;</span><br><span class="line">        <span class="keyword">int</span> priceCode = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> _daysRented = <span class="number">7</span>;</span><br><span class="line">        Movie movie = <span class="keyword">new</span> Movie(title, priceCode);</span><br><span class="line">        Rental rental = <span class="keyword">new</span> Rental(movie, _daysRented);</span><br><span class="line">        customer.addRental(rental);</span><br><span class="line">        String result = customer.statement();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>说明<br>单一逻辑，没有扩展性以及面向对象思维   </li>
</ol>
<h1 id="Ver02-分解重组statement"><a href="#Ver02-分解重组statement" class="headerlink" title="Ver02 分解重组statement()"></a>Ver02 分解重组statement()</h1><ol>
<li>避免长函数、逻辑独立的抽成方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String _name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> Vector _rentals = <span class="keyword">new</span> Vector(); <span class="comment">// 租借记</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRental</span><span class="params">(Rental arg)</span> </span>&#123;</span><br><span class="line">        _rentals.addElement(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalAmount = <span class="number">0</span>; <span class="comment">// 总消费金。</span></span><br><span class="line">        <span class="keyword">int</span> frequentRenterPoints = <span class="number">0</span>; <span class="comment">// 常客积点</span></span><br><span class="line">        Enumeration rentals = _rentals.elements();</span><br><span class="line">        String result = <span class="string">"Rental Record for "</span> + getName() + <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements()) &#123;</span><br><span class="line">            Rental each = (Rental) rentals.nextElement(); <span class="comment">// 取得一笔租借记。</span></span><br><span class="line">            <span class="keyword">double</span> thisAmount = amountFor(each);</span><br><span class="line">            <span class="comment">// add frequent renter points （累计常客积点。</span></span><br><span class="line">            frequentRenterPoints++;</span><br><span class="line">            <span class="comment">// add bonus for a two day new release rental</span></span><br><span class="line">            <span class="keyword">if</span> ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE)</span><br><span class="line">                    &amp;&amp; each.getDaysRented() &gt; <span class="number">1</span>)</span><br><span class="line">                frequentRenterPoints++;</span><br><span class="line">            <span class="comment">// show figures for this rental（显示此笔租借记录）</span></span><br><span class="line">            result += <span class="string">"\t"</span> + each.getMovie().getTitle() + <span class="string">"\t"</span></span><br><span class="line">                    + String.valueOf(thisAmount) + <span class="string">"\n"</span>;</span><br><span class="line">            totalAmount += thisAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add footer lines（结尾打印）</span></span><br><span class="line">        result += <span class="string">"Amount owed is "</span> + String.valueOf(totalAmount) + <span class="string">"\n"</span>;</span><br><span class="line">        result += <span class="string">"You earned "</span> + String.valueOf(frequentRenterPoints)</span><br><span class="line">                + <span class="string">" frequent renter points"</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">amountFor</span><span class="params">(Rental rental)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> thisAmount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// determine amounts for each line</span></span><br><span class="line">        <span class="keyword">switch</span> (rental.getMovie().getPriceCode()) &#123; <span class="comment">// 取得影片出租价格</span></span><br><span class="line">            <span class="keyword">case</span> Movie.REGULAR: <span class="comment">// 普通片</span></span><br><span class="line">                thisAmount += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (rental.getDaysRented() &gt; <span class="number">2</span>)</span><br><span class="line">                    thisAmount += (rental.getDaysRented() - <span class="number">2</span>) * <span class="number">1.5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Movie.NEW_RELEASE: <span class="comment">// 新片</span></span><br><span class="line">                thisAmount += rental.getDaysRented() * <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Movie.CHILDRENS: <span class="comment">// 儿童。</span></span><br><span class="line">                thisAmount += <span class="number">1.5</span>;</span><br><span class="line">                <span class="keyword">if</span> (rental.getDaysRented() &gt; <span class="number">3</span>)</span><br><span class="line">                    thisAmount += (rental.getDaysRented() - <span class="number">3</span>) * <span class="number">1.5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thisAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Ver03-金额计算代码，迁移至Rental类"><a href="#Ver03-金额计算代码，迁移至Rental类" class="headerlink" title="Ver03 金额计算代码，迁移至Rental类"></a>Ver03 金额计算代码，迁移至Rental类</h1><p>   参看：<a href="'https://github.com/bjlhx15/refactoring.git'">github ver03</a></p>
<h1 id="Ver04-同类聚合，单一原则"><a href="#Ver04-同类聚合，单一原则" class="headerlink" title="Ver04 同类聚合，单一原则"></a>Ver04 同类聚合，单一原则</h1><ol>
<li><p>Movie中放置与影片直接相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHILDRENS = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REGULAR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW_RELEASE = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> String _title;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> _priceCode;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, <span class="keyword">int</span> priceCode)</span> </span>&#123;</span><br><span class="line">            _title = title;</span><br><span class="line">            _priceCode = priceCode;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriceCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _priceCode;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _title;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriceCode</span><span class="params">(<span class="keyword">int</span> priceCode)</span> </span>&#123;</span><br><span class="line">            _priceCode = priceCode;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCharge</span><span class="params">(<span class="keyword">int</span> daysRented)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (getPriceCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> Movie.REGULAR:</span><br><span class="line">                    result += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (daysRented &gt; <span class="number">2</span>)</span><br><span class="line">                        result += (daysRented - <span class="number">2</span>) * <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Movie.NEW_RELEASE:</span><br><span class="line">                    result += daysRented * <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Movie.CHILDRENS:</span><br><span class="line">                    result += <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">if</span> (daysRented &gt; <span class="number">3</span>)</span><br><span class="line">                        result += (daysRented - <span class="number">3</span>) * <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFrequentRenterPoints</span><span class="params">(<span class="keyword">int</span> daysRented)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; daysRented &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ```   </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 租赁放置相关方法</span><br><span class="line">   ```java</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rental</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Movie _movie; <span class="comment">// 影片</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> _daysRented; <span class="comment">// 租期</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Rental</span><span class="params">(Movie movie, <span class="keyword">int</span> daysRented)</span> </span>&#123;</span><br><span class="line">            _movie = movie;</span><br><span class="line">            _daysRented = daysRented;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDaysRented</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _daysRented;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Movie <span class="title">getMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _movie;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getCharge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _movie.getCharge(_daysRented);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFrequentRenterPoints</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _movie.getFrequentRenterPoints(_daysRented);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顾客相关</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{
    <span class="keyword">private</span> String _name; <span class="comment">// 姓名</span>
    <span class="keyword">private</span> Vector _rentals = <span class="keyword">new</span> Vector(); <span class="comment">// 租借记</span>

    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span> </span>{
        _name = name;
    };

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRental</span><span class="params">(Rental arg)</span> </span>{
        _rentals.addElement(arg);
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> _name;
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">statement</span><span class="params">()</span> </span>{
        <span class="keyword">int</span> frequentRenterPoints = <span class="number">0</span>;
        Enumeration rentals = _rentals.elements();
        String result = <span class="string">"Rental Record for "</span> + getName() + <span class="string">"\n"</span>;
        <span class="keyword">while</span> (rentals.hasMoreElements()) {
            Rental each = (Rental) rentals.nextElement();
            frequentRenterPoints += each.getFrequentRenterPoints();
            <span class="comment">// show figures for this rental</span>
            result += <span class="string">"\t"</span> + each.getMovie().getTitle() + <span class="string">"\t"</span>
                    + String.valueOf(each.getCharge()) + <span class="string">"\n"</span>;
        }
        <span class="comment">// add footer lines</span>
        result += <span class="string">"Amount owed is "</span> + String.valueOf(getTotalCharge()) + <span class="string">"\n"</span>;
        result += <span class="string">"You earned "</span> + String.valueOf(getTotalFrequentRenterPoints())
                + <span class="string">" frequent renter points"</span>;
        <span class="keyword">return</span> result;
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">htmlStatement</span><span class="params">()</span> </span>{
        Enumeration rentals = _rentals.elements();
        String result = <span class="string">"&lt;H1&gt;Rentals for &lt;EM&gt;"</span> + getName() + <span class="string">"&lt;/EM&gt;&lt;/ H1&gt;&lt;P&gt;\n"</span>;
        <span class="keyword">while</span> (rentals.hasMoreElements()) {
            Rental each = (Rental) rentals.nextElement();
            <span class="comment">// show figures for each rental</span>
            result += each.getMovie().getTitle() + <span class="string">": "</span>
                    + String.valueOf(each.getCharge()) + <span class="string">"&lt;BR&gt;\n"</span>;
        }
        <span class="comment">// add footer lines</span>
        result += <span class="string">"&lt;P&gt;You owe &lt;EM&gt;"</span> + String.valueOf(getTotalCharge())
                + <span class="string">"&lt;/EM&gt;&lt;P&gt;\n"</span>;
        result += <span class="string">"On this rental you earned &lt;EM&gt;"</span>
                + String.valueOf(getTotalFrequentRenterPoints())
                + <span class="string">"&lt;/EM&gt; frequent renter points&lt;P&gt;"</span>;
        <span class="keyword">return</span> result;
    }

    <span class="comment">// 译注：此即所谓query method</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTotalFrequentRenterPoints</span><span class="params">()</span> </span>{
        <span class="keyword">int</span> result = <span class="number">0</span>;
        Enumeration rentals = _rentals.elements();
        <span class="keyword">while</span> (rentals.hasMoreElements()) {
            Rental each = (Rental) rentals.nextElement();
            result += each.getFrequentRenterPoints();
        }
        <span class="keyword">return</span> result;
    }

    <span class="comment">// 译注：此即所谓query method</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getTotalCharge</span><span class="params">()</span> </span>{
        <span class="keyword">double</span> result = <span class="number">0</span>;
        Enumeration rentals = _rentals.elements();
        <span class="keyword">while</span> (rentals.hasMoreElements()) {
            Rental each = (Rental) rentals.nextElement();
            result += each.getCharge();
        }
        <span class="keyword">return</span> result;
    }

}</code></pre>
</li>
</ol>
<h1 id="重新分析，抽象模型"><a href="#重新分析，抽象模型" class="headerlink" title="重新分析，抽象模型"></a>重新分析，抽象模型</h1><ol>
<li><p>抽象过程一、</p>
<ul>
<li>影片实体：抽象类Movie,子类：普通片、儿童片、新片.每个子类有各自计费方法实现。常见操作是抽象功能接口<br>影片可能会根据不同的类型有不同的收费规则，所以影片可以根据类型有不同的子类，但是有个问题，影片如果换了类型，但是class是不能换的，所以可以考虑影片没有子类，但是影片包含一个Price的类，这个类可以根据不同类型有不同子类。Movie有一个Price类的引用，不同的类型对应不同的Price子类，调用Price类的方法来计算收费。</li>
</ul>
<p>参看：<a href="'https://github.com/bjlhx15/refactoring.git'">github ver03</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>001-概述</title>
    <url>/articles/20210101/35a24dd9.html</url>
    <content><![CDATA[<p>摘要：重构基础以及目录</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>重构（refactoring）：是一个过程：在不改变代码外在行为的前提下，对代码做出修改，已改进程序的内部结构。</p>
<p>本质上，重构就是在代码写好之后改进他的设计。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>更改变量名是绝对值得的行为，好的代码应该清楚表达出自己的功能，变量名是代码清晰的关键。任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员 。</li>
<li>绝大多数情况下，函数应该放在它所使用的数据的所属对象内。</li>
<li>重构的前提是需要有测试工具和测试用例，每次重构一小部分代码就进行测试，保证在不改变代码行为的前提下重构。</li>
<li>不要对另一个对象的属性用switch，如果要用switch，也应该在自己的属性上用，这样可以解耦，别的对象的修改也影响不到你。</li>
</ul>
<ol>
<li>示例</li>
</ol>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
  </entry>
  <entry>
    <title>001-边际、成本、需求、科斯定律、弹性、主观性-薛兆丰的北大经济学课</title>
    <url>/articles/20200528/c31ed728.html</url>
    <content><![CDATA[<p>摘要：关注边际，关注均衡。我的资源是有限的，时间精力。每一分资源都应该花在边际收益最大化的地方。</p>
<a id="more"></a>

<p>科斯定理是信息经济学的范畴，是说如果产权定义明确，那么即使信息存在不对称和外部性，双方也会通过自主的交换来实现最有效率的配置，即帕累托最优的境界。</p>
<p>什么是科斯定理<br> 只要财产权是明确的，并且交易成本为零或者很小，那么，无论在开始时将财产权赋予谁，市场均衡的最终结果都是有效率的，实现资源配置的帕雷托最优。</p>
<p>伤害是相互的，假如不把伤害看作伤害，把伤害看作对资源的争用，谁能把资源用的好，资源最有可能落到谁手上。</p>
<p>分析方法：经济学家理查德.爱泼斯坦根据科斯定律提出了一个简单的解决方案——123原则，即假设所有东西的产权都归一个人所有，两个人所有，或者三个人所有，分别会是什么情况。</p>
<h1 id="概念一、边际"><a href="#概念一、边际" class="headerlink" title="概念一、边际"></a>概念一、边际</h1><p>理性的决策，永远要盯住边际值，而不是总值或均值。边际就是新增带来的新增。</p>
<p>假如我面前有水和钻石，当我只有一块钱，那我肯定买水，当我有1000块钱我可能还会买水，假如我有1万块钱，那么为了幸福最大化，我有没有可能买钻石呢？</p>
<p>一瓶水我喝第1口时感觉最解渴，喝第2口时，就感觉解渴，喝第100口时可能就想吐。所以我们要追求的是边际效用的最大，用自己有限的时间精力，在可能涉及的领域活动选项中，分配资源，从而使收入最大。</p>
<h1 id="原则二、成本。–谁避免意外所付出的成本最低，谁的责任就最大"><a href="#原则二、成本。–谁避免意外所付出的成本最低，谁的责任就最大" class="headerlink" title="原则二、成本。–谁避免意外所付出的成本最低，谁的责任就最大"></a>原则二、成本。–谁避免意外所付出的成本最低，谁的责任就最大</h1><p>只要有人群的地方，就有交易费用，比如给人记公分，给人做公证，给人打官司，这些活动产生的费用就称为交易费用。</p>
<ul>
<li><p>示例一、火车路过，喷出的火星，烧了旁边的亚麻。假如你是法官，这个案子，应该判火车公司胜诉还是种亚麻的农民胜诉呢？</p>
<ul>
<li><p>通常，我们会认为铁路公司挣的钱多，属于强势群体，所以应该负责任，赔偿农夫的损失——当时的社会也是这么想的，所以判处铁路公司予以赔偿。</p>
</li>
<li><p>假设铁路和种亚麻的农民是一个人的，有个好处就是他在做计算衡量时，几乎不需要成本，只需要说服自己就可以了。</p>
</li>
<li><p>这样，火星烧了亚麻，火车改变轨道是成本较高的，而亚麻离铁道远的地方放，是成本较低的，所以农民会承担较大的责任。整个社会避免意外所付出的总成本就会最小。</p>
</li>
</ul>
</li>
<li><p>示例二、新建的小区挡住了老居民区的阳光，应该谁负责任？</p>
<ul>
<li>假如这两个小区都是你的，新小区可以帮你挣一亿，你拿出1000万补贴给老居民，还能多赚9000万。</li>
<li>新小区推翻重建的成本很高，补贴老居民的成本较低。</li>
</ul>
</li>
</ul>
<p>在会产生伤害的事件中，谁避免伤害的成本最低，谁就应该承担最大的责任。这样分摊整个社会为避免意外，所以付出的总成本就会达到最小。谁的成本低，谁就承担责任。</p>
<h1 id="第3个概念是科斯定律。"><a href="#第3个概念是科斯定律。" class="headerlink" title="第3个概念是科斯定律。"></a>第3个概念是科斯定律。</h1><p>既然使用权的确定，视不同用途的价值而定，那关于权利争用的问题，就应该以“提高共同的产出，合理分配收益”的原则，也就是寻求合作解，不要讲理要讲数。</p>
<p>一个足球场，好的球队经常来打球，球场周围的居民就把自家房顶改成看台。球场主人不乐意，双方就斗到了法院。</p>
<p>最终双方达成和解，方案是居民向球场交纳收入的17%作为回报，球场同意周围居民修建看台。</p>
<p>一项有价值的资源，不管从一开始他的产权谁属，最后这项资源都会流动到，能最大化利用其价值的人手中去。</p>
<p>街上走过一个漂亮的女孩子，我非常喜欢她，但问题是她已经有男朋友了。经济学家告诉我，只要交易费用足够低，不管这个女孩现在跟谁谈朋友，她最后会跟最合适她的人在一起。</p>
<h1 id="第4个概念需求。"><a href="#第4个概念需求。" class="headerlink" title="第4个概念需求。"></a>第4个概念需求。</h1><p>价格越高，需求量越小。无论何时何地，价格提高，商品的需求量就会减少，价格降到一定程度，需求量就会增加。</p>
<p>价格上升，需求者可变供给者，需求和供给之间没有绝对的区别。就像我要出去玩儿，但出租车太贵，我就选择自驾驶，顺便捎两个搭顺风车的。</p>
<p>消费者的个人估值和他们实际上付出的价格之间的差值，就是交易剩余，而交易剩余是由消费者和生产者共同创造的。</p>
<p>比如我想花10块钱买个杯子，结果5块钱就买到了。有个人想卖杯子，本来打算卖3块，结果卖了5块。中间的剩余是我和卖家共同创造的。</p>
<p>每当消费者必须支付一笔附加费的时候，这笔附加费越高，高品质产品的相对价格就变得越便宜，好东西要运到远方去定律。</p>
<p>比如超市放着一块澳洲牛排，它更可能是去骨头的，还是不去骨头的？答案是去骨头的，因为有运输成本。</p>
<p>比如苹果分两种，一种是一般的苹果，2块钱一斤，一种是高档苹果，5块钱一斤。假如每斤苹果都要加上5块的运费，那哪种苹果更划算呢？答案当然是高档苹果。</p>
<h1 id="第5个概念是弹性。"><a href="#第5个概念是弹性。" class="headerlink" title="第5个概念是弹性。"></a>第5个概念是弹性。</h1><p>需求对价格的弹性和价格变化之后流失的时间长度成正比。一个商品到底是必需品和奢侈品，跟价格有密切的关系。</p>
<p>有没有什么商品不管价格多高，需求量都不变的？没有，高到一定程度，总会选择替代品，就像药太贵了就选择死。</p>
<h1 id="第6个概念是主观性。"><a href="#第6个概念是主观性。" class="headerlink" title="第6个概念是主观性。"></a>第6个概念是主观性。</h1><p>价值都是由个人评估的，主观的，一个人对一件商品的个人估值是他为了得到这件商品所愿意支付的其他商品的最高数量。</p>
<p>你手里有一台我喜欢的游戏机，我手里有的是能兑换面包的钱，这个游戏机我愿意花多少买面包的钱兑换，就是我对它最高的个人估值。</p>
<p>总结：关注边际，关注均衡。我的资源是有限的，时间精力。每一分资源都应该花在边际收益最大化的地方。</p>
<p>能运到远方的，大都是好东西。就像能来中国的留学生平均成绩，一定比全体中国学生的平均成绩高。好东西要运到远方去。</p>
<p>谢谢欣赏，观点来自《薛兆丰的北大经济学课》。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>002-TIg集成一体化监控</title>
    <url>/articles/20200421/181299f3.html</url>
    <content><![CDATA[<p>通过TICK(Telegraf+Influxdb+Chronograf+Kapacitor)进行主机性能监控告警，职责描述如下：</p>
<p>Telegraf：数据采集，用于主机性能数据，包括主机CPU、内存、IO、进程状态、服务状态等<br>Influxdb的：时序数据库，用于存储Telegraf采集来的数据<br>grafana：数据可视化，用于将Influxdb数据库的性能数据时序展示：规则告警，用于配置告警规则将Influxdb数据库查询触发规则的数据进行告警</p>
<p>其中，时序数据库可使用刚开源的TDEngine，可视化可以使用Grafana替代使用</p>
<a id="more"></a>
<h2 id="概述-Telegraf、InfluxDB"><a href="#概述-Telegraf、InfluxDB" class="headerlink" title="概述-Telegraf、InfluxDB"></a>概述-Telegraf、InfluxDB</h2><p>参看：上文 001-TICK集成一体化监控</p>
<h2 id="可视化-2：Grafana"><a href="#可视化-2：Grafana" class="headerlink" title="可视化-2：Grafana"></a>可视化-2：Grafana</h2><p>一般可以使用 Grafana 替代 Chronograf +Kapacitor 组合</p>
<p>Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。它主要有以下六大特点：</p>
<p>1、展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式；</p>
<p>2、数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等；</p>
<p>3、通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知；</p>
<p>4、混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源；</p>
<p>5、注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记；</p>
<p>6、过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="原始安装"><a href="#原始安装" class="headerlink" title="原始安装"></a>原始安装</h4><p><a href="https://grafana.com/grafana/download" target="_blank" rel="noopener">https://grafana.com/grafana/download</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.grafana.com&#x2F;oss&#x2F;release&#x2F;grafana-6.7.2-1.x86_64.rpm</span><br><span class="line">sudo yum install grafana-6.7.2-1.x86_64.rpm</span><br><span class="line">systemctl start grafana-server</span><br></pre></td></tr></table></figure>
<h4 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h4><p>启动服务，打开浏览器，输入IP+端口，3000为Grafana的默认侦听端口。</p>
<p>系统默认用户名和密码为admin/admin，第一次登陆系统会要求修改密码，修改密码后登陆</p>
<h3 id="Grafana使用方法"><a href="#Grafana使用方法" class="headerlink" title="Grafana使用方法"></a>Grafana使用方法</h3><p>1、添加数据源</p>
<p>首先是添加数据源，点击左上角的grafana图标，示例如下：</p>
<p>PS：选择influxdb作为数据源，需要在influxdb中创建该用户以及对应的数据库！</p>
<p>2、创建DashBoard</p>
<p>创建好数据源之后，就需要创建DashBoard（仪表盘），可以自定义，也可以导入你需要的仪表盘，官方提供了很多的可选仪表盘。</p>
<p>BashBoard地址：<a href="https://grafana.com/dashboards?dataSource=influxdb" target="_blank" rel="noopener">https://grafana.com/dashboards?dataSource=influxdb</a><br>①、搜索对应仪表盘<br>②、选择对应的仪表盘ID<br>③、复制ID，填入导入界面<br>④、展示仪表盘</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>001-TICK集成一体化监控</title>
    <url>/articles/20200410/95a952d4.html</url>
    <content><![CDATA[<p>通过TICK(Telegraf+Influxdb+Chronograf+Kapacitor)进行主机性能监控告警，职责描述如下：</p>
<p>Telegraf：数据采集，用于主机性能数据，包括主机CPU、内存、IO、进程状态、服务状态等<br>Influxdb的：时序数据库，用于存储Telegraf采集来的数据<br>Chronograf：数据可视化，用于将Influxdb数据库的性能数据时序展示<br>Kapacitor：规则告警，用于配置告警规则将Influxdb数据库查询触发规则的数据进行告警</p>
<p>其中，时序数据库可使用刚开源的TDEngine，可视化可以使用Grafana替代使用</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 数据采集：Telegraf 和 数据存储：InfluxDB</p>
<p>下载地址：<br><a href="https://portal.influxdata.com/downloads/" target="_blank" rel="noopener">https://portal.influxdata.com/downloads/</a></p>
<p>环境：CentOS7.4 64位</p>
<p>在平台监控系统中，可以使用 Telegraf 采集多种组件的运行信息，而不需要自己手写脚本定时采集，大大降低数据获取的难度；且 Telegraf 配置极为简单，只要有基本的 Linux 基础即可快速上手。Telegraf 按照时间序列采集数据，数据结构中包含时序信息，时序数据库就是为此类数据设计而来，使用 Influxdb 可以针采集得到的数据完成各种分析计算操作。</p>
<h3 id="为什么要用telegraf和influxdb？"><a href="#为什么要用telegraf和influxdb？" class="headerlink" title="为什么要用telegraf和influxdb？"></a>为什么要用telegraf和influxdb？</h3><p>①、在数据采集和平台监控系统中，Telegraf 可以采集多种组件的运行信息，而不需要自己手写脚本定时采集，降低数据获取的难度；</p>
<p>②、Telegraf 配置简单，只要有基本的 Linux 基础即可快速上手；</p>
<p>③、Telegraf 按照时间序列采集数据，数据结构中包含时序信息，influxdb就是为此类数据设计而来，使用 Influxdb 可以针采集得到的数据完成各种分析计算操作；</p>
<h2 id="数据采集：Telegraf"><a href="#数据采集：Telegraf" class="headerlink" title="数据采集：Telegraf"></a>数据采集：Telegraf</h2><p>Telegraf 是一个用 Go 编写的代理程序，可收集系统和服务的统计数据，并写入到 InfluxDB 数据库。内存占用小，通过插件系统可轻松添加支持其他服务的扩展。</p>
<p>Telegraf 是收集和报告指标和数据的代理。</p>
<p>Telegraf是TICK Stack的一部分，是一个插件驱动的服务器代理，用于收集和报告指标。</p>
<p>Telegraf 集成了直接从其运行的容器和系统中提取各种指标，事件和日志，从第三方API提取指标，甚至通过StatsD和Kafka消费者服务监听指标。</p>
<p>它还具有输出插件，可将指标发送到各种其他数据存储，服务和消息队列，包括InfluxDB，Graphite，OpenTSDB，Datadog，Librato，Kafka，MQTT，NSQ等等。</p>
<p>常用的输入插件（mysql、redis、prometheus）配置可参见 附录说明</p>
<p>Telegraf由4个独立的插件驱动</p>
<p>Input Plugins：输入插件，收集系统、服务、第三方组件的数据<br>Processor Plugins：处理插件，转换、处理、过滤数据<br>Aggregator Plugins：聚合插件，数据特征聚合<br>Output Plugins：输出插件，写metrics数据</p>
<p>相比zabbix，对主流开源应用的探测支持的更好，并且无需安装agent。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.influxdata.com&#x2F;telegraf&#x2F;releases&#x2F;telegraf-1.14.1-1.x86_64.rpm</span><br><span class="line">rpm -ivh telegraf-1.14.1-1.x86_64.rpm</span><br><span class="line">systemctl start telegraf</span><br></pre></td></tr></table></figure>

<h2 id="数据存储：InfluxDB"><a href="#数据存储：InfluxDB" class="headerlink" title="数据存储：InfluxDB"></a>数据存储：InfluxDB</h2><p>Influxdb 是一个开源的分布式时序、时间和指标数据库，使用 Go 语言编写，无需外部依赖。Influxdb 有如下三大特性：</p>
<p>①、基于时间序列(Time Series)，支持与时间有关的相关函数（如最大，最小，求和等）；</p>
<p>②、可度量性（Metrics）：你可以实时对大量数据进行计算；</p>
<p>③、基于事件（Event）：它支持任意的事件数据；</p>
<h3 id="安装使用-1"><a href="#安装使用-1" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.8.0.x86_64.rpm</span><br><span class="line">rpm -ivh influxdb-1.8.0.x86_64.rpm</span><br><span class="line">systemctl start influxd </span><br><span class="line"><span class="comment"># 检测</span></span><br><span class="line">curl <span class="string">"http://localhost:8086/query?q=show+databases"</span></span><br></pre></td></tr></table></figure>

<h3 id="创建-Influxdb-用户和数据库"><a href="#创建-Influxdb-用户和数据库" class="headerlink" title="创建 Influxdb 用户和数据库"></a>创建 Influxdb 用户和数据库</h3><p>上述服务启动后，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入数据库</span></span><br><span class="line">influx</span><br><span class="line"><span class="comment"># Connected to http://localhost:8086 version 1.8.0</span></span><br><span class="line"><span class="comment"># InfluxDB shell version: 1.8.0</span></span><br><span class="line">create user <span class="string">"telegraf"</span> with password <span class="string">'password'</span></span><br><span class="line">show users</span><br><span class="line"><span class="comment"># user     admin</span></span><br><span class="line"><span class="comment"># ----     -----</span></span><br><span class="line"><span class="comment"># telegraf false</span></span><br><span class="line">create database telegraf</span><br><span class="line">show databases</span><br><span class="line"><span class="comment"># name: databases</span></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line"><span class="comment"># ----</span></span><br><span class="line"><span class="comment"># telegraf</span></span><br><span class="line"><span class="comment"># _internal</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Telegraf-监听本机cpu信息"><a href="#配置Telegraf-监听本机cpu信息" class="headerlink" title="配置Telegraf 监听本机cpu信息"></a>配置Telegraf 监听本机cpu信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/telegraf/telegraf.conf</span><br><span class="line">   <span class="comment">## 修改内容如下： </span></span><br><span class="line">   [[outputs.influxdb]]</span><br><span class="line">     urls = [<span class="string">"http://localhost:8086"</span>] <span class="comment"># required </span></span><br><span class="line">     database = <span class="string">"telegraf"</span> <span class="comment"># required</span></span><br><span class="line">     retention_policy = <span class="string">""</span></span><br><span class="line">     precision = <span class="string">"s"</span></span><br><span class="line">     timeout = <span class="string">"5s"</span></span><br><span class="line">     username = <span class="string">"telegraf"</span></span><br><span class="line">     password = <span class="string">"password"</span></span><br></pre></td></tr></table></figure>
<p>systemctl restart telegraf</p>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>vim /etc/influxdb/influxdb.conf</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.8/administration/config/" target="_blank" rel="noopener">https://docs.influxdata.com/influxdb/v1.8/administration/config/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局配置</span><br><span class="line"></span><br><span class="line">reporting-disabled &#x3D; false  # 该选项用于上报influxdb的使用信息给InfluxData公司，默认值为false</span><br><span class="line">bind-address &#x3D; &quot;:8088&quot;  # 备份恢复时使用，默认值为8088</span><br><span class="line"></span><br><span class="line">1、meta相关配置</span><br><span class="line"></span><br><span class="line">[meta]</span><br><span class="line">dir &#x3D; &quot;&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;meta&quot;  # meta数据存放目录</span><br><span class="line">retention-autocreate &#x3D; true  # 用于控制默认存储策略，数据库创建时，会自动生成autogen的存储策略，默认值：true</span><br><span class="line">logging-enabled &#x3D; true  # 是否开启meta日志，默认值：true</span><br><span class="line"></span><br><span class="line">2、data相关配置</span><br><span class="line"></span><br><span class="line">[data]</span><br><span class="line">dir &#x3D; &quot;&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;data&quot;  # 最终数据（TSM文件）存储目录</span><br><span class="line">wal-dir &#x3D; &quot;&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;wal&quot;  # 预写日志存储目录</span><br><span class="line">query-log-enabled &#x3D; true  # 是否开启tsm引擎查询日志，默认值： true</span><br><span class="line">cache-max-memory-size &#x3D; 1048576000  # 用于限定shard最大值，大于该值时会拒绝写入，默认值：1000MB，单位：byte</span><br><span class="line">cache-snapshot-memory-size &#x3D; 26214400  # 用于设置快照大小，大于该值时数据会刷新到tsm文件，默认值：25MB，单位：byte</span><br><span class="line">cache-snapshot-write-cold-duration &#x3D; &quot;10m&quot;  # tsm引擎 snapshot写盘延迟，默认值：10Minute</span><br><span class="line">compact-full-write-cold-duration &#x3D; &quot;4h&quot;  # tsm文件在压缩前可以存储的最大时间，默认值：4Hour</span><br><span class="line">max-series-per-database &#x3D; 1000000  # 限制数据库的级数，该值为0时取消限制，默认值：1000000</span><br><span class="line">max-values-per-tag &#x3D; 100000  # 一个tag最大的value数，0取消限制，默认值：100000</span><br><span class="line"></span><br><span class="line">3、coordinator查询管理的配置选项</span><br><span class="line"></span><br><span class="line">[coordinator]</span><br><span class="line">write-timeout &#x3D; &quot;10s&quot;  # 写操作超时时间，默认值： 10s</span><br><span class="line">max-concurrent-queries &#x3D; 0  # 最大并发查询数，0无限制，默认值： 0</span><br><span class="line">query-timeout &#x3D; &quot;0s  # 查询操作超时时间，0无限制，默认值：0s</span><br><span class="line">log-queries-after &#x3D; &quot;0s&quot;  # 慢查询超时时间，0无限制，默认值：0s</span><br><span class="line">max-select-point &#x3D; 0  # SELECT语句可以处理的最大点数（points），0无限制，默认值：0</span><br><span class="line">max-select-series &#x3D; 0  # SELECT语句可以处理的最大级数（series），0无限制，默认值：0</span><br><span class="line">max-select-buckets &#x3D; 0  # SELECT语句可以处理的最大&quot;GROUP BY time()&quot;的时间周期，0无限制，默认值：0</span><br><span class="line"></span><br><span class="line">4、retention旧数据的保留策略</span><br><span class="line"></span><br><span class="line">[retention]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ： true</span><br><span class="line">check-interval &#x3D; &quot;30m&quot;  # 检查时间间隔，默认值 ：&quot;30m&quot;</span><br><span class="line"></span><br><span class="line">5、shard-precreation分区预创建</span><br><span class="line"></span><br><span class="line">[shard-precreation]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ： true</span><br><span class="line">check-interval &#x3D; &quot;10m&quot;  # 检查时间间隔，默认值 ：&quot;10m&quot;</span><br><span class="line">advance-period &#x3D; &quot;30m&quot;  # 预创建分区的最大提前时间，默认值 ：&quot;30m&quot;</span><br><span class="line"></span><br><span class="line">6、monitor 控制InfluxDB自有的监控系统。 默认情况下，InfluxDB把这些数据写入_internal 数据库，如果这个库不存在则自动创建。 _internal 库默认的retention策略是7天，如果你想使用一个自己的retention策略，需要自己创建。</span><br><span class="line"></span><br><span class="line">[monitor]</span><br><span class="line">store-enabled &#x3D; true  # 是否启用该模块，默认值 ：true</span><br><span class="line">store-database &#x3D; &quot;_internal&quot;  # 默认数据库：&quot;_internal&quot;</span><br><span class="line">store-interval &#x3D; &quot;10s  # 统计间隔，默认值：&quot;10s&quot;</span><br><span class="line"></span><br><span class="line">7、admin web管理页面[1.3界面已删除使用 1：chronograf]</span><br><span class="line"></span><br><span class="line">[admin]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ： false</span><br><span class="line">bind-address &#x3D; &quot;:8083&quot;  # 绑定地址，默认值 ：&quot;:8083&quot;</span><br><span class="line">https-enabled &#x3D; false  # 是否开启https ，默认值 ：false</span><br><span class="line">https-certificate &#x3D; &quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;  # https证书路径，默认值：&quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;</span><br><span class="line"></span><br><span class="line">8、http API</span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ：true</span><br><span class="line">bind-address &#x3D; &quot;:8086&quot;  # 绑定地址，默认值：&quot;:8086&quot;</span><br><span class="line">auth-enabled &#x3D; false  # 是否开启认证，默认值：false</span><br><span class="line">realm &#x3D; &quot;InfluxDB&quot;  # 配置JWT realm，默认值: &quot;InfluxDB&quot;</span><br><span class="line">log-enabled &#x3D; true  # 是否开启日志，默认值：true</span><br><span class="line">write-tracing &#x3D; false  # 是否开启写操作日志，如果置成true，每一次写操作都会打日志，默认值：false</span><br><span class="line">pprof-enabled &#x3D; true  # 是否开启pprof，默认值：true</span><br><span class="line">https-enabled &#x3D; false  # 是否开启https，默认值：false</span><br><span class="line">https-certificate &#x3D; &quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;  # 设置https证书路径，默认值：&quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;</span><br><span class="line">https-private-key &#x3D; &quot;&quot;  # 设置https私钥，无默认值</span><br><span class="line">shared-secret &#x3D; &quot;&quot;  # 用于JWT签名的共享密钥，无默认值</span><br><span class="line">max-row-limit &#x3D; 0  # 配置查询返回最大行数，0无限制，默认值：0</span><br><span class="line">max-connection-limit &#x3D; 0  # 配置最大连接数，0无限制，默认值：0</span><br><span class="line">unix-socket-enabled &#x3D; false  # 是否使用unix-socket，默认值：false</span><br><span class="line">bind-socket &#x3D; &quot;&#x2F;var&#x2F;run&#x2F;influxdb.sock&quot;  # unix-socket路径，默认值：&quot;&#x2F;var&#x2F;run&#x2F;influxdb.sock&quot;</span><br><span class="line"></span><br><span class="line">9、subscriber 控制Kapacitor接受数据的配置</span><br><span class="line"></span><br><span class="line">[subscriber]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ：true</span><br><span class="line">http-timeout &#x3D; &quot;30s&quot;  # http超时时间，默认值：&quot;30s&quot;</span><br><span class="line">insecure-skip-verify &#x3D; false  # 是否允许不安全的证书</span><br><span class="line">ca-certs &#x3D; &quot;&quot;  # 设置CA证书</span><br><span class="line">write-concurrency &#x3D; 40  # 设置并发数目，默认值：40</span><br><span class="line">write-buffer-size &#x3D; 1000  # 设置buffer大小，默认值：1000</span><br><span class="line"></span><br><span class="line">10、graphite 相关配置</span><br><span class="line"></span><br><span class="line">[[graphite]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值 ：false</span><br><span class="line">database &#x3D; &quot;graphite&quot;  # 数据库名称，默认值：&quot;graphite&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">bind-address &#x3D; &quot;:2003&quot;  # 绑定地址，默认值：&quot;:2003&quot;</span><br><span class="line">protocol &#x3D; &quot;tcp&quot;  # 协议，默认值：&quot;tcp&quot;</span><br><span class="line">consistency-level &#x3D; &quot;one&quot;  # 一致性级别，默认值：&quot;one</span><br><span class="line">batch-size &#x3D; 5000  # 批量size，默认值：5000</span><br><span class="line">batch-pending &#x3D; 10  # 配置在内存中等待的batch数，默认值：10</span><br><span class="line">batch-timeout &#x3D; &quot;1s&quot;  # 超时时间，默认值：&quot;1s&quot;</span><br><span class="line">udp-read-buffer &#x3D; 0  # udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。 该配置的默认值：0</span><br><span class="line">separator &#x3D; &quot;.&quot;  # 多个measurement间的连接符，默认值： &quot;.&quot;</span><br><span class="line"></span><br><span class="line">11、collectd</span><br><span class="line"></span><br><span class="line">[[collectd]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值 ：false</span><br><span class="line">bind-address &#x3D; &quot;:25826&quot;  # 绑定地址，默认值： &quot;:25826&quot;</span><br><span class="line">database &#x3D; &quot;collectd&quot;  # 数据库名称，默认值：&quot;collectd&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">typesdb &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;share&#x2F;collectd&quot;  # 路径，默认值：&quot;&#x2F;usr&#x2F;share&#x2F;collectd&#x2F;types.db&quot;</span><br><span class="line">auth-file &#x3D; &quot;&#x2F;etc&#x2F;collectd&#x2F;auth_file&quot;</span><br><span class="line">batch-size &#x3D; 5000</span><br><span class="line">batch-pending &#x3D; 10</span><br><span class="line">batch-timeout &#x3D; &quot;10s&quot;</span><br><span class="line">read-buffer &#x3D; 0  # udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。默认值：0</span><br><span class="line"></span><br><span class="line">12、opentsdb</span><br><span class="line"></span><br><span class="line">[[opentsdb]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值：false</span><br><span class="line">bind-address &#x3D; &quot;:4242&quot;  # 绑定地址，默认值：&quot;:4242&quot;</span><br><span class="line">database &#x3D; &quot;opentsdb&quot;  # 默认数据库：&quot;opentsdb&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">consistency-level &#x3D; &quot;one&quot;  # 一致性级别，默认值：&quot;one&quot;</span><br><span class="line">tls-enabled &#x3D; false  # 是否开启tls，默认值：false</span><br><span class="line">certificate&#x3D; &quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;  # 证书路径，默认值：&quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;</span><br><span class="line">log-point-errors &#x3D; true  # 出错时是否记录日志，默认值：true</span><br><span class="line">batch-size &#x3D; 1000</span><br><span class="line">batch-pending &#x3D; 5</span><br><span class="line">batch-timeout &#x3D; &quot;1s&quot;</span><br><span class="line"></span><br><span class="line">13、udp</span><br><span class="line"></span><br><span class="line">[[udp]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值：false</span><br><span class="line">bind-address &#x3D; &quot;:8089&quot;  # 绑定地址，默认值：&quot;:8089&quot;</span><br><span class="line">database &#x3D; &quot;udp&quot;  # 数据库名称，默认值：&quot;udp&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">batch-size &#x3D; 5000</span><br><span class="line">batch-pending &#x3D; 10</span><br><span class="line">batch-timeout &#x3D; &quot;1s&quot;</span><br><span class="line">read-buffer &#x3D; 0  # udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。 该配置的默认值：0</span><br><span class="line">　</span><br><span class="line">14、continuous_queries</span><br><span class="line"></span><br><span class="line">[continuous_queries]</span><br><span class="line">enabled &#x3D; true  # enabled 是否开启CQs，默认值：true</span><br><span class="line">log-enabled &#x3D; true  # 是否开启日志，默认值：true</span><br><span class="line">run-interval &#x3D; &quot;1s&quot;  # 时间间隔，默认值：&quot;1s&quot;</span><br></pre></td></tr></table></figure>

<p>telegraph会和influxDB的HTTP APi通信来写入数据。</p>
<h2 id="可视化-1：chronograf"><a href="#可视化-1：chronograf" class="headerlink" title="可视化-1：chronograf"></a>可视化-1：chronograf</h2><p>influxdb 在1.3之后取消web 界面后 使用的一个新的管理界面<br>Chronograf是InfluxData的TICK堆栈的用户界面组件。它使您的基础架构的监控和警报易于设置和维护。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.influxdata.com&#x2F;chronograf&#x2F;releases&#x2F;chronograf-1.8.2.x86_64.rpm</span><br><span class="line">rpm -ivh chronograf-1.8.2.x86_64.rpm</span><br><span class="line">systemctl start chronograf</span><br></pre></td></tr></table></figure>
<p>修改配置启动：<br>vim /etc/influxdb/influxdb.conf<br>基础配置<br><a href="http://116.198.1.1:8888/" target="_blank" rel="noopener">http://116.198.1.1:8888/</a></p>
<p>查看界面输入基础数据库连接即可</p>
<p>一个操作界面。</p>
<h2 id="规则告警：Kapacitor"><a href="#规则告警：Kapacitor" class="headerlink" title="规则告警：Kapacitor"></a>规则告警：Kapacitor</h2><p>Kapacitor是TICK堆栈的数据处理平台。Kapacitor负责在Chronograf中创建和发送警报。</p>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.influxdata.com/kapacitor/releases/kapacitor-1.5.4-1.x86_64.rpm</span><br><span class="line">yum localinstall kapacitor-1.5.4-1.x86_64.rpm</span><br><span class="line">systemctl start kapacitor</span><br><span class="line">kapacitor list tasks</span><br><span class="line"><span class="comment"># ID Type      Status    Executing Databases and Retention Policies</span></span><br></pre></td></tr></table></figure>

<p>对于Kapacitor URL，输入运行Kapacitor的计算机的主机名或IP，并确保包含Kapacitor的默认端口：9092。<br>接下来，命名连接字符串; 这可以是你想要的任何东西。由于在Kapacitor的默认配置中禁用了授权，因此无需为Username和Password输入输入任何信息。最后，点击Connect。</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>004-tools-chrome插件开发</title>
    <url>/articles/20200323/bb0aad89.html</url>
    <content><![CDATA[<p>概述:004-tools-chrome插件开发</p>
<a id="more"></a>
<h1 id="什么是Chrome插件"><a href="#什么是Chrome插件" class="headerlink" title="什么是Chrome插件"></a>什么是Chrome插件</h1><pre><code>叫Chrome扩展(Chrome Extension)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯。</code></pre><p>Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包.</p>
<p>另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。<br>helper.dll</p>
<p>由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。</p>
<h2 id="开发Chrome插件意义"><a href="#开发Chrome插件意义" class="headerlink" title="开发Chrome插件意义"></a>开发Chrome插件意义</h2><p>Chrome插件提供了很多实用API供我们使用，包括但不限于：<br>书签控制；下载控制；窗口控制；标签控制；网络请求控制，各类事件监听；自定义原生菜单；完善的通信机制；</p>
<h1 id="开发与调试"><a href="#开发与调试" class="headerlink" title="开发与调试"></a>开发与调试</h1><p>Chrome插件没有严格的项目结构要求，只要保证本目录有一个manifest.json即可，也不需要专门的IDE，普通的web开发工具即可。</p>
<p>从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 chrome://extensions 访问。</p>
<p>勾选开发者模式即可以文件夹的形式直接加载插件，否则只能安装.crx格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把crx文件解压，然后通过开发者模式直接加载。<br>开发者模式：一般是打开扩展工具后，右上角有个开关</p>
<p>开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下Ctrl+R即可，以防万一最好还把页面刷新一下。</p>
<h1 id="核心开发"><a href="#核心开发" class="headerlink" title="核心开发"></a>核心开发</h1><h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p>这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。</p>
<p>下面给出的是一些常见的配置项，均有中文注释，<a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="noopener">完整的配置文档</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 清单文件的版本，这个必须写，而且必须是2</span></span><br><span class="line">	<span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="comment">// 插件的名称</span></span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"demo"</span>,</span><br><span class="line">	<span class="comment">// 插件的版本</span></span><br><span class="line">	<span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">	<span class="comment">// 插件描述</span></span><br><span class="line">	<span class="attr">"description"</span>: <span class="string">"简单的Chrome扩展demo"</span>,</span><br><span class="line">	<span class="comment">// 图标，一般偷懒全部用一个尺寸的也没问题</span></span><br><span class="line">	<span class="attr">"icons"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"16"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="attr">"48"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="attr">"128"</span>: <span class="string">"img/icon.png"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line">	<span class="attr">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">		<span class="attr">"page"</span>: <span class="string">"background.html"</span></span><br><span class="line">		<span class="comment">//"scripts": ["js/background.js"]</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 浏览器右上角图标设置，browser_action、page_action、app必须三选一</span></span><br><span class="line">	<span class="attr">"browser_action"</span>: </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line">		<span class="attr">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">		<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 当某些特定页面打开才显示的图标</span></span><br><span class="line">	<span class="comment">/*"page_action":</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		"default_icon": "img/icon.png",</span></span><br><span class="line"><span class="comment">		"default_title": "我是pageAction",</span></span><br><span class="line"><span class="comment">		"default_popup": "popup.html"</span></span><br><span class="line"><span class="comment">	&#125;,*/</span></span><br><span class="line">	<span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line">	<span class="attr">"content_scripts"</span>: </span><br><span class="line">	[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//"matches": ["http://*/*", "https://*/*"],</span></span><br><span class="line">			<span class="comment">// "&lt;all_urls&gt;" 表示匹配所有地址</span></span><br><span class="line">			<span class="attr">"matches"</span>: [<span class="string">"&lt;all_urls&gt;"</span>],</span><br><span class="line">			<span class="comment">// 多个JS按顺序注入</span></span><br><span class="line">			<span class="attr">"js"</span>: [<span class="string">"js/jquery-1.8.3.js"</span>, <span class="string">"js/content-script.js"</span>],</span><br><span class="line">			<span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line">			<span class="attr">"css"</span>: [<span class="string">"css/custom.css"</span>],</span><br><span class="line">			<span class="comment">// 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line">			<span class="attr">"run_at"</span>: <span class="string">"document_start"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// 这里仅仅是为了演示content-script可以配置多个规则</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"matches"</span>: [<span class="string">"*://*/*.png"</span>, <span class="string">"*://*/*.jpg"</span>, <span class="string">"*://*/*.gif"</span>, <span class="string">"*://*/*.bmp"</span>],</span><br><span class="line">			<span class="attr">"js"</span>: [<span class="string">"js/show-image-content-size.js"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="comment">// 权限申请</span></span><br><span class="line">	<span class="attr">"permissions"</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">"contextMenus"</span>, <span class="comment">// 右键菜单</span></span><br><span class="line">		<span class="string">"tabs"</span>, <span class="comment">// 标签</span></span><br><span class="line">		<span class="string">"notifications"</span>, <span class="comment">// 通知</span></span><br><span class="line">		<span class="string">"webRequest"</span>, <span class="comment">// web请求</span></span><br><span class="line">		<span class="string">"webRequestBlocking"</span>,</span><br><span class="line">		<span class="string">"storage"</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line">		<span class="string">"http://*/*"</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">		<span class="string">"https://*/*"</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">	],</span><br><span class="line">	<span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line">	<span class="attr">"web_accessible_resources"</span>: [<span class="string">"js/inject.js"</span>],</span><br><span class="line">	<span class="comment">// 插件主页，这个很重要，不要浪费了这个免费广告位</span></span><br><span class="line">	<span class="attr">"homepage_url"</span>: <span class="string">"https://www.baidu.com"</span>,</span><br><span class="line">	<span class="comment">// 覆盖浏览器默认页面</span></span><br><span class="line">	<span class="attr">"chrome_url_overrides"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 覆盖浏览器默认的新标签页</span></span><br><span class="line">		<span class="attr">"newtab"</span>: <span class="string">"newtab.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line">	<span class="attr">"options_page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">	<span class="comment">// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个</span></span><br><span class="line">	<span class="attr">"options_ui"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">		<span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line">		<span class="attr">"chrome_style"</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line">	<span class="attr">"omnibox"</span>: &#123; <span class="attr">"keyword"</span> : <span class="string">"go"</span> &#125;,</span><br><span class="line">	<span class="comment">// 默认语言</span></span><br><span class="line">	<span class="attr">"default_locale"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">	<span class="comment">// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line">	<span class="attr">"devtools_page"</span>: <span class="string">"devtools.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content-scripts"></a>content-scripts</h3><p>所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。</p>
<p>配置如上，特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'我被执行了！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种：</p>
<ul>
<li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li>
<li>chrome.i18n</li>
<li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li>
<li>chrome.storage</li>
</ul>
<p>常用API，非要调用其它API的话，可以通过通信来实现让background来帮你调用。</p>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p>
<p>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。</p>
<p>经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。</p>
<p>配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line">	<span class="attr">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">		<span class="attr">"page"</span>: <span class="string">"background.html"</span></span><br><span class="line">		<span class="comment">//"scripts": ["js/background.js"]</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别说明的是，虽然你可以通过chrome-extension://xxx/background.html直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个background.html，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。</p>
<h3 id="event-pages"><a href="#event-pages" class="headerlink" title="event-pages"></a>event-pages</h3><p>鉴于background生命周期太长，长时间挂载后台可能会影响性能，在配置文件上，它与background的唯一区别就是多了一个persistent参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"scripts"</span>: [<span class="string">"event-page.js"</span>],</span><br><span class="line">		<span class="attr">"persistent"</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。</p>
<p>一般情况下background也不会很消耗性能的。</p>
<h3 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h3><p>是点击browser_action或者page_action图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。<br>popup可以包含任意你想要的HTML内容，并且会自适应大小。可以通过default_popup字段来指定popup页面，也可以调用setPopup()方法。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"browser_action"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line">		<span class="attr">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">		<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。</p>
<p>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。</p>
<h3 id="js注入"><a href="#js注入" class="headerlink" title="js注入"></a>js注入</h3><p>指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？</p>
<p>这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。</p>
<p>在content-script中通过DOM方式向页面注入inject-script代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向页面注入JS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectCustomJs</span>(<span class="params">jsPath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jsPath = jsPath || <span class="string">'js/inject.js'</span>;</span><br><span class="line">	<span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">	temp.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span><br><span class="line">	<span class="comment">// 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js</span></span><br><span class="line">	temp.src = chrome.extension.getURL(jsPath);</span><br><span class="line">	temp.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 放在页面不好看，执行完后移除掉</span></span><br><span class="line">		<span class="keyword">this</span>.parentNode.removeChild(<span class="keyword">this</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">document</span>.head.appendChild(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接访问报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Denying load of chrome-extension:&#x2F;&#x2F;efbllncjkjiijkppagepehoekjojdclc&#x2F;js&#x2F;inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</span><br></pre></td></tr></table></figure>
<p>在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line">	<span class="attr">"web_accessible_resources"</span>: [<span class="string">"js/inject.js"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="homepage-url"><a href="#homepage-url" class="headerlink" title="homepage_url"></a>homepage_url</h3><p>开发者或者插件主页设置，一般会在如下2个地方显示：详细信息，开发者网站等</p>
<h1 id="Chrome插件的8种展示形式"><a href="#Chrome插件的8种展示形式" class="headerlink" title="Chrome插件的8种展示形式"></a>Chrome插件的8种展示形式</h1><h2 id="browserAction-浏览器右上角"><a href="#browserAction-浏览器右上角" class="headerlink" title="browserAction(浏览器右上角)"></a>browserAction(浏览器右上角)</h2><p>通过配置browser_action可以在浏览器的右上角增加一个图标，一个browser_action可以拥有一个图标，一个tooltip，一个badge和一个popup。</p>
<p>示例配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">"browser_action":</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">	<span class="attr">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">	<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>browser_action 图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中default_icon字段配置，也可以调用setIcon()方法。</p>
<h3 id="tooltip"><a href="#tooltip" class="headerlink" title="tooltip"></a>tooltip</h3><p>修改browser_action的manifest中default_title字段，或者调用setTitle()方法。</p>
<h3 id="badge"><a href="#badge" class="headerlink" title="badge"></a>badge</h3><p>所谓badge就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用setBadgeText()和setBadgeBackgroundColor()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.browserAction.setBadgeText(&#123;<span class="attr">text</span>: <span class="string">'new'</span>&#125;);</span><br><span class="line">chrome.browserAction.setBadgeBackgroundColor(&#123;<span class="attr">color</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="pageAction-地址栏右侧"><a href="#pageAction-地址栏右侧" class="headerlink" title="pageAction(地址栏右侧)"></a>pageAction(地址栏右侧)</h2><p>所谓pageAction，指的是只有当某些特定页面打开才显示的图标，它和browserAction最大的区别是一个始终都显示，一个只在特定情况才显示。</p>
<p>需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单：</p>
<p>而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项。</p>
<p>调整之后的pageAction我们可以简单地把它看成是可以置灰的browserAction。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.pageAction.show(tabId) 显示图标；</span><br><span class="line">chrome.pageAction.hide(tabId) 隐藏图标；</span><br></pre></td></tr></table></figure>
<p>示例(只有打开百度才显示图标)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"page_action"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="attr">"default_title"</span>: <span class="string">"我是pageAction"</span>,</span><br><span class="line">		<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"permissions"</span>: [<span class="string">"declarativeContent"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.runtime.onInstalled.addListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	chrome.declarativeContent.onPageChanged.removeRules(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		chrome.declarativeContent.onPageChanged.addRules([</span><br><span class="line">			&#123;</span><br><span class="line">				conditions: [</span><br><span class="line">					<span class="comment">// 只有打开百度才显示pageAction</span></span><br><span class="line">					<span class="keyword">new</span> chrome.declarativeContent.PageStateMatcher(&#123;<span class="attr">pageUrl</span>: &#123;<span class="attr">urlContains</span>: <span class="string">'baidu.com'</span>&#125;&#125;)</span><br><span class="line">				],</span><br><span class="line">				actions: [<span class="keyword">new</span> chrome.declarativeContent.ShowPageAction()]</span><br><span class="line">			&#125;</span><br><span class="line">		]);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="右键菜单"><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h2><p>通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里</p>
<h3 id="最简单的右键菜单示例"><a href="#最简单的右键菜单示例" class="headerlink" title="最简单的右键菜单示例"></a>最简单的右键菜单示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; manifest.json</span><br><span class="line">&#123;&quot;permissions&quot;: [&quot;contextMenus&quot;]&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; background.js</span><br><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	title: &quot;测试右键菜单&quot;,</span><br><span class="line">	onclick: function()&#123;alert(&#39;您点击了右键菜单！&#39;);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="添加右键百度搜索"><a href="#添加右键百度搜索" class="headerlink" title="添加右键百度搜索"></a>添加右键百度搜索</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; manifest.json</span><br><span class="line">&#123;&quot;permissions&quot;: [&quot;contextMenus&quot;， &quot;tabs&quot;]&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; background.js</span><br><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	title: &#39;使用百度搜索：%s&#39;, &#x2F;&#x2F; %s表示选中的文字</span><br><span class="line">	contexts: [&#39;selection&#39;], &#x2F;&#x2F; 只有当选中文字时才会出现此右键菜单</span><br><span class="line">	onclick: function(params)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; 注意不能使用location.href，因为location是属于background的window对象</span><br><span class="line">		chrome.tabs.create(&#123;url: &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;utf-8&amp;wd&#x3D;&#39; + encodeURI(params.selectionText)&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>完整API参见：<a href="https://developer.chrome.com/extensions/contextMenus" target="_blank" rel="noopener">https://developer.chrome.com/extensions/contextMenus</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	type: &#39;normal&#39;， &#x2F;&#x2F; 类型，可选：[&quot;normal&quot;, &quot;checkbox&quot;, &quot;radio&quot;, &quot;separator&quot;]，默认 normal</span><br><span class="line">	title: &#39;菜单的名字&#39;, &#x2F;&#x2F; 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本</span><br><span class="line">	contexts: [&#39;page&#39;], &#x2F;&#x2F; 上下文环境，可选：[&quot;all&quot;, &quot;page&quot;, &quot;frame&quot;, &quot;selection&quot;, &quot;link&quot;, &quot;editable&quot;, &quot;image&quot;, &quot;video&quot;, &quot;audio&quot;]，默认page</span><br><span class="line">	onclick: function()&#123;&#125;, &#x2F;&#x2F; 单击时触发的方法</span><br><span class="line">	parentId: 1, &#x2F;&#x2F; 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单</span><br><span class="line">	documentUrlPatterns: &#39;https:&#x2F;&#x2F;*.baidu.com&#x2F;*&#39; &#x2F;&#x2F; 只在某些页面显示此右键菜单</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 删除某一个菜单项</span><br><span class="line">chrome.contextMenus.remove(menuItemId)；</span><br><span class="line">&#x2F;&#x2F; 删除所有自定义右键菜单</span><br><span class="line">chrome.contextMenus.removeAll();</span><br><span class="line">&#x2F;&#x2F; 更新某一个菜单项</span><br><span class="line">chrome.contextMenus.update(menuItemId, updateProperties);</span><br></pre></td></tr></table></figure>

<h2 id="override-覆盖特定页面"><a href="#override-覆盖特定页面" class="headerlink" title="override(覆盖特定页面)"></a>override(覆盖特定页面)</h2><p>使用override页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。</p>
<p>扩展可以替代如下页面：</p>
<ul>
<li>历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history</li>
<li>新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab</li>
<li>书签：浏览器的书签，或者直接输入 chrome://bookmarks</li>
</ul>
<p>注意：</p>
<ul>
<li>一个扩展只能替代一个页面；</li>
<li>不能替代隐身窗口的新标签页；</li>
<li>网页必须设置title，否则用户可能会看到网页的URL，造成困扰；</li>
<li>下面的截图是默认的新标签页和被扩展替换掉的新标签页。</li>
</ul>
<p>代码（注意，一个插件只能替代一个默认页，以下仅为演示）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;chrome_url_overrides&quot;:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;newtab&quot;: &quot;newtab.html&quot;,</span><br><span class="line">	&quot;history&quot;: &quot;history.html&quot;,</span><br><span class="line">	&quot;bookmarks&quot;: &quot;bookmarks.html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="devtools-开发者工具"><a href="#devtools-开发者工具" class="headerlink" title="devtools(开发者工具)"></a>devtools(开发者工具)</h2><h3 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h3><p>Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在：</p>
<ul>
<li>自定义一个和多个和Elements、Console、Sources等同级别的面板；</li>
<li>自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏；</li>
</ul>
<h3 id="devtools扩展介绍"><a href="#devtools扩展介绍" class="headerlink" title="devtools扩展介绍"></a>devtools扩展介绍</h3><p>主页：<a href="https://developer.chrome.com/extensions/devtools" target="_blank" rel="noopener">https://developer.chrome.com/extensions/devtools</a></p>
<p>每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的DevTools API以及有限的扩展API，这组特有的DevTools API只有devtools页面才可以访问，background都无权访问，这些API包括：</p>
<ul>
<li>chrome.devtools.panels：面板相关；</li>
<li>chrome.devtools.inspectedWindow：获取被审查窗口的有关信息；</li>
<li>chrome.devtools.network：获取有关网络请求的信息；</li>
</ul>
<p>大部分扩展API都无法直接被DevTools页面调用，但它可以像content-script一样直接调用chrome.extension和chrome.runtimeAPI，同时它也可以像content-script一样使用Message交互的方式与background页面进行通信。</p>
<h3 id="实例：创建一个devtools扩展"><a href="#实例：创建一个devtools扩展" class="headerlink" title="实例：创建一个devtools扩展"></a>实例：创建一个devtools扩展</h3><p>首先，要针对开发者工具开发插件，需要在清单文件声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 只能指向一个HTML文件，不能是JS文件</span><br><span class="line">	&quot;devtools_page&quot;: &quot;devtools.html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个devtools.html里面一般什么都没有，就引入一个js：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/devtools.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再来看devtools.js的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建自定义面板，同一个插件可以创建多个自定义面板</span><br><span class="line">&#x2F;&#x2F; 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调</span><br><span class="line">chrome.devtools.panels.create(&#39;MyPanel&#39;, &#39;img&#x2F;icon.png&#39;, &#39;mypanel.html&#39;, function(panel)</span><br><span class="line">&#123;</span><br><span class="line">	console.log(&#39;自定义面板创建成功！&#39;); &#x2F;&#x2F; 注意这个log一般看不到</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建自定义侧边栏</span><br><span class="line">chrome.devtools.panels.elements.createSidebarPane(&quot;Images&quot;, function(sidebar)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; sidebar.setPage(&#39;..&#x2F;sidebar.html&#39;); &#x2F;&#x2F; 指定加载某个页面</span><br><span class="line">	sidebar.setExpression(&#39;document.querySelectorAll(&quot;img&quot;)&#39;, &#39;All Images&#39;); &#x2F;&#x2F; 通过表达式来指定</span><br><span class="line">	&#x2F;&#x2F;sidebar.setObject(&#123;aaa: 111, bbb: &#39;Hello World!&#39;&#125;); &#x2F;&#x2F; 直接设置显示某个对象</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>mypanel.js代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检测jQuery</span><br><span class="line">document.getElementById(&#39;check_jquery&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 访问被检查的页面DOM需要使用inspectedWindow</span><br><span class="line">	&#x2F;&#x2F; 简单例子：检测被检查页面是否使用了jQuery</span><br><span class="line">	chrome.devtools.inspectedWindow.eval(&quot;jQuery.fn.jquery&quot;, function(result, isException)</span><br><span class="line">	&#123;</span><br><span class="line">		var html &#x3D; &#39;&#39;;</span><br><span class="line">		if (isException) html &#x3D; &#39;当前页面没有使用jQuery。&#39;;</span><br><span class="line">		else html &#x3D; &#39;当前页面使用了jQuery，版本为：&#39;+result;</span><br><span class="line">		alert(html);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打开某个资源</span><br><span class="line">document.getElementById(&#39;open_resource&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	chrome.devtools.inspectedWindow.eval(&quot;window.location.href&quot;, function(result, isException)</span><br><span class="line">	&#123;</span><br><span class="line">		chrome.devtools.panels.openResource(result, 20, function()</span><br><span class="line">		&#123;</span><br><span class="line">			console.log(&#39;资源打开成功！&#39;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 审查元素</span><br><span class="line">document.getElementById(&#39;test_inspect&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	chrome.devtools.inspectedWindow.eval(&quot;inspect(document.images[0])&quot;, function(result, isException)&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取所有资源</span><br><span class="line">document.getElementById(&#39;get_all_resources&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	chrome.devtools.inspectedWindow.getResources(function(resources)</span><br><span class="line">	&#123;</span><br><span class="line">		alert(JSON.stringify(resources));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下Ctrl+R重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。</p>
<p>由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 chrome-extension://extid/devtools.html”的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。</p>
<h2 id="option-选项页"><a href="#option-选项页" class="headerlink" title="option(选项页)"></a>option(选项页)</h2><p>所谓options页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面：</p>
<p>在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。</p>
<p>老版的options：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; Chrome40以前的插件配置页写法</span><br><span class="line">	&quot;options_page&quot;: &quot;options.html&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版的optionsV2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;options_ui&quot;:</span><br><span class="line">	&#123;</span><br><span class="line">    	&quot;page&quot;: &quot;options.html&quot;,</span><br><span class="line">		&#x2F;&#x2F; 添加一些默认的样式，推荐使用</span><br><span class="line">    	&quot;chrome_style&quot;: true</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几点注意：</p>
<ul>
<li>为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式；</li>
<li>新版options中不能使用alert；</li>
<li>数据存储建议用chrome.storage，因为会随用户自动同步；<br>$$ omnibox<br>omnibox是向用户提供搜索建议的一种方式。</li>
</ul>
<p>注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。</p>
<p>首先，manifest.json配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span><br><span class="line">	&quot;omnibox&quot;: &#123; &quot;keyword&quot; : &quot;go&quot; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后background.js中注册监听事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; omnibox 演示</span><br><span class="line">chrome.omnibox.onInputChanged.addListener((text, suggest) &#x3D;&gt; &#123;</span><br><span class="line">	console.log(&#39;inputChanged: &#39; + text);</span><br><span class="line">	if(!text) return;</span><br><span class="line">	if(text &#x3D;&#x3D; &#39;美女&#39;) &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;content: &#39;中国&#39; + text, description: &#39;你要找“中国美女”吗？&#39;&#125;,</span><br><span class="line">			&#123;content: &#39;日本&#39; + text, description: &#39;你要找“日本美女”吗？&#39;&#125;,</span><br><span class="line">			&#123;content: &#39;泰国&#39; + text, description: &#39;你要找“泰国美女或人妖”吗？&#39;&#125;,</span><br><span class="line">			&#123;content: &#39;韩国&#39; + text, description: &#39;你要找“韩国美女”吗？&#39;&#125;</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(text &#x3D;&#x3D; &#39;微博&#39;) &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;content: &#39;新浪&#39; + text, description: &#39;新浪&#39; + text&#125;,</span><br><span class="line">			&#123;content: &#39;腾讯&#39; + text, description: &#39;腾讯&#39; + text&#125;,</span><br><span class="line">			&#123;content: &#39;搜狐&#39; + text, description: &#39;搜索&#39; + text&#125;,</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;content: &#39;百度搜索 &#39; + text, description: &#39;百度搜索 &#39; + text&#125;,</span><br><span class="line">			&#123;content: &#39;谷歌搜索 &#39; + text, description: &#39;谷歌搜索 &#39; + text&#125;,</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当用户接收关键字建议时触发</span><br><span class="line">chrome.omnibox.onInputEntered.addListener((text) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;inputEntered: &#39; + text);</span><br><span class="line">	if(!text) return;</span><br><span class="line">	var href &#x3D; &#39;&#39;;</span><br><span class="line">    if(text.endsWith(&#39;美女&#39;)) href &#x3D; &#39;http:&#x2F;&#x2F;image.baidu.com&#x2F;search&#x2F;index?tn&#x3D;baiduimage&amp;ie&#x3D;utf-8&amp;word&#x3D;&#39; + text;</span><br><span class="line">	else if(text.startsWith(&#39;百度搜索&#39;)) href &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;&#39; + text.replace(&#39;百度搜索 &#39;, &#39;&#39;);</span><br><span class="line">	else if(text.startsWith(&#39;谷歌搜索&#39;)) href &#x3D; &#39;https:&#x2F;&#x2F;www.google.com.tw&#x2F;search?q&#x3D;&#39; + text.replace(&#39;谷歌搜索 &#39;, &#39;&#39;);</span><br><span class="line">	else href &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;&#39; + text;</span><br><span class="line">	openUrlCurrentTab(href);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 获取当前选项卡ID</span><br><span class="line">function getCurrentTabId(callback)</span><br><span class="line">&#123;</span><br><span class="line">	chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function(tabs)</span><br><span class="line">	&#123;</span><br><span class="line">		if(callback) callback(tabs.length ? tabs[0].id: null);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当前标签打开某个链接</span><br><span class="line">function openUrlCurrentTab(url)</span><br><span class="line">&#123;</span><br><span class="line">	getCurrentTabId(tabId &#x3D;&gt; &#123;</span><br><span class="line">		chrome.tabs.update(tabId, &#123;url: url&#125;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：先输入go，然后 空格键 再输入“美女”</p>
<h2 id="桌面通知"><a href="#桌面通知" class="headerlink" title="桌面通知"></a>桌面通知</h2><p>Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。</p>
<p>在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chrome.notifications.create(null, &#123;</span><br><span class="line">	type: &#39;basic&#39;,</span><br><span class="line">	iconUrl: &#39;img&#x2F;icon.png&#39;,</span><br><span class="line">	title: &#39;这是标题&#39;,</span><br><span class="line">	message: &#39;您刚才点击了自定义右键菜单！&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通知的样式可以很丰富,有需要的可以看官方文档。</p>
<h1 id="5种类型的JS对比"><a href="#5种类型的JS对比" class="headerlink" title="5种类型的JS对比"></a>5种类型的JS对比</h1><p>Chrome插件的JS主要可以分为这5类：injected script、content-script、popup js、background js和devtools js，</p>
<h2 id="权限对比"><a href="#权限对比" class="headerlink" title="权限对比"></a>权限对比</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS种类               DOM访问情况     JS访问情况     直接跨域    调试方式                 可访问的API			</span><br><span class="line">injected script     可以访问        可以访问        不可以      直接普通的F12即可        和普通JS无任何差别，不能访问任何扩展API		</span><br><span class="line">content script      可以访问        不可以	       不可以       打开Console             只能访问 extension、runtime等部分API		</span><br><span class="line">popup js	        不可直接访问     不可以	        可以        popup页面右键审查元素     可访问绝大部分API，除了devtools系列		</span><br><span class="line">background js	    不可直接访问     不可以	        可以        插件管理页点击背景页即可   可访问绝大部分API，除了devtools系列		</span><br><span class="line">devtools js	        可以            可以	      不可以       暂无                   只能访问 devtools、extension、runtime等部分API</span><br></pre></td></tr></table></figure>

<h1 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h1><p>通信主页：<a href="https://developer.chrome.com/extensions/messaging" target="_blank" rel="noopener">https://developer.chrome.com/extensions/messaging</a></p>
<p>前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。</p>
<h2 id="互相通信概览"><a href="#互相通信概览" class="headerlink" title="互相通信概览"></a>互相通信概览</h2><p>注：-表示不存在或者无意义，或者待验证。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    injected-script         content-script	            popup-js	            background-js</span><br><span class="line">injected-script	        -	                window.postMessage	            -	                -</span><br><span class="line">content-script	    window.postMessage	        -	                chrome.runtime.sendMessage  chrome.runtime.sendMessage</span><br><span class="line">                                                                    chrome.runtime.connect	    chrome.runtime.connect</span><br><span class="line">popup-js	            -	                chrome.tabs.sendMessage          -                  chrome.extension. getBackgroundPage()</span><br><span class="line">                                            chrome.tabs.connect</span><br><span class="line">background-js	        -	                chrome.tabs.sendMessage  chrome.extension.getViews  -</span><br><span class="line">                                            chrome.tabs.connect		</span><br><span class="line">devtools-js	chrome.devtools.inspectedWindow.eval	-	             chrome.runtime.sendMessage	chrome.runtime.sendMessage</span><br></pre></td></tr></table></figure>
<h2 id="通信详细介绍"><a href="#通信详细介绍" class="headerlink" title="通信详细介绍"></a>通信详细介绍</h2><h3 id="popup和background"><a href="#popup和background" class="headerlink" title="popup和background"></a>popup和background</h3><p>popup可以直接调用background中的JS方法，也可以直接访问background的DOM：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; background.js</span><br><span class="line">function test()</span><br><span class="line">&#123;</span><br><span class="line">	alert(&#39;我是background！&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; popup.js</span><br><span class="line">var bg &#x3D; chrome.extension.getBackgroundPage();</span><br><span class="line">bg.test(); &#x2F;&#x2F; 访问bg的函数</span><br><span class="line">alert(bg.document.body.innerHTML); &#x2F;&#x2F; 访问bg的DOM</span><br></pre></td></tr></table></figure>
<p>至于background访问popup如下（前提是popup已经打开）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var views &#x3D; chrome.extension.getViews(&#123;type:&#39;popup&#39;&#125;);</span><br><span class="line">if(views.length &gt; 0) &#123;</span><br><span class="line">	console.log(views[0].location.href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="popup或者bg向content主动发送消息"><a href="#popup或者bg向content主动发送消息" class="headerlink" title="popup或者bg向content主动发送消息"></a>popup或者bg向content主动发送消息</h3><p>background.js或者popup.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		chrome.tabs.sendMessage(tabs[<span class="number">0</span>].id, message, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(response);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sendMessageToContentScript(&#123;<span class="attr">cmd</span>:<span class="string">'test'</span>, <span class="attr">value</span>:<span class="string">'你好，我是popup！'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'来自content的回复：'</span>+response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-script.js接收：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// console.log(sender.tab ?"from a content script:" + sender.tab.url :"from the extension");</span></span><br><span class="line">	<span class="keyword">if</span>(request.cmd == <span class="string">'test'</span>) alert(request.value);</span><br><span class="line">	sendResponse(<span class="string">'我收到了你的消息！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。</p>
<p>网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。</p>
<h3 id="content-script主动发消息给后台"><a href="#content-script主动发消息给后台" class="headerlink" title="content-script主动发消息给后台"></a>content-script主动发消息给后台</h3><p>content-script.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.runtime.sendMessage(&#123;<span class="attr">greeting</span>: <span class="string">'你好，我是content-script呀，我主动发消息给后台！'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到来自后台的回复：'</span> + response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>background.js 或者 popup.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听来自content-script的消息</span></span><br><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到来自content-script的消息：'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(request, sender, sendResponse);</span><br><span class="line">	sendResponse(<span class="string">'我是后台，我已收到你的消息：'</span> + <span class="built_in">JSON</span>.stringify(request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转；</li>
<li>如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；</li>
</ul>
<h3 id="injected-script和content-script"><a href="#injected-script和content-script" class="headerlink" title="injected script和content-script"></a>injected script和content-script</h3><p>content-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：</p>
<p>可以通过window.postMessage和window.addEventListener来实现二者消息通讯；</p>
<p>通过自定义DOM事件来实现；<br>第一种方法（推荐）：</p>
<p>injected-script中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(&#123;<span class="string">"test"</span>: <span class="string">'你好！'</span>&#125;, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure>
<p>content script中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>第二种方法：</p>
<p>injected-script中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customEvent = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line">customEvent.initEvent(<span class="string">'myCustomEvent'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fireCustomEvent</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	hiddenDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>);</span><br><span class="line">	hiddenDiv.innerText = data</span><br><span class="line">	hiddenDiv.dispatchEvent(customEvent);</span><br><span class="line">&#125;</span><br><span class="line">fireCustomEvent(<span class="string">'你好，我是普通JS！'</span>);</span><br></pre></td></tr></table></figure>
<p>content-script.js中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hiddenDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>);</span><br><span class="line"><span class="keyword">if</span>(!hiddenDiv) &#123;</span><br><span class="line">	hiddenDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">	hiddenDiv.style.display = <span class="string">'none'</span>;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(hiddenDiv);</span><br><span class="line">&#125;</span><br><span class="line">hiddenDiv.addEventListener(<span class="string">'myCustomEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> eventData = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>).innerText;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到自定义事件消息：'</span> + eventData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。</p>
<p>短连接的话，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。</p>
<p>短连接上面已经有代码示例了，这里只讲一下长连接。</p>
<p>popup.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getCurrentTabId(<span class="function">(<span class="params">tabId</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> port = chrome.tabs.connect(tabId, &#123;<span class="attr">name</span>: <span class="string">'test-connect'</span>&#125;);</span><br><span class="line">	port.postMessage(&#123;<span class="attr">question</span>: <span class="string">'你是谁啊？'</span>&#125;);</span><br><span class="line">	port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">'收到消息：'</span>+msg.answer);</span><br><span class="line">		<span class="keyword">if</span>(msg.answer &amp;&amp; msg.answer.startsWith(<span class="string">'我是'</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			port.postMessage(&#123;<span class="attr">question</span>: <span class="string">'哦，原来是你啊！'</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-script.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听长连接</span></span><br><span class="line">chrome.runtime.onConnect.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">port</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(port);</span><br><span class="line">	<span class="keyword">if</span>(port.name == <span class="string">'test-connect'</span>) &#123;</span><br><span class="line">		port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'收到长连接消息：'</span>, msg);</span><br><span class="line">			<span class="keyword">if</span>(msg.question == <span class="string">'你是谁啊？'</span>) port.postMessage(&#123;<span class="attr">answer</span>: <span class="string">'我是你爸！'</span>&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="其它补充"><a href="#其它补充" class="headerlink" title="其它补充"></a>其它补充</h1><h2 id="动态注入或执行JS"><a href="#动态注入或执行JS" class="headerlink" title="动态注入或执行JS"></a>动态注入或执行JS</h2><p>虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。</p>
<p>示例manifest.json配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"动态JS注入演示"</span>,</span><br><span class="line">	...</span><br><span class="line">	"permissions": [</span><br><span class="line">		"tabs", "http://*/*", "https://*/*"</span><br><span class="line">	],</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态执行JS代码</span></span><br><span class="line">chrome.tabs.executeScript(tabId, &#123;<span class="attr">code</span>: <span class="string">'document.body.style.backgroundColor="red"'</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行JS文件</span></span><br><span class="line">chrome.tabs.executeScript(tabId, &#123;<span class="attr">file</span>: <span class="string">'some-script.js'</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="动态注入CSS"><a href="#动态注入CSS" class="headerlink" title="动态注入CSS"></a>动态注入CSS</h2><p>示例manifest.json配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"动态CSS注入演示"</span>,</span><br><span class="line">	...</span><br><span class="line">	"permissions": [</span><br><span class="line">		"tabs", "http://*/*", "https://*/*"</span><br><span class="line">	],</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态执行CSS代码，TODO，这里有待验证</span></span><br><span class="line">chrome.tabs.insertCSS(tabId, &#123;<span class="attr">code</span>: <span class="string">'xxx'</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行CSS文件</span></span><br><span class="line">chrome.tabs.insertCSS(tabId, &#123;<span class="attr">file</span>: <span class="string">'some-style.css'</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前窗口ID"><a href="#获取当前窗口ID" class="headerlink" title="获取当前窗口ID"></a>获取当前窗口ID</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params">currentWindow</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'当前窗口ID：'</span> + currentWindow.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前标签页ID"><a href="#获取当前标签页ID" class="headerlink" title="获取当前标签页ID"></a>获取当前标签页ID</h2><p>一般有2种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId</span>(<span class="params">callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params">currentWindow</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">windowId</span>: currentWindow.id&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是：</p>
<p>chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到；<br>chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；<br>需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数据，第一个参数是指定要读取的key以及设置默认值</span></span><br><span class="line">chrome.storage.sync.get(&#123;<span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(items.color, items.age);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">chrome.storage.sync.set(&#123;<span class="attr">color</span>: <span class="string">'blue'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'保存成功！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="webRequest"><a href="#webRequest" class="headerlink" title="webRequest"></a>webRequest</h2><p>通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过beforeRequest来简单演示一下它的冰山一角：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 权限申请</span></span><br><span class="line">	<span class="attr">"permissions"</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">"webRequest"</span>, <span class="comment">// web请求</span></span><br><span class="line">		<span class="string">"webRequestBlocking"</span>, <span class="comment">// 阻塞式web请求</span></span><br><span class="line">		<span class="string">"storage"</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line">		<span class="string">"http://*/*"</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">		<span class="string">"https://*/*"</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">	],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="comment">// 是否显示图片</span></span><br><span class="line"><span class="keyword">var</span> showImage;</span><br><span class="line">chrome.storage.sync.get(&#123;<span class="attr">showImage</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	showImage = items.showImage;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking</span></span><br><span class="line">chrome.webRequest.onBeforeRequest.addListener(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// cancel 表示取消本次请求</span></span><br><span class="line">	<span class="keyword">if</span>(!showImage &amp;&amp; details.type == <span class="string">'image'</span>) <span class="keyword">return</span> &#123;<span class="attr">cancel</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	<span class="comment">// 简单的音视频检测</span></span><br><span class="line">	<span class="comment">// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义</span></span><br><span class="line">	<span class="keyword">if</span>(details.type == <span class="string">'media'</span>) &#123;</span><br><span class="line">		chrome.notifications.create(<span class="literal">null</span>, &#123;</span><br><span class="line">			type: <span class="string">'basic'</span>,</span><br><span class="line">			iconUrl: <span class="string">'img/icon.png'</span>,</span><br><span class="line">			title: <span class="string">'检测到音视频'</span>,</span><br><span class="line">			message: <span class="string">'音视频地址：'</span> + details.url,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">"&lt;all_urls&gt;"</span>]&#125;, [<span class="string">"blocking"</span>]);</span><br></pre></td></tr></table></figure>
<p>8.7. 国际化<br>插件根目录新建一个名为_locales的文件夹，再在下面新建一些语言的文件夹，如en、zh_CN、zh_TW，然后再在每个文件夹放入一个messages.json，同时必须在清单文件中设置default_locale。</p>
<p>_locales\en\messages.json内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"pluginDesc"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"A simple chrome extension demo"</span>&#125;,</span><br><span class="line">	<span class="attr">"helloWorld"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"Hello World!"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_locales\zh_CN\messages.json内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"pluginDesc"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"一个简单的Chrome插件demo"</span>&#125;,</span><br><span class="line">	<span class="attr">"helloWorld"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"你好啊，世界！"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在manifest.json和CSS文件中通过<strong>MSG_messagename</strong>引入，如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"description"</span>: <span class="string">"__MSG_pluginDesc__"</span>,</span><br><span class="line">	<span class="comment">// 默认语言</span></span><br><span class="line">	<span class="attr">"default_locale"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS中则直接chrome.i18n.getMessage(“helloWorld”)。</p>
<p>测试时，通过给chrome建立一个不同的快捷方式chrome.exe –lang=en来切换语言，如：</p>
<h2 id="API总结"><a href="#API总结" class="headerlink" title="API总结"></a>API总结</h2><p>比较常用用的一些API系列：</p>
<ul>
<li>chrome.tabs</li>
<li>chrome.runtime</li>
<li>chrome.webRequest</li>
<li>chrome.window</li>
<li>chrome.storage</li>
<li>chrome.contextMenus</li>
<li>chrome.devtools</li>
<li>chrome.extension</li>
</ul>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="查看已安装插件路径"><a href="#查看已安装插件路径" class="headerlink" title="查看已安装插件路径"></a>查看已安装插件路径</h2><p>windows 已安装的插件源码路径：C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，源码。</p>
<p>如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。</p>
<h1 id="打包与发布"><a href="#打包与发布" class="headerlink" title="打包与发布"></a>打包与发布</h1><h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><p>打开插件管理页面：chrome://extensions/<br>开启开发者 模式<br>既可以部署解压的插件，以及打包插件</p>
<h2 id="打包插件"><a href="#打包插件" class="headerlink" title="打包插件"></a>打包插件</h2><p>打包的话直接在插件管理页有一个打包按钮：然后会生成一个.crx文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p>推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）：</p>
<p><a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">Chrome插件官方文档主页</a><br><a href="https://developer.chrome.com/extensions/samples" target="_blank" rel="noopener">Chrome插件官方示例</a><br><a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="noopener">manifest清单文件</a><br><a href="https://developer.chrome.com/extensions/permissions" target="_blank" rel="noopener">permissions权限</a><br><a href="https://developer.chrome.com/extensions/api_index" target="_blank" rel="noopener">chrome.xxx.api文档</a><br><a href="https://developer.chrome.com/extensions/match_patterns" target="_blank" rel="noopener">模糊匹配规则语法详解</a></p>
<p>参看地址：<a href="https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>009-Mysql 在线新建或重做主从</title>
    <url>/articles/20200319/4f016687.html</url>
    <content><![CDATA[<p>摘要：009-Mysql 在线新建或重做主从<br>以前停服做主从的主要目的是想锁表，是想找到 master_log_file 和 master_log_pos 两个参数。如果有方法在不停服的情况下，能确定这两个参数，那么在线建立主从架构的功能，就可以实现了。</p>
<a id="more"></a>
<p>注意：主端不停服的前提是，它已经开启了bin-log 日志！！</p>
<h1 id="主从新建过程"><a href="#主从新建过程" class="headerlink" title="主从新建过程"></a>主从新建过程</h1><p>如果之前在主库没有开启 bin-log 日志，那就没有办法，因为配置 bin-log 日志之后，主库一定要重启才能生效。不过，如果现在的情况是重做主库，那就证明之前是做过主从的，只是可能主从失效了需要重做。这种情况，主库也不需要重启，只要重新备份一下数据库，就可以重建从库了。</p>
<h2 id="主从新建过程-主库操作"><a href="#主从新建过程-主库操作" class="headerlink" title="主从新建过程-主库操作"></a>主从新建过程-主库操作</h2><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><p>在主库修改配置文件 my.cnf ，添加开启 bin-log 日志，格式用 row</p>
<p>server-id=1<br>log-bin=mysql-bin<br>binlog-format=ROW</p>
<p>如果之前已经开启了bin-log 功能，就不用修改了。</p>
<h3 id="主库创建用户以及授权"><a href="#主库创建用户以及授权" class="headerlink" title="主库创建用户以及授权"></a>主库创建用户以及授权</h3><p>接着在主库上进行备份用户的授权操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'repel'</span>@<span class="string">'172.10.0.1'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure>
<p>授权给从库的 ip 地址，备份的用户名是 repel，建议不要使用 ‘repel’@’%’ 这种方式进行授权操作，主要是为了安全问题，限制授权的 ip 白名单。</p>
<h3 id="主库将需要备份的数据库导出来："><a href="#主库将需要备份的数据库导出来：" class="headerlink" title="主库将需要备份的数据库导出来："></a>主库将需要备份的数据库导出来：</h3><p>用 mysqldump 的方式，以下是导出整个数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p  <span class="comment">--single-transaction --no-autocommit --master-data=2 -A &gt;test2.sql</span></span><br></pre></td></tr></table></figure>
<p>用 mysqldump 的方式，如果主端 Mysql 上有不止一个项目的业务库，但是只想导出其中一个业务库，假设叫做 hr_mysql 数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p  <span class="comment">--single-transaction --no-autocommit --master-data=2  hr_mysql &gt; hr_mysql_dump.sql</span></span><br></pre></td></tr></table></figure>
<p>关键的参数 “–master-data=2”，能帮助实现在线重建主从数据库。<br>将hr_mysql_dump.sql传输给从库。</p>
<h2 id="主从新建过程-从库操作"><a href="#主从新建过程-从库操作" class="headerlink" title="主从新建过程-从库操作"></a>主从新建过程-从库操作</h2><h3 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h3><p>修改从库 my.cnf ，只备份 hr_mysql 业务库，所以只增加了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id&#x3D;2</span><br><span class="line">replicate_wild_do_table&#x3D;hr_mysql.%</span><br></pre></td></tr></table></figure>
<p>其实如果进行的是全库备份，那么只要配置 server-id 和主库不一样就可以了，其他的不需要增加。<br>但是，如果只想备份某些特定的业务库，就需要使用 replicate_wild_do_table 这个参数了。它的作用是告诉从库只需要备份特定的库，如果有多个库，就继续用逗号隔开添加即可。<br>还有一个功能相反的参数 replicate_wild_ignore_table ,是配置忽略的数据库，即不备份的数据库，这个参数使用起来比较多限制，不熟悉最好不使用。</p>
<h3 id="导入主库数据"><a href="#导入主库数据" class="headerlink" title="导入主库数据"></a>导入主库数据</h3><p>接下来是导入数据库，在导入数据库前，需要重置一下从库binlog：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p   -e '<span class="keyword">reset</span> <span class="keyword">master</span><span class="string">'</span></span><br><span class="line"><span class="string">mysql -uroot -p   hr_mysql &lt; hr_mysql_dump.sql</span></span><br></pre></td></tr></table></figure>

<h3 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h3><p>在备份数据库的时候，使用了一个关键的参数 –master-data=2。在备份文件中，可以看到需要的 master_log_file 和 master_log_pos 两个参数。有了这两个参数，我们就不需要像以往那样停服锁表，来查看了。</p>
<p>具体怎么查找这两个参数？它们大概在dump文件的前 30 行以内，所以可以用 head 命令找到：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">head -n 30 feitian_dump.sql</span><br></pre></td></tr></table></figure>
<p>在上面的输出，可以看到 binlog 是 mysql-bin.000063，position 是 144333309.有了这两个参数，就可以配置从库同步了。</p>
<p>一般在从库 change master to 就可以了。</p>
<p>所以，在从库做以下配置：</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>005-mysql-查看MYSQL数据库中所有用户及拥有权限</title>
    <url>/articles/20200319/b9b0f2a9.html</url>
    <content><![CDATA[<p>摘要：005-mysql-查看MYSQL数据库中所有用户及拥有权限</p>
<a id="more"></a>

<h1 id="查看MYSQL数据库中所有用户"><a href="#查看MYSQL数据库中所有用户" class="headerlink" title="查看MYSQL数据库中所有用户"></a>查看MYSQL数据库中所有用户</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">CONCAT</span>(<span class="string">'User: '''</span>,<span class="keyword">user</span>,<span class="string">'''@'''</span>,host,<span class="string">''';'</span>) <span class="keyword">AS</span> <span class="keyword">query</span> <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"><span class="comment">-- +------------------------------------+</span></span><br><span class="line"><span class="comment">-- | query                              |</span></span><br><span class="line"><span class="comment">-- +------------------------------------+</span></span><br><span class="line"><span class="comment">-- | User: 'root'@'%';                  |</span></span><br><span class="line"><span class="comment">-- | User: 'mysql.session'@'localhost'; |</span></span><br><span class="line"><span class="comment">-- | User: 'mysql.sys'@'localhost';     |</span></span><br><span class="line"><span class="comment">-- | User: 'root'@'localhost';          |</span></span><br><span class="line"><span class="comment">-- +------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>查看数据库中具体某个用户的权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">'root'</span>@<span class="string">'%'</span>; </span><br><span class="line"><span class="comment">-- +-------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- | Grants for root@%                                           |</span></span><br><span class="line"><span class="comment">-- +-------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- | GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION |</span></span><br><span class="line"><span class="comment">-- +-------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- 1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.user <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span> \G   </span><br><span class="line"><span class="comment">-- *************************** 1. row ***************************</span></span><br><span class="line"><span class="comment">--                   Host: localhost</span></span><br><span class="line"><span class="comment">--                   User: root</span></span><br><span class="line"><span class="comment">--            Select_priv: Y</span></span><br><span class="line"><span class="comment">--            Insert_priv: Y</span></span><br><span class="line"><span class="comment">--            Update_pr</span></span><br><span class="line"><span class="comment">--              ……</span></span><br></pre></td></tr></table></figure>

<p>查看user表结构　需要具体的项可结合表结构来查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc mysql.user;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>008-mysql5.7配置文件</title>
    <url>/articles/20200319/c5078da8.html</url>
    <content><![CDATA[<p>摘要：008-mysql5.7配置文件</p>
<a id="more"></a>

<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 53306:3306 --name mymysql57 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">docker <span class="built_in">exec</span> -it mymysql57 /bin/bash</span><br></pre></td></tr></table></figure>
<p>进入docker后查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /etc</span><br></pre></td></tr></table></figure>
<p>没有 my.cnf,存在mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /etc/mysql</span><br><span class="line"><span class="comment"># conf.d	my.cnf	my.cnf.fallback  mysql.cnf  mysql.conf.d</span></span><br><span class="line">cat /etc/mysql/my.cnf</span><br><span class="line"><span class="comment"># 意思是配置文件在这两个目录下</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/conf.d/</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/mysql.conf.d/</span></span><br><span class="line">cat /etc/mysql/mysql.cnf</span><br><span class="line"><span class="comment"># 意思是配置文件在这两个目录下</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/conf.d/</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/mysql.conf.d/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------</span></span><br><span class="line">ls /etc/mysql/conf.d/</span><br><span class="line"><span class="comment"># docker.cnf  mysql.cnf  mysqldump.cnf</span></span><br><span class="line">cat /etc/mysql/conf.d/docker.cnf</span><br><span class="line"><span class="comment"># [mysqld]</span></span><br><span class="line"><span class="comment"># skip-host-cache</span></span><br><span class="line"><span class="comment"># skip-name-resolve</span></span><br><span class="line">cat /etc/mysql/conf.d/mysql.cnf</span><br><span class="line"><span class="comment"># 空</span></span><br><span class="line">cat /etc/mysql/conf.d/mysqldump.cnf</span><br><span class="line"><span class="comment"># [mysqldump]</span></span><br><span class="line"><span class="comment"># quick</span></span><br><span class="line"><span class="comment"># quote-names</span></span><br><span class="line"><span class="comment"># max_allowed_packet	= 16M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------</span></span><br><span class="line">ls /etc/mysql/mysql.conf.d/</span><br><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line">cat /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"><span class="comment"># [mysqld]</span></span><br><span class="line"><span class="comment"># pid-file	= /var/run/mysqld/mysqld.pid</span></span><br><span class="line"><span class="comment"># socket		= /var/run/mysqld/mysqld.sock</span></span><br><span class="line"><span class="comment"># datadir		= /var/lib/mysql</span></span><br><span class="line"><span class="comment"># #log-error	= /var/log/mysql/error.log</span></span><br><span class="line"><span class="comment"># # By default we only accept connections from localhost</span></span><br><span class="line"><span class="comment"># #bind-address	= 127.0.0.1</span></span><br><span class="line"><span class="comment"># # Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line"><span class="comment"># symbolic-links=0</span></span><br></pre></td></tr></table></figure>

<p>故核心配置在： /etc/mysql/mysql.conf.d/mysqld.cnf</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>005-opencv中numpy数组与图像类型转换</title>
    <url>/articles/20200302/b2b98e8d.html</url>
    <content><![CDATA[<p>摘要：005-opencv中numpy数组与图像类型转换</p>
<p>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/005</p>
<a id="more"></a>

<h1 id="numpy数组与图像类型转换"><a href="#numpy数组与图像类型转换" class="headerlink" title="numpy数组与图像类型转换"></a>numpy数组与图像类型转换</h1><p>Python OpenCV存储图像使用的是Numpy存储，所以可以将Numpy当做图像类型操作，操作之前还需进行类型转换，转换到int8类型</p>
<h2 id="遍历图片三个通道像素点，并修改相应的RGB"><a href="#遍历图片三个通道像素点，并修改相应的RGB" class="headerlink" title="遍历图片三个通道像素点，并修改相应的RGB"></a>遍历图片三个通道像素点，并修改相应的RGB</h2>]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>004-opencv目标区域图像分割</title>
    <url>/articles/20200301/d2b99b52.html</url>
    <content><![CDATA[<p>摘要：004-opencv目标区域图像分割</p>
<p>使用OpenCV截取目标区域</p>
<p>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/004</p>
<a id="more"></a>

<h1 id="指定图像位置的裁剪处理"><a href="#指定图像位置的裁剪处理" class="headerlink" title="指定图像位置的裁剪处理"></a>指定图像位置的裁剪处理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 遍历指定目录，显示目录下的所有文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CropImage4File</span><span class="params">(filepath,destpath)</span>:</span></span><br><span class="line">    pathDir =  os.listdir(filepath)    <span class="comment"># 列出文件路径中的所有路径或文件</span></span><br><span class="line">    <span class="keyword">for</span> allDir <span class="keyword">in</span> pathDir:</span><br><span class="line">        child = os.path.join(filepath, allDir)</span><br><span class="line">        dest = os.path.join(destpath,allDir)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(child):</span><br><span class="line">            image = cv2.imread(child)</span><br><span class="line">            <span class="comment"># 获取图像形状 返回 行数值，列数值列表</span></span><br><span class="line">            sp=image.shape</span><br><span class="line">            <span class="comment">#图像的高度（行 范围）</span></span><br><span class="line">            sz1 = sp[<span class="number">0</span>]       </span><br><span class="line">            <span class="comment">#图像的宽度（列 范围）          </span></span><br><span class="line">            sz2 = sp[<span class="number">1</span>]                 </span><br><span class="line">            <span class="comment">#sz3 = sp[2]                #像素值由【RGB】三原色组成</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#你想对文件的操作</span></span><br><span class="line">            a=int(sz1/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># x start</span></span><br><span class="line">            b=int(sz1/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># x end</span></span><br><span class="line">            c=int(sz2/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># y start</span></span><br><span class="line">            d=int(sz2/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># y end</span></span><br><span class="line">            cropImg = image[a:b,c:d]   <span class="comment">#裁剪图像</span></span><br><span class="line">            cv2.imwrite(dest,cropImg)  <span class="comment">#写入图像路径</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    filepath =<span class="string">'src/python-opencv/'</span>             <span class="comment">#源图像</span></span><br><span class="line">    destpath=<span class="string">'src/python-opencv/003-cut/dist_img'</span>        <span class="comment"># resized images saved here</span></span><br><span class="line">    CropImage4File(filepath,destpath)</span><br></pre></td></tr></table></figure>

<h1 id="批量处理—指定图像位置的裁剪"><a href="#批量处理—指定图像位置的裁剪" class="headerlink" title="批量处理—指定图像位置的裁剪"></a>批量处理—指定图像位置的裁剪</h1><p>我这个是用来截取发票的印章区域，用于图像分割（公司的数据集保密）<br>各位可以用自己的增值发票裁剪。适当的更改截取区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    scale = len(img_paths)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">1000</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">1000</span>)-int(i/<span class="number">1000</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        print(<span class="string">'正在处理图像： %s'</span> % img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>])</span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        weight = img.shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> weight&gt;<span class="number">1600</span>:                         <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">50</span>:<span class="number">200</span>, <span class="number">700</span>:<span class="number">1500</span>]    <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            <span class="comment">#cropImg = cv2.resize(cropImg, None, fx=0.5, fy=0.5,</span></span><br><span class="line">                                 <span class="comment">#interpolation=cv2.INTER_CUBIC) #缩小图像</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                        <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span>+img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c,a,b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    print(<span class="string">'图片获取完成 。。。！'</span>)</span><br><span class="line">    cut_img(img_paths,output_dir)</span><br></pre></td></tr></table></figure>

<h1 id="多进程（加快处理）"><a href="#多进程（加快处理）" class="headerlink" title="多进程（加快处理）"></a>多进程（加快处理）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">采用多进程加快处理。添加了在读取图片时捕获异常，OpenCV对大分辨率或者tif格式图片支持不好</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    imread_failed = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        img = cv2.imread(img_paths)</span><br><span class="line">        height, weight = img.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1.0</span> * height / weight) &lt; <span class="number">1.3</span>:       <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]     <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/1'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                   <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">30</span>:<span class="number">60</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> r:</span><br><span class="line">        print(<span class="string">"error:"</span>,r)</span><br><span class="line">        imread_failed.append(img_paths)</span><br><span class="line">    <span class="keyword">return</span> imread_failed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(input_dir,output_dir)</span>:</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    scale = len(img_paths)</span><br><span class="line"></span><br><span class="line">    results = []</span><br><span class="line">    pool = multiprocessing.Pool(processes = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">10</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">10</span>)-int(i/<span class="number">10</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        results.append(pool.apply_async(cut_img, (img_path,output_dir )))</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c, a, b)) <span class="comment"># 进度条（可用tqdm）</span></span><br><span class="line">    pool.close()                        <span class="comment"># 调用join之前，先调用close函数，否则会出错。</span></span><br><span class="line">    pool.join()                         <span class="comment"># join函数等待所有子进程结束</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        print(<span class="string">'image read failed!:'</span>, result.get())</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"All done."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    main(input_dir, output_dir)</span><br><span class="line">    <span class="comment"># cv2.imshow('imgflip_1',imgflip_1)</span></span><br></pre></td></tr></table></figure>
<p>更多：<a href="https://blog.csdn.net/sinat_36458870/article/details/78825571" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36458870/article/details/78825571</a></p>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>003-opencv图像指定区域裁剪</title>
    <url>/articles/20200301/a2f0259b.html</url>
    <content><![CDATA[<p>摘要：003-opencv图像指定区域裁剪</p>
<p>在工作中。在做数据集时，需要对图片进行处理，照相的图片我们只需要特定的部分，所以就想到裁剪一种所需的部分。当然若是图片有规律可循则使用opencv对其进行膨胀腐蚀等操作。这样更精准一些。</p>
<p>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/003-cut</p>
<a id="more"></a>

<h1 id="指定图像位置的裁剪处理"><a href="#指定图像位置的裁剪处理" class="headerlink" title="指定图像位置的裁剪处理"></a>指定图像位置的裁剪处理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 遍历指定目录，显示目录下的所有文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CropImage4File</span><span class="params">(filepath,destpath)</span>:</span></span><br><span class="line">    pathDir =  os.listdir(filepath)    <span class="comment"># 列出文件路径中的所有路径或文件</span></span><br><span class="line">    <span class="keyword">for</span> allDir <span class="keyword">in</span> pathDir:</span><br><span class="line">        child = os.path.join(filepath, allDir)</span><br><span class="line">        dest = os.path.join(destpath,allDir)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(child):</span><br><span class="line">            image = cv2.imread(child)</span><br><span class="line">            <span class="comment"># 获取图像形状 返回 行数值，列数值列表</span></span><br><span class="line">            sp=image.shape</span><br><span class="line">            <span class="comment">#图像的高度（行 范围）</span></span><br><span class="line">            sz1 = sp[<span class="number">0</span>]       </span><br><span class="line">            <span class="comment">#图像的宽度（列 范围）          </span></span><br><span class="line">            sz2 = sp[<span class="number">1</span>]                 </span><br><span class="line">            <span class="comment">#sz3 = sp[2]                #像素值由【RGB】三原色组成</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#你想对文件的操作</span></span><br><span class="line">            a=int(sz1/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># x start</span></span><br><span class="line">            b=int(sz1/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># x end</span></span><br><span class="line">            c=int(sz2/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># y start</span></span><br><span class="line">            d=int(sz2/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># y end</span></span><br><span class="line">            cropImg = image[a:b,c:d]   <span class="comment">#裁剪图像</span></span><br><span class="line">            cv2.imwrite(dest,cropImg)  <span class="comment">#写入图像路径</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    filepath =<span class="string">'src/python-opencv/'</span>             <span class="comment">#源图像</span></span><br><span class="line">    destpath=<span class="string">'src/python-opencv/003-cut/dist_img'</span>        <span class="comment"># resized images saved here</span></span><br><span class="line">    CropImage4File(filepath,destpath)</span><br></pre></td></tr></table></figure>

<h1 id="批量处理—指定图像位置的裁剪"><a href="#批量处理—指定图像位置的裁剪" class="headerlink" title="批量处理—指定图像位置的裁剪"></a>批量处理—指定图像位置的裁剪</h1><p>我这个是用来截取发票的印章区域，用于图像分割（公司的数据集保密）<br>各位可以用自己的增值发票裁剪。适当的更改截取区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    scale = len(img_paths)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">1000</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">1000</span>)-int(i/<span class="number">1000</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        print(<span class="string">'正在处理图像： %s'</span> % img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>])</span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        weight = img.shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> weight&gt;<span class="number">1600</span>:                         <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">50</span>:<span class="number">200</span>, <span class="number">700</span>:<span class="number">1500</span>]    <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            <span class="comment">#cropImg = cv2.resize(cropImg, None, fx=0.5, fy=0.5,</span></span><br><span class="line">                                 <span class="comment">#interpolation=cv2.INTER_CUBIC) #缩小图像</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                        <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span>+img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c,a,b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    print(<span class="string">'图片获取完成 。。。！'</span>)</span><br><span class="line">    cut_img(img_paths,output_dir)</span><br></pre></td></tr></table></figure>

<h1 id="多进程（加快处理）"><a href="#多进程（加快处理）" class="headerlink" title="多进程（加快处理）"></a>多进程（加快处理）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">采用多进程加快处理。添加了在读取图片时捕获异常，OpenCV对大分辨率或者tif格式图片支持不好</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    imread_failed = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        img = cv2.imread(img_paths)</span><br><span class="line">        height, weight = img.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1.0</span> * height / weight) &lt; <span class="number">1.3</span>:       <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]     <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/1'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                   <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">30</span>:<span class="number">60</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> r:</span><br><span class="line">        print(<span class="string">"error:"</span>,r)</span><br><span class="line">        imread_failed.append(img_paths)</span><br><span class="line">    <span class="keyword">return</span> imread_failed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(input_dir,output_dir)</span>:</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    scale = len(img_paths)</span><br><span class="line"></span><br><span class="line">    results = []</span><br><span class="line">    pool = multiprocessing.Pool(processes = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">10</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">10</span>)-int(i/<span class="number">10</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        results.append(pool.apply_async(cut_img, (img_path,output_dir )))</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c, a, b)) <span class="comment"># 进度条（可用tqdm）</span></span><br><span class="line">    pool.close()                        <span class="comment"># 调用join之前，先调用close函数，否则会出错。</span></span><br><span class="line">    pool.join()                         <span class="comment"># join函数等待所有子进程结束</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        print(<span class="string">'image read failed!:'</span>, result.get())</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"All done."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    main(input_dir, output_dir)</span><br><span class="line">    <span class="comment"># cv2.imshow('imgflip_1',imgflip_1)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>002-opencv图像压缩</title>
    <url>/articles/20200229/576a7ff9.html</url>
    <content><![CDATA[<p>摘要：002-opencv图像压缩<br>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/002-enhance</p>
<a id="more"></a>

<h1 id="简单的图像压缩"><a href="#简单的图像压缩" class="headerlink" title="简单的图像压缩"></a>简单的图像压缩</h1><p>cv2的ImageEnhance模块</p>
<ul>
<li>ImageEnhance.Color(image) 颜色增强类：用于调整图像的颜色均衡</li>
<li>ImageEnhance.Brightness(image) 亮度增强类：用于调整图像的亮度。</li>
<li>ImageEnhance.Contrast(image) 对比度增强类：用于调整图像的对比度。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------直接读取--------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(imgPath,enhance)</span>:</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,0)    #读取图像（直接读取）</span></span><br><span class="line"></span><br><span class="line">    image=cv2.imread(imgPath)</span><br><span class="line">    res = cv2.resize(image, (image.shape[<span class="number">1</span>],image.shape[<span class="number">0</span>]), interpolation=cv2.INTER_AREA)</span><br><span class="line">    imgE = Image.fromarray(cv2.cvtColor(res,cv2.COLOR_BGR2RGB))</span><br><span class="line">    imgEH = ImageEnhance.Contrast(imgE)</span><br><span class="line">    <span class="comment"># 当参数为1.2 灰度图243KB，当参数为2.8 灰度图124KB.（亮度提升后转灰度图，图片会黑白分化）</span></span><br><span class="line">    gray=imgEH.enhance(enhance).convert(<span class="string">"L"</span>)</span><br><span class="line">    gray.save(<span class="string">r"src/python-opencv/002-enhance/dist_img/test_001_simple.gray."</span>+str(enhance)+<span class="string">".png"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#图像增强</span></span><br><span class="line">    <span class="comment"># 创建滤波器，使用不同的卷积核</span></span><br><span class="line">    gray2=gray.filter(ImageFilter.DETAIL)</span><br><span class="line">    gray2.save(<span class="string">r"src/python-opencv/002-enhance/dist_img/test_001_simple.gray2."</span>+str(enhance)+<span class="string">".png"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># #图像点运算</span></span><br><span class="line">    gray3=gray2.point(<span class="keyword">lambda</span> i:i*<span class="number">0.9</span>)</span><br><span class="line">    gray3.save(<span class="string">r"src/python-opencv/002-enhance/dist_img/test_001_simple.gray3."</span>+str(enhance)+<span class="string">".png"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># k = cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># if k == 27:                     # 按 Esc 退出（关闭显示窗口）</span></span><br><span class="line">    <span class="comment">#     cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    enhance=<span class="number">1.2</span></span><br><span class="line">    func(imgPath,enhance)</span><br><span class="line">    enhance=<span class="number">2.8</span></span><br><span class="line">    func(imgPath,enhance)</span><br></pre></td></tr></table></figure>

<h1 id="基于机器学习的图像压缩方法"><a href="#基于机器学习的图像压缩方法" class="headerlink" title="基于机器学习的图像压缩方法"></a>基于机器学习的图像压缩方法</h1><p>关于PCA降维，SVD理论详情：<a href="https://blog.csdn.net/wsp_1138886114/article/details/80967843" target="_blank" rel="noopener">https://blog.csdn.net/wsp_1138886114/article/details/80967843</a></p>
<h2 id="SVD图像压缩"><a href="#SVD图像压缩" class="headerlink" title="SVD图像压缩"></a>SVD图像压缩</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild_img</span><span class="params">(u, sigma, v, p)</span>:</span>  <span class="comment"># p表示奇异值的百分比</span></span><br><span class="line">    print(<span class="string">'sigma.shape'</span>, sigma.shape)</span><br><span class="line">    print(<span class="string">'sum(sigma)'</span>, sum(sigma))</span><br><span class="line">    m , n= len(u),len(v)</span><br><span class="line">    a = np.zeros((m, n))         <span class="comment"># 创建空图片</span></span><br><span class="line"></span><br><span class="line">    count = (int)(sum(sigma))</span><br><span class="line">    curSum = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> curSum &lt;= count * p:</span><br><span class="line">        uk = u[:, k].reshape(m, <span class="number">1</span>)</span><br><span class="line">        vk = v[k].reshape(<span class="number">1</span>, n)</span><br><span class="line">        a += sigma[k] * np.dot(uk, vk)</span><br><span class="line">        curSum += sigma[k]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'==k===:'</span>, k)</span><br><span class="line"></span><br><span class="line">    a[a &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    a[a &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> np.rint(a).astype(<span class="string">"uint8"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> np.arange(<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">0.2</span>):</span><br><span class="line">        u, sigma, v = np.linalg.svd(img[:, :, <span class="number">0</span>])</span><br><span class="line">        R = rebuild_img(u, sigma, v, p)</span><br><span class="line"></span><br><span class="line">        u, sigma, v = np.linalg.svd(img[:, :, <span class="number">1</span>])</span><br><span class="line">        G = rebuild_img(u, sigma, v, p)</span><br><span class="line"></span><br><span class="line">        u, sigma, v = np.linalg.svd(img[:, :, <span class="number">2</span>])</span><br><span class="line">        B = rebuild_img(u, sigma, v, p)</span><br><span class="line"></span><br><span class="line">        I = np.stack((R, G, B), <span class="number">2</span>)</span><br><span class="line">        cv2.imshow(<span class="string">"svd_"</span> + str(p * <span class="number">100</span>),I)</span><br><span class="line">        <span class="comment"># cv2.imwrite("src/python-opencv/002-enhance/dist_img_" + str(p * 100) + ".jpg", I)</span></span><br><span class="line">    cv2.imshow(<span class="string">"img"</span> , img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>奇异值分解能够有效的降低数据的维数，以本文的图片为例，从450维降到149维后，还保留了90%的信息<br>虽然奇异值分解很有效，但是不能滥用，一般情况下要求降维后信息的损失度不能超过5%，甚至是1%<br>Ng的视频中提到常见的错误使用降维的情况，在这里也贴出来：<br>使用降维解决过拟合问题<br>不论什么情况，先用降维处理一下数据，即把降维当做模型训练的必须步骤</p>
<h2 id="PCA图像压缩"><a href="#PCA图像压缩" class="headerlink" title="PCA图像压缩"></a>PCA图像压缩</h2><p>pca函数实现图像的降维<br>关于PCA理论详情请点击：<a href="https://blog.csdn.net/wsp_1138886114/article/details/80967843" target="_blank" rel="noopener">https://blog.csdn.net/wsp_1138886114/article/details/80967843</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comp_2d</span><span class="params">(image_2d,rate)</span>:</span></span><br><span class="line">    height,width = image_2d.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行下面这一行报错显示无法广播。我修改了dtype还是报错，不知道为何。</span></span><br><span class="line">    <span class="comment"># cov_mat = image_2d - np.mean(image_2d, axis=1) 。</span></span><br><span class="line">    <span class="comment"># print("data.type:", image_2d.astype(np.float64).dtype)</span></span><br><span class="line">    <span class="comment"># print("mean.type:", np.mean(image_2d, axis=1).dtype)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># print("data.shape:", image_2d.astype(np.float64).shape)</span></span><br><span class="line">    <span class="comment"># print("mean.shape:", np.mean(image_2d, axis=1).shape)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我自己广播代码为如下三行代码</span></span><br><span class="line">    mean_array = np.mean(image_2d, axis=<span class="number">1</span>)</span><br><span class="line">    mean_array = mean_array[:, np.newaxis]</span><br><span class="line">    mean_array = np.tile(mean_array, width)</span><br><span class="line"></span><br><span class="line">    cov_mat = image_2d.astype(np.float64) - mean_array</span><br><span class="line">    eig_val, eig_vec = np.linalg.eigh(np.cov(cov_mat))  <span class="comment"># 求特征值 特征向量</span></span><br><span class="line">    p = np.size(eig_vec, axis=<span class="number">1</span>)</span><br><span class="line">    idx = np.argsort(eig_val)</span><br><span class="line">    idx = idx[::<span class="number">-1</span>]</span><br><span class="line">    eig_vec = eig_vec[:, idx]</span><br><span class="line">    numpc = rate</span><br><span class="line">    <span class="keyword">if</span> numpc &lt; p <span class="keyword">or</span> numpc &gt; <span class="number">0</span>:</span><br><span class="line">        eig_vec = eig_vec[:, range(numpc)]</span><br><span class="line">    score = np.dot(eig_vec.T, cov_mat)</span><br><span class="line">    recon = np.dot(eig_vec, score) + mean_array</span><br><span class="line">    recon_img_mat = np.uint8(np.absolute(recon))</span><br><span class="line">    <span class="keyword">return</span> recon_img_mat</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    height, width = data.shape[:<span class="number">2</span>]</span><br><span class="line">    a_g = data[:, :, <span class="number">0</span>]</span><br><span class="line">    a_b = data[:, :, <span class="number">1</span>]</span><br><span class="line">    a_r = data[:, :, <span class="number">2</span>]</span><br><span class="line">    rates = [<span class="number">30</span>,<span class="number">60</span>,<span class="number">90</span>]  <span class="comment">#主成分前30，60，90个k值</span></span><br><span class="line">    <span class="keyword">for</span> rate <span class="keyword">in</span> rates:</span><br><span class="line">        g_recon, b_recon, r_recon = comp_2d(a_g,rate), comp_2d(a_b,rate), comp_2d(a_r,rate)</span><br><span class="line">        result = cv2.merge([g_recon, b_recon, r_recon])</span><br><span class="line">        cv2.imshow(<span class="string">'result_'</span>+str(rate),result)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>显然，k=30时就包含了矩阵的至少70%的信息含量，当k=90时就包含了矩阵的至少90%信息含量。</p>
<h1 id="基于K-means图像压缩"><a href="#基于K-means图像压缩" class="headerlink" title="基于K-means图像压缩"></a>基于K-means图像压缩</h1><h2 id="肘部法则"><a href="#肘部法则" class="headerlink" title="肘部法则"></a>肘部法则</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cdist</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]= [<span class="string">'SimHei'</span>]    <span class="comment">#中文注释</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>     <span class="comment">#显示正负号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    cluster1 = np.random.uniform(<span class="number">0.5</span>,<span class="number">1.5</span>,(<span class="number">2</span>,<span class="number">5</span>))    <span class="comment">#生成（0.5,1.5）之间的随机数（2行5列）</span></span><br><span class="line">    cluster2 = np.random.uniform(<span class="number">3.5</span>,<span class="number">4.5</span>,(<span class="number">2</span>,<span class="number">5</span>))</span><br><span class="line">    X = np.hstack((cluster1,cluster2)).T           <span class="comment">#列拼接 并转置（10行2列）</span></span><br><span class="line"></span><br><span class="line">    K = range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    meandistortions = []    <span class="comment">#存放聚类中心列表</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> K:</span><br><span class="line">        kmeans = KMeans(n_clusters=k)</span><br><span class="line">        kmeans.fit(X)       <span class="comment">#拟合训练</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#任一点到 簇中心点（1,2,3,4,5）的最小距离（计算过程：求和再求平均值）</span></span><br><span class="line">        meandistortions.append(sum(np.min(cdist(X,kmeans.cluster_centers_,<span class="string">'euclidean'</span>), axis=<span class="number">1</span>)) / X.shape[<span class="number">0</span>])</span><br><span class="line">        print(<span class="string">"第 &#123;&#125; 次-聚类中心"</span>.format(k))</span><br><span class="line">        print(cdist(X,kmeans.cluster_centers_,<span class="string">'euclidean'</span>))</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">"第 &#123;&#125; 次聚类时----任一点到这&#123;&#125;个聚类中心其中一个的最小值"</span>.format(k,k))</span><br><span class="line">        print(np.min(cdist(X,kmeans.cluster_centers_,<span class="string">'euclidean'</span>), axis=<span class="number">1</span>))</span><br><span class="line">    print(meandistortions)</span><br><span class="line">    plt.plot(K, meandistortions,<span class="string">'bx-'</span>) <span class="comment"># 颜色blue，线条为-</span></span><br><span class="line">    plt.xlabel(<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">    plt.ylabel(<span class="string">'Ave Distor'</span>)           <span class="comment"># plt.ylabel('平均畸变程度',fontproperties=font)</span></span><br><span class="line">    plt.title(<span class="string">'Elbow method value K'</span>)  <span class="comment"># plt.title('用肘部法则来确定最佳的K值',fontproperties=font);</span></span><br><span class="line">    plt.scatter(K,meandistortions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>

<h2 id="轮廓系数验证K值"><a href="#轮廓系数验证K值" class="headerlink" title="轮廓系数验证K值"></a>轮廓系数验证K值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cdist</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]= [<span class="string">'SimHei'</span>]    <span class="comment">#中文注释</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>     <span class="comment">#显示正负号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">10</span>)) </span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    x1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">    x2 = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">    X = np.array(list(zip(x1, x2))).reshape(len(x1), <span class="number">2</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">10</span>])                                   <span class="comment"># x轴的刻度</span></span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">10</span>])                                   <span class="comment"># y轴的刻度</span></span><br><span class="line">    plt.title(<span class="string">'Sample'</span>)</span><br><span class="line">    plt.scatter(x1, x2)</span><br><span class="line">    colors = [<span class="string">'b'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'c'</span>, <span class="string">'m'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'b'</span>]  <span class="comment">#样本点颜色</span></span><br><span class="line">    markers = [<span class="string">'o'</span>, <span class="string">'s'</span>, <span class="string">'D'</span>, <span class="string">'v'</span>, <span class="string">'^'</span>, <span class="string">'p'</span>, <span class="string">'*'</span>, <span class="string">'+'</span>] <span class="comment">#样本点形状</span></span><br><span class="line">    tests = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]                            <span class="comment">#簇的个数</span></span><br><span class="line">    subplot_counter = <span class="number">1</span>                                <span class="comment">#训练模型</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> tests:</span><br><span class="line">        subplot_counter += <span class="number">1</span></span><br><span class="line">        plt.subplot(<span class="number">3</span>, <span class="number">2</span>, subplot_counter)</span><br><span class="line">        kmeans_model = KMeans(n_clusters=t).fit(X)</span><br><span class="line">        <span class="keyword">for</span> i, l <span class="keyword">in</span> enumerate(kmeans_model.labels_):</span><br><span class="line">            plt.plot(x1[i], x2[i], color=colors[l], marker=markers[l],ls=<span class="string">'None'</span>)</span><br><span class="line">            plt.xlim([<span class="number">0</span>, <span class="number">10</span>])</span><br><span class="line">            plt.ylim([<span class="number">0</span>, <span class="number">10</span>])                       <span class="comment">#SCoefficient:轮廓系数[-1,1]</span></span><br><span class="line">            plt.title(<span class="string">'K = %s, SCoefficient = %.03f'</span> % (t, metrics.silhouette_score</span><br><span class="line">                                                        (X, kmeans_model.labels_,metric=<span class="string">'euclidean'</span>)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>

<h2 id="Mini-Batch-K-Means（适合大数据的聚类算法）"><a href="#Mini-Batch-K-Means（适合大数据的聚类算法）" class="headerlink" title="Mini Batch K-Means（适合大数据的聚类算法）"></a>Mini Batch K-Means（适合大数据的聚类算法）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans, KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># make_blobs 自定义数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># X为样本特征，Y为样本簇类别， 共1000个样本，</span></span><br><span class="line">    <span class="comment"># 每个样本4个特征，共4个簇，</span></span><br><span class="line">    <span class="comment"># 簇中心在[-1,-1], [0,0],[1,1], [2,2]， </span></span><br><span class="line">    <span class="comment"># 簇方差分别为[0.4, 0.2, 0.2]</span></span><br><span class="line"></span><br><span class="line">    X, y = make_blobs(n_samples=<span class="number">1000</span>, n_features=<span class="number">2</span>, </span><br><span class="line">                    centers=[[<span class="number">-1</span>,<span class="number">-1</span>], [<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>]], </span><br><span class="line">                    cluster_std=[<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>], </span><br><span class="line">                    random_state =<span class="number">9</span>)</span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], marker=<span class="string">'o'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, k <span class="keyword">in</span> enumerate((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)):</span><br><span class="line">        plt.subplot(<span class="number">2</span>,<span class="number">2</span>,index+<span class="number">1</span>)</span><br><span class="line">        y_pred = MiniBatchKMeans(n_clusters=k, batch_size = <span class="number">200</span>, random_state=<span class="number">9</span>).fit_predict(X)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#用Calinski-Harabasz Index评估二分类的聚类分数 其方法是metrics.calinski_harabaz_score</span></span><br><span class="line">        score= metrics.calinski_harabaz_score(X, y_pred)  </span><br><span class="line">        plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred)</span><br><span class="line">        plt.text(<span class="number">.99</span>, <span class="number">.01</span>, (<span class="string">'k=%d, score: %.2f'</span> % (k,score)),</span><br><span class="line">                    transform=plt.gca().transAxes, size=<span class="number">10</span>,</span><br><span class="line">                    horizontalalignment=<span class="string">'right'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>

<h2 id="使用K-means压缩图片"><a href="#使用K-means压缩图片" class="headerlink" title="使用K-means压缩图片"></a>使用K-means压缩图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> pairwise_distances_argmin</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_sample_image</span><br><span class="line"><span class="keyword">from</span> sklearn.utils <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recreate_image</span><span class="params">(codebook, labels, w, h)</span>:</span></span><br><span class="line">    <span class="comment"># Recreate the (compressed) image from the code book &amp; labels</span></span><br><span class="line">    d = codebook.shape[<span class="number">1</span>]</span><br><span class="line">    image = np.zeros((w, h, d))</span><br><span class="line">    label_idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(h):</span><br><span class="line">            image[i][j] = codebook[labels[label_idx]]</span><br><span class="line">            label_idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    n_colors = <span class="number">64</span></span><br><span class="line">    china2 = load_sample_image(imgPath)  <span class="comment"># 加载图片</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#转换为浮点数，PLTIMSID行为在浮点数据上很好地工作</span></span><br><span class="line">    china2 = np.array(china2, dtype=np.float64) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#将图片转成二维数组</span></span><br><span class="line">    w, h, d = original_shape = tuple(china2.shape)</span><br><span class="line">    <span class="keyword">assert</span> d == <span class="number">3</span></span><br><span class="line">    image_array = np.reshape(china2, (w * h, d))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"一个小样本数据的拟合模型"</span>)</span><br><span class="line">    t0 = time()</span><br><span class="line">    image_array_sample = shuffle(image_array, random_state=<span class="number">0</span>)[:<span class="number">1000</span>]</span><br><span class="line">    kmeans = KMeans(n_clusters=n_colors, random_state=<span class="number">0</span>).fit(image_array_sample)</span><br><span class="line">    print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get labels for all points</span></span><br><span class="line">    print(<span class="string">"Predicting color indices on the full image (k-means)"</span>)</span><br><span class="line">    t0 = time()</span><br><span class="line">    labels = kmeans.predict(image_array)</span><br><span class="line">    print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># codebook_random = shuffle(image_array, random_state=0)[:n_colors + 1]</span></span><br><span class="line">    <span class="comment"># print("Predicting color indices on the full image (random)")</span></span><br><span class="line">    <span class="comment"># t0 = time()</span></span><br><span class="line">    <span class="comment"># labels_random = pairwise_distances_argmin(codebook_random,</span></span><br><span class="line">                                            <span class="comment"># image_array,</span></span><br><span class="line">                                            <span class="comment"># axis=0)</span></span><br><span class="line">    <span class="comment"># print("done in %0.3fs." % (time() - t0))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display all results, alongside original image</span></span><br><span class="line">    plt.figure(<span class="number">1</span>)</span><br><span class="line">    plt.clf()</span><br><span class="line">    ax = plt.axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.title(<span class="string">'Original image (96,615 colors)'</span>)</span><br><span class="line">    plt.imshow(china2)</span><br><span class="line"></span><br><span class="line">    plt.figure(<span class="number">2</span>)</span><br><span class="line">    plt.clf()</span><br><span class="line">    ax = plt.axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.title(<span class="string">'Quantized image (64 colors, K-Means)'</span>)</span><br><span class="line">    plt.imshow(recreate_image(kmeans.cluster_centers_, labels, w, h))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plt.figure(3)</span></span><br><span class="line">    <span class="comment"># plt.clf()</span></span><br><span class="line">    <span class="comment"># ax = plt.axes([0, 0, 1, 1])</span></span><br><span class="line">    <span class="comment"># plt.axis('off')</span></span><br><span class="line">    <span class="comment"># plt.title('Quantized image (64 colors, Random)')</span></span><br><span class="line">    <span class="comment"># plt.imshow(recreate_image(codebook_random, labels_random, w, h))</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    imgPath = <span class="string">'a.jpg'</span></span><br><span class="line">    func(imgPath)</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>001-opencv图像基本操作</title>
    <url>/articles/20200229/2c2f4b26.html</url>
    <content><![CDATA[<p>摘要：001-opencv图像基本操作<br>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/001-base</p>
<a id="more"></a>

<h1 id="图片-读、写、显示、属性查看"><a href="#图片-读、写、显示、属性查看" class="headerlink" title="图片 读、写、显示、属性查看"></a>图片 读、写、显示、属性查看</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------直接读取--------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">direct_read</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath,<span class="number">0</span>)    <span class="comment">#读取图像（直接读取）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,cv2.IMREAD_COLOR)   #读取图像（BGR，忽略alpha通道）</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,cv2.IMREAD_GRAYSCALE)   #读取图像（读入灰度图片）</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,cv2.IMREAD_UNCHANGED)   #读取图像（完整图片，包括alpha通道）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># -----------------------------图片的属性 （长、宽、通道数）--------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    输出：</span></span><br><span class="line"><span class="string">        图片形状： (366, 445, 3)</span></span><br><span class="line"><span class="string">        图片大小： 488610</span></span><br><span class="line"><span class="string">        图片类型： uint8</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"图片形状："</span>,img.shape)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"图片大小："</span>,img.size)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"图片类型："</span>,img.dtype)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)         <span class="comment">#显示图像</span></span><br><span class="line">    k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:                     <span class="comment"># 按 Esc 退出（关闭显示窗口）</span></span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">    <span class="keyword">elif</span> k == ord(<span class="string">'s'</span>):             <span class="comment"># 按 's' 保存并退出 （关闭显示窗口）</span></span><br><span class="line">        cv2.imwrite(<span class="string">'test.png'</span>,img)</span><br><span class="line">        cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------保存------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">写入（保存）图片选取参数：</span></span><br><span class="line"><span class="string">	cv2.imwrite(file，img，num)</span></span><br><span class="line"><span class="string">	file：文件名</span></span><br><span class="line"><span class="string">	img： 图像</span></span><br><span class="line"><span class="string">	num： 可选参数（针对特定的格式）：</span></span><br><span class="line"><span class="string">		  对于JPEG，表示图像的质量，用0-100的整数表示，默认95，越高画质越好，文件越大</span></span><br><span class="line"><span class="string">		  对于png， 表示压缩级别。范围0到9，默认3，越高文件越小，画质越差</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    grayImage = cv2.imread(imgPath, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    cv2.imwrite(<span class="string">'test.png'</span>, grayImage) </span><br><span class="line">    cv2.imwrite(<span class="string">'test.jpeg'</span>, grayImage , (cv2.IMWRITE_JPEG_QUALITY, <span class="number">80</span>))</span><br><span class="line">    cv2.imwrite(<span class="string">'test.png'</span>, grayImage , (cv2.IMWRITE_PNG_COMPRESSION, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    direct_read(imgPath)</span><br></pre></td></tr></table></figure>

<h1 id="图像增强（缩放、平移、旋转、翻转）"><a href="#图像增强（缩放、平移、旋转、翻转）" class="headerlink" title="图像增强（缩放、平移、旋转、翻转）"></a>图像增强（缩放、平移、旋转、翻转）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># （缩放、平移、旋转、翻转）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像缩放--------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">cv2.resize(src,dsize,dst=None,fx=None,fy=None,interpolation=None)  </span></span><br><span class="line"><span class="string">	scr:   原图</span></span><br><span class="line"><span class="string">	dsize：输出图像尺寸</span></span><br><span class="line"><span class="string">	fx:    沿水平轴的比例因子(大于1放大图像；小于1缩小图像)</span></span><br><span class="line"><span class="string">	fy:    沿垂直轴的比例因子（同上）</span></span><br><span class="line"><span class="string">	interpolation：插值方法（见附录）</span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_resize</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># 方法1：直接设定缩放因子</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    res = cv2.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation = cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line">    print(img.shape)         <span class="comment">#输出为（366，445，3）【宽:x轴，高:y轴，通道数】</span></span><br><span class="line">    print(img.shape[:<span class="number">2</span>])     <span class="comment">#输出为（366，445）</span></span><br><span class="line">    cv2.imshow(<span class="string">'res'</span>, res)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#方法2：获取原图像的水平方向尺寸和垂直方向尺寸。再缩放</span></span><br><span class="line">    height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line">    res2 = cv2.resize(img,(<span class="number">2</span>*width, <span class="number">3</span>*height), interpolation = cv2.INTER_CUBIC)</span><br><span class="line">    cv2.imshow(<span class="string">'res2'</span>, res2)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像平移--------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_warp</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath,<span class="number">0</span>)</span><br><span class="line">    rows,cols = img.shape</span><br><span class="line">    </span><br><span class="line">    M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span><br><span class="line">    dst = cv2.warpAffine(img,M,(cols,rows))</span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,dst)                  <span class="comment">#展示图片并退出</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像旋转--------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">cv2.getRotationMatrix2D()</span></span><br><span class="line"><span class="string">详细参数：</span></span><br><span class="line"><span class="string">	得到变换的矩阵，通过这个矩阵再利用warpAffine来进行变换</span></span><br><span class="line"><span class="string">	第一个参数就是旋转中心，元组的形式，这里设置成相片中心</span></span><br><span class="line"><span class="string">	第二个参数90，是旋转的角度</span></span><br><span class="line"><span class="string">	第三个参数1，表示放缩的系数，1表示保持原图大小</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_rot</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    rows, cols,_ = img.shape</span><br><span class="line"></span><br><span class="line">    Matrix = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), <span class="number">90</span>, <span class="number">1</span>)</span><br><span class="line">    img1 = cv2.warpAffine(img, Matrix, (cols, rows))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>, img)</span><br><span class="line">    cv2.imshow(<span class="string">'img1'</span>, img1) </span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像(X,Y轴翻转)--------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"> cv2.flip(img,flipcode) 翻转图像，flipcode控制翻转效果。</span></span><br><span class="line"><span class="string">	flipcode = 0：沿x轴翻转</span></span><br><span class="line"><span class="string">	flipcode &gt; 0：沿y轴翻转</span></span><br><span class="line"><span class="string">	flipcode &lt; 0：x,y轴同时翻转</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_flip</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath,<span class="number">0</span>)</span><br><span class="line">    imgflip_1 = cv2.flip(img,<span class="number">1</span>)</span><br><span class="line">    imgflip_0 = cv2.flip(img,<span class="number">0</span>)</span><br><span class="line">    imgflip_2 = cv2.flip(img,<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'imgflip_1'</span>,imgflip_1) </span><br><span class="line">    cv2.imshow(<span class="string">'imgflip_0'</span>,imgflip_0) </span><br><span class="line">    cv2.imshow(<span class="string">'imgflip_2'</span>,imgflip_2) </span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_resize(imgPath)</span></span><br><span class="line">    <span class="comment"># img_warp(imgPath)</span></span><br><span class="line">    img_rot(imgPath)</span><br><span class="line">    <span class="comment"># img_flip(imgPath)</span></span><br></pre></td></tr></table></figure>

<h1 id="仿射变换（图像位置校正）"><a href="#仿射变换（图像位置校正）" class="headerlink" title="仿射变换（图像位置校正）"></a>仿射变换（图像位置校正）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment">#  仿射变换（图像位置校正）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_three</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># ---------------------------三点得到一个变换矩阵 ---------------------------</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        三点确定一个平面，通过确定三个点的关系来得到转换矩阵</span></span><br><span class="line"><span class="string">        然后再通过warpAffine来进行变换</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    rows,cols,_ = img.shape</span><br><span class="line">    points1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">    points2 = np.float32([[<span class="number">10</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span><br><span class="line"></span><br><span class="line">    matrix = cv2.getAffineTransform(points1,points2)</span><br><span class="line">    output = cv2.warpAffine(img,matrix,(cols,rows))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'input1'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'output1'</span>,output)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_four</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># ---------------------------四点得到一个变换矩阵---------------------------</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        进行透视变换</span></span><br><span class="line"><span class="string">        可以先用四个点来确定一个3*3的变换矩阵（cv2.getPerspectiveTransform）</span></span><br><span class="line"><span class="string">        然后通过cv2.warpPerspective和上述矩阵对图像进行变换</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    rows,cols,_ = img.shape</span><br><span class="line">    points1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">    points2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line"></span><br><span class="line">    matrix = cv2.getPerspectiveTransform(points1,points2)</span><br><span class="line">    <span class="comment"># 将四个点组成的平面转换成另四个点组成的一个平面</span></span><br><span class="line">    output = cv2.warpPerspective(img, matrix, (cols, rows))</span><br><span class="line">    <span class="comment"># 通过warpPerspective函数来进行变换</span></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'input2'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'output2'</span>,output)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_three(imgPath)</span></span><br><span class="line">    img_four(imgPath)</span><br></pre></td></tr></table></figure>

<h1 id="颜色变换（色调，明暗，直方图和Gamma曲线）"><a href="#颜色变换（色调，明暗，直方图和Gamma曲线）" class="headerlink" title="颜色变换（色调，明暗，直方图和Gamma曲线）"></a>颜色变换（色调，明暗，直方图和Gamma曲线）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment">#  颜色变换（色调，明暗，直方图和Gamma曲线）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_color</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    original_img = cv2.imread(imgPath)</span><br><span class="line">    img = cv2.resize(original_img,<span class="literal">None</span>,fx=<span class="number">0.8</span>,fy=<span class="number">0.8</span>,</span><br><span class="line">                    interpolation=cv2.INTER_AREA)            <span class="comment"># 图像缩小</span></span><br><span class="line"></span><br><span class="line">    Make_border_img = cv2.copyMakeBorder(img, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        cv2.BORDER_CONSTANT,</span><br><span class="line">                                        value=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))    <span class="comment"># 绘制边框(原图上下贴30像素黑边)</span></span><br><span class="line"></span><br><span class="line">    img_hsv = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)            <span class="comment"># 转成 HSV 格式</span></span><br><span class="line">    colorless_hsv = img_hsv.copy()</span><br><span class="line">    colorless_hsv[:,:,<span class="number">1</span>] = <span class="number">0.5</span> * colorless_hsv[:,:,<span class="number">1</span>]        <span class="comment"># 减小饱和度会让图像损失鲜艳，变得更灰</span></span><br><span class="line">    colorless_img = cv2.cvtColor(colorless_hsv,cv2.COLOR_HSV2BGR)</span><br><span class="line"></span><br><span class="line">    darker_hsv = img_hsv.copy()</span><br><span class="line">    darker_hsv[:,:,<span class="number">2</span>] = <span class="number">0.5</span> * darker_hsv[:,:,<span class="number">2</span>]             <span class="comment"># 减小明度为原来一半</span></span><br><span class="line">    darker_img = cv2.cvtColor(darker_hsv,cv2.COLOR_HSV2BGR)</span><br><span class="line"></span><br><span class="line">    img_corrected = gamma_trans(img,<span class="number">0.5</span>)                   <span class="comment"># 执行Gamma矫正</span></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"original_img"</span>,img)                         <span class="comment"># 原图</span></span><br><span class="line">    cv2.imshow(<span class="string">"Make_border_img"</span>,Make_border_img)          <span class="comment"># 添加黑边</span></span><br><span class="line">    cv2.imshow(<span class="string">'colorless_jpg'</span>,colorless_img)              <span class="comment"># 图像变灰</span></span><br><span class="line">    cv2.imshow(<span class="string">'darker_jpg'</span>,darker_img)                    <span class="comment"># 图像变暗</span></span><br><span class="line">    cv2.imshow(<span class="string">'gamma_corrected_jpg'</span>,img_corrected)        <span class="comment"># gamma校正</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line">    hist_b = cv2.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])    <span class="comment"># 分通道计算每个通道的直方图</span></span><br><span class="line">    hist_g = cv2.calcHist([img],[<span class="number">1</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    hist_r = cv2.calcHist([img],[<span class="number">2</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">    plt.plot(hist_b, label=<span class="string">'B'</span>, color=<span class="string">'blue'</span>)              <span class="comment"># 显示3个通道的颜色直方图</span></span><br><span class="line">    plt.plot(hist_g, label=<span class="string">'G'</span>, color=<span class="string">'green'</span>)</span><br><span class="line">    plt.plot(hist_r, label=<span class="string">'R'</span>, color=<span class="string">'red'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_trans</span><span class="params">(img,gamma)</span>:</span></span><br><span class="line">    gamma_table = [np.power(x/<span class="number">255.0</span>,gamma)*<span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> cv2.LUT(img,gamma_table)                    <span class="comment"># 实现这个映射用的是OpenCV的查表函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_three(imgPath)</span></span><br><span class="line">    img_color(imgPath)</span><br></pre></td></tr></table></figure>

<h2 id="本地摄像头，视频处理"><a href="#本地摄像头，视频处理" class="headerlink" title="本地摄像头，视频处理"></a>本地摄像头，视频处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">cv2.cvtColor(input_image, flag)函数实现图片颜色空间的转换：</span></span><br><span class="line"><span class="string">	flag 参数决定变换类型。如 BGR-&gt;Gray           </span></span><br><span class="line"><span class="string">	flag 就可以设置为 cv2.COLOR_BGR2GRAY</span></span><br><span class="line"><span class="string">		         cv2.COLOR_BGR2HSV 。</span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        _, frame = cap.read()                           <span class="comment"># 读取视频的每一帧</span></span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)    <span class="comment"># 将图片颜色空间从 BGR -&gt; HSV 空间</span></span><br><span class="line"></span><br><span class="line">        lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])              <span class="comment"># 定义在HSV空间中蓝色的范围</span></span><br><span class="line">        upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    </span><br><span class="line">        mask = cv2.inRange(hsv, lower_blue, upper_blue) <span class="comment"># 根据以上定义的蓝色的阈值得到蓝色的部分</span></span><br><span class="line">        res = cv2.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    </span><br><span class="line">        cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line">        cv2.imshow(<span class="string">'mask'</span>,mask)</span><br><span class="line">        cv2.imshow(<span class="string">'res'</span>,res)</span><br><span class="line">        k = cv2.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h1 id="通道的拆分-合并处理-添加边距"><a href="#通道的拆分-合并处理-添加边距" class="headerlink" title="通道的拆分/合并处理/添加边距"></a>通道的拆分/合并处理/添加边距</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通道的拆分/合并处理/添加边距</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># 拆分/合并处理</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    b,g,r = cv2.split(img)</span><br><span class="line">    img = cv2.merge((b,g,r)) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># -----------------------------添加边距--------------------------------</span></span><br><span class="line">    <span class="string">"""cv2.copyMakeBorder函数"""</span> </span><br><span class="line">    BLUE = [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    img1 = cv2.imread(imgPath)</span><br><span class="line">    </span><br><span class="line">    replicate = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REPLICATE)</span><br><span class="line">    reflect = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT)</span><br><span class="line">    reflect101 = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT_101)</span><br><span class="line">    wrap = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_WRAP)</span><br><span class="line">    constant= cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_CONSTANT,value=BLUE)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"img"</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">"replicate"</span>,replicate)</span><br><span class="line">    cv2.imshow(<span class="string">"reflect"</span>,reflect)</span><br><span class="line">    cv2.imshow(<span class="string">"reflect101"</span>,reflect101)</span><br><span class="line">    cv2.imshow(<span class="string">"wrap"</span>,wrap)</span><br><span class="line">    cv2.imshow(<span class="string">"constant"</span>,constant)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_three(imgPath)</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>

<h1 id="读取图像添加文字（可用于图像添加水印）"><a href="#读取图像添加文字（可用于图像添加水印）" class="headerlink" title="读取图像添加文字（可用于图像添加水印）"></a>读取图像添加文字（可用于图像添加水印）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通道的拆分/合并处理/添加边距</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,cv2.IMREAD_COLOR)    <span class="comment"># 打开文件</span></span><br><span class="line">    cv2.imshow(<span class="string">'Original_img'</span>,img )</span><br><span class="line">    font = cv2.FONT_HERSHEY_DUPLEX              <span class="comment"># 设置字体</span></span><br><span class="line">    img_word = cv2.putText(img, <span class="string">"liuyan"</span>, (<span class="number">5</span>, <span class="number">150</span>), font, <span class="number">2.5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>,)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    cv2.putText()</span></span><br><span class="line"><span class="string">    传入参数：图片对象、文本、像素、字体、字体大小、颜色、字体粗细</span></span><br><span class="line"><span class="string">    其中：像素为文字位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cv2.imshow('Original_img',img )</span></span><br><span class="line">    cv2.imshow(<span class="string">'Add_text_img'</span>,img_word )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cv2.imwrite('5.png',img_word )      # 保存</span></span><br><span class="line"></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()             <span class="comment"># 关闭所有窗口</span></span><br><span class="line">    <span class="comment"># cv2.destroyWindow(wname)            # 关闭指定窗口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interpolation   所用的插值方法</span><br><span class="line"></span><br><span class="line">	INTER_NEAREST 	最近邻插值</span><br><span class="line">	INTER_LINEAR 	双线性插值（默认设置）</span><br><span class="line">	INTER_AREA 	使用像素区域关系进行重采样。  </span><br><span class="line">	                它可能是图像抽取的首选方法，因为它会产生无云纹理的结果。 </span><br><span class="line">	                但是当图像缩放时，它类似于INTER_NEAREST方法。</span><br><span class="line">	                </span><br><span class="line">	INTER_CUBIC 	4x4像素邻域的双三次插值</span><br><span class="line">	INTER_LANCZOS4 	8x8像素邻域的Lanczos插值</span><br></pre></td></tr></table></figure>

<h1 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h1><p>将一个灰色的图片，变成要么是白色要么就是黑色。（大于规定thresh值就是设置的最大值（常为255，也就是白色））</p>
<p>Python: cv2.threshold(src, thresh, maxval, type[, dst]) → retval, dst</p>
<ul>
<li>src：表示的是图片源</li>
<li>thresh：表示的是阈值（起始值）</li>
<li>maxval：表示的是最大值</li>
<li>type：表示的是这里划分的时候使用的是什么类型的算法，常用值为0（cv2.THRESH_BINARY）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 通道的拆分/合并处理/添加边距</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,cv2.IMREAD_COLOR)    <span class="comment"># 打开文件</span></span><br><span class="line">    <span class="comment"># img = np.zeros((200, 200), dtype=np.uint8)</span></span><br><span class="line">    img[<span class="number">50</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">150</span>] = <span class="number">255</span>  <span class="comment"># create a image with black color in the middle and its background is white.</span></span><br><span class="line">    cv2.imshow(<span class="string">"Image-Old"</span>, img)</span><br><span class="line">    ret, thresh = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">"Image-New"</span>, thresh)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>
<h1 id="反相"><a href="#反相" class="headerlink" title="反相"></a>反相</h1><h2 id="黑白反相（二值化图）"><a href="#黑白反相（二值化图）" class="headerlink" title="黑白反相（二值化图）"></a>黑白反相（二值化图）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 黑白反相（二值化图）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_color</span><span class="params">(image)</span>:</span></span><br><span class="line">    height,width = image.shape</span><br><span class="line">    img2 = image.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">            img2[i,j] = (<span class="number">255</span>-image[i,j])</span><br><span class="line">    <span class="keyword">return</span> img2 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,<span class="number">0</span>)    <span class="comment"># 打开文件</span></span><br><span class="line">    cv2.imshow(<span class="string">"Image-Old"</span>, img)</span><br><span class="line"></span><br><span class="line">    img_new = inverse_color(img)</span><br><span class="line">    cv2.imshow(<span class="string">"img_new"</span>, img_new)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>
<h2 id="彩色反相（原始图）"><a href="#彩色反相（原始图）" class="headerlink" title="彩色反相（原始图）"></a>彩色反相（原始图）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 彩色反相（二值化图）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_color</span><span class="params">(image)</span>:</span> </span><br><span class="line">    height,width,_ = image.shape </span><br><span class="line">    img2 = image.copy() </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(height): </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(width): </span><br><span class="line">            img2[i,j] = (<span class="number">255</span>-image[i,j][<span class="number">0</span>],<span class="number">255</span>-image[i,j][<span class="number">1</span>],<span class="number">255</span>-image[i,j][<span class="number">2</span>]) </span><br><span class="line">    <span class="keyword">return</span> img2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,cv2.IMREAD_COLOR)    <span class="comment"># 打开文件</span></span><br><span class="line">    cv2.imshow(<span class="string">"Image-Old"</span>, img)</span><br><span class="line"></span><br><span class="line">    img_new = inverse_color(img)</span><br><span class="line">    cv2.imshow(<span class="string">"img_new"</span>, img_new)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>000-图像基本信息</title>
    <url>/articles/20200229/50aaac91.html</url>
    <content><![CDATA[<p>摘要：000-图像基本信息<br>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/001-base</p>
<a id="more"></a>

<p>opencv 提供了cvtColor()函数，用于在图像中不同的色彩空间进行转换，用于后续处理。在使用cvtColor之前首先需要了解下基本的图像色彩模式，色彩模式决定了打印或显示的图片颜色。</p>
<h1 id="图像色彩模式"><a href="#图像色彩模式" class="headerlink" title="图像色彩模式"></a>图像色彩模式</h1><h2 id="位图模式"><a href="#位图模式" class="headerlink" title="位图模式"></a>位图模式</h2><p>位图模式是图像中最基本的格式，图像只有黑色和白色像素，是色彩模式中占有空间最小的，同样也叫做黑白图，它包含的信息量最少，无法包含图像中的细节，相当于只有0或者1</p>
<p>一副彩色图如果要转换成黑白模式，则一般不能直接转换，需要首先将图像转换成灰度模式</p>
<h2 id="灰度模式"><a href="#灰度模式" class="headerlink" title="灰度模式"></a>灰度模式</h2><p>灰度模式即使用单一色调来表示图像，与位图模式不同，不像位图只有0和1，使用256级的灰度来表示图像，一个像素相当于占用8为一个字节，每个像素值使用0到255的亮度值代表，其中0为黑色，255为白色，相当于从黑-&gt;灰-&gt;白的过度，通常我们所说的黑白照片就是这种模式，与位图模式相比，能表现出一定的细节，占用空间也比位图模式较大</p>
<h2 id="RGB模式"><a href="#RGB模式" class="headerlink" title="RGB模式"></a>RGB模式</h2><p>RGB模式为我们经常见到的，被称为真色彩。RGB模式的图像有3个颜色通道，分布为红（Red）,绿（Green）和蓝（Bule），每个都占用8位一个字节来表示颜色信息，这样每个颜色的取值范围为0~255，那么就三种颜色就可以有多种组合，</p>
<p>当三种基色的值相等是，表现出为灰色，三种颜色都为255即为白色，三种颜色都为0，即为黑色</p>
<p>RGB模式的图像占用空间要比位图，灰度图都要大，但表现出的细节更加明显</p>
<h2 id="CMYK模式"><a href="#CMYK模式" class="headerlink" title="CMYK模式"></a>CMYK模式</h2><p>CMYK模式被称为印刷色彩模式，主要是来源于印刷行业，以打印油墨在纸张上的光线吸收特性为基础，与RGB类似，也是使用三种颜色，分别为青色（Cyan）,品红色（Magenta）,黄色（Yellow）,以及黑色（Black） </p>
<p>与RGB不同的是：RGB模式依靠的是自身发光的色彩模式，而CMYK是一种依靠反光的色彩模式。</p>
<p>H## SB模式<br>是根据日常生活中人眼的视觉对色彩的观察得而制定的一套色彩模式，最接近与人类对色彩的辨认的思考方式，所有的颜色都是用色彩三属性来描述</p>
<p>H:(色相）：是指从物体反射或透过物体传播的颜色</p>
<p>S:(饱和度)：是指颜色的强度或纯度，表示色相中灰色成分所占的比例</p>
<p>B:(亮度)：是指颜色对相对明暗程度，通常 100%定义为白色；0%为黑色 </p>
<p>除了上述以上之外，还有索引模式，多通道模式等等不再介绍</p>
<h2 id="YUV格式"><a href="#YUV格式" class="headerlink" title="YUV格式"></a>YUV格式</h2><p>除了上述图像模式之外，由于历史原因大部分摄像头输入的图片格式都是YUV格式，开始主要用于电视系统以及模拟视频领域。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。如果没用UV信息，只有Y信息，也可以进行成像不过只是黑白的，这样就能很好解决彩色电视与黑白电视的兼容问题，与RGB相比，YUV占用带宽较少，目前摄像头输出格式普遍采用YUV格式。具体介绍可以见<a href="https://blog.csdn.net/weixin_42730667/article/details/97233856" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42730667/article/details/97233856</a></p>
<p>而在图像的处理过程中，其实很少使用YUV格式，一般都需要转成RGB格式或者灰度图格式进行转换，而opencv的cvtColor()函数支持这种转换</p>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>007-特征提取算法-SURF-检测斑点</title>
    <url>/articles/20200229/4550d3a.html</url>
    <content><![CDATA[<p>摘要：007-特征提取算法-SURF-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SURF采用快速Hessian算法检测关键点，然后SURF提取特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>011-特征提取算法-边缘检测</title>
    <url>/articles/20200229/d3acbf6a.html</url>
    <content><![CDATA[<p>摘要：011-特征提取算法-边缘检测</p>
<a id="more"></a>

<h1 id="边缘定义及类型"><a href="#边缘定义及类型" class="headerlink" title="边缘定义及类型"></a>边缘定义及类型</h1><p>边缘类型：简单分为4中类型，阶跃型、屋脊型、斜坡型、脉冲型，其中阶跃型和斜坡型是类似的，只是变化的快慢不同。</p>
<h1 id="边缘检测算子类别"><a href="#边缘检测算子类别" class="headerlink" title="边缘检测算子类别"></a>边缘检测算子类别</h1><p>边缘检测算子：</p>
<ul>
<li>一阶导数： Roberts、Sobel、Prewitt</li>
<li>二阶导数： Laplacian、Log/Marr、(Kirsch、Nevitia)</li>
<li>非微分边缘检测算子： Canny<br>算子参看：<a href="https://blog.csdn.net/wsp_1138886114/article/details/81368890" target="_blank" rel="noopener">https://blog.csdn.net/wsp_1138886114/article/details/81368890</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算子        优缺点比较</span><br><span class="line">Roberts     对具有陡峭的低噪声的图像处理效果好，但利用Roberts算子提取边缘的结果是边缘比较粗，因此边缘定位不是很准确</span><br><span class="line">Sobel       对灰度渐变和噪声较多的图像处理效果比较好，Sobel算子对边缘定位比较准确</span><br><span class="line">Kirsch      对灰度渐变和噪声较多的图像处理效果较好。</span><br><span class="line">Prewitt     对灰度渐变和噪声较多的图像处理效果较好。</span><br><span class="line">Laplacian   对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，造成一些不连续的检测边缘</span><br><span class="line">LoG         LoG算子经常出现双边缘像素边界，而且该检测方法对噪声比较敏感，所以很少用LoG算子检测边缘，而是用来判断边缘像素是位于图像的明区还是暗区</span><br><span class="line">Canny       此方法不易受噪声的干扰，能够检测到真正的弱边缘。在edge函数中，最有效的边缘检测方法是Canny方法。</span><br><span class="line">            该方法的优点在于使用两种不同的阈值分别检测强边缘和弱边缘，并且仅当弱边缘与强边缘相连时，才将弱边缘包含在输出图像中。。</span><br><span class="line">            因此，这种方法不容易被噪声”填充“，更容易检测出真正的弱边缘</span><br></pre></td></tr></table></figure>

<h2 id="OpenCV-Python-中-Canny"><a href="#OpenCV-Python-中-Canny" class="headerlink" title="OpenCV-Python 中 Canny()"></a>OpenCV-Python 中 Canny()</h2><p>步骤：</p>
<ul>
<li>彩色图像转换为灰度图像（以灰度图或者单通道图读入）</li>
<li>对图像进行高斯模糊（去噪）</li>
<li>计算图像梯度，根据梯度计算图像边缘幅值与角度</li>
<li>沿梯度方向进行非极大值抑制（边缘细化）</li>
<li>双阈值边缘连接处理</li>
<li>二值化图像输出结果</li>
</ul>
<p>“””<br>cv2.Canny(image,            # 输入原图（必须为单通道图）<br>          threshold1,<br>          threshold2,       # 较大的阈值2用于检测图像中明显的边缘<br>          [, edges[,<br>          apertureSize[,    # apertureSize：Sobel算子的大小<br>          L2gradient ]]])   # 参数(布尔值)：<br>                              true： 使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放），<br>                              false：使用L1范数（直接将两个方向导数的绝对值相加）。<br>“””</p>
]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>009-特征提取算法-BRIEF-检测斑点</title>
    <url>/articles/20200229/6944d2af.html</url>
    <content><![CDATA[<p>摘要：009-特征提取算法-BRIEF-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>并不是特征检测算法，它是一个描述符。关键点描述符是图像的一种表示，因为可以比较两个图像的关键点描述符，并找到他们的共同之处，因此可以作为特征匹配的一种方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>009-特征提取算法-BRIEF-检测斑点</title>
    <url>/articles/20200229/6944d2af.html</url>
    <content><![CDATA[<p>摘要：009-特征提取算法-BRIEF-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>并不是特征检测算法，它是一个描述符。关键点描述符是图像的一种表示，因为可以比较两个图像的关键点描述符，并找到他们的共同之处，因此可以作为特征匹配的一种方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>007-特征提取算法-SURF-检测斑点</title>
    <url>/articles/20200229/4550d3a.html</url>
    <content><![CDATA[<p>摘要：005-特征提取算法-Harris-检测角点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SURF采用快速Hessian算法检测关键点，然后SURF提取特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>006-特征提取算法-SIFT-检测斑点</title>
    <url>/articles/20200229/811a1f63.html</url>
    <content><![CDATA[<p>摘要：006-特征提取算法-SIFT-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Harris的cornerHarris函数可以很好的检测角点，并且在图像旋转的情况下也能检测到，然而减少或者增加图像的大小，可能会丢失图像的某些部分，甚至会增加角点的质量。所以采用一种与图像比例变化无关的角点检测方法来解决特特征损失现象！也就是尺度不变特征变换（SIFT）。</p>
<p>尺度不变特征变换匹配算法<br>Scale Invariant Feature Transform(SIFT)</p>
<h2 id><a href="#" class="headerlink" title></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>005-特征提取算法-Harris-检测角点</title>
    <url>/articles/20200229/49e94f08.html</url>
    <content><![CDATA[<p>摘要：005-特征提取算法-Harris-检测角点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>角点：三维图像亮度变化剧烈的点或者图像边缘曲线上曲率极大值的点</p>
<p>使用cornerHarris来识别角点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>004-图形相似-特征提取算法概述</title>
    <url>/articles/20200229/414b8f31.html</url>
    <content><![CDATA[<p>摘要：004-图形相似-特征提取算法概述</p>
<a id="more"></a>

<h1 id="概述-特征，特征描述，特征匹配"><a href="#概述-特征，特征描述，特征匹配" class="headerlink" title="概述-特征，特征描述，特征匹配"></a>概述-特征，特征描述，特征匹配</h1><p>图像处理的基础就是要进行特征点的提取，feature(interest points) detect 的方法也在不断的进步，边检测，角点检测，直线检测，圆检测，SIFT特征点检测，同时描述符也在发展，为了匹配的高效，逐渐从高维特征向量到二进制向量</p>
<p>在一般的图像处理库中（如opencv, VLFeat, Boofcv等）都会实现。</p>
<p>什么是特征，什么是特征描述，什么是特征匹配</p>
<p>要匹配两张图像是否是同一个图像，比较好的方法就是找出图像中特征显著的内容然后来进行比较，如果这些特征都一致，那么就有很高的概率称他们为同一个图像。</p>
<ol>
<li>找出图像中特征性强的内容（Feature Detect），特征性强的图案。</li>
<li>但是只知道有显著特征没用，必须知道两张图像中的特征是不是一致的，如何判断特征是不是一致的，就需要对这个特征进行描述（Feature Descriptor），如果描述非常的相似或者说是相同，那么就可以判断为是同一特征。</li>
<li>该如何去描述一个特征，什么样的描述是一个好的描述呢。描述一个特征其实就是描述特征与他周围内容的相互关系。那么什么样的描述是一个好的描述呢，就要提到为什么要描述特征了？描述特征是为了能够更好的匹配特征，使得我们认为描述相同的特征是同一个特征的是可信的（概率高的）。所以描述必须是有代表性的，具有排他性的（discriminative）,而不是模棱两可泛泛而谈的。</li>
<li>最后就可以根据描述的相似性来判断这对特征是否是同一个特征。</li>
</ol>
<h2 id="特征不变性的理解："><a href="#特征不变性的理解：" class="headerlink" title="特征不变性的理解："></a>特征不变性的理解：</h2><p>常用特征，如Harris Corner、SIFT、SURF、BRIEF、BRISK等，而特征的一个重要特性就是特征不变性，常见的就是旋转不变性和尺度不变性，还有一些具有仿射不变性的特征。而这些特征该怎么理解呢？</p>
<h3 id="旋转不变性："><a href="#旋转不变性：" class="headerlink" title="旋转不变性："></a>旋转不变性：</h3><p>旋转不变性。只要对特征定义方向，然后在同一个方向上进行特征描述就可以实现旋转不变性。这称之为 Rotation Normalization。</p>
<h3 id="尺度不变性"><a href="#尺度不变性" class="headerlink" title="尺度不变性"></a>尺度不变性</h3><p>实现尺度不变性，需要给特征加上尺度因子，在进行描述的时候，将尺度统一就可以实现尺度不变性了。这过程称为Scale Normalization。</p>
<h3 id="不变性小结"><a href="#不变性小结" class="headerlink" title="不变性小结"></a>不变性小结</h3><p>所谓的旋转不变性和尺度不变性的原理，就是我们在描述一个特征之前，将两张图像都变换到同一个方向和同一个尺度上，然后再在这个统一标准上来描述这个特征。同样的，如果在描述一个特征之前，将图像变换到同一个仿射尺度或者投影尺度上，那么就可以实现仿射不变性和投影不变性。分别称为Affine Normalization 和 Projected Normalization.</p>
<h2 id="特征提取算法小结"><a href="#特征提取算法小结" class="headerlink" title="特征提取算法小结"></a>特征提取算法小结</h2><p>特征匹配的方法是先找出特征显著的特征点（Feature Detect），然后再分别描述两个特征点（Feature Descriptor），最后比较两个描述的的相似程度来判断是否为同一个特征（Feature Match）。</p>
<p>而在特征描述之前如果能够做到确定特征的方向，则可以实现旋转不变性（Rotation invarient），如果能确定尺度，则可以实现尺度不变性（Scale invarient）。</p>
<h3 id="fast"><a href="#fast" class="headerlink" title="fast"></a>fast</h3><h3 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h3><p>提点方法：DoG的最值点位置在通过二次拟合来确定位置</p>
<p>确定方向：特征邻域的梯度直方图的最值方向</p>
<p>确定尺度：通过建立确定尺度空间，尺度空间中DoG最值所在尺度为特征尺度</p>
<p>描述方法：在特征周围取一个region，分成4*4的sub-region，对每个sub-region使用八方向的梯度表示，总共128维</p>
<h3 id="SURF"><a href="#SURF" class="headerlink" title="SURF"></a>SURF</h3><p>受SIFT启发，比SIFT快，健壮，64-dim(256B).</p>
<p>提点方法：Hessian矩阵的行列式最值</p>
<p>确定方向：特征邻域对Haar wavelet的最大响应方向</p>
<p>确定尺度：通过建立确定尺度空间，尺度空间中DoG最值所在尺度为特征尺度</p>
<p>描述方法：在特征周围取一个region，分成4*4的sub-region，对每个sub-region计算haar wavelet响应，分别取x方向响应和，x方向响应绝对值之和，y方向响应和，y方向绝对值之和四个值描述，总共64维</p>
<h3 id="BRIEF"><a href="#BRIEF" class="headerlink" title="BRIEF"></a>BRIEF</h3><p>提点方法：无</p>
<p>确定方向：无</p>
<p>确定尺度：无</p>
<p>描述方法：在特征点周围随机抽取随机点对，比较两个点的像素强度，根据结果的大小记为1或0，取256组组成256位的二进制字符串</p>
<h3 id="ORB"><a href="#ORB" class="headerlink" title="ORB"></a>ORB</h3><p>基于FAST和BRIEF，比SIFT快两个数量级，可作为SIFT的替代(a fusion of FAST keypoint detector and BRIEF descriptor). 32B binary descriptor.</p>
<p>提点方法：使用FAST提点，使用Harris Corner去除非角点</p>
<p>确定方向：使用Intensity centroid方法来确定方向</p>
<p>确定尺度：无</p>
<p>描述方法：通过贪心方法抽取符合正态分布的随机点对，其他同BRIEF</p>
<h3 id="BRISK"><a href="#BRISK" class="headerlink" title="BRISK"></a>BRISK</h3><p>提点方法：使用FAST或AGAST提点</p>
<p>确定方向：使用邻域随机抽样点对，对远点对做梯度确定方向</p>
<p>确定尺度：尺度空间中FAST提点最显著的尺度</p>
<p>描述方法：使用短距离点对进行强度匹配，组成512位的二进制字符串</p>
<h3 id="MSER"><a href="#MSER" class="headerlink" title="MSER"></a>MSER</h3><p>斑点检测</p>
<h3 id="HARRIS"><a href="#HARRIS" class="headerlink" title="HARRIS"></a>HARRIS</h3><p>角点检测方法</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>GFTT、STAR</p>
<p>需要注意的地方：</p>
<ul>
<li>链接的时候加上pkg-config opencv –cflags –libs可以加入所有opencv的库</li>
<li>SIFT，SURF是nonfree的，使用的时候需要方法initModule_nonfree()，需要头文件opencv2/nonfree/nonfree.hpp</li>
<li>FAST只是检测角点，要结合其他extractor如ORB,SIFT.</li>
</ul>
]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>002-数据库分库分表架构与框架</title>
    <url>/articles/20200227/e129d172.html</url>
    <content><![CDATA[<p>摘要：github：<a href="https://github.com/bjlhx15/framework-middleware.git" target="_blank" rel="noopener">https://github.com/bjlhx15/framework-middleware.git</a></p>
<a id="more"></a>

<h1 id="分库分表方式"><a href="#分库分表方式" class="headerlink" title="分库分表方式"></a>分库分表方式</h1><h2 id="垂直拆分与水平拆分"><a href="#垂直拆分与水平拆分" class="headerlink" title="垂直拆分与水平拆分"></a>垂直拆分与水平拆分</h2><p>表结构与数据，user</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  address</span><br><span class="line">1   张三1  15    男      北京市大兴区</span><br><span class="line">2   李四2  17    男      北京市海淀区</span><br><span class="line">3   李四3  17    男      北京市海淀区</span><br><span class="line">4   李四4  17    男      北京市海淀区</span><br></pre></td></tr></table></figure>

<h3 id="垂直拆分【纵向拆分】"><a href="#垂直拆分【纵向拆分】" class="headerlink" title="垂直拆分【纵向拆分】"></a>垂直拆分【纵向拆分】</h3><p>表结构拆分，如上分为：</p>
<ul>
<li>示例<br>表1，user_base<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  </span><br><span class="line">1   张三1   15    男    </span><br><span class="line">2   李四2   17    男</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>表2，user_ext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  address</span><br><span class="line">1    北京市大兴区</span><br><span class="line">2    北京市海淀区</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>拆分后业务清晰，查分规则明确</li>
<li>系统之间整合扩展容易</li>
<li>按照成本、应用等级、应用类型等将表放置在不同的机器上，便于管理</li>
<li>便于实现动静分离、冷热分离的数据库表的设计模式</li>
<li>数据维护简单</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>部分业务表无法关联【join】、只能通过接口方式解决。提高了复杂度</li>
<li>存在单库、单表性能瓶颈。不易进行数据扩展和性能提升</li>
<li>事务处理复杂。</li>
</ol>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>数据拆分，如上表可分为：</p>
<ul>
<li><p>示例<br>表1，user1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  address</span><br><span class="line">1   张三1  15    男      北京市大兴区</span><br><span class="line">3   李四3  17    男      北京市海淀区</span><br></pre></td></tr></table></figure>
<p>表2，user2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  address</span><br><span class="line">2   张三2  15    男      北京市大兴区</span><br><span class="line">4   李四4  17    男      北京市海淀区</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>单库单表数量级一定，有助于性能的提升</li>
<li>应用改造少，只需增加路由规则</li>
<li>提高了系统稳定性和负载能力</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>数据分散，使用join较难，性能差</li>
<li>拆分规则难以抽象</li>
<li>分片事务的一致性难以解决</li>
<li>数据扩容的难度和维护量极大</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>共同问题：</p>
<ol>
<li>分布式事务问题</li>
<li>跨节点join问题</li>
<li>存在跨节点合并排序、分页问题</li>
<li>多数据源管理问题</li>
</ol>
<p>如上，垂直拆分，倾向于业务拆分，技术上比较关注水平拆分。。</p>
<h2 id="使用数据库的三个阶段"><a href="#使用数据库的三个阶段" class="headerlink" title="使用数据库的三个阶段"></a>使用数据库的三个阶段</h2><p>单库单表→单库多表→多库多表</p>
<h2 id="分库分表适用情况"><a href="#分库分表适用情况" class="headerlink" title="分库分表适用情况"></a>分库分表适用情况</h2><ol>
<li>数据表瓶颈【mysql 单表5000w数据达到极限】</li>
<li>数据库吞吐瓶颈</li>
<li>未来预留设计</li>
</ol>
<h1 id="解决实施方案"><a href="#解决实施方案" class="headerlink" title="解决实施方案"></a>解决实施方案</h1><p>主要有三类：客户端分片、代理分片、支持事务的分布式数据库</p>
<h2 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h2><p>应用端实现，每个应用层直接嵌入分片逻辑，一般一个jar。主要有三种方式:应用层直接实现、通过定制JDBC协议实现、通过定义ORM框架实现。</p>
<h3 id="应用层直接实现"><a href="#应用层直接实现" class="headerlink" title="应用层直接实现"></a>应用层直接实现</h3><p>直接在应用层，根据分片字段读取分片规则，然后解析分片规则。根据分片规则实现切分的路由逻辑，从应用层直接决定每次操作应该使用哪个数据库实例、数据库以及数据库表。通常实现方式是封装成一个jar。</p>
<ul>
<li>优点：简单、快速、方便定位问题</li>
<li>缺点：业务侵入、产生较多的数据库连接</li>
</ul>
<h3 id="通过定制JDBC协议实现"><a href="#通过定制JDBC协议实现" class="headerlink" title="通过定制JDBC协议实现"></a>通过定制JDBC协议实现</h3><p>在jdbc层进行处理，参看sharding jdbc</p>
<ul>
<li>优点：业务透明，不侵入</li>
<li>缺点：需要了解jdbc协议</li>
</ul>
<h3 id="通过定义ORM框架实现"><a href="#通过定义ORM框架实现" class="headerlink" title="通过定义ORM框架实现"></a>通过定义ORM框架实现</h3><p>把分片规则实现到orm框架或者通过ORM框架的扩展机制来完成分库分表逻辑。如mybatis，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.Map"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">select * from User_#&#123;index&#125;</span><br><span class="line">where userId=#&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="代理分片"><a href="#代理分片" class="headerlink" title="代理分片"></a>代理分片</h2><p>在应用层与数据库层中增加一个代理层，把分片的路由规则配置在代理层,代理层对外提供与JDBC兼容的接口给应用层，应用层开发不必关心分片规则。</p>
<ul>
<li>优点：应用开发专注业务逻辑</li>
<li>缺点：增加了代理层，而且数据库部署一般与应用分离。</li>
</ul>
<p>框架：Cobar和Mycat</p>
<h2 id="支持事务的分布式数据库"><a href="#支持事务的分布式数据库" class="headerlink" title="支持事务的分布式数据库"></a>支持事务的分布式数据库</h2><p>如：OceanBase、TiDB，对外提供JDBC接口。</p>
<h1 id="分库分表的架构设计"><a href="#分库分表的架构设计" class="headerlink" title="分库分表的架构设计"></a>分库分表的架构设计</h1><p>如上，垂直拆分，倾向于业务拆分，技术上比较关注水平拆分。故后续研究是水平拆分</p>
<h2 id="水平切分方式的路由过程和分片维度"><a href="#水平切分方式的路由过程和分片维度" class="headerlink" title="水平切分方式的路由过程和分片维度"></a>水平切分方式的路由过程和分片维度</h2><h3 id="路由过程"><a href="#路由过程" class="headerlink" title="路由过程"></a>路由过程</h3><p>在表设计时，需要确定对表按照什么样的规则进行分库分表。</p>
<p>针对输入的请求，通过分库分表规则查找到对应的表和库的过程叫做路由。</p>
<h3 id="水平切分的分片维度"><a href="#水平切分的分片维度" class="headerlink" title="水平切分的分片维度"></a>水平切分的分片维度</h3><h4 id="按照哈希切片"><a href="#按照哈希切片" class="headerlink" title="按照哈希切片"></a>按照哈希切片</h4><p>对数据分某个字段求哈希，在除以分片总数后取模，取模后相同的数据为一个分片，这种将数据分成多个分片的方法叫哈希分片。</p>
<p>设计系统时，要充分考虑如何设计数据库的分库分表的路由规则。</p>
<ul>
<li>优点：数据分散均匀，数据压力分散的效果比较好</li>
<li>缺点：查询需求需要聚合处理。</li>
</ul>
<h4 id="按照时间切片"><a href="#按照时间切片" class="headerlink" title="按照时间切片"></a>按照时间切片</h4><p>按照指定时间周期进行切片【如按年，按月】，主要取决于数据交易量。</p>
<p>针对具有明确时间特点的数据进行切分。</p>
<h2 id="分片后的事务处理机制"><a href="#分片后的事务处理机制" class="headerlink" title="分片后的事务处理机制"></a>分片后的事务处理机制</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>由于将单表的数据切片后存储在多个数据库甚至多个数据库实例中，所以依靠数据库本身的事务机制不能满足所有场景的需要。</p>
<p>主流分布式事务解决方案：两阶段提交协议、最大努力保证模式、事务补偿机制</p>
<h4 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h4><p>将分布式事务分为两个阶段，一个是准备阶段，一个是提交阶段，两个阶段都是由事务管理器发起。</p>
<p>基于两阶段提交协议，事务管理器能够最大限度地保证跨数据库操作的事务的原子性，是分布式系统环境下最严格的事务实现方法。</p>
<p>符合J2EE规范的AppServer（如：webSphere、Jboss等）对关系型数据库数据源和消息队列都实现了两阶段提交协议。。只需在使用时配置即可。</p>
<ul>
<li>缺点<br>两阶段提交协议，会有性能问题，难以进行水平伸缩，因为在提交事务的过程中，事务管理器需要和每个参与者进行准备和提交的操作的协调，在准备阶段锁定资源，在提交阶段消费资源，但是由于参与者较多，锁定资源和消费资源之间的时间差被拉长，导致响应速度较慢，在此期间产生死锁或者不确定结果的可能性比较大。因此在互联网行业里，为了追求性能的提升，很少时候两阶段提交协议。</li>
</ul>
<p>另外，由于两阶段提交协议是阻塞协议，在极端情况下不能快速响应请求方，因此目前有提出过三阶段提交协议，解决了两阶段提交协议的阻塞问题，但仍然需要事务管理器在参与者之间协调，才能完成一个分布式事务。</p>
<h4 id="最大努力保证模式"><a href="#最大努力保证模式" class="headerlink" title="最大努力保证模式"></a>最大努力保证模式</h4><p>一种常用的保证分布式一致性的模式，最大努力保证模式适用于对一致性要求并不十分严格但是对性能要求较高的场景。</p>
<p>具体实现，在更新多个资源时，将多个资源的提交尽量延后到最后一刻处理，这样的话，如果业务流程出现问题，则所有的资源更新都可以回滚，事务仍然保持一致性。<br>唯一可能出现问题，在提交多个资源时发生了系统异常，如网络问题，一旦出现这种情况，就需要进行实时补偿，将已提交的事务进行回滚，同TCC模式类似。</p>
<p>示例：如 涉及两个操作，一个是消息消费，一个是更新数据库，需要保证分布式的一致性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、开始消息事务</span><br><span class="line">2、开始数据库事务</span><br><span class="line">3、接收消息</span><br><span class="line">4、更新数据库</span><br><span class="line">5、提交数据库事务</span><br><span class="line">6、提交消息事务</span><br></pre></td></tr></table></figure>
<p>1-4不是很重要，5、6 发生异常都会回滚，5-6之间异常，导致消息被重发，消息重复消费，需要通过幂等进行处理。</p>
<p>对于提交顺序，需要充分考虑。如数据库事务中嵌套远程调用事务，且远程调用事务是耗时任务，导致数据库事务拉长，拖垮数据库。</p>
<h4 id="事务补偿机制"><a href="#事务补偿机制" class="headerlink" title="事务补偿机制"></a>事务补偿机制</h4><p>性能要求比较高场景中，两阶段提交协议不适用，最大努力保证模式会使多个分布式操作互相嵌套，也可能不适合。</p>
<p>事务补偿机制，提高性能，并且能够尽最大可能地保证事务的最终一致性。</p>
<p>在数据库分库分表后，如果涉及的多个更新操作在某一个数据库范围内完成，则可以使用数据库内的本地事务保证一致性；对于跨库的多个操作，可通过补偿和重试，使其在一定时间窗口内完成操作。</p>
<h3 id="事务路由"><a href="#事务路由" class="headerlink" title="事务路由"></a>事务路由</h3>]]></content>
      <categories>
        <category>framework-middleware</category>
      </categories>
  </entry>
  <entry>
    <title>001-分布式id生成</title>
    <url>/articles/20200227/9b0c33d0.html</url>
    <content><![CDATA[<p>摘要：github：<a href="https://github.com/bjlhx15/framework-middleware.git" target="_blank" rel="noopener">https://github.com/bjlhx15/framework-middleware.git</a></p>
<a id="more"></a>

<h2 id="自研发"><a href="#自研发" class="headerlink" title="自研发"></a>自研发</h2><p>可以看分类中，mysql 主键设计。</p>
<p>自开发版本github：<a href="https://github.com/bjlhx15/framework-middleware.git" target="_blank" rel="noopener">https://github.com/bjlhx15/framework-middleware.git</a> 下的：id-generator<br>支持DB，配置文件配置，配置文件配置IP等生成工作id</p>
<p>业界经典：雪花算法</p>
<h2 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h2><p>github地址：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">https://github.com/baidu/uid-generator</a></p>
<p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p>
<p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p>
<p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p>
<p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></p>
<h2 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h2><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">https://github.com/Meituan-Dianping/Leaf</a></p>
<p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p>
<p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p>
<p>上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>可以利用Redis中的incr命令来实现原子性的自增与返回</p>
]]></content>
      <categories>
        <category>framework-middleware</category>
      </categories>
  </entry>
  <entry>
    <title>003-dubbo的服务注册与发现</title>
    <url>/articles/20200226/8c67eec6.html</url>
    <content><![CDATA[<p>摘要：后续文章主要以2.7.5 版本说明，推荐使用zookeeper注册中心。</p>
<a id="more"></a>

<p>参看官方源码，支持一下方案：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-default<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-multicast<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-zookeeper<span class="tag">&lt;/<span class="name">module</span>&gt;</span>[推荐]</span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-redis<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-consul<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-etcd3<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-nacos<span class="tag">&lt;/<span class="name">module</span>&gt;</span>[推荐]</span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-multiple<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-sofa<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Multicast-注册中心"><a href="#Multicast-注册中心" class="headerlink" title="Multicast 注册中心"></a>Multicast 注册中心</h1><h1 id="zookeeper-注册中心"><a href="#zookeeper-注册中心" class="headerlink" title="zookeeper 注册中心"></a>zookeeper 注册中心</h1><h2 id="需要安装zookeeper"><a href="#需要安装zookeeper" class="headerlink" title="需要安装zookeeper"></a>需要安装zookeeper</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:12181"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:2181"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181,10.20.153.12:2181"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="zk客户端"><a href="#zk客户端" class="headerlink" title="zk客户端"></a>zk客户端</h3><p>dubbo 2.6 以前的版本引入 zkclient 操作 zookeeper<br>dubbo 2.6 及以后的版本引入 curator 操作 zookeeper<br>2.7.5版本查看代码：curator</p>
<h1 id="Nacos-注册中心"><a href="#Nacos-注册中心" class="headerlink" title="Nacos 注册中心"></a>Nacos 注册中心</h1><p><a href="https://nacos.io/zh-cn/docs/quick-start-docker.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/quick-start-docker.html</a></p>
<p>参看git：<a href="https://github.com/bjlhx15/shell.git" target="_blank" rel="noopener">https://github.com/bjlhx15/shell.git</a><br>中:docker/nacos</p>
<h1 id="Redis-注册中心"><a href="#Redis-注册中心" class="headerlink" title="Redis 注册中心"></a>Redis 注册中心</h1>]]></content>
      <categories>
        <category>rpc-dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>002-dubbo的四种配置方式</title>
    <url>/articles/20200226/be7f604f.html</url>
    <content><![CDATA[<p>摘要：后续文章主要以2.7.5 版本说明</p>
<a id="more"></a>

<h1 id="xml配置【最为常用】"><a href="#xml配置【最为常用】" class="headerlink" title="xml配置【最为常用】"></a>xml配置【最为常用】</h1><p>代码级别：<a href="https://github.com/bjlhx15/rpc-dubbo.git" target="_blank" rel="noopener">https://github.com/bjlhx15/rpc-dubbo.git</a> 的 rpc-dubbo-001-sample<br>使用的既是 xml配置</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="provider-xml-示例"><a href="#provider-xml-示例" class="headerlink" title="provider.xml 示例"></a>provider.xml 示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20890"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.samples.basic.impl.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="consumer-xml-示例"><a href="#consumer-xml-示例" class="headerlink" title="consumer.xml 示例"></a>consumer.xml 示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">group</span>=<span class="string">"aaa"</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="标签支持自定义参数"><a href="#标签支持自定义参数" class="headerlink" title="标签支持自定义参数"></a>标签支持自定义参数</h3><p>所有标签都支持自定义参数，用于不同扩展点实现的特殊配置，如：<br>如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"jms"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"queue"</span> <span class="attr">value</span>=<span class="string">"your_queue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"jms"</span> <span class="attr">p:queue</span>=<span class="string">"your_queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签	用途	解释</span><br><span class="line">&lt;dubbo:service&#x2F;&gt;	服务配置	用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</span><br><span class="line">&lt;dubbo:reference&#x2F;&gt;	引用配置	用于创建一个远程服务代理，一个引用可以指向多个注册中心</span><br><span class="line">&lt;dubbo:protocol&#x2F;&gt;	协议配置	用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</span><br><span class="line">&lt;dubbo:application&#x2F;&gt;	应用配置	用于配置当前应用信息，不管该应用是提供者还是消费者</span><br><span class="line">&lt;dubbo:module&#x2F;&gt;	模块配置	用于配置当前模块信息，可选</span><br><span class="line">&lt;dubbo:registry&#x2F;&gt;	注册中心配置	用于配置连接注册中心相关信息</span><br><span class="line">&lt;dubbo:monitor&#x2F;&gt;	监控中心配置	用于配置连接监控中心相关信息，可选</span><br><span class="line">&lt;dubbo:provider&#x2F;&gt;	提供方配置	当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</span><br><span class="line">&lt;dubbo:consumer&#x2F;&gt;	消费方配置	当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</span><br><span class="line">&lt;dubbo:method&#x2F;&gt;	方法配置	用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</span><br><span class="line">&lt;dubbo:argument&#x2F;&gt;	参数配置	用于指定方法参数配置</span><br></pre></td></tr></table></figure>

<h2 id="不同粒度配置的覆盖关系"><a href="#不同粒度配置的覆盖关系" class="headerlink" title="不同粒度配置的覆盖关系"></a>不同粒度配置的覆盖关系</h2><p>以 timeout 为例，下图显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：</p>
<ul>
<li>方法级优先，接口级次之，全局配置再次之。</li>
<li>如果级别一样，则消费方优先，提供方次之。</li>
</ul>
<p>其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。</p>
<p>（建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置）。</p>
<p>理论上 ReferenceConfig 中除了interface这一项，其他所有配置项都可以缺省不配置，框架会自动使用ConsumerConfig，ServiceConfig, ProviderConfig等提供的缺省配置。</p>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><p>属性配置、API配置、注解配置<br>参看：<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/properties.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/configuration/properties.html</a></p>
]]></content>
      <categories>
        <category>rpc-dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>001-dubbo简介与准备</title>
    <url>/articles/20200226/47f3ff77.html</url>
    <content><![CDATA[<p>摘要：阿里出品，开源。目前持续支持。</p>
<a id="more"></a>

<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>dubbo个人示例代码：<a href="https://github.com/bjlhx15/rpc-dubbo.git" target="_blank" rel="noopener">https://github.com/bjlhx15/rpc-dubbo.git</a></p>
<p>docker安装：<a href="https://github.com/bjlhx15/shell.git" target="_blank" rel="noopener">https://github.com/bjlhx15/shell.git</a></p>
<p>dubbo代码：<a href="https://github.com/apache/dubbo.git" target="_blank" rel="noopener">https://github.com/apache/dubbo.git</a></p>
<p>dubbo参看文档：<a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p>
<p>nacos文档：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>远程接口调用、负载均衡和容错、自动服务注册和发现。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>需要安装注册中心、开发提供者、消费者</p>
<h2 id="注册中心安装-mac机器docker安装zk"><a href="#注册中心安装-mac机器docker安装zk" class="headerlink" title="注册中心安装-mac机器docker安装zk"></a>注册中心安装-mac机器docker安装zk</h2><p>参看git：<a href="https://github.com/bjlhx15/shell.git" target="_blank" rel="noopener">https://github.com/bjlhx15/shell.git</a><br>中docker/zookeeper/mac</p>
<h2 id="安装dubbo-admin对服务监控功能"><a href="#安装dubbo-admin对服务监控功能" class="headerlink" title="安装dubbo-admin对服务监控功能"></a>安装dubbo-admin对服务监控功能</h2><p>看：<a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin</a></p>
<p>生产环境配置 步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载代码: git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;dubbo-admin.git</span><br><span class="line"></span><br><span class="line">在 dubbo-admin-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties中指定注册中心地址</span><br><span class="line"></span><br><span class="line">构建</span><br><span class="line"></span><br><span class="line">mvn clean package -Dmaven.test.skip&#x3D;true</span><br><span class="line">启动</span><br><span class="line"></span><br><span class="line">mvn --projects dubbo-admin-server spring-boot:run</span><br><span class="line">或者</span><br><span class="line">cd dubbo-admin-distribution&#x2F;target; java -jar dubbo-admin-0.1.jar</span><br><span class="line">访问 http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>

<h2 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h2><p>代码级别：<a href="https://github.com/bjlhx15/rpc-dubbo.git" target="_blank" rel="noopener">https://github.com/bjlhx15/rpc-dubbo.git</a> 的 rpc-dubbo-001-sample</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id-generator-sample-dubbo-consumer</span><br><span class="line">id-generator-sample-dubbo-intf</span><br><span class="line">id-generator-sample-dubbo-provider</span><br></pre></td></tr></table></figure>
<ol>
<li>修改配置<br>在 provider、consumer 项目配置中：dubbo-XX.xml 修改配置中心地址</li>
<li>分别启动对应的main方法</li>
<li>测试<br>服务端服务：<a href="http://localhost:8082/get" target="_blank" rel="noopener">http://localhost:8082/get</a></li>
</ol>
<p>消费者服务：<a href="http://localhost:8083/get" target="_blank" rel="noopener">http://localhost:8083/get</a></p>
<p>参看项目：<a href="https://github.com/apache/dubbo/tree/master/dubbo-demo/dubbo-demo-xml" target="_blank" rel="noopener">https://github.com/apache/dubbo/tree/master/dubbo-demo/dubbo-demo-xml</a></p>
]]></content>
      <categories>
        <category>rpc-dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>001-rpc简介以及原理</title>
    <url>/articles/20200226/f4b7122c.html</url>
    <content><![CDATA[<p>摘要：什么是rpc,原理</p>
<a id="more"></a>

<h1 id="什么是rpc"><a href="#什么是rpc" class="headerlink" title="什么是rpc"></a>什么是rpc</h1><p>  RPC 【Remote Procedure Call，远程过程调用】：A调用B，A挂起，B执行，执行完毕后，继续执行A，这种机制称为RPC。<br>  是一种通过网络从远程计算机程序上请求服务来得到计算服务或者数据服务，且不需要了解底层网络技术的协议和框架。</p>
<h1 id="RPC服务原理"><a href="#RPC服务原理" class="headerlink" title="RPC服务原理"></a>RPC服务原理</h1><h2 id="socket-套接字"><a href="#socket-套接字" class="headerlink" title="socket 套接字"></a>socket 套接字</h2><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为socket。</p>
<p>socket用于描述IP地址和端口，是一个通信连接的句柄，可以用来实现不同的计算机之间的通信，是网络编程接口的具体实现。</p>
<h2 id="rpc调用过程"><a href="#rpc调用过程" class="headerlink" title="rpc调用过程"></a>rpc调用过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------客户端---------+        +---------服务端---------+ </span><br><span class="line">|                       |        |                       |</span><br><span class="line">|     |客户端函数|        |        |      |服务端函数|      |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|       1     10        |        |        5     6        |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|     |客户端存根|        |        |      |服务端存根|      |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|       2     9         |        |        4     7        |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|     |客户端套接字|------|---3----|-----→|服务端套接字|     |</span><br><span class="line">|                 ←-----|---8----|------                 |</span><br><span class="line">|_______________________|        |_______________________|</span><br></pre></td></tr></table></figure>

<ul>
<li>第1步，客户端调用本地存根方法，对于客户端程序来说，就是本地普通方法，但是，他的执行与本地代码不同，因为真正执行的是发生在远程服务器上。<br>客户端存根方法会将参数打包并封装成一个或多个网络消息体并发送到服务端。参数封装到网络消息中的过程称为编码（encode），他会将所有数据序列化为字节数组格式</li>
<li>第2步，客户端存根通过系统调用，使用操作系统内核提供的socket套接字接口来向远程服务发送我们编码的的网络消息</li>
<li>第3步，网络消息由内核通过某种协议（UDP，TCP）传输到远端服务器。</li>
<li>第4步，服务端存根接收到客户端消息，并对参数消息进行解码（decode），通常会将参数从标准的网络格式转换成特定的语言格式。</li>
<li>第5步，服务端存根调用服务端方法，并将从客户端接收的参数传递给该方法，他来运行具体的功能并返回，这部分代码的执行对客户端来说就是远程调用过程</li>
<li>第6步，服务端方法执行完毕后，会把结果返回到服务端存根代码中。</li>
<li>第7步，服务端存根在将该返回值进行编码并序列化后，通过一个或多个套接字网络消息发送给客户端</li>
<li>第8步，消息通过网络发送给客户端存根中。</li>
<li>第9步，客户端存根从本地socket接口中读取结果消息。</li>
<li>第10步，客户端存根将结果传给客户端函数，并且将消息从网络二进制转化为本地语言格式。</li>
</ul>
<p>以上为整个rpc调用过程。</p>
<h1 id="在程序中使用RPC"><a href="#在程序中使用RPC" class="headerlink" title="在程序中使用RPC"></a>在程序中使用RPC</h1><p>目前大部分语言【C、C++、java等】，都没有设计用于远程调用的内置语法，因此不能编译生成必要的存根方法。</p>
<p>IDL 接口定义语言。</p>
<p>RPC是构建在语言级别之上的，是跨语言的，他在OSI七层网络模型中介于会话层和表示层之间。</p>
]]></content>
      <categories>
        <category>rpc</category>
      </categories>
  </entry>
  <entry>
    <title>数据存储分布方案</title>
    <url>/articles/20200225/e0a8e4c6.html</url>
    <content><![CDATA[<p>1、数据结构<br>2、数据量：第一次 7条<br>    后续：每个合同 5条</p>
<p>3、分布式主键 生成</p>
<p>4、数据库mysql 分库分表</p>
]]></content>
  </entry>
  <entry>
    <title>003-tools-markdown-流程图</title>
    <url>/articles/20200225/b7758272.html</url>
    <content><![CDATA[<p>概述:003-tools-markdown-流程图</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><p>Markdown Preview Enhanced<br>默认支持，直接使用，预览功能 最流程图支持不够。</p>
<p>推荐使用插件：Markdown Preview Enhanced</p>
<p>Markdown Preview Enhanced 内部支持 mermaid, PlantUML, WaveDrom,GraphViz，Vega &amp; Vega-lite，Ditaa 图像渲染。<br>你也可以通过使用 Code Chunk 来渲染 TikZ, Python Matplotlib, Plotly 等图像。</p>
<h2 id="流图-mermaid"><a href="#流图-mermaid" class="headerlink" title="流图-mermaid"></a>流图-mermaid</h2><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。</p>
<p>Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码，因此安全许多。</p>
<p>官网：<a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">https://mermaidjs.github.io/</a><br>Github 项目地址：<a href="https://github.com/knsv/mermaid" target="_blank" rel="noopener">https://github.com/knsv/mermaid</a></p>
<h3 id="流程图-graph"><a href="#流程图-graph" class="headerlink" title="流程图-graph"></a>流程图-graph</h3><p>语法，左侧 // 不需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;        &#96;&#96;&#96;mermaid</span><br><span class="line">&#x2F;&#x2F;        graph 方向</span><br><span class="line">&#x2F;&#x2F;          A --&gt; B</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说明 </span><br><span class="line">1. 三个“&#96;”后的mermaid表示使用这个语言化图</span><br><span class="line">2. graph：流程图</span><br><span class="line">3. graph 后字符：方向描述</span><br><span class="line">4. 实际业务</span><br><span class="line"></span><br><span class="line">#### 方向描述</span><br></pre></td></tr></table></figure>
<pre><code>用词    含义
TB    从上到下
BT    从下到上
RL    从右到左
LR    从左到右</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 节点定义</span><br><span class="line">即流程图中每个文本块，包括开始、结束、处理、判断等。Mermaid 中每个节点都有一个 id，以及节点的文字。</span><br></pre></td></tr></table></figure>
<p>表述    说明<br>id[文字]    矩形节点<br>id(文字)    圆角矩形节点<br>id((文字))    圆形节点<br>id&gt;文字]    右向旗帜状节点<br>id{文字}    菱形节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">graph LR</span><br><span class="line">  id1[矩形节点]--&gt;id2(圆角矩形节点)</span><br><span class="line">  --&gt;id3((圆形节点))</span><br><span class="line">  id4&gt;右向旗帜状节点]--&gt;id5&#123;菱形节点&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果节点的文字中包含标点符号，需要时用双引号包裹起来。<br>另外如果希望在文字中使用换行，请使用 替换换行</p>
<h4 id="节点间的连线"><a href="#节点间的连线" class="headerlink" title="节点间的连线"></a>节点间的连线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表述	说明</span><br><span class="line">&gt;	添加尾部箭头</span><br><span class="line">-	不添加尾部箭头</span><br><span class="line">--	单线</span><br><span class="line">--text--	单线上加文字</span><br><span class="line">&#x3D;&#x3D;	粗线</span><br><span class="line">&#x3D;&#x3D;text&#x3D;&#x3D;	粗线加文字</span><br><span class="line">-.-	虚线</span><br><span class="line">-.text.-	虚线加文字</span><br></pre></td></tr></table></figure>

<p>线条 箭头 可以组合使用</p>
<h4 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h4><p>使用以下语法添加子图表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subgraph 子图表名称</span><br><span class="line">    子图表中的描述语句...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><ul>
<li>linkStyle 后面的数字表示第几根线，从 0 开始。可以指定颜色和粗细。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">    linkStyle 0 stroke:#0ff,stroke-width:2px;</span><br><span class="line">    linkStyle 3 stroke:#ff3,stroke-width:4px;</span><br></pre></td></tr></table></figure></li>
<li>可以设置节点背景，边框颜色，粗细，实线还是虚线<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1(Start)--&gt;id2(Stop)</span><br><span class="line">    style id1 fill:#f9f,stroke:#333,stroke-width:4px</span><br><span class="line">    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5</span><br></pre></td></tr></table></figure></li>
<li>样式类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt;B</span><br><span class="line"></span><br><span class="line">    %% 定义样式类</span><br><span class="line">    classDef className fill:#f9f,stroke:#333,stroke-width:4px;</span><br><span class="line"></span><br><span class="line">    %% 应用样式类，markdown里没效果</span><br><span class="line">    class A className</span><br></pre></td></tr></table></figure>
定义一个名为 default 的类，节点没有指定特定样式类时，将都会应用这个样式类。</li>
</ul>
<h4 id="图标-对-fontawesome-的支持"><a href="#图标-对-fontawesome-的支持" class="headerlink" title="图标-对 fontawesome 的支持"></a>图标-对 fontawesome 的支持</h4><p>使用 fa: #图表名称# 的语法添加 <a href="https://fontawesome.com/" target="_blank" rel="noopener">fontawesome</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">   B[&quot;fa:fa-twitter for peace&quot;]</span><br><span class="line">   B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">   B--&gt;D(fa:fa-spinner);</span><br><span class="line">   B--&gt;E(A fa:fa-camera-retro perhaps?);</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    id1(圆角矩形)--普通线--&gt;id2[矩形]</span><br><span class="line">    subgraph 子图表</span><br><span class="line">        id2&#x3D;&#x3D;粗线&#x3D;&#x3D;&gt;id3&#123;菱形&#125;</span><br><span class="line">        id3-.虚线.-&gt;id4&gt;右向旗帜]</span><br><span class="line">        id3--无箭头---id5((圆形))</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三-&gt;&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure>

<h3 id="序列图、时序图-sequenceDiagram"><a href="#序列图、时序图-sequenceDiagram" class="headerlink" title="序列图、时序图-sequenceDiagram"></a>序列图、时序图-sequenceDiagram</h3><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#96;&#96;&#96;mermaid</span><br><span class="line">&#x2F;&#x2F;sequenceDiagram</span><br><span class="line">&#x2F;&#x2F;  [参与者1][消息线][参与者2]:消息体</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<p>  或<br>  //<code>mermaid
  //sequenceDiagram
  //  participant 参与者 1
  //  participant 参与者 2
  //  ...
  //  participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3
  //</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">    张三-&gt;&gt;李四: 吃了吗？</span><br><span class="line">    李四-&gt;&gt;张三: 吃了</span><br></pre></td></tr></table></figure>

<h4 id="消息线"><a href="#消息线" class="headerlink" title="消息线"></a>消息线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|类型|描述|</span><br><span class="line">|-&gt;|无箭头的实线|</span><br><span class="line">|--&gt;|无箭头的虚线|</span><br><span class="line">|-&gt;&gt;|有箭头的实线|</span><br><span class="line">|--&gt;&gt;|有箭头的虚线|</span><br><span class="line">|-x|末端为叉的实线（表示异步）|</span><br><span class="line">|--x|末端为叉的虚线（表示异步）|</span><br></pre></td></tr></table></figure>

<h4 id="处理中"><a href="#处理中" class="headerlink" title="处理中"></a>处理中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在消息线末尾增加 + ，则消息接收者进入当前消息的“处理中”状态；</span><br><span class="line">在消息线末尾增加 - ，则消息接收者离开当前消息的“处理中”状态。</span><br></pre></td></tr></table></figure>
<p>或者使用以下语法直接说明某个参与者进入“处理中”状态:activate 参与者</p>
<h4 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h4><p>语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note 位置表述 参与者: 标注文字</span><br></pre></td></tr></table></figure>
<p>其中位置表述可以为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表述	含义</span><br><span class="line">right of	右侧</span><br><span class="line">left of	左侧</span><br><span class="line">over	在当中，可以横跨多个参与者</span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop 循环的条件</span><br><span class="line">    循环体描述语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alt 条件 1 描述</span><br><span class="line">    分支 1 描述语句</span><br><span class="line">else 条件 2 描述 # else 分支可选</span><br><span class="line">    分支 2 描述语句</span><br><span class="line">else ...</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>如果遇到可选的情况，即没有 else 分支的情况，使用如下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opt 条件描述</span><br><span class="line">    分支描述语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="mermaid">sequenceDiagram
    participant z as 张三
    participant l as 李四
    loop 日复一日
        z-&gt;&gt;l: 吃了吗您呐？
        l--&gt;&gt;z: 吃了，您呢？
        activate z
        Note left of z: 想了一下
        alt 还没吃
            z-xl: 还没呢，正准备回去吃
        else 已经吃了
            z-xl: 我也吃过了，哈哈
        end
        opt 大过年的
            l--&gt;z: 祝您新年好啊
        end
    end</code></pre>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>009-cmd-清空文件</title>
    <url>/articles/20200224/f0d92348.html</url>
    <content><![CDATA[<p>摘要：009-cmd-清空文件</p>
<a id="more"></a>

<ol>
<li>使用重定向的方法</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">&gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用true命令重定向清空文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line"><span class="literal">true</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用cat/cp/dd命令及/dev/null设备来清空文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">cat /dev/null &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br><span class="line"><span class="comment">###################################################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">cp /dev/null test.txt </span><br><span class="line">cp：是否覆盖<span class="string">"test.txt"</span>？ y</span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/null of=test.txt </span><br><span class="line"><span class="comment"># 记录了0+0 的读入</span></span><br><span class="line"><span class="comment"># 记录了0+0 的写出</span></span><br><span class="line"><span class="comment"># 0字节(0 B)已复制，0.000266781 秒，0.0 kB/秒</span></span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用echo命令清空文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">""</span> &gt; test.txt    ==&gt;要加上<span class="string">"-n"</span>参数，默认情况下会<span class="string">"\n"</span>，也就是回车符</span><br><span class="line">du -h test.txt  </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure></li>
<li>使用truncate命令清空文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">truncate -s 0 test.txt   -s参数用来设定文件的大小，清空文件，就设定为0；</span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>






</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>008-cmd-文件cat、touch、echo</title>
    <url>/articles/20200224/341c10ca.html</url>
    <content><![CDATA[<p>摘要：008-cmd-文件cat、touch、echo</p>
<a id="more"></a>

<h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容</p>
<ul>
<li>cat主要有三大功能：</li>
</ul>
<ol>
<li>一次显示整个文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure></li>
<li>从键盘创建一个文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat  &gt;  filename</span><br></pre></td></tr></table></figure>
只能创建新文件,不能编辑已有文件.</li>
<li>将几个文件合并为一个文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat   file1   file2  &gt; file</span><br></pre></td></tr></table></figure>
两种均可，后者，支持嵌套</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>cat具体命令格式为 : cat [-AbeEnstTuv] [–help] [–version] fileName</p>
<p>说明：把档案串连接后传到基本输出(屏幕或加 &gt; fileName 到另一个档案)</p>
<p>参数：</p>
<blockquote>
<p>-n 或 –number 由 1 开始对所有输出的行数编号<br>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号<br>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-v 或 –show-nonprinting</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li>把 linuxfile1 的档案内容加上行号后输入 linuxfile2 这个档案里<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat -n linuxfile1 &gt; linuxfile2</span><br></pre></td></tr></table></figure></li>
<li>把 linuxfile1 和 linuxfile2 的档案内容加上行号(空白行不加)之后将内容附加到 linuxfile3 里。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat -b linuxfile1 linuxfile2 &gt;&gt; linuxfile3</span><br><span class="line">cat /dev/null &gt; /etc/test.txt 此为清空/etc/test.txt档案内容</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h1><p>一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；</p>
<p>二是用来创建新的空文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a或--time&#x3D;atime或--time&#x3D;access或--time&#x3D;use  只更改存取时间。</span><br><span class="line">-c或--no-create  不建立任何文件。</span><br><span class="line">-d&lt;时间日期&gt;  使用指定的日期时间，而非现在的时间。</span><br><span class="line">-f  此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</span><br><span class="line">-m或--time&#x3D;mtime或--time&#x3D;modify  只更改变动时间。</span><br><span class="line">-r&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同。</span><br><span class="line">-t&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间。</span><br><span class="line">--help  在线帮助。</span><br><span class="line">--version  显示版本信息。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><ol>
<li>创建file1—file10共10个文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch file&#123;1..10&#125;</span><br></pre></td></tr></table></figure></li>
<li>设定文件的时间戳<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch -t 201810121230 hh.sh 【-t用十进制数】</span><br></pre></td></tr></table></figure></li>
<li>更新log.log的时间和log2012.log时间戳相同<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch -r hh hh.sh    【touch -r目标文件  源文件】</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>003-ocr-baidu</title>
    <url>/articles/20200220/ce469e7.html</url>
    <content><![CDATA[<p>摘要：003-ocr-baidu</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从一张图片中识别出中文，通过python来实现</p>
<h2 id="百度注册"><a href="#百度注册" class="headerlink" title="百度注册"></a>百度注册</h2><p>百度云注册账号 <a href="https://cloud.baidu.com/?from=console" target="_blank" rel="noopener">https://cloud.baidu.com/?from=console</a><br>管理应用 <a href="https://console.bce.baidu.com/ai/#/ai/ocr/overview/index" target="_blank" rel="noopener">https://console.bce.baidu.com/ai/#/ai/ocr/overview/index</a> 创建一个</p>
<p>进入链接之后创建应用，由于是从文字识别点进去的，所以默认选中的就是ocr相关内容，填好表格确认。</p>
<p>使用：AppID 、API Key、Secret Key</p>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>官方指南：<a href="https://ai.baidu.com/docs#/OCR-Python-SDK/top" target="_blank" rel="noopener">https://ai.baidu.com/docs#/OCR-Python-SDK/top</a><br>安装使用Python SDK： pip install baidu-aip<br>cv2 需要安装：pip install opencv_python<br>如果只需要预测文字以及框出文字区域，执行以下代码即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line"><span class="string">""" 你的 APPID AK SK  图2的内容"""</span></span><br><span class="line">APP_ID = <span class="string">'14318340'</span></span><br><span class="line">API_KEY = <span class="string">'DUvK5jEkNmCIEz4cXH8VvIVC'</span></span><br><span class="line">SECRET_KEY = <span class="string">'*******'</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line">fname = <span class="string">'picture/test4.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="string">""" 读取图片 """</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filePath, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line">image = get_file_content(fname)</span><br><span class="line"></span><br><span class="line"><span class="string">""" 调用通用文字识别, 图片参数为本地图片 """</span></span><br><span class="line">results = client.general(image)[<span class="string">"words_result"</span>]  <span class="comment"># 还可以使用身份证驾驶证模板，直接得到字典对应所需字段</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(fname)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    text = result[<span class="string">"words"</span>]</span><br><span class="line">    location = result[<span class="string">"location"</span>]</span><br><span class="line"></span><br><span class="line">    print(text)</span><br><span class="line">    <span class="comment"># 画矩形框</span></span><br><span class="line">    cv2.rectangle(img, (location[<span class="string">"left"</span>],location[<span class="string">"top"</span>]), (location[<span class="string">"left"</span>]+location[<span class="string">"width"</span>],location[<span class="string">"top"</span>]+location[<span class="string">"height"</span>]), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(fname[:<span class="number">-4</span>]+<span class="string">"_result.jpg"</span>, img)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>002-ocr-tesseract-ocr</title>
    <url>/articles/20200220/ff5ff1f0.html</url>
    <content><![CDATA[<p>摘要：002-ocr-tesseract-ocr</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从一张图片中识别出中文，通过python来实现</p>
<p>Tesseract的OCR引擎目前已作为开源项目发布在Google Project，其项目主页在这里查看<a href="https://github.com/tesseract-ocr，" target="_blank" rel="noopener">https://github.com/tesseract-ocr，</a></p>
<p>它支持中文OCR，并提供了一个命令行工具。python中对应的包是pytesseract. 通过这个工具我们可以识别图片上的文字。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="开发环境如下："><a href="#开发环境如下：" class="headerlink" title="开发环境如下："></a>开发环境如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macosx</span><br><span class="line">python 3.7</span><br><span class="line">brew</span><br></pre></td></tr></table></figure>

<h3 id="安装tesseract-和-pytesseract"><a href="#安装tesseract-和-pytesseract" class="headerlink" title="安装tesseract 和 pytesseract"></a>安装tesseract 和 pytesseract</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装tesseract</span></span><br><span class="line">brew install tesseract</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装python对应的包：pytesseract</span></span><br><span class="line">pip install pytesseract</span><br></pre></td></tr></table></figure>

<h3 id="中文字体下载安装"><a href="#中文字体下载安装" class="headerlink" title="中文字体下载安装"></a>中文字体下载安装</h3><h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><p>要识别中文需要下载对应的训练集：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></p>
<p>下载”chi_sim.traineddata”，然后copy到训练数据集的存放路径，如：</p>
<p>/usr/local/Cellar/tesseract/4.1.1/share/tessdata</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">'/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/ocr/timg.jpeg'</span>)</span><br><span class="line">code = pytesseract.image_to_string(image, lang=<span class="string">'chi_sim'</span>)</span><br><span class="line">print(code)</span><br><span class="line"><span class="comment"># 你 一 定 要 过 的 好</span></span><br><span class="line"><span class="comment"># 不 然 对 不 起 我 的 不 打 扰</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>001-感知哈希算法</title>
    <url>/articles/20200220/121774e7.html</url>
    <content><![CDATA[<p>摘要：001-感知哈希算法</p>
<a id="more"></a>

<h1 id="两个图片是否是同一个图片内容"><a href="#两个图片是否是同一个图片内容" class="headerlink" title="两个图片是否是同一个图片内容"></a>两个图片是否是同一个图片内容</h1><h2 id="绝对一样【数据存储结构一样】"><a href="#绝对一样【数据存储结构一样】" class="headerlink" title="绝对一样【数据存储结构一样】"></a>绝对一样【数据存储结构一样】</h2><p>如果就是复制出来的，其实比较两个图片的 普通 sha 或者md5即可，</p>
<p>此处比对的是文件的数据结构。</p>
<h2 id="相似图片"><a href="#相似图片" class="headerlink" title="相似图片"></a>相似图片</h2><p>如果两个图片内容一样，但是有的经过压缩处理了，大小不一样，即存储结果不一样</p>
<h1 id="感知哈希"><a href="#感知哈希" class="headerlink" title="感知哈希"></a>感知哈希</h1><p>感知哈希算法（Perceptual hash algorithm），是一类哈希算法的总称，它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，比较不同图像的指纹信息来判断图像的相似性。结果越接近图像越相似。</p>
<p>感知哈希算法包括均值哈希（aHash）、感知哈希（pHash）和dHash（差异值哈希）。</p>
<p>aHash速度较快，但精确度较低；pHash则反其道而行之，精确度较高但速度较慢；dHash兼顾二者，精确度较高且速度较快。</p>
<p>在得到64位hash值后，使用汉明距离量化两张图像的相似性。汉明距离越大，图像的相似度越小，汉明距离越小，图像的相似度越大。</p>
<h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p>汉明距离是使用在数据传输差错控制编码里面的，汉明距离是一个概念，它表示两个（相同长度）字对应位不同的数量，我们以d（x,y）表示两个字x,y之间的汉明距离。对两个字符串进行异或运算，并统计结果为1的个数，那么这个数就是汉明距离。例如：<br>1011101与1001001之间的汉明距离是2。<br>2143896与2233796之间的汉明距离是3。<br>“toned”与”roses”之间的汉明距离是3。</p>
<h2 id="均值哈希（aHash）"><a href="#均值哈希（aHash）" class="headerlink" title="均值哈希（aHash）"></a>均值哈希（aHash）</h2><ul>
<li>a) 缩放图片：为了保留图像的结构，降低图像的信息量，需要去掉细节、大小和横纵比的差异，建议把图片统一缩放到8*8，共64个像素的图片；</li>
<li>b) 转化为灰度图：把缩放后的图片转化为256阶的灰度图；</li>
</ul>
<blockquote>
<p>灰度图相关算法（R = red， G = green， B = blue）<br>对于彩色转灰度，其基础的心理学公式为： Gray = R0.299 + G0.587 + B0.114，部分变种也很流行：<br>i. 浮点算法：Gray=R0.3+G0.59+B0.11<br>ii. 整数方法：Gray=(R30+G59+B11)/100<br>iii. 移位方法：Gray =(R76+G151+B28)&gt;&gt;8;<br>iv. 平均值法：Gray=（R+G+B）/3;<br>v. 仅取绿色：Gray=G；</p>
</blockquote>
<ul>
<li>c) 计算平均值： 计算进行灰度处理后图片的所有像素点的平均值；</li>
<li>d) 比较像素灰度值：遍历灰度图片每一个像素，如果大于平均值记录为1，否则为0；</li>
<li>e) 构造hash值：组合64个bit位生成hash值，顺序随意但前后保持一致性即可；</li>
<li>f) 对比指纹：计算两幅图片的指纹，计算汉明距离。</li>
</ul>
<h2 id="感知哈希（pHash）"><a href="#感知哈希（pHash）" class="headerlink" title="感知哈希（pHash）"></a>感知哈希（pHash）</h2><p>感知哈希算法可以获得更精确的结果，它采用的是DCT（离散余弦变换）来降低频率。</p>
<ul>
<li>a) 缩小尺寸<br>为了简化了DCT的计算，pHash以小图片开始（建议图片大于8x8，32x32）。</li>
<li>b) 简化色彩<br>与aHash相同，需要将图片转化成灰度图像，进一步简化计算量（具体算法见aHash算法步骤）。</li>
<li>c) 计算DCT<br>DCT是把图片分解频率聚集和梯状形。这里以32x32的图片为例。</li>
</ul>
<blockquote>
<p>DCT变换的全称是离散余弦变换(Discrete Cosine Transform)，主要用于将数据或图像的压缩，能够将空域的信号转换到频域上，具有良好的去相关性的性能。DCT变换本身是无损的，但是在图像编码等领域给接下来的量化、哈弗曼编码等创造了很好的条件，同时，由于DCT变换时对称的，所以，我们可以在量化编码后利用DCT反变换，在接收端恢复原始的图像信息。对原始图像进行离散余弦变换，变换后DCT系数能量主要集中在左上角，其余大部分系数接近于零，DCT具有适用于图像压缩的特性。将变换后的DCT系数进行门限操作，将小于一定值得系数归零，这就是图像压缩中的量化过程，然后进行逆DCT运算，可以得到压缩后的图像。</p>
</blockquote>
<blockquote>
<p>离散余弦变换的原理：<br>一维DCT变换：<br><img src="/images/post/python-algorithm/1dct.jpg" alt><br>其中，f(i)为原始的信号，F(u)是DCT变换后的系数，N为原始信号的点数，c(u)可以认为是一个补偿系数，可以使DCT变换矩阵为正交矩阵。<br>二维离散余弦变换的正变换公式为：<br><img src="/images/post/python-algorithm/1dct.jpg" alt></p>
</blockquote>
<ul>
<li>d) 缩小DCT<br>DCT的结果为32x32大小的矩阵，但只需保留左上角的8x8的矩阵，这部分呈现了图片中的最低频率。</li>
<li>e) 计算平均值<br>如同均值哈希一样，计算DCT的均值</li>
<li>f) 进一步减小DCT<br>根据8x8的DCT矩阵进行比较，大于等于DCT均值的设为”1”，小于DCT均值的设为“0”。图片的整体结构保持不变的情况下，hash结果值不变。</li>
<li>g) 构造hash值<br>组合64个bit位生成hash值，顺序随意但前后保持一致性即可。</li>
<li>h）对比指纹：计算两幅图片的指纹，计算汉明距离。</li>
</ul>
<h2 id="差异值哈希（dHash）"><a href="#差异值哈希（dHash）" class="headerlink" title="差异值哈希（dHash）"></a>差异值哈希（dHash）</h2><p>相比pHash，dHash的速度更快，相比aHash，dHash在效率几乎相同的情况下的效果要更好，它是基于渐变实现的。</p>
<ul>
<li>a) 缩小图片：收缩至9*8的大小，它有72的像素点；</li>
<li>b) 转化为灰度图：把缩放后的图片转化为256阶的灰度图。（具体算法见aHash算法步骤）；</li>
<li>c) 计算差异值：计算相邻像素间的差异值，这样每行9个像素之间产生了8个不同的差异，一共8行，则产生了64个差异值；</li>
<li>d) 比较差异值：如果前一个像素的颜色强度大于第二个像素，那么差异值就设置为“1”，如果不大于第二个像素，就设置“0”。</li>
<li>e) 构造hash值：组合64个bit位生成hash值，顺序随意但前后保持一致性即可。</li>
<li>f) 对比指纹：计算两幅图片的指纹，计算汉明距离。</li>
</ul>
<h2 id="小波哈希（wavelet-hashing）"><a href="#小波哈希（wavelet-hashing）" class="headerlink" title="小波哈希（wavelet hashing）"></a>小波哈希（wavelet hashing）</h2><p>离散小波变换（DWT）是频表示的另一种形式。流行的DCT和傅立叶变换使用余弦函数作为sin\cos的基础：sin(x)，sin(2x)，sin(3x)等等。与此相反，DWT使用一个单一的功能作为基础，但在不同的形式：缩放和移动。基础功能是可以改变的，这就是为什么我们可以有Haar小波，Daubechie-4小波等，这尺度效应给我们很大“时频表示”的时候，低频部分类似于原始信号。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>aHash：平均值哈希。速度比较快，但是常常不太精确<br>pHash：感知哈希。精确度比较高，但是速度方面较差一些<br>dHash：差异值哈希。精确度较高，且速度也非常快。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h3><p>github<a href="https://github.com/JohannesBuchner/imagehash" target="_blank" rel="noopener">https://github.com/JohannesBuchner/imagehash</a></p>
<h3 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install imagehash</span><br></pre></td></tr></table></figure>
<p>安装后在：/Users/lihongxu6/opt/anaconda3/lib/python3.7/site-packages</p>
<p>代码使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; import imagehash</span><br><span class="line">&gt;&gt;&gt; hash &#x3D; imagehash.average_hash(Image.open(&#39;test.png&#39;))</span><br><span class="line">&gt;&gt;&gt; print(hash)</span><br><span class="line">d879f8f89b1bbf</span><br><span class="line">&gt;&gt;&gt; otherhash &#x3D; imagehash.average_hash(Image.open(&#39;other.bmp&#39;))</span><br><span class="line">&gt;&gt;&gt; print(otherhash)</span><br><span class="line">ffff3720200ffff</span><br><span class="line">&gt;&gt;&gt; print(hash &#x3D;&#x3D; otherhash)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(hash - otherhash)</span><br><span class="line">36</span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="average-hashing"><a href="#average-hashing" class="headerlink" title="average hashing"></a>average hashing</h4><p>平均散列，对于每个像素输出1，如果该像素是大于或等于平均值，否则为0。</p>
<p>主函数：<br>  average_hash(image, hash_size=8)</p>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash_size = <span class="number">6</span></span><br><span class="line">hash1 = imagehash.average_hash(Image.open(<span class="string">'1_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.average_hash(Image.open(<span class="string">'5_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">hash1 - hash2</span><br></pre></td></tr></table></figure>

<h4 id="perception-hashing"><a href="#perception-hashing" class="headerlink" title="perception hashing"></a>perception hashing</h4><p>感知哈希，不同于aHash，但首先它确实是离散余弦变换和频域。</p>
<p>主函数：<br>def phash(image, hash_size=8, highfreq_factor=4):</p>
<p>两个参数，一起决定了图片resize的大小，最适合的才最好，按照公式：</p>
<ul>
<li>img_size = hash_size * highfreq_factor</li>
<li>hash_size代表最终返回hash数值长度</li>
<li>highfreq_factor，代表resize的尺度<br>案例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">highfreq_factor = <span class="number">1</span></span><br><span class="line">hash_size = <span class="number">8</span></span><br><span class="line">img_size = hash_size * highfreq_factor</span><br><span class="line"></span><br><span class="line">hash1 = imagehash.phash(Image.open(<span class="string">'1_1.jpg'</span>),hash_size=hash_size,highfreq_factor=highfreq_factor)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.phash(Image.open(<span class="string">'5_1.jpg'</span>),hash_size=hash_size,highfreq_factor=highfreq_factor)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="difference-hashing"><a href="#difference-hashing" class="headerlink" title="difference hashing"></a>difference hashing</h4><p>梯度散列，计算每个像素的差值，并与平均差异的差异进行比较。</p>
<p>主函数：def dhash(image, hash_size=8)</p>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash_size = <span class="number">10</span></span><br><span class="line">hash1 = imagehash.dhash(Image.open(<span class="string">'5_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.dhash(Image.open(<span class="string">'1_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br></pre></td></tr></table></figure>

<h5 id="wavelet-hashing"><a href="#wavelet-hashing" class="headerlink" title="wavelet hashing"></a>wavelet hashing</h5><p>离散小波变换（DWT）是频表示的另一种形式。流行的DCT和傅立叶变换使用余弦函数作为sin\cos的基础：sin(x)，sin(2x)，sin(3x)等等。与此相反，DWT使用一个单一的功能作为基础，但在不同的形式：缩放和移动。基础功能是可以改变的，这就是为什么我们可以有Haar小波，Daubechie-4小波等，这尺度效应给我们很大“时频表示”的时候，低频部分类似于原始信号。</p>
<p>它的工作原理在频域中作为pHash但它使用DWT代替DCT变换。<br>主函数：def whash(image, hash_size = 8, image_scale = None, mode = ‘haar’, remove_max_haar_ll = True)</p>
<p>参数：</p>
<ul>
<li>mode:<br>‘haar’ - Haar wavelets, by default<br>‘db4’ - Daubechies wavelets</li>
<li>remove_max_haar_ll:是否去掉低频段位，low level (LL) frequency</li>
<li>image_scale:图像重新resize成多大，一定是2的倍数</li>
</ul>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash_size = <span class="number">8</span></span><br><span class="line">mode = <span class="string">'db4'</span></span><br><span class="line">image_scale = <span class="number">64</span></span><br><span class="line">hash1 = imagehash.whash(Image.open(<span class="string">'1_1.jpg'</span>),image_scale=image_scale,hash_size=hash_size,mode = mode)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.whash(Image.open(<span class="string">'5_1.jpg'</span>),image_scale=image_scale,hash_size=hash_size,mode = mode)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br></pre></td></tr></table></figure>
<p>更多代码：<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a></p>
]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>007-binlog</title>
    <url>/articles/20200220/feb3a22e.html</url>
    <content><![CDATA[<p>摘要：007-binlog</p>
<a id="more"></a>

<h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><h2 id="日志的三种模式"><a href="#日志的三种模式" class="headerlink" title="日志的三种模式"></a>日志的三种模式</h2><p>系统变量binlog_format 指定二进制日志的类型。分别有STATEMENT、ROW、MIXED三种值。MySQL 5.7.6之前默认为STATEMENT模式。MySQL 5.7.7之后默认为ROW模式。这个参数主要影响主从复制。</p>
<p>开启和停用Binlog：log-bin=mysql-bin</p>
<p>查看binlog的格式：show variables like ‘binlog_format’</p>
<p>基于SQL语句的复制（statement-based replication, SBR）<br>基于行的复制（row-based replication, RBR）<br>混合模式复制（mixed-based replication, MBR）</p>
<h3 id="statement-level模式"><a href="#statement-level模式" class="headerlink" title="statement level模式"></a>statement level模式</h3><p>每一条会修改数据的sql都会记录到master的bin-log中。slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql来再次执行。</p>
<ul>
<li>适用场景：对主从数据一致性要求不太高，并且很少用到函数、存储过程、触发器等场景</li>
<li>优点：statement level下的优点，首先就是解决了row level下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约io，提高性能。因为他只需要记录在master上所执行的语句的细节，以及执行语句时候的上下文的信息。</li>
<li>缺点：由于它是记录的执行语句，所以为了让这些语句在slave端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果。另外就是,由于mysql现在发展比较快，很多的新功能加入，使mysql的复制遇到了不小的挑战,自然复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement level下，目前已经发现的就有不少情况会造成mysql的复制问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如sleep()在有些版本就不能正确复制。<br>部分新功能（函数、存储过程、触发器）同步会有障碍，比如now()</li>
</ul>
<h3 id="rowlevel模式"><a href="#rowlevel模式" class="headerlink" title="rowlevel模式"></a>rowlevel模式</h3><p>5.1.5版本的MySQL才开始支持row level的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>
<p>日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改</p>
<ul>
<li>适用场景：对主从数据一致性要求比较高的场景。</li>
<li>优点：bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以row level的日志的内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function,以及trigger的调用和触发无法被正确复制的问题。</li>
<li>缺点：row level下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改记录，这样可能会产生大量的日志内容，比如有这样一条update语句：update product set owner_member_id=‘d’ where owner_member_id=‘a’,执行之后，日志中记录的不是这条update语句所对应的事件(mysql是以事件的形式来记录bin-log日志)，而是这条语句所更新的每一条记录的变化情况，这样就记录成很多条记录被更新的很多事件。自然，bin-log日志的量会很大。</li>
</ul>
<h3 id="mixed模式"><a href="#mixed模式" class="headerlink" title="mixed模式"></a>mixed模式</h3><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合</p>
<p>实际上就是前两种模式的结合，在mixed模式下，mysql会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在statement和row之间选一种。新版本中的statement level还是和以前一样，仅仅记录执行的语句。而新版本的mysql中对row level模式被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete 等修改数据的语句，那么还是会记录所有行的变更。</p>
<p>MySQL默认采用statement格式进行二进制日志文件的记录，但是在一些情况下会使用row格式，可能的情况有：</p>
<blockquote>
<p>  1）、表的存储引擎为NDB，此时对表的DML操作都会以ROW格式记录<br>  2）、使用了UUID(),USER(),CURRENT_USER(),FOUND_ROWS(),ROW_count()等不确定函数时<br>  3）、使用了insert delay语句<br>  4）、使用了用户定义函数（UDF）<br>  5）、使用了临时表</p>
</blockquote>
<ul>
<li>适用场景：对主从数据一致性要求不太高，可能会用到函数、存储过程、触发器等场景</li>
<li>优缺点介于statement和row模式之间</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="MySQL主从复制的原理"><a href="#MySQL主从复制的原理" class="headerlink" title="MySQL主从复制的原理"></a>MySQL主从复制的原理</h2><p>（1）、主库必须开启二进制日志<br>（2）、当有增删改的语句时，会记录到主库的binlog中<br>（3）、主库通过IO线程把binlog里面的内容传给从库的relay binlog（中继日志）（这是msyql复制是异步复制的原因）<br>（4）、从库的sql线程负责读取它的relay log里的信息并应用到数据库中</p>
<h2 id="Seconds-Behind-Master的原理。"><a href="#Seconds-Behind-Master的原理。" class="headerlink" title="Seconds_Behind_Master的原理。"></a>Seconds_Behind_Master的原理。</h2><p>表示sql线程和io线程之间的时间差<br>具体的计算：从库服务器当前的时间戳与二进制日志中的事件的时间戳相对比得到的，所以只有在执行事件时才能报告延迟。<br>不足：<br>一些错误（例如主备的max_allowed_packet不匹配，或者网络不稳定）可能中断复制，由于主从复制是异步操作，Seconds_Behind_Master可能显示为0</p>
<h2 id="主从延迟的主要原因有哪些？"><a href="#主从延迟的主要原因有哪些？" class="headerlink" title="主从延迟的主要原因有哪些？"></a>主从延迟的主要原因有哪些？</h2><p>（1）、慢SQL语句过多<br>（2）、从库的硬件比主库差<br>（3）、同一个主库下有过多的从库<br>（4）、网络延迟<br>（5）、表分区过多</p>
<h1 id="CentOs7-6基于docker搭建主从集群"><a href="#CentOs7-6基于docker搭建主从集群" class="headerlink" title="CentOs7.6基于docker搭建主从集群"></a>CentOs7.6基于docker搭建主从集群</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mysql主从又叫Replication、AB复制。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步<br>mysql主从是基于binlog，主上需开启binlog才能进行主从</p>
<h3 id="主从过程大概有3个步骤"><a href="#主从过程大概有3个步骤" class="headerlink" title="主从过程大概有3个步骤"></a>主从过程大概有3个步骤</h3><ol>
<li>主将更改操作记录到binlog里</li>
<li>从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里</li>
<li>从根据relaylog里面的sql语句按顺序执行</li>
</ol>
<h3 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h3><ol>
<li>实时灾备，用于故障切换</li>
<li>读写分离，提供查询服务</li>
<li>备份，避免影响业务</li>
</ol>
<h3 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h3><ul>
<li>一主一从</li>
<li>主主复制</li>
<li>一主多从—扩展系统读取的性能，因为读是在从库读取的</li>
<li>多主一从—5.7版本开始支持</li>
<li>联级复制</li>
</ul>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p><img src="/images/post/db-mysql/mysqlrepl.webp" alt></p>
<ol>
<li>主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程</li>
<li>从库生成两个线程，一个是I/O线程，另一个是SQL线程</li>
<li>I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中</li>
<li>SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的</li>
</ol>
<h3 id="主从复制配置步骤："><a href="#主从复制配置步骤：" class="headerlink" title="主从复制配置步骤："></a>主从复制配置步骤：</h3><ol>
<li>确保从数据库与主数据库里的数据一致</li>
<li>在主数据库里创建一个同步账户授权给从数据库使用</li>
<li>配合主数据库（修改配置文件）</li>
<li>配置从数据库（修改配置文件）</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作</p>
<h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库角色	IP	应用与系统	有无数据</span><br><span class="line">主数据库	192.168.55.130	centos7 mysql-5.7	有</span><br><span class="line">从数据库	192.168.55.129	centos7 mysql-5.7	无</span><br></pre></td></tr></table></figure>

<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br><span class="line">docker version</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker <span class="comment">#开机启动docker</span></span><br><span class="line">docker version</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>详细参看：<a href="https://github.com/bjlhx15/shell" target="_blank" rel="noopener">https://github.com/bjlhx15/shell</a> 的 cmd/centos/docker</p>
<h3 id="docker安装mysql"><a href="#docker安装mysql" class="headerlink" title="docker安装mysql"></a>docker安装mysql</h3><h4 id="docker安装mysql以及配置文件"><a href="#docker安装mysql以及配置文件" class="headerlink" title="docker安装mysql以及配置文件"></a>docker安装mysql以及配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<h5 id="查看配置文件以及共享配置【过程说明】"><a href="#查看配置文件以及共享配置【过程说明】" class="headerlink" title="查看配置文件以及共享配置【过程说明】"></a>查看配置文件以及共享配置【过程说明】</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 53306:3306 --name mymysql57 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">docker <span class="built_in">exec</span> -it mymysql57 /bin/bash</span><br><span class="line">cat /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p>在宿主机上创建文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">export</span>/Data/docker/mymysql57/conf</span><br><span class="line">vim /<span class="built_in">export</span>/Data/docker/mymysql57/conf/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p>输入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file	&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket		&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">datadir		&#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">#log-error	&#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line"># By default we only accept connections from localhost</span><br><span class="line">#bind-address	&#x3D; 127.0.0.1</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br></pre></td></tr></table></figure>
<p>启动并添加目录映射</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 53306:3306 --name mymysql57 \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mymysql57/conf:/etc/mysql/mysql.conf.d \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mymysql57/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br></pre></td></tr></table></figure>

<p>详细参看：<a href="https://github.com/bjlhx15/shell" target="_blank" rel="noopener">https://github.com/bjlhx15/shell</a> 的 cmd/centos/docker</p>
<h4 id="Docker搭建主从服务器"><a href="#Docker搭建主从服务器" class="headerlink" title="Docker搭建主从服务器"></a>Docker搭建主从服务器</h4><ul>
<li>Master(主)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">export</span>/Data/docker/mysql_master/conf</span><br><span class="line">vim /<span class="built_in">export</span>/Data/docker/mysql_master/conf/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p>输入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file	&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket		&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">datadir		&#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">#log-error	&#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line"># By default we only accept connections from localhost</span><br><span class="line">#bind-address	&#x3D; 127.0.0.1</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line"></span><br><span class="line">## 开启 主从配置</span><br><span class="line">## 同一局域网内注意要唯一</span><br><span class="line">server-id&#x3D;100  </span><br><span class="line">## 开启二进制日志功能，可以随便取（关键）</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line">#binlog-do-db&#x3D;zn                   #可以被从服务器复制的库, 二进制需要同步的数据库名</span><br><span class="line">#binlog-ignore-db&#x3D;mysql            #不可以被从服务器复制的库</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 53306:3306 --name mysql_master \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_master/conf:/etc/mysql/mysql.conf.d \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_master/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br></pre></td></tr></table></figure>

<ul>
<li>Slave(从)：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">export</span>/Data/docker/mysql_slave/conf</span><br><span class="line">vim /<span class="built_in">export</span>/Data/docker/mysql_slave/conf/mysqld.cnf</span><br></pre></td></tr></table></figure>
输入如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"> </span><br><span class="line">[mysql]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">pid-file	&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket		&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">datadir		&#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">#log-error	&#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line"># By default we only accept connections from localhost</span><br><span class="line">#bind-address	&#x3D; 127.0.0.1</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line">character-set-server &#x3D; utf8</span><br><span class="line"></span><br><span class="line">## 设置server_id,注意要唯一</span><br><span class="line">server-id&#x3D;101  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin&#x3D;mysql-slave-bin   </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log&#x3D;edu-mysql-relay-bin</span><br><span class="line">log_slave_updates&#x3D;1</span><br><span class="line">replicate-do-db&#x3D;contract</span><br><span class="line">sql_mode&#x3D;NO_AUTO_VALUE_ON_ZERO,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 53307:3306 --name mysql_slave \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_slave/conf:/etc/mysql/mysql.conf.d \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_slave/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Master对外映射的端口是53306，Slave对外映射的端口是53307。因为docker容器是相互独立的，每个容器有其独立的ip，所以不同容器使用相同的端口并不会冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>可以使用Navicat等工具测试连接mysql</p>
<h3 id="账户配置及说明"><a href="#账户配置及说明" class="headerlink" title="账户配置及说明"></a>账户配置及说明</h3><p>进入主数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_master /bin/bash</span><br></pre></td></tr></table></figure>
<p>在Master数据库创建数据同步用户，授予用户 slave的 REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于在主从库之间同步数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'slave'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'slave'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>
<p>这里表示创建一个slaver同步账号slave，允许访问的IP地址为%，%表示通配符</p>
<h3 id="链接Master-主-和Slave-从"><a href="#链接Master-主-和Slave-从" class="headerlink" title="链接Master(主)和Slave(从)"></a>链接Master(主)和Slave(从)</h3><h4 id="进入主数据库"><a href="#进入主数据库" class="headerlink" title="进入主数据库"></a>进入主数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_master /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="comment"># 增加读锁，放置建立期间有人写入数据，查看完毕不要关闭窗口，unlock tables; 释放锁</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment">-- +------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="comment">-- | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span></span><br><span class="line"><span class="comment">-- +------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="comment">-- | mysql-bin.000001 |      617 |              |                  |                   |</span></span><br><span class="line"><span class="comment">-- +------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="comment">-- 1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>
<p>File和Position字段的值后面将会用到，在后面的操作完成之前，需要保证Master库不能做任何操作，否则将会引起状态变化，File和Position字段的值变化。<br>mysqlbinlog mysql-bin.000001</p>
<h5 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h5><p>mysqldump -h127.0.0.1 -uroot -p123456 –default-character-set=utf8 contract&gt;contract.sql</p>
<p>注意查看字符集<br>系统参数 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'char%'</span></span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br><span class="line">| Variable_name            | <span class="keyword">Value</span>                      |</span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br><span class="line">| character_set_client     | latin1                     |</span><br><span class="line">| character_set_connection | latin1                     |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | <span class="built_in">binary</span>                     |</span><br><span class="line">| character_set_results    | latin1                     |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/<span class="keyword">share</span>/mysql/charsets/ |</span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>上述导出：一般character_set_database 相一致：–default-character-set=utf8</p>
<h4 id="进入从数据库"><a href="#进入从数据库" class="headerlink" title="进入从数据库"></a>进入从数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_slave /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="comment">-- 创建从库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> contract2 <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="comment">-- 导入已有数据</span></span><br><span class="line"><span class="comment">-- 本机上传文件：scp /Users/lihongxu/work/contract.sql root@10.0.01:/export/Data/contract.sql</span></span><br><span class="line"><span class="comment">-- 容器拷贝：docker cp /home/trace/contract_dll_dml_0326.sql mysql_hr_prod_slave:/</span></span><br><span class="line"><span class="comment">-- 重置binlog,导入数据</span></span><br><span class="line">mysql -uroot -p   -e '<span class="keyword">reset</span> <span class="keyword">master</span><span class="string">'</span></span><br><span class="line"><span class="string">mysql -uroot -p   contract &lt; contract_dll_dml_0326.sql</span></span><br><span class="line"><span class="string">-- 从库配置链接主库</span></span><br><span class="line"><span class="string">change master to master_host='</span><span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span><span class="string">', master_user='</span><span class="keyword">slave</span><span class="string">', master_password='</span><span class="number">123456</span><span class="string">', master_port=3306, master_log_file='</span>mysql-<span class="keyword">bin</span><span class="number">.000001</span><span class="string">', master_log_pos= 617, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure>
<p>命令说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master_host ：Master的地址，指的是容器的独立ip,可以通过docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称|容器id  查询容器的ip</span><br><span class="line">master_port：Master的端口号，指的是容器的端口号</span><br><span class="line">master_user：用于数据同步的用户</span><br><span class="line">master_password：用于同步的用户的密码</span><br><span class="line">master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值</span><br><span class="line">master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值</span><br><span class="line">master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是60秒</span><br></pre></td></tr></table></figure>
<p>在Slave 中的mysql终端执行show slave status \G;用于查看主从同步状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;    <span class="comment">-- 开启从  stop slave 停止从</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span> \G;</span><br><span class="line"><span class="comment"># 主要关注参数 </span></span><br><span class="line"> <span class="comment">#  Slave_IO_Running: No</span></span><br><span class="line"> <span class="comment"># Slave_SQL_Running: No</span></span><br></pre></td></tr></table></figure>
<p>正常情况下，SlaveIORunning 和 SlaveSQLRunning 都是No，因为还没有开启主从复制过程。<br>使用start slave开启主从复制过程，然后再次查询主从同步状态show slave status \G;。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span> \G;</span><br></pre></td></tr></table></figure>
<p>使用start slave开启主从复制过程后，查看状态，如果SlaveIORunning一直是Connecting，则说明主从复制一直处于连接状态，这种情况一般是下面几种原因造成的，可以根据 Last_IO_Error提示予以排除。</p>
<p>网络不通:检查ip,端口<br>密码不对:检查是否创建用于同步的用户和用户密码是否正确<br>pos不对:检查Master的 Position</p>
<p>测试主从复制<br>在Master创建一个数据库，然后检查Slave是否存在此数据库。<br>Master:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_master /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>006-count优化</title>
    <url>/articles/20200220/1e6de73e.html</url>
    <content><![CDATA[<p>摘要：006-count优化</p>
<a id="more"></a>

<h1 id="增加占用空间小的非聚簇索引优化count"><a href="#增加占用空间小的非聚簇索引优化count" class="headerlink" title="增加占用空间小的非聚簇索引优化count"></a>增加占用空间小的非聚簇索引优化count</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`table500w`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5000001</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>
<p>然后，插入500w数据<br>参看<a href="https://www.cnblogs.com/bjlhx/p/11949479.html" target="_blank" rel="noopener">010-MySQL批量插入测试数据</a></p>
<ol>
<li>查看索引<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4967713				BTREE</span></span><br></pre></td></tr></table></figure>
只有主键id索引</li>
<li>count查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> table500w;</span><br></pre></td></tr></table></figure>
尝试多次后，耗时几乎一致，本机约6s<br>查看explain执行计划，<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="comment">-- Id  select_type table    type    possiable_key   key     key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1	  SIMPLE	  table500w	index		PRIMARY	        8		                4967713	Using index</span></span><br></pre></td></tr></table></figure>
三个均为一致，故网上说的count(id)、count(*)、count(1)快慢说法没有什么科学依据。用啥写法都是这么慢。</li>
<li>非聚簇索引优化<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">add</span> <span class="keyword">index</span> index_age(age);</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4967713				BTREE		</span></span><br><span class="line"><span class="comment">-- table500w	1	index_age	1	age	A	202			YES	BTREE</span></span><br></pre></td></tr></table></figure>
执行查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> table500w;</span><br></pre></td></tr></table></figure>
发现耗时，几乎约600ms，原因是mysql引擎做的优化，会使用占用空间较少的索引作为count（*）的命中统计<br>重复上述，查看执行计划，三个都一样<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="comment">-- 1	SIMPLE	table500w	index		index_age	5		4967713	Using index</span></span><br></pre></td></tr></table></figure>
上述可以通过force强制使用指定索引,来查看使用聚集索引以及非聚集索引 对count影响<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w <span class="keyword">FORCE</span> <span class="keyword">index</span>(<span class="string">`PRIMARY`</span>); </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w <span class="keyword">FORCE</span> <span class="keyword">index</span>(index_age);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>非聚集索引所占空间的大小往往，远小于聚集索引或堆表所占用的空间大小；<br>同样的，表中占用较少字节的字段的非聚集索引，对于速度的提升效果，也要远大于，占用较多字节的字段的非聚集索引，因为占用字节少，那么索引占用的空间也少，同样是扫描，只需要更少的时间，对硬盘的访问次数也更少，那么速度就会更快了。</p>
<ul>
<li>情况一、只有主键索引，</li>
</ul>
<ol>
<li>数据和主键索引存储在一个ibd中，总大小224mb，所加载文件也为全部</li>
</ol>
<ul>
<li>情况二、找一个短小的列age，为它建立辅助索引。<br>仅加载索引页统计，索引页为90mb，</li>
</ul>
<ol>
<li>二级索引的存储空间仅包含length字段值(4) 、数据主键(8)，假设二级索引辅助结构不占用空间（仅计算数据占用空间）</li>
<li>在默认情况下，MySQL的一个数据页大小为16K，一个页可存储的数据条数为 16*1024/(4+8) =1365 </li>
<li>按照单页存储空间占用为50%（页分裂现象导致页不满）计算，500万条数据的统计需要读取约:500 0000/(1365*0.5)=7331 个物理页</li>
<li>而页在连续的情况下，数据库一次可读取多个连续的页，数据读取总量为 16k*7331 约 114MB，使用附注方法查看约 90mb，以</li>
<li>因mysql空间分配为按区分配，每个区1M，一次分配1-5个连续区，当数据量较小，一次仅分配一个区，112M数据会分配在114个区中，</li>
<li>固态硬盘读取均速约 679m/s ，整个过程：io寻址时间(0ms)+读取时间（114m/679m=167ms）= 167 ms，</li>
<li>而数据解析统计约为 30-100ms，故总耗时会在300ms加。</li>
</ol>
<p>综上所述，纠结 count(id)、count(*) 、count(1)写法上性能没有任何意义，通过执行几化发现没有任何效率差异。关注语句真正命中的索引意义重大。</p>
<h1 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h1><h2 id="mac固态硬盘测试"><a href="#mac固态硬盘测试" class="headerlink" title="mac固态硬盘测试"></a>mac固态硬盘测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo time dd <span class="keyword">if</span>=/dev/zero bs=1024k of=tstfile count=1024</span><br><span class="line"><span class="comment"># 1024+0 records in</span></span><br><span class="line"><span class="comment"># 1024+0 records out</span></span><br><span class="line"><span class="comment"># 1073741824 bytes transferred in 1.506577 secs (712702911 bytes/sec)</span></span><br><span class="line"><span class="comment">#         1.51 real         0.00 user         0.49 sys</span></span><br></pre></td></tr></table></figure>

<p>速度：712702911/1024/1024=679m/s</p>
<h2 id="索引占用空间"><a href="#索引占用空间" class="headerlink" title="索引占用空间"></a>索引占用空间</h2><p>如上述，先删除age索引，则只剩下主键索引，主键索引和数据在一起，不被计算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">drop</span> <span class="keyword">index</span> index_age;</span><br><span class="line"><span class="comment">-- 查看表中存在的索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4988148				BTREE		</span></span><br><span class="line"><span class="comment">-- 优化 清理空间</span></span><br><span class="line"><span class="keyword">OPTIMIZE</span> <span class="keyword">table</span> table500w;</span><br><span class="line"><span class="comment">-- 查看 索引存储空间</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(INDEX_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> INDEX_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_FREE / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_FREE</span><br><span class="line"><span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'test_innodb'</span> <span class="keyword">and</span> table_name=<span class="string">'table500w'</span>;</span><br><span class="line"><span class="comment">-- DATA_SIZE  INDEX_SIZE  DATA_FREE</span></span><br><span class="line"><span class="comment">--  223.78MB	0.00MB	0.00MB</span></span><br><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">add</span> <span class="keyword">index</span> index_age(age);</span><br><span class="line"><span class="comment">-- 查看表中存在的索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4988148				BTREE		</span></span><br><span class="line"><span class="comment">-- table500w	1	index_age	1	age	A	202			YES	BTREE		</span></span><br><span class="line"><span class="comment">-- 查看 索引存储空间</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(INDEX_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> INDEX_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_FREE / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_FREE</span><br><span class="line"><span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'test_innodb'</span> <span class="keyword">and</span> table_name=<span class="string">'table500w'</span>;</span><br><span class="line"><span class="comment">-- DATA_SIZE  INDEX_SIZE  DATA_FREE</span></span><br><span class="line"><span class="comment">--  223.78MB	89.66MB	0.00MB</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>004-mysql-语句执行顺序</title>
    <url>/articles/20200220/55a48c08.html</url>
    <content><![CDATA[<p>摘要：004-mysql-语句执行顺序</p>
<a id="more"></a>

<h1 id="mysql-语句语法结构"><a href="#mysql-语句语法结构" class="headerlink" title="mysql 语句语法结构"></a>mysql 语句语法结构</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<h1 id="mysql-语句执行顺序"><a href="#mysql-语句执行顺序" class="headerlink" title="mysql 语句执行顺序"></a>mysql 语句执行顺序</h1><p>MySQL的语句，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定对应的操作，那么将会跳过相应的步骤。</p>
<ol>
<li>from:需要从哪个数据表检索数据，对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li>on：在生成临时表时使用的条件，对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。</join-condition></li>
<li>join：联合多表查询返回记录时，并生成一张临时表，如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li>where:过滤表中数据的条件，对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。</where-condition></li>
<li>group by:如何将上面过滤出的数据分组，根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li>having:对上面已经分组的数据进行过滤的条件，对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。</having-condition></li>
<li>select:查看结果集中的哪个列，或列的计算结果，执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li>DISTINCT: 对VT8中的记录进行去重。产生虚拟表VT9.</li>
<li>order by :按照什么样的顺序来查看返回的数据,将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10.</order_by_list></li>
<li>limit：限制查询结果返回的数量,取出指定行的记录，产生虚拟表VT11, 并将结果返回。</li>
</ol>
<h2 id="on与where的用法区别："><a href="#on与where的用法区别：" class="headerlink" title="on与where的用法区别："></a>on与where的用法区别：</h2><ol>
<li>on后面的筛选条件主要是针对的是关联表【而对于主表刷选条件不适用】。</li>
<li>如果是想再连接完毕后才筛选就应把条件放置于where后面。对于关联表我们要区分对待。如果是要条件查询后才连接应该把查询件放置于on后。</li>
<li>对于主表的筛选条件应放在where后面，不应该放在on后面</li>
</ol>
<h2 id="having和where的用法区别："><a href="#having和where的用法区别：" class="headerlink" title="having和where的用法区别："></a>having和where的用法区别：</h2><ol>
<li>having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。</li>
<li>where肯定在group by 之前，即也在having之前。</li>
<li>where后的条件表达式里不允许使用聚合函数，而having可以。</li>
</ol>
<h2 id="count用法"><a href="#count用法" class="headerlink" title="count用法"></a>count用法</h2><p>统计某个列值的数量，也可以统计行数<br>count(*) 和count(1) 都是统计行数，<br>count(col) 是统计col列非null的行数</p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>005-sql慢查询日志及优化建议</title>
    <url>/articles/20200219/cef9cfb1.html</url>
    <content><![CDATA[<p>摘要：优化</p>
<a id="more"></a>

<h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能</p>
<h2 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slow_query_log 慢查询开启状态</span><br><span class="line">slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</span><br><span class="line">long_query_time 查询超过多少秒才记录</span><br></pre></td></tr></table></figure>
<h2 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h2><ol>
<li>查看基础参数<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br><span class="line"><span class="comment">-- Variable_name  Value</span></span><br><span class="line"><span class="comment">-- slow_query_log	OFF</span></span><br><span class="line"><span class="comment">-- slow_query_log_file	/var/lib/mysql/2a623b03f48a-slow.log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br><span class="line"><span class="comment">-- Variable_name  Value</span></span><br><span class="line"><span class="comment">-- long_query_time	10.000000</span></span><br></pre></td></tr></table></figure></li>
<li>设置方法</li>
</ol>
<ul>
<li><p>方法一：全局变量设置【即时性的，重启mysql之后失效，常用的】<br>将 slow_query_log 全局变量设置为“ON”状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>; 或者 <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>
<p>设置慢查询日志存放的位置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file=<span class="string">'/var/log/mysql/slow.log'</span>;</span><br></pre></td></tr></table></figure>
<p>查询超过1秒就记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：配置文件设置【永久性的】<br>修改配置文件my.cnf，在[mysqld]下的下方加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;slow.log</span><br><span class="line">long_query_time &#x3D; 1</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>服务重启<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
可以使用步骤1中的查看</li>
</ol>
<h2 id="慢sql分析"><a href="#慢sql分析" class="headerlink" title="慢sql分析"></a>慢sql分析</h2><p>打开文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Time: 200219  9:09:58</span><br><span class="line"># User@Host: root[root] @  [172.17.0.1]  Id:     7</span><br><span class="line"># Query_time: 5.142734  Lock_time: 0.000080 Rows_sent: 5  Rows_examined: 5000000</span><br><span class="line">SET timestamp&#x3D;1582103398;</span><br><span class="line">select * from table500w where username&#x3D;&#39;name-23233&#39;;</span><br></pre></td></tr></table></figure>
<p>查询的时间，用户，花费的时间，使用的数据库，执行的sql语句等信息。在生产上我们就可以使用这种方式来查看 执行慢的sql</p>
<h2 id="查询慢查询的次数"><a href="#查询慢查询的次数" class="headerlink" title="查询慢查询的次数"></a>查询慢查询的次数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'slow_queries'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="优化及示例"><a href="#优化及示例" class="headerlink" title="优化及示例"></a>优化及示例</h1><ul>
<li><p>提前过滤<br>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</p>
</li>
<li><p>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
</li>
<li><p>避免在索引列上使用计算</p>
</li>
<li><p>避免在索引列上使用IS NULL和IS NOT NULL</p>
</li>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
</li>
</ul>
<h2 id="超大分页怎么处理"><a href="#超大分页怎么处理" class="headerlink" title="超大分页怎么处理?"></a>超大分页怎么处理?</h2><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><h4 id="基础分页-慢-大概5s"><a href="#基础分页-慢-大概5s" class="headerlink" title="基础分页-慢-大概5s"></a>基础分页-慢-大概5s</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>查看慢sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Time: 200219 23:47:01</span><br><span class="line"># User@Host: root[root] @  [172.17.0.1]  Id:    10</span><br><span class="line"># Query_time: 5.141059  Lock_time: 0.000086 Rows_sent: 5  Rows_examined: 4255328</span><br><span class="line">SET timestamp&#x3D;1582156021;</span><br><span class="line">select * from table500w where age&gt;5 limit 4000000,5;</span><br></pre></td></tr></table></figure>
<p>标准大分页 慢sql</p>
<h4 id="基础分页-优化-1s内"><a href="#基础分页-优化-1s内" class="headerlink" title="基础分页-优化-1s内"></a>基础分页-优化-1s内</h4><ol>
<li><p>查看执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment">-- Id  select_type table type  possiable_key key key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1 	SIMPLE	    table500w	  ALL					                  4967713	Using where</span></span><br></pre></td></tr></table></figure>
<p>参看:<a href="https://www.cnblogs.com/bjlhx/p/7567110.html" target="_blank" rel="noopener">004-mysql explain详解</a><br>发现：简单查询，使用all 全表扫描，涉及行数 4967713</p>
</li>
<li><p>优化-条件增加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">add</span> <span class="keyword">index</span> index_age(age);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment">-- Id  select_type table  type  possiable_key   key key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1	  SIMPLE	table500w	range	index_age	  index_age	5		      2483856	Using index condition; Using MRR</span></span><br></pre></td></tr></table></figure>
<p>发现：简单查询，使用range 索引范围扫描，涉及行数 2483856<br>执行查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>发现根本查询不出来了，或者查询巨慢<br>原因查看：<br>上述语句可以理解为</p>
<ol>
<li>命中非聚簇索引,通过age 查询 主索引 id</li>
<li>回读主索引，即聚簇索引查询主索引，然后获取叶子节点数据</li>
<li>根据limit 取结果</li>
</ol>
</li>
<li><p>利用关联子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">select</span> b.* <span class="keyword">from</span> table500w b, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>)<span class="keyword">as</span> a <span class="keyword">WHERE</span> b.id=a.id;</span><br><span class="line"><span class="comment">-- Id  select_type table    type    possiable_key   key     key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1	PRIMARY	    &lt;derived2&gt;ALL					                                2483856	</span></span><br><span class="line"><span class="comment">-- 1	PRIMARY	    b	        eq_ref	PRIMARY	      PRIMARY	   8	    a.id	1	</span></span><br><span class="line"><span class="comment">-- 2	DERIVED	    table500w	range	  index_age    	index_age	 5		      2483856	Using where; Using index</span></span><br></pre></td></tr></table></figure>
<p>查询后速度：0.88s<br>from 取出 a结果 5行，b 表 按条件 筛选 5行。</p>
</li>
</ol>
<h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>原因：mysql 并不是跳过offset行，而是取 offset + N 行，然后返回，放弃offset行，返回N行，那当offset特别大的时候，效率非常低。<br>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面,快速定位需要获取的id段，然后在关联<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.* <span class="keyword">from</span> table500w b, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>)<span class="keyword">as</span> a <span class="keyword">WHERE</span> b.id=a.id;</span><br></pre></td></tr></table></figure></li>
<li>需求界面上控制总页数<br>不允许直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>004-数据类型</title>
    <url>/articles/20200219/56a0d34f.html</url>
    <content><![CDATA[<p>摘要：事务</p>
<a id="more"></a>

<h1 id="整数类型-括号内数值含义"><a href="#整数类型-括号内数值含义" class="headerlink" title="整数类型-括号内数值含义"></a>整数类型-括号内数值含义</h1><p>包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p>
<h1 id="类型后的括号"><a href="#类型后的括号" class="headerlink" title="类型后的括号"></a>类型后的括号</h1><p>是展示长度含义：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</p>
<p>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
<h1 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h1><p>char是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符</p>
<p>varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.<br>在行数数据存储的时候，varchar 实际长度是需要记录到页结构中的 infimum和supermum record</p>
<p>在检索效率上来讲,char &gt; varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则按照设计应该使用varchar.</p>
<h1 id="varchar-10-和int-10-代表什么含义"><a href="#varchar-10-和int-10-代表什么含义" class="headerlink" title="varchar(10)和int(10)代表什么含义?"></a>varchar(10)和int(10)代表什么含义?</h1><ul>
<li>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度</li>
<li>int的10只是代表了展示的长度,不足10位以0填充.即,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</li>
</ul>
<h1 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h1><p>尽量使用timestamp，空间效率高于datetime,但是 注意存储范围</p>
<p>用整数保存时间戳通常不方便处理。如果需要存储微秒，可以使用bigint存储。</p>
<h1 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h1><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p>
<p>怎样才能找出最后一次插入时分配了哪个自动增量？</p>
<p>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</p>
<h1 id="段为什么要求定义为not-null"><a href="#段为什么要求定义为not-null" class="headerlink" title="段为什么要求定义为not null?"></a>段为什么要求定义为not null?</h1><p>MySQL官网这样介绍:</p>
<blockquote>
<p>NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
<p>null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.不利于索引</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>003-事务、锁总结</title>
    <url>/articles/20200219/6fd41f87.html</url>
    <content><![CDATA[<p>摘要：事务</p>
<a id="more"></a>

<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>事务是一系列的操作,他们要符合ACID特性.常见的理解就是:事务中的操作要么全部成功,要么全部失败.</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul>
<li><p>A=Atomicity 原子性<br>就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.</p>
</li>
<li><p>C=Consistency 一致性<br>系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.</p>
</li>
<li><p>I=Isolation 隔离性<br>通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.</p>
</li>
<li><p>D=Durability 持久性<br>一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.</p>
</li>
</ul>
<h1 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h1><p>5.5之前 是 myISAM<br>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。</p>
<p>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET<br>AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。<br>5.5之后是InnoDB,支持事务</p>
<h1 id="同时有多个事务在进行会怎么样呢"><a href="#同时有多个事务在进行会怎么样呢" class="headerlink" title="同时有多个事务在进行会怎么样呢?"></a>同时有多个事务在进行会怎么样呢?</h1><p>多事务的并发进行一般会造成以下几个问题:</p>
<ul>
<li>脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.</li>
<li>不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.</li>
<li>幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成”幻觉”.</li>
</ul>
<h1 id="MySQL的四种隔离级别"><a href="#MySQL的四种隔离级别" class="headerlink" title="MySQL的四种隔离级别"></a>MySQL的四种隔离级别</h1><ul>
<li>未提交读(READ UNCOMMITTED) 读到未提交数据<br>这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).</li>
</ul>
<p>这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.</p>
<ul>
<li>已提交读(READ COMMITTED) 脏读，不可重复读</li>
</ul>
<p>其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.</p>
<ul>
<li>REPEATABLE READ(可重复读)(InnoDB默认使用)</li>
</ul>
<p>可重复读隔离级别解决了上面不可重复读的问题,但是仍然有一个新问题,就是 幻读,当你读取id&gt; 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.</p>
<ul>
<li>SERIALIZABLE(可串行化事务)</li>
</ul>
<p>这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.</p>
<h1 id="mysql-锁"><a href="#mysql-锁" class="headerlink" title="mysql 锁"></a>mysql 锁</h1><p>当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.</p>
<p>例如，酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.</p>
<h1 id="MySQL都有哪些锁"><a href="#MySQL都有哪些锁" class="headerlink" title="MySQL都有哪些锁?"></a>MySQL都有哪些锁?</h1><p>从锁的类别上来讲,有共享锁和排他锁.</p>
<p>共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.</p>
<p>排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.</p>
<ul>
<li>表锁，系统开销最小，会锁定整张表，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。MyIsam使用表锁。</li>
<li>行锁，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。InnoDB使用行锁。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>他们的加锁开销从大到小,并发能力也是从大到小.</li>
</ul>
<h1 id="锁作用"><a href="#锁作用" class="headerlink" title="锁作用"></a>锁作用</h1><p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>002-索引总结</title>
    <url>/articles/20200219/24069596.html</url>
    <content><![CDATA[<p>摘要：存储引擎是数据库管理系统用来从数据库创建、读取和更新数据的软件模块。MySQL中有两种类型的存储引擎：事务性和非事务性。<br>对于MySQL 5.5及更高版本，默认的存储引擎是InnoDB。在5.5版本之前，MySQL的默认存储引擎是MyISAM。</p>
<a id="more"></a>

<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>索引是一种数据结构，可以快速的进行数据的查找.<br>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p>
<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM &lt;tablename&gt;;</span><br></pre></td></tr></table></figure>

<h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><p>任何标准表最多可以创建16个索引列。</p>
<h1 id="什么时候不需要回表查询数据"><a href="#什么时候不需要回表查询数据" class="headerlink" title="什么时候不需要回表查询数据"></a>什么时候不需要回表查询数据</h1><p>B+树在满足聚簇索引和覆盖索引的时候。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使不创建主键，系统也会帮你创建一个隐式的主键。<br>B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，称之为聚集索引。</p>
<p>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p>
<h2 id="非聚簇索引一定会回表查询吗-覆盖索引"><a href="#非聚簇索引一定会回表查询吗-覆盖索引" class="headerlink" title="非聚簇索引一定会回表查询吗-覆盖索引"></a>非聚簇索引一定会回表查询吗-覆盖索引</h2><p>不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.</p>
<p>例如，假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age &lt; 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.</p>
<h1 id="在建立索引的时候-都有哪些需要考虑的因素呢"><a href="#在建立索引的时候-都有哪些需要考虑的因素呢" class="headerlink" title="在建立索引的时候,都有哪些需要考虑的因素呢?"></a>在建立索引的时候,都有哪些需要考虑的因素呢?</h1><p>建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.</p>
<h2 id="联合索引是什么-为什么需要注意联合索引中的顺序"><a href="#联合索引是什么-为什么需要注意联合索引中的顺序" class="headerlink" title="联合索引是什么?为什么需要注意联合索引中的顺序?"></a>联合索引是什么?为什么需要注意联合索引中的顺序?</h2><p>MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.</p>
<p>具体原因为:</p>
<p>MySQL使用索引时需要索引有序,假设现在建立了”name,age,school”的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.</p>
<p>当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p>
<h1 id="语句是否使用了索引，分析语句？"><a href="#语句是否使用了索引，分析语句？" class="headerlink" title="语句是否使用了索引，分析语句？"></a>语句是否使用了索引，分析语句？</h1><p>MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.</p>
<p><a href="https://www.cnblogs.com/bjlhx/p/7567110.html" target="_blank" rel="noopener">更多,004-mysql explain详解</a></p>
<h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p>列设置了索引但是查询不生效</p>
<ul>
<li>使用不等于查询,</li>
<li>列参与了数学运算或者函数</li>
<li>在字符串like时左边是通配符.类似于’%aaa’.</li>
<li>当mysql分析全表扫描比使用索引快的时候不使用索引.</li>
<li>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.</li>
</ul>
<h1 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h1><p>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.</p>
<p>B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.</p>
<h2 id="不同"><a href="#不同" class="headerlink" title="不同:"></a>不同:</h2><p>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>
<p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</p>
<p>hash索引不支持使用索引进行排序,原理同上.</p>
<p>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性.</p>
<p>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</p>
<p>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</p>
<p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p>
<p><a href="https://www.cnblogs.com/bjlhx/p/11953939.html" target="_blank" rel="noopener">012-MySQL 索引添加以及优化说明</a></p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>001-存储引擎MyISAM和InnoDB</title>
    <url>/articles/20200219/b39e95d3.html</url>
    <content><![CDATA[<p>摘要：存储引擎是数据库管理系统用来从数据库创建、读取和更新数据的软件模块。MySQL中有两种类型的存储引擎：事务性和非事务性。<br>对于MySQL 5.5及更高版本，默认的存储引擎是InnoDB。在5.5版本之前，MySQL的默认存储引擎是MyISAM。</p>
<a id="more"></a>

<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="查看安装mysql版本的支持的"><a href="#查看安装mysql版本的支持的" class="headerlink" title="查看安装mysql版本的支持的"></a>查看安装mysql版本的支持的</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br><span class="line"><span class="comment">-- Enginne      Supports     Trabsactions    XA  Savepoints  Comment</span></span><br><span class="line"><span class="comment">-- FEDERATED	    NO				                                Federated MySQL storage engine</span></span><br><span class="line"><span class="comment">-- MRG_MYISAM	    YES	        NO	        NO	   NO	Collection of identical MyISAM tables</span></span><br><span class="line"><span class="comment">-- MyISAM	        YES	        NO	        NO	   NO	MyISAM storage engine</span></span><br><span class="line"><span class="comment">-- BLACKHOLE	    YES	        NO	        NO	   NO	/dev/null storage engine (anything you write to it disappears)</span></span><br><span class="line"><span class="comment">-- CSV	            YES	        NO	        NO	   NO	CSV storage engine</span></span><br><span class="line"><span class="comment">-- MEMORY	        YES	        NO	        NO	   NO	Hash based, stored in memory, useful for temporary tables</span></span><br><span class="line"><span class="comment">-- ARCHIVE	        YES	        NO	        NO	   NO	Archive storage engine</span></span><br><span class="line"><span class="comment">-- InnoDB	        DEFAULT	    YES	        YES	   YES	Supports transactions, row-level locking, and foreign keys</span></span><br><span class="line"><span class="comment">-- PERFORMANCE_SCHEMA	YES	    NO	        NO	   NO	Performance Schema</span></span><br></pre></td></tr></table></figure>
<p>说明<br>　　engine：引擎名称。<br>　　suppot：是否支持。<br>　　comment：说明。<br>　　transactions：是够支持事务。<br>　　xa：是否支持XA事务。<br>　　savepoints：是否支持保存savepoints之间的内容。</p>
<h1 id="常用引擎（常用的MyISAM和InnoDB）"><a href="#常用引擎（常用的MyISAM和InnoDB）" class="headerlink" title="常用引擎（常用的MyISAM和InnoDB）"></a>常用引擎（常用的MyISAM和InnoDB）</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>mysql5.5之前默认的存储引擎，由MYD和MYI组成。<br>查看数据库的data目录/数据库名称/，在查找相对应的表名。frm,myd,myi这三个结尾的文件。<br>　　.myd　　//数据库文件<br>　　.myi　　//索引文件  又叫非聚集索引</p>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul>
<li>并发性与锁级别-表解锁</li>
<li>支持全文索引</li>
<li>支持数据压缩   命令：进入到mysql的bin文件夹， .\myisampack.exe -b -f “需要压缩的test.MYI地址” （此命令实在Windows运行）。</li>
<li>运行完以后，会出现一个以OLD结尾的文件，删除OLD可能会出现问题。需要恢复 CHECK table 表名，REPAIR table 表名      </li>
</ul>
<h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><ul>
<li>非事务的类型</li>
<li>只读类应用，读取数据的速度快</li>
<li>空间类型（坐标，空间函数）</li>
</ul>
<h2 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h2><p>　　mysql5.5以后默认的存储引擎，innodb_file_per_table  on：表示独立表空间，OFF：表示系统表空间。5.6之前是系统表空间，之后为独立表空间。<br>　　独立表空间：.frm .ibd  存储数据+索引。 可以通过 optimize table 表名 .ibd收缩数据文件，同时可以向多个文件刷新数据。<br>　　系统表空间：.frm是放在数据库的文件下的。 .ibdata1是放在data文件夹下的，表公用的，会产生IO的瓶颈。 系统表空间无法简单的收缩文件大小<br>　　建议使用独立表空间。</p>
<h3 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h3><p>是一种事务性存储引擎。完全支持事务的ACID特性。执行行级锁，并发程度高。Redo Log和Undo Log。</p>
<h3 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h3><p>大多数的OLTP应用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对比项  MyISAM  InnoDB</span><br><span class="line">外键    不支持      支持</span><br><span class="line">事务    不支持      支持</span><br><span class="line">锁      表锁       行锁</span><br><span class="line">关注点  性能        事务</span><br><span class="line">表空间  小          大</span><br><span class="line">缓存    缓存索引    缓存索引和数据</span><br><span class="line">场景    不合适高并发 适合高并发</span><br></pre></td></tr></table></figure>

<h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><p>　　数据以文本方式存储，表的字段不能为空，不能有主键。<br>　　.frm , .csv数据的内容， .csm存储表的元数据 。<br>　　使用文本编辑器可以直接编辑.csv数据，然后保存，在数据库里面执行flush  tables;<br>　　注：要在最后一行数据回车一下，要不然最后一条数据不展示。<br>　　在excel里面操作提示兼容性问题，无法操作成功，编辑完以后修复一下，可能是excel版本的问题吧。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>以CSV格式进行数据存储，所有列的字段都不能为null，不支持索引，可以对数据文件在线编辑。</p>
<h2 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h2><p>　　以zlib对表数据进行压缩，磁盘I/O更少，数据存储在.ARZ。<br>　　.frm , .ARZ数据的内容。</p>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>　　　　只支持insert和select操作，只允许在自增ID列上加索引。</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>　　　　日志和数据采集应用</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>　　在data文件夹里面只有一个frm。<br>　　数据保存在内存中，支持hash索引和BTree索引，所有字段都是固定的长度varchar(10)=char(10),不支持Blog和Text等字段<br>　　使用表级索，最大有max_heap_table_size 决定。 重启会丢失数据。<br>　　在系统使用临时表的时候，超过限制会使用MyISAM，未超过的时候使用Memory<br>　　临时表：在同一个session（会话）里面，才能使用。重启服务会丢失数据。<br>　　应用场景：mysql后台服务使用Memory</p>
<h2 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h2><p>　　访问远程的数据库表，本地只保存数据库结构和连接信息，数据保存在远程的服务器中。在本地只保存.frm<br>　　默认不是开启的引擎，在my.ini  增加 federated=1，重启。<br>　　只能用命令创建。create table ‘aaa’(里面的字段，要和连接的服务器一样) engine=federated connection=’mysql://用户名:密码@地址:IP/数据库名/表名’</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>001-mac安装、工具vscode配置、工程目录</title>
    <url>/articles/20200214/769cb3c4.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://www.cnblogs.com/bjlhx/p/11940108.html" target="_blank" rel="noopener">001-mac搭建Python开发环境、Anaconda、zsh兼容</a></p>
<h2 id="检测安装情况"><a href="#检测安装情况" class="headerlink" title="检测安装情况"></a>检测安装情况</h2><p>一般默认安装了 py2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># py 3 版本检测</span></span><br><span class="line">python3 -V</span><br><span class="line"><span class="comment"># py 2 版本检测</span></span><br><span class="line">python2 -V</span><br><span class="line"><span class="comment"># Anaconda 版本检测</span></span><br><span class="line">conda --version</span><br></pre></td></tr></table></figure>

<h2 id="vscodoe安装Python插件"><a href="#vscodoe安装Python插件" class="headerlink" title="vscodoe安装Python插件"></a>vscodoe安装Python插件</h2><p>搜索后安装“Python”即可,成功后重启</p>
<p>如果你同时安装了多个版本的Python（如Python2.7，Python3.x和Anaconda），你可以通过点击左下角的语言（这里的Python x.x.x）或在命令盘中选择select interpreter来切换Python解释器。VSCode默认用PEP8标准来格式化Python代码，但你也可以选用其他标准。</p>
<h1 id="python项目工程结构"><a href="#python项目工程结构" class="headerlink" title="python项目工程结构"></a>python项目工程结构</h1><p>参看几个比较流行的python开源项目<br><a href="https://github.com/pallets/flask" target="_blank" rel="noopener">flask</a><br><a href="https://github.com/psf/requests" target="_blank" rel="noopener">requests</a><br><a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">thefuck</a><br><a href="https://github.com/docker/compose" target="_blank" rel="noopener">compose</a><br><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">tensorflow</a><br><a href="https://github.com/django/django" target="_blank" rel="noopener">django</a></p>
<p>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project&#x2F;</span><br><span class="line">|-- bin&#x2F;    存放项目的一些可执行文件，或 script&#x2F;。</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- project&#x2F; 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录tests&#x2F;存放单元测试代码； (3) 程序的入口最好命名为main.py。</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py   </span><br><span class="line">|   |-- moduleA</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- packageA.py</span><br><span class="line">|   |-- moduleB</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- packageB.py</span><br><span class="line">|</span><br><span class="line">|-- tests&#x2F;</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- test_main.py</span><br><span class="line">|</span><br><span class="line">|-- docs&#x2F; 文档</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py  安装、部署、打包的脚本</span><br><span class="line">|-- requirements.txt 存放软件依赖的外部Python包列表</span><br><span class="line">|-- README  说明</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application" target="_blank" rel="noopener">查看</a></p>
]]></content>
      <categories>
        <category>python-syntax</category>
      </categories>
  </entry>
  <entry>
    <title>003-ab压力测试之post与get请求</title>
    <url>/articles/20200214/8dd4d804.html</url>
    <content><![CDATA[<p>摘要：使用ab检测指定地址 处理问题能力。</p>
<a id="more"></a>

<h1 id="模拟get请求"><a href="#模拟get请求" class="headerlink" title="模拟get请求"></a>模拟get请求</h1><p>直接在url后面带参数即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 10 -n 10 http://www.test.api.com/?gid=2</span><br></pre></td></tr></table></figure>
<p>n 总数，c 一次请求</p>
<h1 id="模拟post请求"><a href="#模拟post请求" class="headerlink" title="模拟post请求"></a>模拟post请求</h1><h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h2><p>在当前目录下创建一个文件post.txt,编辑文件post.txt写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cid&#x3D;4&amp;status&#x3D;1</span><br></pre></td></tr></table></figure>
<p>相当于post传递cid,status参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -n 100  -c 10 -p <span class="string">'post.txt'</span> -T <span class="string">'application/x-www-form-urlencoded'</span> <span class="string">'http://test.api.com/ttk/auth/info/'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test-ab</category>
      </categories>
  </entry>
  <entry>
    <title>007-高性能网站建设笔记-12移除重读脚本、13配置ETag、14使用ajax</title>
    <url>/articles/20200214/96280786.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="12移除重读脚本"><a href="#12移除重读脚本" class="headerlink" title="12移除重读脚本"></a>12移除重读脚本</h1><h1 id="13配置ETag"><a href="#13配置ETag" class="headerlink" title="13配置ETag"></a>13配置ETag</h1><p>[Pragma、Expires、Cache-Control、max-age、Last-Modified、用户刷新访问、避免过度304]（<a href="https://www.cnblogs.com/bjlhx/p/10338625.html）" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10338625.html）</a></p>
<h1 id="14使用ajax"><a href="#14使用ajax" class="headerlink" title="14使用ajax"></a>14使用ajax</h1>]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>006-高性能网站建设笔记-09减少DNS查找、10精简javscript、11避免重定向</title>
    <url>/articles/20200214/d6bed999.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="09减少DNS查找"><a href="#09减少DNS查找" class="headerlink" title="09减少DNS查找"></a>09减少DNS查找</h1><p>DNS 域名解析也会耗时。</p>
<h1 id="10精简javscript"><a href="#10精简javscript" class="headerlink" title="10精简javscript"></a>10精简javscript</h1><p>混淆：也能优化注释和空白，但是注意混淆可能会使代码出现错误</p>
<p>压缩和精简：推荐压缩，会使变量名，方法名变短，减少带宽，增加下载速度，解析速度。</p>
<h1 id="11避免重定向"><a href="#11避免重定向" class="headerlink" title="11避免重定向"></a>11避免重定向</h1><p>重定向会增加http请求次数</p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>005-高性能网站建设笔记-07避免CSS表达式、08使用外部的js和css</title>
    <url>/articles/20200213/ac31f31.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="07避免CSS表达式"><a href="#07避免CSS表达式" class="headerlink" title="07避免CSS表达式"></a>07避免CSS表达式</h1><p>浏览器兼容，大部分不支持css表达式</p>
<h1 id="08使用外部的js和css"><a href="#08使用外部的js和css" class="headerlink" title="08使用外部的js和css"></a>08使用外部的js和css</h1><h2 id="内联和外置"><a href="#内联和外置" class="headerlink" title="内联和外置"></a>内联和外置</h2><ul>
<li>内联：默认的script 引入</li>
<li>外置：动态加载 脚本<br>切割公共部分，适当选择使用外部js和css<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doOnload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="string">"downloadComponents()"</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload=doOnload;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doenloadComponents</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  downloadJS(<span class="string">"ss"</span>);</span><br><span class="line">  downloadCSS(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadJS</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  elem.src = url;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadCSS</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">  elem.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">  elem.type = <span class="string">"text/css"</span>;</span><br><span class="line">  elem.href = url;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>




</li>
</ul>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>004-高性能网站建设笔记-05样式表放在顶部、06脚本放在底部</title>
    <url>/articles/20200213/372b80cc.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="05样式表放在顶部【必须】"><a href="#05样式表放在顶部【必须】" class="headerlink" title="05样式表放在顶部【必须】"></a>05样式表放在顶部【必须】</h1><p>将样式表放在 head中，在html规范中，也明确规定Link需出现下head中，不限次数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//storage.jd.com/sy-static.jd.com/1564972561844_index.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>避免了白屏和无样式内容的闪烁问题</p>
<h1 id="06脚本放在底部"><a href="#06脚本放在底部" class="headerlink" title="06脚本放在底部"></a>06脚本放在底部</h1><p>DOM 加载是顺序加载<a href="http://blog.bjlhx.top/categories/html_jd_css" target="_blank" rel="noopener">more</a></p>
<p>如果脚本在页面头部，可能会造成，页面阻塞。</p>
<h2 id="并行下载-无意义，会发生脚本阻塞下载"><a href="#并行下载-无意义，会发生脚本阻塞下载" class="headerlink" title="并行下载-无意义，会发生脚本阻塞下载"></a>并行下载-无意义，会发生脚本阻塞下载</h2><p>如果页面编写了 script 标签，那么每个脚本都会产生一个http请求，进而进行下载。</p>
<p>在http 1.1规范，建议浏览器从每个主机名并行下载两个组件。简单理解，默认同时下载两个文件。</p>
<p>增加并行下载数量：可以简单使用CNAME（DNS别名）来将组件分别放到多个主机域名中。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>增加了带宽以及cpu的使用</p>
<h2 id="脚本阻塞下载"><a href="#脚本阻塞下载" class="headerlink" title="脚本阻塞下载"></a>脚本阻塞下载</h2><p>并行下载组件的优点多多，但是，在下载脚本时并行下载实际上是被禁用的–即使用了不同的主机名，浏览器也不会启动其他的下载。<br>原因：<br>1、脚本可能使用了document.write来修改页面内容，因此浏览器会等待，以确保页面能够恰当的布局。<br>2、为了保证脚本能够按照正确的顺序执行。</p>
<p>如果并行下载多个脚本，就无法保证响应是按照特定顺序到达浏览器的。如后面的先下载，结果后面的执行了，但内部有依赖于上一个脚本的代码，或导致js错误</p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>003-高性能网站建设笔记-03添加Expires头、04压缩组件</title>
    <url>/articles/20200213/457472c2.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="03添加Expires头-【推荐Cache-Control】"><a href="#03添加Expires头-【推荐Cache-Control】" class="headerlink" title="03添加Expires头-【推荐Cache-Control】"></a>03添加Expires头-【推荐Cache-Control】</h1><h2 id="添加Expires头和Cache-Control"><a href="#添加Expires头和Cache-Control" class="headerlink" title="添加Expires头和Cache-Control"></a>添加Expires头和Cache-Control</h2><p>关于gzip压缩、http缓存控制和缓存校验[Pragma、Expires、Cache-Control、max-age、Last-Modified、用户刷新访问、避免过度304]（<a href="https://www.cnblogs.com/bjlhx/p/10338625.html）" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10338625.html）</a></p>
<p>可以参看，大部分站点会将变更较少的图片、js、css等设置成缓存30天以上</p>
<h1 id="04压缩组件"><a href="#04压缩组件" class="headerlink" title="04压缩组件"></a>04压缩组件</h1><h2 id="压缩的是什么"><a href="#压缩的是什么" class="headerlink" title="压缩的是什么"></a>压缩的是什么</h2><p>主要压缩静态资源：html 文档、js、css、xml、json等</p>
<p>压缩成本：花费额外的CPU 周期完成压缩，配置文件大于一个常规值开始压缩，如：1M 或 2M</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx开启压缩：<a href="https://www.cnblogs.com/bjlhx/p/12034531.html" target="_blank" rel="noopener">006-nginx.conf详解-error_page 使用、压缩</a></p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>003-分析Chrome的瀑布流（Waterfall）</title>
    <url>/articles/20200213/961373d8.html</url>
    <content><![CDATA[<p>摘要：当需要调试网页或分析网站性能时，我们往往会F12打开浏览器控制台，查看网络请求，看网页加载了哪些资源，以及对应的请求方式（Method）、状态码（Status）、资源类型（Type）、大小（Size）、耗费的时间（Time）等。</p>
<p>如果某个资源耗费的时间比较长，需要深入分析时，则需要看：瀑布流（Waterfall），在Waterfall中可以看出时间具体花在了哪些部分。</p>
<!-- maore -->

<h1 id="解说"><a href="#解说" class="headerlink" title="解说"></a>解说</h1><p>打开用chrome console，可以看到如下</p>
<p><img src="/images/post/performance-web/chrome-console.jpg" alt></p>
<p>可以看到页面加载的时间窗口。此时可以将鼠标放置 右侧的waterfall上，可以查看具体耗时</p>
<p><img src="/images/post/performance-web/chrome-console2.jpg" alt></p>
<h2 id="瀑布流中各项指标含义如下："><a href="#瀑布流中各项指标含义如下：" class="headerlink" title="瀑布流中各项指标含义如下："></a>瀑布流中各项指标含义如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queueing：浏览器将资源放入队列时间，比如：遇到更高优先级的请求或请求并发超过6了。</span><br><span class="line">Stalled：因放入队列时间而发生的停滞时间。</span><br><span class="line">Proxy negotiation：与代理服务器协商时间。</span><br><span class="line">DNS Lookup：DNS解析时间，浏览器需要将域名转换成IP。</span><br><span class="line">Initial Connection：在浏览器发送请求前，需要建立HTTP连接的时间。</span><br><span class="line">SSL：如果网站使用了HTTPS，这个就是浏览器与服务器建立安全性连接的时间。</span><br><span class="line">Request sent：请求发送的时间。</span><br><span class="line">Waiting (TTFB)：等待服务端返回数据的时间，这个时间受制于服务端处理性能。</span><br><span class="line">Content Download：浏览器下载资源的时间，这个时间受制于文件大小和带宽。</span><br></pre></td></tr></table></figure>

<p>如何优化，请参看：<a href="http://blog.bjlhx.top/categories/performance-web" target="_blank" rel="noopener">http://blog.bjlhx.top/categories/performance-web</a></p>
]]></content>
      <categories>
        <category>performance</category>
      </categories>
  </entry>
  <entry>
    <title>002-高性能网站建设笔记-01减少http请求、02使用内容发布网络CDN</title>
    <url>/articles/20200213/481fe23c.html</url>
    <content><![CDATA[<p>摘要：减少http请求：图片地图、css scripts、内联图片和脚本、样式表的合并</p>
<a id="more"></a>

<h1 id="减少http请求"><a href="#减少http请求" class="headerlink" title="减少http请求"></a>减少http请求</h1><h2 id="图片地图-【不常用】"><a href="#图片地图-【不常用】" class="headerlink" title="图片地图-【不常用】"></a>图片地图-【不常用】</h2><p>多个图片合成一个，根据区域不同触发不同操作。<br>或者一个图片有多个区域触发不同操作，不用将图片拆成多个<br>如，导航栏 有帮助、关于、设置等图标，变成一个图片，根据坐标触发不同操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"planets.gif"</span> <span class="attr">alt</span>=<span class="string">"Planets"</span> <span class="attr">usemap</span>=<span class="string">"#planetmap"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"sun.htm"</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,110,260"</span>&gt;</span>Sun<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"mercur.htm"</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"129,161,10"</span>&gt;</span>Mercury<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"venus.htm"</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"180,139,14"</span>&gt;</span>Venus<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="css-scripts-【即雪碧图，常用】"><a href="#css-scripts-【即雪碧图，常用】" class="headerlink" title="css scripts-【即雪碧图，常用】"></a>css scripts-【即雪碧图，常用】</h2><p>多个图片合成一个，根据区域不同触发不同操作。只不过是 使用css脚本控制，需要用到background-position属性</p>
<p>主要适用：页面背景、按钮、导航栏、链接图标等</p>
<p>图片截取都是从左上角的（0,0）坐标开始，所有需要把所需的图片移动想左、上移动，移动到所截取的图片的位置即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*空格  ：后代选择器（所有后代）*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-id">#container</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">            width: 25px;</span><br><span class="line">            height: 25px;</span><br><span class="line">            color: red;</span><br><span class="line">            background-image: url("../../img/icon.gif");</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#div2</span>&#123;<span class="attribute">background-position</span>:-<span class="number">42px</span> <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#div3</span>&#123;  <span class="attribute">background-position</span>: -<span class="number">165px</span> -<span class="number">25px</span>; &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>雪碧图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内联图片-【适当使用】"><a href="#内联图片-【适当使用】" class="headerlink" title="内联图片-【适当使用】"></a>内联图片-【适当使用】</h2><p>将图片编码，通html放置在一起，已达到降低请求次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;data:[mediatype][;base64],base64data&gt;  data - 取得数据的协定名称</span><br><span class="line"></span><br><span class="line">mediatype:image&#x2F;png - 数据类型名称</span><br><span class="line">base64 - 数据的编码方法</span><br><span class="line">base64data - 编码后的数据</span><br><span class="line">: , ; - data URI scheme 指定的分隔符号</span><br></pre></td></tr></table></figure>
<p>缺点</p>
<ol>
<li>浏览器不会缓存内联图片资源</li>
<li>存在大小限制</li>
<li>base64编码会使图片大小增大，导致网页整体下载速度减慢</li>
</ol>
<h2 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h2><p>样式表-每个页面统一成一个<br>脚本-适当合并，尽量减少脚本数量</p>
<h1 id="使用内容发布网络CDN"><a href="#使用内容发布网络CDN" class="headerlink" title="使用内容发布网络CDN"></a>使用内容发布网络CDN</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>归纳起来，CDN具有以下主要功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)节省骨干网带宽，减少带宽需求量；</span><br><span class="line">(2)提供服务器端加速，解决由于用户访问量大造成的服务器过载问题；</span><br><span class="line">(3)服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求；</span><br><span class="line">(4)能克服网站分布不均的问题，并且能降低网站自身建设和维护成本；</span><br><span class="line">(5)降低“通信风暴”的影响，提高网络访问的稳定性。</span><br></pre></td></tr></table></figure>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>002-使用、参数讲解</title>
    <url>/articles/20200213/629a2186.html</url>
    <content><![CDATA[<p>摘要：使用ab检测指定地址 处理问题能力。</p>
<a id="more"></a>

<h1 id="AB的简介"><a href="#AB的简介" class="headerlink" title="AB的简介"></a>AB的简介</h1><h2 id="命令常用参数"><a href="#命令常用参数" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># -n requests Number of requests to perform //本次测试发起的总请求数</span></span><br><span class="line"><span class="comment"># -c concurrency Number of multiple requests to make　　 //一次产生的请求数（或并发数）</span></span><br><span class="line"><span class="comment"># -t timelimit Seconds to max. wait for responses　　　　//测试所进行的最大秒数，默认没有时间限制。</span></span><br><span class="line"><span class="comment"># -r Don't exit on socket receive errors.    // 抛出异常继续执行测试任务</span></span><br><span class="line"><span class="comment"># -p postfile File containing data to POST　　//包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt</span></span><br><span class="line"><span class="comment"># -T content-type Content-type header for POSTing</span></span><br><span class="line"><span class="comment"># //POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）</span></span><br><span class="line"><span class="comment"># -v verbosity How much troubleshooting info to print</span></span><br><span class="line"><span class="comment"># //设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。</span></span><br><span class="line"><span class="comment"># -C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)</span></span><br><span class="line"><span class="comment"># //-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。</span></span><br><span class="line"><span class="comment"># 提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。</span></span><br><span class="line"><span class="comment"># -w Print out results in HTML tables　　//以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 500 -n 5000 http://jd.com/</span><br></pre></td></tr></table></figure>
<p>说明：发送 5000个请求，每次发送500 个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 500 -n 5000 http://jd.com/</span><br><span class="line"><span class="comment"># This is ApacheBench, Version 2.3 &lt;$Revision: 1826891 $&gt;</span></span><br><span class="line"><span class="comment"># Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span></span><br><span class="line"><span class="comment"># Licensed to The Apache Software Foundation, http://www.apache.org/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Benchmarking jd.com (be patient)</span></span><br><span class="line"><span class="comment"># Completed 500 requests</span></span><br><span class="line"><span class="comment"># Completed 1000 requests</span></span><br><span class="line"><span class="comment"># Completed 1500 requests</span></span><br><span class="line"><span class="comment"># Completed 2000 requests</span></span><br><span class="line"><span class="comment"># Completed 2500 requests</span></span><br><span class="line"><span class="comment"># Completed 3000 requests</span></span><br><span class="line"><span class="comment"># Completed 3500 requests</span></span><br><span class="line"><span class="comment"># Completed 4000 requests</span></span><br><span class="line"><span class="comment"># Completed 4500 requests</span></span><br><span class="line"><span class="comment"># Completed 5000 requests</span></span><br><span class="line"><span class="comment"># Finished 5000 requests</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Server Software:        jfe #测试服务器的名字</span></span><br><span class="line"><span class="comment"># Server Hostname:        jd.com  #请求的URL主机名</span></span><br><span class="line"><span class="comment"># Server Port:            80   #请求端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Document Path:          / #请求路径</span></span><br><span class="line"><span class="comment"># Document Length:        165 bytes #HTTP响应数据的正文长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Concurrency Level:      500   #并发用户数，这是我们设置的参数之一</span></span><br><span class="line"><span class="comment"># Time taken for tests:   14.630 seconds  #所有这些请求被处理完成所花费的总时间 单位秒</span></span><br><span class="line"><span class="comment"># Complete requests:      5000  #总请求数量，这是我们设置的参数之一</span></span><br><span class="line"><span class="comment"># Failed requests:        0     #表示失败的请求数量</span></span><br><span class="line"><span class="comment"># Non-2xx responses:      5000</span></span><br><span class="line"><span class="comment"># Total transferred:      1715000 bytes #所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度</span></span><br><span class="line"><span class="comment"># HTML transferred:       825000 bytes  #所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度</span></span><br><span class="line"><span class="comment"># Requests per second:    341.75 [#/sec] (mean) #吞吐量，计算公式：Complete requests/Time taken for tests  总请求数/处理完成这些请求数所花费的时间</span></span><br><span class="line"><span class="comment"># Time per request:       1463.049 [ms] (mean)   #用户平均请求等待时间，计算公式：Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）</span></span><br><span class="line"><span class="comment"># Time per request:       2.926 [ms] (mean, across all concurrent requests) #服务器平均请求等待时间，计算公式：Time taken for tests/Complete requests，正好是吞吐率的倒数。也可以这么统计：Time per request/Concurrency Level</span></span><br><span class="line"><span class="comment"># Transfer rate:          114.47 [Kbytes/sec] received  #表示这些请求在单位时间内从服务器获取的数据长度，计算公式：Total trnasferred/ Time taken for tests，这个统计很好的说明服务器的处理能力达到极限时，其出口宽带的需求量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connection Times (ms)   #网络消耗时间，</span></span><br><span class="line"><span class="comment">#               min  mean[+/-sd] median   max</span></span><br><span class="line"><span class="comment"># Connect:        9  242 414.5    138    3513</span></span><br><span class="line"><span class="comment"># Processing:    12  407 801.4    158   11468</span></span><br><span class="line"><span class="comment"># Waiting:       12  276 575.5    147    8130</span></span><br><span class="line"><span class="comment"># Total:         26  649 938.0    320   12727</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Percentage of the requests served within a certain time (ms)</span></span><br><span class="line"><span class="comment">#   50%    320    #50%用户请求在320ms内返回</span></span><br><span class="line"><span class="comment">#   66%    359    #60%用户请求在359ms内返回</span></span><br><span class="line"><span class="comment">#   75%    858</span></span><br><span class="line"><span class="comment">#   80%   1009</span></span><br><span class="line"><span class="comment">#   90%   1431    #这是一个衡量点，主要参看指标</span></span><br><span class="line"><span class="comment">#   95%   2478</span></span><br><span class="line"><span class="comment">#   98%   3963    #98%用户请求在3963ms内返回</span></span><br><span class="line"><span class="comment">#   99%   4664</span></span><br><span class="line"><span class="comment">#  100%  12727 (longest request)</span></span><br></pre></td></tr></table></figure>

<h2 id="关键指标说明"><a href="#关键指标说明" class="headerlink" title="关键指标说明"></a>关键指标说明</h2><p>主要看90% 的请求响应时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TPS吞吐量：请求数&#x2F;请求响应的时间(s) ，即每秒请求数，对应 Request per second一项，tps&#x3D;13.24 req&#x2F;s</span><br><span class="line">响应时间：请求发送到接受到请求的时间差，单位为ms，一般看90%的响应时间，此时RT&#x3D;862ms</span><br><span class="line">并发连接数：每秒服务器端能处理的连接数。并发连接数 &#x3D; 吞吐量*响应时间，并发连接数&#x3D;11.4 req</span><br><span class="line">PV:Page View网页的浏览次数,或者点击量</span><br><span class="line">UV:Unique Visitor,一台ip地址为一个访客。00:00-24:00内相同的客户端只被计算一次</span><br><span class="line">峰值QPS:每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间</span><br><span class="line">( 总PV数 * 80% ) &#x2F; ( 每天秒数 * 20% ) &#x3D; 峰值时间每秒请求数(QPS)</span><br><span class="line">峰值机器数：保证机器数量抗住峰值QPS，机器数 &#x3D; 峰值QPS&#x2F;单台机器QPS</span><br></pre></td></tr></table></figure>

<h2 id="防重放攻击处理"><a href="#防重放攻击处理" class="headerlink" title="防重放攻击处理"></a>防重放攻击处理</h2><p>上述请求没有增加防重放攻击处理，可以尝试请求测试下百度的，</p>
<p>可以看到 发送了100个，失败了99个，做了重放攻击的处理<br>如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 10 -n 100 http://www.baidu.com/</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1826891 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking www.baidu.com (be patient).....<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">Server Software:        BWS/1.1</span><br><span class="line">Server Hostname:        www.baidu.com</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        168409 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   4.660 seconds</span><br><span class="line">Complete requests:      100</span><br><span class="line">Failed requests:        99</span><br><span class="line">   (Connect: 0, Receive: 0, Length: 99, Exceptions: 0)</span><br><span class="line">Total transferred:      16300978 bytes</span><br><span class="line">HTML transferred:       16182926 bytes</span><br><span class="line">Requests per second:    21.46 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       466.012 [ms] (mean)</span><br><span class="line">Time per request:       46.601 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          3415.99 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        7   83  46.2     77     219</span><br><span class="line">Processing:   134  371  76.3    383     775</span><br><span class="line">Waiting:        7   91  40.2     87     205</span><br><span class="line">Total:        141  454  72.9    455     826</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    455</span><br><span class="line">  66%    477</span><br><span class="line">  75%    488</span><br><span class="line">  80%    496</span><br><span class="line">  90%    509</span><br><span class="line">  95%    585</span><br><span class="line">  98%    654</span><br><span class="line">  99%    826</span><br><span class="line"> 100%    826 (longest request)</span><br></pre></td></tr></table></figure>

<h2 id="导出报告"><a href="#导出报告" class="headerlink" title="导出报告"></a>导出报告</h2><p>ab -c10 -n100 <a href="http://www.baidu.com/&gt;report.html" target="_blank" rel="noopener">http://www.baidu.com/&gt;report.html</a>    </p>
]]></content>
      <categories>
        <category>test-ab</category>
      </categories>
  </entry>
  <entry>
    <title>001-安装简介</title>
    <url>/articles/20200213/ff1f09cb.html</url>
    <content><![CDATA[<h1 id="AB的简介"><a href="#AB的简介" class="headerlink" title="AB的简介"></a>AB的简介</h1><p>ab是apachebench命令的缩写。Apache Bench 是 Apache 服务器的一个web压力测试工具.</p>
<p>ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等</p>
<p>ab也是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一个URL地址进行访问，因此可以用来测试目标服务器的负载压力。缺点就是没有图形化结果，不能监控。</p>
<h1 id="ab的原理"><a href="#ab的原理" class="headerlink" title="ab的原理"></a>ab的原理</h1><p>　　ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。</p>
<p>　　ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机</p>
<h1 id="ab的安装"><a href="#ab的安装" class="headerlink" title="ab的安装"></a>ab的安装</h1><h2 id="linux-上，安装命令："><a href="#linux-上，安装命令：" class="headerlink" title="linux 上，安装命令："></a>linux 上，安装命令：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install httpd-tools</span><br></pre></td></tr></table></figure>
<p>查看参数说明：ab –help</p>
<h2 id="MAC中自带了Apache"><a href="#MAC中自带了Apache" class="headerlink" title="MAC中自带了Apache"></a>MAC中自带了Apache</h2><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在使用ab命令时，并发了过高会出现错误：Too many open files，由于系统打开文件数量限制了。</p>
<ol>
<li>查看系统打开文件数量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a </span><br><span class="line"><span class="comment"># -t: cpu time (seconds)              unlimited</span></span><br><span class="line"><span class="comment"># -f: file size (blocks)              unlimited</span></span><br><span class="line"><span class="comment"># -d: data seg size (kbytes)          unlimited</span></span><br><span class="line"><span class="comment"># -s: stack size (kbytes)             8192</span></span><br><span class="line"><span class="comment"># -c: core file size (blocks)         0</span></span><br><span class="line"><span class="comment"># -v: address space (kbytes)          unlimited</span></span><br><span class="line"><span class="comment"># -l: locked-in-memory size (kbytes)  unlimited</span></span><br><span class="line"><span class="comment"># -u: processes                       1418</span></span><br><span class="line"><span class="comment"># -n: file descriptors                8192</span></span><br></pre></td></tr></table></figure></li>
<li>修改打开文件数量，修改成1024，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 1024</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>test-ab</category>
      </categories>
  </entry>
  <entry>
    <title>002-性能测试方法及性能优化分类</title>
    <url>/articles/20200213/7add234f.html</url>
    <content><![CDATA[<p>摘要：并发数、响应时间(RT)、吞吐量(Throughput)、页面浏览量(PV)、网站独立访客(UV)、峰值QPS和机器计算公式</p>
<a id="more"></a>

<h1 id="性能测试方法"><a href="#性能测试方法" class="headerlink" title="性能测试方法"></a>性能测试方法</h1><p>性能测试是一个不断对系统添加访问压力，以获得系统性能指标、最大负载能力、最大压力承受能力的过程。</p>
<p>性能测试方法：</p>
<ul>
<li>性能测试：以系统设计初期规划的性能指标为预期目标，对系统不断施加压力。验证系统在资源可接受范围内，能否达到性能预期。</li>
<li>负载測试：对系统不断地添加并发请求以添加系统压力，知道系统的某项或多项性能指标达到安全临界值。如某种资源已经呈饱和状态，这是继续对系统施加压力，系统的处理能力不但不提高，反而会下降。</li>
<li>压力测试：超过安全负载的情况下。对系统继续施加压力，知道系统崩溃或不能再处理请求，一次获得系统最大压力承受能力。</li>
<li>稳定性测试：被測试系统在特定硬件、软件、网络环境条件下。给系统载入一定业务压力，使系统执行一段较长时间，以此检測系统是否稳定。在不同生成环境、不同一时候间点的请求压力是不均匀的，呈波浪特性。因此为了更好地模拟生产环境，稳定性測试也不应均与地对系统施加压力。</li>
</ul>
<h1 id="性能优化分类"><a href="#性能优化分类" class="headerlink" title="性能优化分类"></a>性能优化分类</h1><p>参看现在大多数站点分层架构设计,性能优化可分为：web前端性能优化、应用server性能优化、存储server性能优化。</p>
<h2 id="web前端性能优化"><a href="#web前端性能优化" class="headerlink" title="web前端性能优化"></a>web前端性能优化</h2><ul>
<li>浏览器访问优化：降低http请求;使用浏览器缓存;启用压缩;css放在页面最上面、javaScript放在页面最以下;降低Cookie传输</li>
<li>CDN加速</li>
<li>反向代理</li>
</ul>
<h2 id="应用server性能优化"><a href="#应用server性能优化" class="headerlink" title="应用server性能优化"></a>应用server性能优化</h2><ul>
<li>内存数据库的使用（Redis、等）</li>
<li>异步操作（消息队列）</li>
<li>使用集群（负载均衡）</li>
<li>代码优化</li>
</ul>
<h2 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h2><ul>
<li>机械硬盘→固态硬盘</li>
<li>B+树 vs LSM树</li>
<li>RAID vs HDFS</li>
<li>DB表结构设计，索引设计</li>
<li>elastsearch 合理使用</li>
</ul>
]]></content>
      <categories>
        <category>performance</category>
      </categories>
  </entry>
  <entry>
    <title>001-网站的性能指标及指标测试方法</title>
    <url>/articles/20200213/ea81502f.html</url>
    <content><![CDATA[<p>摘要：并发数、响应时间(RT)、吞吐量(Throughput)、页面浏览量(PV)、网站独立访客(UV)、峰值QPS和机器计算公式</p>
<a id="more"></a>

<h1 id="常用网站性能参数"><a href="#常用网站性能参数" class="headerlink" title="常用网站性能参数"></a>常用网站性能参数</h1><h2 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h2><p>是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。</p>
<h2 id="响应时间-RT"><a href="#响应时间-RT" class="headerlink" title="响应时间(RT)"></a>响应时间(RT)</h2><p>响应时间是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。响应时间是指执行一个请求从开始到最后收到响应数据所花费的总体时间。</p>
<h2 id="吞吐量-Throughput-TPS"><a href="#吞吐量-Throughput-TPS" class="headerlink" title="吞吐量(Throughput)-TPS"></a>吞吐量(Throughput)-TPS</h2><p>吞吐量是指单位时间内系统能处理的请求数量，体现系统处理请求的能力，这是目前最常用的性能测试指标。</p>
<p>QPS（每秒查询数）、TPS（每秒事务数）是吞吐量的常用量化指标，另外还有HPS（每秒HTTP请求数）。</p>
<p>跟吞吐量有关的几个重要是：并发数、响应时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QPS（TPS）&#x3D; 并发数 &#x2F; 平均响应时间</span><br></pre></td></tr></table></figure>

<h3 id="QPS和TPS有什么区别？"><a href="#QPS和TPS有什么区别？" class="headerlink" title="QPS和TPS有什么区别？"></a>QPS和TPS有什么区别？</h3><p>TPS是每秒处理的请求数，是统计每秒用户的请求次数。QPS是每秒处理的查询次数，是统计每秒对于服务器查询的次数。用户一次请求，tps+1，而可能该请求中对应3次服务器查询次数，则qps+3。</p>
<p>例如输入一个url，返回html内容，对应查询服务器一次，而有可能在html中再次出现一个url，还需查询同样的服务器一次，则此时QPS&gt;TPS。</p>
<h2 id="页面浏览量-PV"><a href="#页面浏览量-PV" class="headerlink" title="页面浏览量(PV)"></a>页面浏览量(PV)</h2><p>PV即Page View的简写, 即页面浏览量或点击量，用户每次刷新即被计算一次。<br>单台服务器每天PV计算：<br>公式1：每天总PV = QPS * 3600 * 6<br>公式2：每天总PV = QPS * 3600 * 8</p>
<h2 id="网站独立访客-UV"><a href="#网站独立访客-UV" class="headerlink" title="网站独立访客(UV)"></a>网站独立访客(UV)</h2><p>UV即Unique Visitor的简写，访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次<br>服务器数量。<br>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器<br>机器：ceil( 每天总PV / 单台服务器每天总PV )</p>
<h2 id="峰值QPS和机器计算公式"><a href="#峰值QPS和机器计算公式" class="headerlink" title="峰值QPS和机器计算公式"></a>峰值QPS和机器计算公式</h2><p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间<br>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)<br>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器</p>
<p>例子：<br>每天300万PV的在单台机器上，这台机器需要多少QPS？<br>答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)<br>如果一台机器的QPS是58，需要几台机器来支持？<br>答：139 / 58 = 3</p>
<h1 id="如何评估网站性能参数"><a href="#如何评估网站性能参数" class="headerlink" title="如何评估网站性能参数"></a>如何评估网站性能参数</h1><h2 id="针对中小型站点"><a href="#针对中小型站点" class="headerlink" title="针对中小型站点"></a>针对中小型站点</h2><ul>
<li>方式一、使用：ab，可参看：<a href="http://blog.bjlhx.top/categories/test-ab" target="_blank" rel="noopener">http://blog.bjlhx.top/categories/test-ab</a></li>
</ul>
<p>初步评估 站点TPS等性能参数</p>
<ul>
<li>方式二、jemter评估</li>
</ul>
<h2 id="大型-对应性能团队"><a href="#大型-对应性能团队" class="headerlink" title="大型-对应性能团队"></a>大型-对应性能团队</h2>]]></content>
      <categories>
        <category>performance</category>
      </categories>
  </entry>
  <entry>
    <title>001-高性能网站建设笔记-整体规则</title>
    <url>/articles/20200213/90bc3718.html</url>
    <content><![CDATA[<p>摘要：web性能优化，指导规则；性能黄金法则：只有10%-20%的最终用户响应时间花在了下载HTML文档上；其余的80%-90%的时间花在了下载页面中的所有组件上。</p>
<a id="more"></a>

<h1 id="整体规则"><a href="#整体规则" class="headerlink" title="整体规则"></a>整体规则</h1><p>按照优先级排序，不是每个网站要求使用每个规则，但是值得参考。</p>
<ul>
<li>规则1——减少HTTP请求- </li>
<li>规则2——使用内容发布网络- </li>
<li>规则3——添加Expires头- </li>
<li>规则4——压缩组件- </li>
<li>规则5——将样式表放在顶部- </li>
<li>规则6——将脚本放在底部- </li>
<li>规则7——避免CSS表达式- </li>
<li>规则8——使用外部JavaScript和CSS- </li>
<li>规则9——减少DNS查找- </li>
<li>规则10——精简JavaScript- </li>
<li>规则11——避免重定向- </li>
<li>规则12——移除重复脚本- </li>
<li>规则13——配置ETag- </li>
<li>规则14——使AjaX可缓存</li>
</ul>
<h1 id="跟踪web页面性能方法"><a href="#跟踪web页面性能方法" class="headerlink" title="跟踪web页面性能方法"></a>跟踪web页面性能方法</h1><p>获取页面耗时，请参看：<a href="http://blog.bjlhx.top/categories/performance" target="_blank" rel="noopener">http://blog.bjlhx.top/categories/performance</a> 关于使用Chrome 瀑布流<br>获取接口耗时，请参看：<a href="http://blog.bjlhx.top/categories/test-ab" target="_blank" rel="noopener">http://blog.bjlhx.top/categories/test-ab</a> </p>
<h1 id="http协议概述"><a href="#http协议概述" class="headerlink" title="http协议概述"></a>http协议概述</h1><p>参看：<a href="https://www.cnblogs.com/bjlhx/p/10987051.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10987051.html</a></p>
<p>关于gzip压缩、http缓存控制和缓存校验【Pragma、Expires、Cache-Control、max-age、Last-Modified、用户刷新访问、避免过度304】<br>参看：<a href="https://www.cnblogs.com/bjlhx/p/10338625.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10338625.html</a></p>
<p>nginx开启压缩：<a href="https://www.cnblogs.com/bjlhx/p/12034531.html" target="_blank" rel="noopener">006-nginx.conf详解-error_page 使用、压缩</a></p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>001-html，css，js加载顺序</title>
    <url>/articles/20200212/6bc16603.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/*.css"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/*.js&gt;&lt;/script&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;/head&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="DOM加载"><a href="#DOM加载" class="headerlink" title="DOM加载"></a>DOM加载</h1><p>DOM文档的加载顺序是由上而下的顺序加载；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 浏览器一边下载HTML网页，一边开始解析</span><br><span class="line">2. 解析过程中，发现&lt;script&gt;标签</span><br><span class="line">3. 暂停解析，网页渲染的控制权转交给JavaScript引擎</span><br><span class="line">4. 如果&lt;script&gt;标签引用了外部脚本，就下载该脚本，否则就直接执行</span><br><span class="line">5. 执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页</span><br></pre></td></tr></table></figure>

<h2 id="DOM加载到link标签"><a href="#DOM加载到link标签" class="headerlink" title="DOM加载到link标签"></a>DOM加载到link标签</h2><p>css文件的加载是与DOM的加载并行的，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；</p>
<h2 id="DOM加载到script标签"><a href="#DOM加载到script标签" class="headerlink" title="DOM加载到script标签"></a>DOM加载到script标签</h2><p>由于js文件不会与DOM并行加载，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；</p>
<p>而这个特性也是为什么在js文件中开头需要$(document).ready(function(){})或者（function(){}）或者window.onload,即是让DOM文档加载完成之后才执行js文件，这样才不会出现查找不到DOM节点等问题；</p>
<p>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现；</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>html需要等head中所有的js和css加载完成后才会开始绘制，但是html不需要等待放在body最后的js下载执行就会开始绘制,因此将js放在body的最后面，可以避免资源阻塞，同时使静态的html页面迅速显示。将脚本文件都放在网页尾部加载，还有一个好处。在DOM结构生成之前就调用DOM，JavaScript会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时DOM肯定已经生成了。</p>
<p>前提，js是外部脚本；</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>外链的js如果含有defer=”true”属性，将会并行加载js，到页面全部加载完成后才会执行，会按顺序执行。</p>
<p>defer属性的作用是，告诉浏览器，等到DOM加载完成后，再执行指定脚本。</p>
<ol>
<li>浏览器开始解析HTML网页</li>
<li>解析过程中，发现带有defer属性的script标签</li>
<li>浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本</li>
<li>浏览器完成解析HTML网页，此时再执行下载的脚本<br>对于内置而不是连接外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。<br>在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；</li>
</ol>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；</p>
<p>async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>
<ol>
<li>浏览器开始解析HTML网页</li>
<li>解析过程中，发现带有async属性的script标签</li>
<li>浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本</li>
<li>脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本</li>
<li>脚本执行完毕，浏览器恢复解析HTML网页</li>
</ol>
<p>同时使用defer和async属性时，defer属性会失效；</p>
<p>可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。</p>
<p>但是</p>
]]></content>
      <categories>
        <category>html_js_css</category>
      </categories>
  </entry>
  <entry>
    <title>007-shell-编程注意事项、引号区别</title>
    <url>/articles/20200212/b4490d2f.html</url>
    <content><![CDATA[<p>摘要：shell开发时，注意事项</p>
<a id="more"></a>

<h1 id="单引号、双引号、反单引号的区别"><a href="#单引号、双引号、反单引号的区别" class="headerlink" title="单引号、双引号、反单引号的区别"></a>单引号、双引号、反单引号的区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单引号&#39; &#39;：包围变量的值时，原样输出。强引用。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</span><br><span class="line"></span><br><span class="line">双引号&quot; &quot;：包围变量的值时，解析里面的变量和命令。弱引。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</span><br><span class="line"></span><br><span class="line">反引号&#96; &#96;：一般用于命令，执行的时候命令会被执行，相当于$()，赋值和输出都要用反引号引起来。</span><br></pre></td></tr></table></figure>

<p>两种均可，后者，支持嵌套</p>
<h1 id="Shell编程注意事项"><a href="#Shell编程注意事项" class="headerlink" title="Shell编程注意事项"></a>Shell编程注意事项</h1><ol>
<li>变量赋值时‘=’两边不能有空格</li>
<li>使用[]命令测试表达式的时候，在操作数和操作符或者方括号的前后都要至少留一个空格</li>
<li>变量的引用： 使用$var 或者 ${var}</li>
<li>命令的引用：【执行命令返回值给变量】<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var2&#x3D;&#96;command&#96; 或者 var3&#x3D;$(command)</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>cmd-data</title>
    <url>/articles/20200211/f7a4df92.html</url>
    <content><![CDATA[<p>摘要：shell开发时，常用date控制展示时间</p>
<a id="more"></a>

<h1 id="date"><a href="#date" class="headerlink" title="date"></a>date</h1><p>date 可以用来显示或设定系统的日期与时间。</p>
<h2 id="查看帮助语法说明"><a href="#查看帮助语法说明" class="headerlink" title="查看帮助语法说明"></a>查看帮助语法说明</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：date [选项]... [+格式]</span><br><span class="line">　或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">可选参数：</span><br><span class="line">  -d, --date&#x3D;STRING         显示字符串所指的日期与时间。字符串前后必须加上引号； not &#39;now&#39;</span><br><span class="line">  -f, --file&#x3D;DATEFILE       like --date once for each line of DATEFILE</span><br><span class="line">  -I[TIMESPEC], --iso-8601[&#x3D;TIMESPEC]  output date&#x2F;time in ISO 8601 format.</span><br><span class="line">                            TIMESPEC&#x3D;&#39;date&#39; for date only (the default),</span><br><span class="line">                            &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, or &#39;ns&#39; for date</span><br><span class="line">                            and time to the indicated precision.</span><br><span class="line">  -r, --reference&#x3D;文件		显示文件指定文件的最后修改时间</span><br><span class="line">  -R, --rfc-2822		以RFC 2822格式输出日期和时间，例如：2006年8月7日，星期一 12:34:56 -0600</span><br><span class="line">      --rfc-3339&#x3D;TIMESPEC   output date and time in RFC 3339 format.</span><br><span class="line">                            TIMESPEC&#x3D;&#39;date&#39;, &#39;seconds&#39;, or &#39;ns&#39; for</span><br><span class="line">                            date and time to the indicated precision.</span><br><span class="line">                            Date and time components are separated by</span><br><span class="line">                            a single space: 2006-08-07 12:34:56-06:00</span><br><span class="line">  -s, --set&#x3D;STRING          根据字符串来设置日期与时间。字符串前后必须加上引号；</span><br><span class="line">  -u, --utc, --universal    print or set Coordinated Universal Time (UTC)</span><br><span class="line">      --help		显示此帮助信息并退出</span><br><span class="line">      --version		显示版本信息并退出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>日期格式字符串</span></figcaption><table><tr><td class="code"><pre><span class="line"># 如果需要以指定的格式显示日期，可以使用“+”开头的字符串指定其格式</span><br><span class="line">  %%	一个文字的 %</span><br><span class="line">  %a	当前locale 的星期名缩写(例如： 日，代表星期日)</span><br><span class="line">  %A	当前locale 的星期名全称 (如：星期日)</span><br><span class="line">  %b	当前locale 的月名缩写 (如：一，代表一月)</span><br><span class="line">  %B	当前locale 的月名全称 (如：一月)</span><br><span class="line">  %c	当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)</span><br><span class="line">  %C	世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)</span><br><span class="line">  %d	按月计的日期(例如：01)</span><br><span class="line">  %D	按月计的日期；等于%m&#x2F;%d&#x2F;%y</span><br><span class="line">  %e	按月计的日期，添加空格，等于%_d</span><br><span class="line">  %F	完整日期格式，等价于 %Y-%m-%d</span><br><span class="line">  %g	ISO-8601 格式年份的最后两位 (参见%G)</span><br><span class="line">  %G	ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用</span><br><span class="line">  %h	等于%b</span><br><span class="line">  %H	小时(00-23)</span><br><span class="line">  %I	小时(00-12)</span><br><span class="line">  %j	按年计的日期(001-366)</span><br><span class="line">  %k   hour, space padded ( 0..23); same as %_H</span><br><span class="line">  %l   hour, space padded ( 1..12); same as %_I</span><br><span class="line">  %m   month (01..12)</span><br><span class="line">  %M   minute (00..59)</span><br><span class="line">  %n	换行</span><br><span class="line">  %N	纳秒(000000000-999999999)</span><br><span class="line">  %p	当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空</span><br><span class="line">  %P	与%p 类似，但是输出小写字母</span><br><span class="line">  %r	当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)</span><br><span class="line">  %R	24 小时时间的时和分，等价于 %H:%M</span><br><span class="line">  %s	自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</span><br><span class="line">  %S	秒(00-60)</span><br><span class="line">  %t	输出制表符 Tab</span><br><span class="line">  %T	时间，等于%H:%M:%S</span><br><span class="line">  %u	星期，1 代表星期一</span><br><span class="line">  %U	一年中的第几周，以周日为每星期第一天(00-53)</span><br><span class="line">  %V	ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)</span><br><span class="line">  %w	一星期中的第几日(0-6)，0 代表周一</span><br><span class="line">  %W	一年中的第几周，以周一为每星期第一天(00-53)</span><br><span class="line">  %x	当前locale 下的日期描述 (如：12&#x2F;31&#x2F;99)</span><br><span class="line">  %X	当前locale 下的时间描述 (如：23:13:48)</span><br><span class="line">  %y	年份最后两位数位 (00-99)</span><br><span class="line">  %Y	年份</span><br><span class="line">  %z +hhmm		数字时区(例如，-0400)</span><br><span class="line">  %:z +hh:mm		数字时区(例如，-04:00)</span><br><span class="line">  %::z +hh:mm:ss	数字时区(例如，-04:00:00)</span><br><span class="line">  %:::z			数字时区带有必要的精度 (例如，-04，+05:30)</span><br><span class="line">  %Z			按字母表排序的时区缩写 (例如，EDT)</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式化输出：</span></span><br><span class="line">date +<span class="string">"%Y-%m-%d"</span> </span><br><span class="line">2020-02-11</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date +%Y%m%d               <span class="comment">#显示当前天年月日 </span></span><br><span class="line">date -d <span class="string">"-1 day"</span> +%Y%m%d   <span class="comment">#显示前一天的日期 或 date -d "1 day ago" +%Y%m%d </span></span><br><span class="line">date -d <span class="string">"+1 day"</span> +%Y%m%d   <span class="comment">#显示后一天的日期 或 date -d "1 day" +%Y%m%d</span></span><br><span class="line"><span class="comment"># 其中：day 天；month 月；year 年；second 秒；</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-java-保留两位小数以及浮点类型精度问题</title>
    <url>/articles/20200211/7aa0e1b.html</url>
    <content><![CDATA[<p>摘要：保存成两个小数</p>
<a id="more"></a>

<h1 id="几种方式"><a href="#几种方式" class="headerlink" title="几种方式"></a>几种方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> roundLong = <span class="number">8710</span>;</span><br><span class="line">System.out.println((roundLong * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((roundLong /<span class="number">100.0</span>));</span><br><span class="line"><span class="comment">// 方式一、DecimalFormat</span></span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">".00"</span>);</span><br><span class="line">System.out.println(df.format(roundLong * <span class="number">0.01</span>));</span><br><span class="line"><span class="comment">// 方式二、String.format</span></span><br><span class="line">System.out.println(String.format(<span class="string">"%.2f"</span>, (roundLong * <span class="number">0.01</span>)));</span><br><span class="line"><span class="comment">// 方式三、BigDecimal</span></span><br><span class="line">BigDecimal bg = <span class="keyword">new</span> BigDecimal(roundLong * <span class="number">0.01</span>);</span><br><span class="line"><span class="keyword">double</span> d3 = bg.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">System.out.println(d3);</span><br><span class="line"><span class="comment">// 方式四：通过NumberFormat类实现</span></span><br><span class="line">NumberFormat nf = NumberFormat.getNumberInstance();</span><br><span class="line">nf.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">System.out.println(nf.format(roundLong * <span class="number">0.01</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">87.10000000000001</span><br><span class="line">87.1</span><br><span class="line">87.10</span><br><span class="line">87.10</span><br><span class="line">87.1</span><br><span class="line">87.1</span><br></pre></td></tr></table></figure>

<h1 id="浮点类型精度问题"><a href="#浮点类型精度问题" class="headerlink" title="浮点类型精度问题"></a>浮点类型精度问题</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t2 = <span class="number">8710</span>;</span><br><span class="line">System.out.println((t2 * <span class="number">0.1</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.001</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line">t2 = <span class="number">870</span>;</span><br><span class="line">System.out.println((t2 * <span class="number">0.1</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.001</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> number1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> number2 = <span class="number">20.2</span>;</span><br><span class="line"><span class="keyword">double</span> number3 = <span class="number">300.03</span>;</span><br><span class="line"><span class="keyword">double</span> result = number1 + number2 + number3;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">871.0</span><br><span class="line">87.10000000000001</span><br><span class="line">8.71</span><br><span class="line">0.871</span><br><span class="line">87.0</span><br><span class="line">8.700000000000001</span><br><span class="line">0.87</span><br><span class="line">0.08700000000000001</span><br><span class="line">321.22999999999996</span><br></pre></td></tr></table></figure>
<p>此处涉及，计算机浮点设计问题，详细可查阅资料。<br>float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。<br>主要是说明应用系统设计、数据库设计，商业计算标准金额时，请尽量避开浮点直接运算，推荐 long、BigDecimal等其他方式进行</p>
]]></content>
      <categories>
        <category>java-base</category>
      </categories>
  </entry>
  <entry>
    <title>005-cmd-stat显示与touch修改文件的各种时间</title>
    <url>/articles/20200211/ced46313.html</url>
    <content><![CDATA[<p>摘要：stat查看具体，touch操作具体<br>主要是测试log4j2日志删除策略时候使用。</p>
<a id="more"></a>

<h1 id="stat显示指定文件的状态信息"><a href="#stat显示指定文件的状态信息" class="headerlink" title="stat显示指定文件的状态信息"></a>stat显示指定文件的状态信息</h1><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><ul>
<li>mac<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -?</span><br><span class="line"><span class="comment"># stat: illegal option -- ?</span></span><br><span class="line"><span class="comment"># usage: stat [-FlLnqrsx] [-f format] [-t timefmt] [file ...]</span></span><br></pre></td></tr></table></figure></li>
<li>centos<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 用法：stat [选项]... 文件...</span></span><br><span class="line"><span class="comment"># Display file or file system status.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   -L, --dereference     follow links</span></span><br><span class="line"><span class="comment">#   -Z, --context         print the SELinux security context </span></span><br><span class="line"><span class="comment">#   -f, --file-system     display file system status instead of file status</span></span><br><span class="line"><span class="comment">#   -c --format=格式	使用指定输出格式代替默认值，每用一次指定格式换一新行</span></span><br><span class="line"><span class="comment">#       --printf=格式	类似 --format，但是会解释反斜杠转义符，不使用换行作</span></span><br><span class="line"><span class="comment"># 				输出结尾。如果您仍希望使用换行，可以在格式中</span></span><br><span class="line"><span class="comment"># 				加入"\n"</span></span><br><span class="line"><span class="comment">#   -t, --terse		使用简洁格式输出</span></span><br><span class="line"><span class="comment">#       --help		显示此帮助信息并退出</span></span><br><span class="line"><span class="comment">#       --version		显示版本信息并退出</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="查看具体时间"><a href="#查看具体时间" class="headerlink" title="查看具体时间"></a>查看具体时间</h2><ul>
<li>mac<br>一次尝试一下其中含义，发现 -x 比较容易理解各种时间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -x text.txt</span><br><span class="line"><span class="comment">#   File: "text.txt"</span></span><br><span class="line"><span class="comment">#   Size: 6            FileType: Regular File</span></span><br><span class="line"><span class="comment">#   Mode: (0644/-rw-r--r--)         Uid: (545858136/lihongxu6)  Gid: (699739227/(699739227))</span></span><br><span class="line"><span class="comment"># Device: 1,4   Inode: 15213285    Links: 1</span></span><br><span class="line"><span class="comment"># Access: Tue Feb 11 08:53:33 2020</span></span><br><span class="line"><span class="comment"># Modify: Tue Feb 11 08:53:32 2020</span></span><br><span class="line"><span class="comment"># Change: Tue Feb 11 08:53:32 2020</span></span><br></pre></td></tr></table></figure>

<p>Access是文件访问时间，Modify是文件内容最后修改时间，Change是文件属性最后修改时间，分别对应时间戳atime/mtime/ctime。<br>Change时间比较特殊，当改变文件的名称，大小和权限的时候Change时间才会改变。</p>
<p>通过上述发现并没有包含文件的创建时间，即crtime。查看源码可知，这是因为inode结构体中并没有crtime。</p>
<ul>
<li>centos<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span>  test.txt </span><br><span class="line"><span class="comment">#   File: "test.txt"</span></span><br><span class="line"><span class="comment">#   Size: 0         	Blocks: 0          IO Block: 4096   普通空文件</span></span><br><span class="line"><span class="comment"># Device: fc01h/64513d	Inode: 1579964     Links: 1</span></span><br><span class="line"><span class="comment"># Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line"><span class="comment"># Access: 2020-02-11 10:07:53.343752608 +0800</span></span><br><span class="line"><span class="comment"># Modify: 2020-02-11 10:08:14.709608664 +0800</span></span><br><span class="line"><span class="comment"># Change: 2020-02-11 10:08:14.709608664 +080</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="查看文件的创建时间。"><a href="#查看文件的创建时间。" class="headerlink" title="查看文件的创建时间。"></a>查看文件的创建时间。</h3><ul>
<li><p>mac<br>Mac OS X上没有debugfs（8）。Debugfs（8）是用于调试Linux文件系统ext2 / ext3的Linux程序。<br>可以使用： HFS+ try fsck(8) or use Disk Utility. 或者自带命令： GetFileInfo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GetFileInfo text.txt </span><br><span class="line"><span class="comment"># file: "/Users/lihongxu6/IdeaProjectsGit/shell/test/fileop/text.txt"</span></span><br><span class="line"><span class="comment"># type: "\0\0\0\0"</span></span><br><span class="line"><span class="comment"># creator: "\0\0\0\0"</span></span><br><span class="line"><span class="comment"># attributes: avbstclinmedz</span></span><br><span class="line"><span class="comment"># created: 02/11/2020 08:53:27</span></span><br><span class="line"><span class="comment"># modified: 02/11/2020 08:53:32</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>centos</p>
</li>
</ul>
<ol>
<li><p>查看文件的inode号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> test.txt</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">stat</span> -x text.txt</span><br></pre></td></tr></table></figure>
<p>inode:15213285</p>
</li>
<li><p>输出分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df test.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df text.txt                         </span></span><br><span class="line"><span class="comment"># Filesystem   512-blocks      Used Available Capacity iused               ifree %iused  Mounted on</span></span><br><span class="line"><span class="comment"># /dev/disk1s1  489620264 215965128 243191936    48% 2289359 9223372036852486448    0%   /</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过debugfs就可以查询到文件的完整信息<br>linux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugfs -R <span class="string">'stat &lt;15213285&gt;'</span> /dev/disk1s1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="linux修改文件各种时间"><a href="#linux修改文件各种时间" class="headerlink" title="linux修改文件各种时间"></a>linux修改文件各种时间</h1><p>查看下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span>  test.txt </span><br><span class="line"><span class="comment">#   File: "test.txt"</span></span><br><span class="line"><span class="comment">#   Size: 0         	Blocks: 0          IO Block: 4096   普通空文件</span></span><br><span class="line"><span class="comment"># Device: fc01h/64513d	Inode: 1579964     Links: 1</span></span><br><span class="line"><span class="comment"># Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line"><span class="comment"># Access: 2020-02-11 10:07:53.343752608 +0800</span></span><br><span class="line"><span class="comment"># Modify: 2020-02-11 10:08:14.709608664 +0800</span></span><br><span class="line"><span class="comment"># Change: 2020-02-11 10:08:14.709608664 +080</span></span><br></pre></td></tr></table></figure>

<h2 id="修改修改时间"><a href="#修改修改时间" class="headerlink" title="修改修改时间"></a>修改修改时间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件修改时间设置为：2020年02月11日09:17:52</span></span><br><span class="line">touch -t 202002110917.52 test.txt</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">touch -d <span class="string">"2020-02-11 09:18:08"</span> test.txt</span><br><span class="line"><span class="comment"># 查看实际是否修改</span></span><br><span class="line"><span class="built_in">stat</span> test.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>004-shell-函数以及传递参数的几种方式</title>
    <url>/articles/20200210/7355fbf4.html</url>
    <content><![CDATA[<p>摘要：linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<a id="more"></a>

<h1 id="函数语法格式"><a href="#函数语法格式" class="headerlink" title="函数语法格式"></a>函数语法格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
<li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。执行成功 默认是 0 </li>
</ol>
<p>shell 语言中 0 代表 true，0 以外的值代表 false。</p>
<ol start="3">
<li>函数返回值在调用该函数后通过 $? 来获得。$? 仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。</li>
</ol>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<p>示例1、无返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"test"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"返回值：$?"</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">返回值：0</span><br></pre></td></tr></table></figure>

<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… </p>
<p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数处理	说明</span><br><span class="line">$#	传递到脚本或函数的参数个数</span><br><span class="line">$*	以一个单字符串显示所有向脚本传递的参数</span><br><span class="line">$	脚本运行的当前进程ID号</span><br><span class="line">$!	后台运行的最后一个进程的ID号</span><br><span class="line">$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">$-	显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"进程id:$"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数个数: <span class="variable">$&#123;#&#125;</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"所有参数: $*"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"所有参数: <span class="variable">$@</span>"</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"显示Shell使用的当前选项:$-"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span> aa xx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"返回值：$?"</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程id:11414</span><br><span class="line">参数个数: 2</span><br><span class="line">所有参数: aa xx</span><br><span class="line">所有参数: aa xx</span><br><span class="line">aa</span><br><span class="line">xx</span><br><span class="line">显示Shell使用的当前选项:hB</span><br><span class="line">返回值：0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-tomcat-日志分割三种方法</title>
    <url>/articles/20200210/6998e040.html</url>
    <content><![CDATA[<p>概述:tomcat-日志分割三种方法<br>三种方式均有优缺点，</p>
<ul>
<li>cronolog：需要在主机安装软件</li>
<li>log4j：方便使用，但是不能删除</li>
<li>crontab：需要有对应目录权限</li>
</ul>
<p>采取cronolog、log4j缺点：已经做好对应主机镜像，大范围使用，在应用系统级别修改，所有使用者会参与修改；<br>采用crontab，crontab不需要安装，检测linux默认自带安装。正好部署时使用shell脚本，此时只需在脚本中嵌入执行crontab脚本即可。</p>
<a id="more"></a>
<h1 id="方法一、用cronolog分割tomcat的catalina-out文件"><a href="#方法一、用cronolog分割tomcat的catalina-out文件" class="headerlink" title="方法一、用cronolog分割tomcat的catalina.out文件"></a>方法一、用cronolog分割tomcat的catalina.out文件</h1><p>Linux 日志切割工具cronolog详解：<a href="https://blog.csdn.net/chenkeqin_2012/article/details/52670887" target="_blank" rel="noopener">https://blog.csdn.net/chenkeqin_2012/article/details/52670887</a></p>
<ol>
<li>编译安装cronolog<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://cronolog.org/download/cronolog-1.6.2.tar.gz </span><br><span class="line">tar zxvf cronolog-1.6.2.tar.gz </span><br><span class="line"><span class="built_in">cd</span> cronolog-1.6.2</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li>查看cronolog安装后所在目录（验证安装是否成功）<br>which cronolog<br>一般情况下显示为：/usr/local/sbin/cronolog </li>
<li>编辑tomcat目录bin下的catalina.sh文件<br>找到下面这行，类似这样的行有2处：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \</span><br><span class="line">      &gt;&gt; &quot;$CATALINA_OUT&quot; 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>第一处：tomcat是带“-security”参数的启动，</li>
<li>第二处：默认tomcat启动方式，也就是else下面的那部分，我们只修改这里。</li>
<li>另外还要把touch “$CATALINA_OUT”这行注释掉。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  touch "$CATALINA_OUT"</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"-security"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$have_tty</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"Using Security Manager"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="string">"<span class="variable">$_RUNJAVA</span>"</span> <span class="string">"<span class="variable">$LOGGING_CONFIG</span>"</span> <span class="variable">$LOGGING_MANAGER</span> <span class="variable">$JAVA_OPTS</span> <span class="variable">$CATALINA_OPTS</span> \</span><br><span class="line">      -Djava.endorsed.dirs=<span class="string">"<span class="variable">$JAVA_ENDORSED_DIRS</span>"</span> -classpath <span class="string">"<span class="variable">$CLASSPATH</span>"</span> \</span><br><span class="line">      -Djava.security.manager \</span><br><span class="line">      -Djava.security.policy==<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span>/conf/catalina.policy \</span><br><span class="line">      -Dcatalina.base=<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span> \</span><br><span class="line">      -Dcatalina.home=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span> \</span><br><span class="line">      -Djava.io.tmpdir=<span class="string">"<span class="variable">$CATALINA_TMPDIR</span>"</span> \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap <span class="string">"<span class="variable">$@</span>"</span> start \</span><br><span class="line">      &gt;&gt; <span class="string">"<span class="variable">$CATALINA_OUT</span>"</span> 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="string">"<span class="variable">$_RUNJAVA</span>"</span> <span class="string">"<span class="variable">$LOGGING_CONFIG</span>"</span> <span class="variable">$LOGGING_MANAGER</span> <span class="variable">$JAVA_OPTS</span> <span class="variable">$CATALINA_OPTS</span> \</span><br><span class="line">      -Djava.endorsed.dirs=<span class="string">"<span class="variable">$JAVA_ENDORSED_DIRS</span>"</span> -classpath <span class="string">"<span class="variable">$CLASSPATH</span>"</span> \</span><br><span class="line">      -Dcatalina.base=<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span> \</span><br><span class="line">      -Dcatalina.home=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span> \</span><br><span class="line">      -Djava.io.tmpdir=<span class="string">"<span class="variable">$CATALINA_TMPDIR</span>"</span> \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap <span class="string">"<span class="variable">$@</span>"</span> start 2&gt;&amp;1 | /usr/<span class="built_in">local</span>/sbin/cronolog /usr/<span class="built_in">local</span>/tomcat/logs/catalina.%Y%m%d.out &gt;&gt; /dev/null &amp;</span><br><span class="line"><span class="comment">#      &gt;&gt; "$CATALINA_OUT" 2&gt;&amp;1 &amp;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>重启tomcat<br>查看日志目录是否生成catalina.yymmdd.out的日志文件</li>
</ol>
<p>-rw-r–r– 1 root root 10537 Jul 30 10:50 catalina.20140730.out</p>
<p>配置cronolog完成了，观察每天是否有一个新的catalina.yymmdd.out的日志文件生成，定期删除日期较旧的日志文件。</p>
<h1 id="方法二、使用log4j成功使catalina-out文件实现分割"><a href="#方法二、使用log4j成功使catalina-out文件实现分割" class="headerlink" title="方法二、使用log4j成功使catalina.out文件实现分割"></a>方法二、使用log4j成功使catalina.out文件实现分割</h1><p>　　1、在tomcat根目录下建立common/classes/log4j.properties，内容如下<br>复制代码<br>log4j.rootLogger=INFO, R<br>log4j.appender.R=org.apache.log4j.RollingFileAppender<br>log4j.appender.R.File=${catalina.home}/logs/tomcat.newlog  #设定日志文件名<br>log4j.appender.R.MaxFileSize=100KB   #设定文件到100kb即分割<br>log4j.appender.R.MaxBackupIndex=10   #设定日志文件保留的序号数<br>log4j.appender.R.layout=org.apache.log4j.PatternLayout<br>log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n<br>复制代码<br>　　2、在tomcat根目录下的common/lib下加入log4j.jar和commons-logging.jar<br>　　3、重新启动tomcat即可。</p>
<h1 id="方法三、使用系统crontab"><a href="#方法三、使用系统crontab" class="headerlink" title="方法三、使用系统crontab"></a>方法三、使用系统crontab</h1><ol>
<li>编写一个crontab_log_work.sh文件,shell脚本如下:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>  `dirname <span class="variable">$0</span>`</span><br><span class="line">d=`date +%Y%m%d`</span><br><span class="line">d7=`date -d<span class="string">'7 day ago'</span> +%Y%m%d`</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>  ../logs/</span><br><span class="line"></span><br><span class="line">cp catalina.out catalina.out.<span class="variable">$&#123;d&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; catalina.out </span><br><span class="line">rm -rf catalina.out.<span class="variable">$&#123;d7&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>编写任务执行计划 crontab_log<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55 23 * * * crontab_log_work.sh</span><br></pre></td></tr></table></figure></li>
<li>使用crontab 启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab crontab_log</span><br></pre></td></tr></table></figure>






</li>
</ol>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>003-shell-crontab定时任务</title>
    <url>/articles/20200208/a16096f7.html</url>
    <content><![CDATA[<p>摘要：有时需要操作系统统，定时做一些任务，解决一些问题。<br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>说明：</p>
<ol>
<li>Linux和Mac下操作crontab都是一致的</li>
<li>配置文件都在/etc/crontab下，如果没有就创建。默认系统级别存在，不需要额外安装定时任务</li>
<li>测试直接使用crontab -e命令创建的定时任务是放在临时文件夹的，重启会删除，并且与/etc/crontab文件无关联。</li>
</ol>
<h2 id="crontab服务的重启关闭，开启"><a href="#crontab服务的重启关闭，开启" class="headerlink" title="crontab服务的重启关闭，开启"></a>crontab服务的重启关闭，开启</h2><p>系统级别，是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。所以下述命令不可用。</p>
<ul>
<li>Mac系统下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/cron start</span><br><span class="line">sudo /usr/sbin/cron restart</span><br><span class="line">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure></li>
<li>Ubuntu<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/cron start</span><br><span class="line">sudo /etc/init.d/cron stop</span><br><span class="line">sudo /etc/init.d/cron restart</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看定时任务：<code>crontab -l</code><br>列出用户test的所有调度任务:<code>crontab -l -u test</code><br>删除所有调度任务：<code>crontab -r</code></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li><p>方式一、系统级别-/etc/crontab 方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/crontab</span><br><span class="line">*/1 * * * * root /bin/date &gt;&gt; /tmp/time2.txt</span><br></pre></td></tr></table></figure>
<p>保存使用：<code>:wq!</code>；默认超管只读权限，需要强制保存退出</p>
</li>
<li><p>方式二、用户级别-crontab -e 自定义脚本启动</p>
</li>
</ul>
<ol>
<li>执行脚本编写<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每分钟执行一次date命令，输出时间到time.txt文本</span></span><br><span class="line">*/1 * * * * /bin/date &gt;&gt; /tmp/time.txt</span><br></pre></td></tr></table></figure></li>
<li>crontab命令调用crontab文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab testing_crontab</span><br></pre></td></tr></table></figure></li>
<li>查看 文件内容<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f  /tmp/time.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="etc-crontab文件和crontab-e命令区别"><a href="#etc-crontab文件和crontab-e命令区别" class="headerlink" title="/etc/crontab文件和crontab -e命令区别"></a>/etc/crontab文件和crontab -e命令区别</h2><ol>
<li>修改/etc/crontab这种方法只有root用户能用，这种方法更加方便与直接直接给其他用户设置计划任务，而且还可以指定执行shell等等，crontab -e这种所有用户都可以使用，普通用户也只能为自己设置计划任务。然后自动写入/var/spool/cron/usename</li>
<li>crontab -e是某个用户的周期计划任务；/etc/crontab是系统的周期任务</li>
<li>crontab -e与/etc/crontab修改语法格式不一样，后者多一个user指定</li>
<li>不管用crontab -e或者/etc/crontab都不需要重新启动crond服务</li>
<li>crontab  -e是针对用户的cron来设计的，如果是系统的例行性任务，需要编辑/etc/crontab文件。需要注意的是：crontab -e的作用其实是/usr/bin/crontab这个执行文件，但是/etc/crontab是个纯文本文件，可以root的身份编辑这个文件。</li>
<li>cron服务的最低检测时间单位是分钟，所以cron会每分钟读取一次/etc/crontab与/var/spool/cron中的数据内容，因此，只要您编辑完/etc/crontab文件并且保存之后，crontab时设定就会自动执行。</li>
</ol>
<p>注意：在Linux下的crontab会自动帮我们每分钟重新读取一次/etc/crontab的例行工作事项，但是某些原因或在其他的unix系统中，由于crontab是读到内存中，所以在您修改完/etc/crontab之后可能并不会马上执行，这时请重新启动crond服务。</p>
<p>/et</p>
<h1 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file [-u user] [ -e | -l | -r ]</span><br><span class="line">*   -u user：用来设定某个用户的crontab服务；</span><br><span class="line">*   file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">*   -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">*   -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">*   -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">*   -i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<h1 id="cron语法"><a href="#cron语法" class="headerlink" title="cron语法"></a>cron语法</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>分钟 小时 日期 月份 周 命令<br>如：数字范围 0-59 0-23 1-31 1-12 0-7 echo “hello” &gt;&gt; abc.log  </p>
<figure class="highlight plain"><figcaption><span>特殊字符的含义</span></figcaption><table><tr><td class="code"><pre><span class="line">*(星号) 代表任何时刻都接受。</span><br><span class="line">,(逗号) 代表分隔时段的意思。</span><br><span class="line">-(减号) 代表一段时间范围内。</span><br><span class="line">&#x2F;n(斜线) 那个 n 代表数字，每隔 n 单位间隔。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>每年的五月一日 10:5 执行一次：<code>5 10 1 5 * command（要是执行网址（curl &quot;http://网址&quot;），或者执行其它的直接写路径）</code></li>
<li>每天的三点，六点各执行一次：<code>00 3,6 * * * command</code></li>
<li>每天的8:20, 9:20,10:20,11:20各执行一次：<code>20 8-11 * * * command</code></li>
<li>每五分钟执行一次：<code>*/5 * * * * command</code></li>
<li>每周一十点执行一次：<code>00 10 * * 1 command</code></li>
<li>每天 02:00 执行任务：<code>0 2 * * * /bin/sh backup.sh</code></li>
<li>每天 5:00和17:00执行任务：<code>0 5,17 * * * /scripts/script.sh</code></li>
<li>每分钟执行一次任务：<code>* * * * * /scripts/script.sh</code></li>
<li>每周日 17:00 执行任务：<code>0 17 * * sun /scripts/script.sh</code></li>
<li>每 10min 执行一次任务：<code>*/10 * * * * /scripts/monitor.sh</code></li>
<li>在特定的某几个月执行任务：<code>* * * jan,may,aug * /script/script.sh</code></li>
<li>在特定的某几天执行任务：<code>0 17 * * sun,fri /script/scripy.sh（在每周五、周日的17点执行任务）</code></li>
<li>在某个月的第一个周日执行任务：<code>0 2 * * sun [ $(date +%d) -le 07 ] &amp;&amp; /script/script.sh</code></li>
<li>每四个小时执行一个任务：<code>0 */4 * * * /scripts/script.sh</code></li>
<li>每周一、周日执行任务：<code>0 4,17 * * sun,mon /scripts/script.sh</code></li>
<li>每个30秒执行一次任务：我们没有办法直接通过上诉类似的例子去执行，因为最小的是1min。但是我们可以通过如下的方法。<br><code>* * * * * /scripts/script.sh</code><br><code>* * * * * sleep 30; /scripts/script.sh</code></li>
<li>多个任务在一条命令中配置<br><code>* * * * * /scripts/script.sh; /scripts/scrit2.sh</code></li>
<li>每年执行一次任务<br><code>@yearly /scripts/script.sh</code><br>@yearly 类似于“0 0 1 1 *”。它会在每年的第一分钟内执行，通常我们可以用这个发送新年的问候。</li>
<li>系统重启时执行：<code>@reboot /scripts/script.sh</code></li>
</ul>
<h1 id="清除日志命令"><a href="#清除日志命令" class="headerlink" title="清除日志命令"></a>清除日志命令</h1><p>主要目标：每日凌晨前10分钟，将catalina.out日志，copy重命名 catalina.out-2020-02-08.log，清空服务器上的catalina.out日志，</p>
<p>编译一个shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>002-tools-mac-vscode</title>
    <url>/articles/20200208/6d6ffdd4.html</url>
    <content><![CDATA[<p>概述:mac下基础操作</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><p>支持：JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity).</p>
<h2 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载 安装"></a>下载 安装</h2><ol>
<li>下载地址<br><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></li>
</ol>
<p>下载后直接运行</p>
<h2 id="界面操作说明"><a href="#界面操作说明" class="headerlink" title="界面操作说明"></a>界面操作说明</h2><h3 id="界面展示语言设置"><a href="#界面展示语言设置" class="headerlink" title="界面展示语言设置"></a>界面展示语言设置</h3><p>command + shift + p，配置语言 或者 Configure Language，选择后会打开 locale.json 文件,【版本不一样其他类似】</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"locale"</span>:<span class="string">"zh-CN"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>界面说明<br>顶部：工具栏<br>最左侧：快捷工具栏【资源管理器、搜索、git、调试、扩展工具】</li>
<li>关闭更新<br>并将联机社会组中部分关闭</li>
</ol>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ &#96; ：调取和关闭终端</span><br><span class="line">⌘ + 、 ⌘ + ：很容易的实现整个页面所有字体大小</span><br><span class="line">⌥ ⇧ F：格式化文件快捷键</span><br></pre></td></tr></table></figure>

<h2 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h2><p>点击 左侧 打开git 操作窗，列表中即文件变化,输入框可以输入 commit message，上面 对号 是提交 </p>
<ol>
<li>界面说明<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左下角，分支选择</span><br><span class="line">顶部 操作</span><br><span class="line">省略号  是 git更多操作</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="markdown-支持"><a href="#markdown-支持" class="headerlink" title="markdown 支持"></a>markdown 支持</h2><p>  vscode 在没有安装任何插件的情况下是可以直接编写markdown文档的，以及 可以预览</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>001-tools-mac-sublime text3</title>
    <url>/articles/20200208/6c7c66a.html</url>
    <content><![CDATA[<p>概述:mac下基础操作</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><h2 id="停止更新提示："><a href="#停止更新提示：" class="headerlink" title="停止更新提示："></a>停止更新提示：</h2><ol>
<li>preferences→setting→增加如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;font_size&quot;: 17,</span><br><span class="line">    &quot;update_check&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意：一定要在每一行结束加逗号</li>
</ol>
<h2 id="插件安装包"><a href="#插件安装包" class="headerlink" title="插件安装包"></a>插件安装包</h2><h3 id="安装-Package-Control"><a href="#安装-Package-Control" class="headerlink" title="安装 Package Control"></a>安装 Package Control</h3><ol>
<li>安装</li>
</ol>
<ul>
<li>方式一、在线安装<br>Mac: cmd+shift+p<br>输入;Install Package Control, 按 enter</li>
<li>方式二、离线安装<br>下载：<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a> 下载 ： Package Control.sublime-package 即可</li>
</ul>
<p>Mac位置:/Users/用户名/Library/Application Support/Sublime Text 3/Installed Packages</p>
<ol start="2">
<li>使用<br>重启Sublime3,如果菜单-&gt;Preferences有Package Setting和Package Control就说明安装成功。</li>
</ol>
<p>Ctrl+Shift+p输入install选中Install Package回车就可以安装插件。</p>
<p>一般有些慢，可以在 菜单-&gt;Preferences有Package Setting 的setting user增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;debug&quot;: true,</span><br><span class="line">&quot;downloader_precedence&quot;:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;linux&quot;:[&quot;curl&quot;,&quot;urllib&quot;,&quot;wget&quot;],</span><br><span class="line">	&quot;osx&quot;:[&quot;curl&quot;,&quot;urllib&quot;],</span><br><span class="line">	&quot;windows&quot;:[&quot;wininet&quot;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="安装markdown-相关"><a href="#安装markdown-相关" class="headerlink" title="安装markdown 相关"></a>安装markdown 相关</h3><ol>
<li>安装预览：cmd+ shift + p,输入 install package，注意看左下角在加载，完毕后 出现输出框，输入 markdown preview 查找合适即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>

<p>markdown edit,preview</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>003-mysql-基础操作-常用数据类型</title>
    <url>/articles/20200205/93944b35.html</url>
    <content><![CDATA[<p>摘要：mysql 常用数据类型:数值类型、字符串类型、日期类型</p>
<a id="more"></a>

<p>更多：<a href="https://www.cnblogs.com/bjlhx/category/998292.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/998292.html</a></p>
<h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><p>MySQL中支持5种整数类型，其实很大程度上相同的，只是存储值的大小范围不同而已。其次是浮点类型float和double类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tinyint：占用1个字节，相对于java中的byte</span><br><span class="line">smallint：占用2个字节，相对于java中的short</span><br><span class="line">int：占用4个字节，相对于java中的int【推荐直接使用这个，已于扩展，降低转换】</span><br><span class="line">bigint：占用8个字节，相对于java中的long【自增主键推荐使用】</span><br><span class="line">float：4字节单精度浮点类型，相对于java中的float</span><br><span class="line">double：8字节双精度浮点类型，相对于java中的double</span><br></pre></td></tr></table></figure>
<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char()------定长字符串，最长255个字符。定长会浪费空间</span><br><span class="line">varchar()----变长(不定长)字符串，最长不超过 65535个字节,一般超过255个字节，会使用text类型. 不定长节省空间,剩余空间会留给别的数据使用</span><br><span class="line">text--------长文本类型,最长65535个字节</span><br></pre></td></tr></table></figure>

<h2 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h2><ul>
<li>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</li>
<li>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</li>
<li>VARCHAR存储的内容超出设置的长度时，内容会被截断。</li>
</ul>
<h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><ul>
<li>CHAR是定长的，根据定义的字符串长度分配足够的空间。</li>
<li>CHAR会根据需要使用空格进行填充方便比较。</li>
<li>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</li>
<li>CHAR存储的内容超出设置的长度时，内容同样会被截断。</li>
</ul>
<h2 id="使用策略："><a href="#使用策略：" class="headerlink" title="使用策略："></a>使用策略：</h2><ul>
<li>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。</li>
<li>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</li>
<li>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</li>
<li>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</li>
</ul>
<h2 id="总结：-char、varchar、text都可以表示字符串类型，其区别在于："><a href="#总结：-char、varchar、text都可以表示字符串类型，其区别在于：" class="headerlink" title="总结： char、varchar、text都可以表示字符串类型，其区别在于："></a>总结： char、varchar、text都可以表示字符串类型，其区别在于：</h2><ol>
<li>char在保存数据时, 如果存入的字符串长度小于指定的长度n,后面会用空格补全。</li>
<li>varchar和text保存数据时, 按数据的真实长度存储, 剩余的空间可以留给别的数据用.</li>
<li>char会造成空间浪费(不足指定长度的会用空格补全), 但是由于不需要计算数据的长度, 因此速度更快。（即浪费空间、节约时间）</li>
<li>varchar和text但是节省了空间, 但是存储的速度不如char快(因为要计算数据的实际长度)</li>
</ol>
<h1 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date：年月日</span><br><span class="line">time：时分秒</span><br><span class="line">datetime：年月日 时分秒</span><br><span class="line">	5.6后：使用：DEFAULT NOW()、DEFAULT CURRENT_TIMESTAMP设置</span><br><span class="line">timestamp：时间戳，与datetime存储相同的数据。</span><br><span class="line">	1、插入记录时，时间戳字段包含DEFAULT CURRENT_TIMESTAMP，如插入记录时未指定具体时间数据则将该时间戳字段值设置为当前时间</span><br><span class="line">  	2、更新记录时，时间戳字段包含ON UPDATE CURRENT_TIMESTAMP，如更新记录时未指定具体时间数据则将该时间戳字段值设置为当前时间</span><br><span class="line">	CURRENT_TIMESTAMP表示使用CURRENT_TIMESTAMP()函数来获取当前时间，类似于NOW()函数</span><br></pre></td></tr></table></figure>
<h2 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日期类型         存储空间       日期格式                                      日期范围</span><br><span class="line">datetime		8 bytes   YYYY-MM-DD HH:MM:SS   1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</span><br><span class="line">timestamp		4 bytes   YYYY-MM-DD HH:MM:SS   1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</span><br><span class="line">date			3 bytes   YYYY-MM-DD            1000-01-01 ~ 9999-12-31</span><br></pre></td></tr></table></figure>

<h3 id="datetime和timestamp的区别用法："><a href="#datetime和timestamp的区别用法：" class="headerlink" title="datetime和timestamp的区别用法："></a>datetime和timestamp的区别用法：</h3><p>1.datetime 的日期范围比较大；如果有1970年以前的数据还是要用datetime.但是timestamp 所占存储空间比较小。(节省空间)<br>2.timestamp 类型的列还有个特性：默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新。(可设置)<br>3.timestamp比较受时区timezone的影响以及MYSQL版本和服务器的SQL MODE的影响.</p>
<p>使用一个常用的格式集的任何一个，你可以指定DATETIME、DATE和TIMESTAMP值：<br>‘YYYY-MM-DD HH:MM:SS’或’YY-MM-DD HH:MM:SS’格式的一个字符串,允许一种”宽松”的语法:任何标点可用作在日期部分和时间部分之间的分隔符。例如，’98-12-31 11:30:45’、’98.12.31 11+30+45’、’98/12/31 11<em>30</em>45’和‘98@12@31 11^30^45’是等价的。</p>
<ul>
<li>timestamp最大表示2038年，而datetime范围是1000~9999</li>
<li>timestamp在插入数、修改数据时，可以自动更新成系统当前时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  在创建新记录和修改现有记录的时候都对这个数据列刷新。</span><br><span class="line">TIMESTAMP DEFAULT CURRENT_TIMESTAMP  在创建新记录的时候把这个字段设置为当前时间，但以后修改时，不再刷新它。</span><br><span class="line">TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  在创建新记录的时候把这个字段设置为0，以后修改时刷新它。</span><br><span class="line">TIMESTAMP DEFAULT ‘yyyy-mm-dd hh:mm:ss’ ON UPDATE CURRENT_TIMESTAMP  在创建新记录的时候把这个字段设置为给定值，以后修改时刷新它</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_date(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">20</span>) AUTO_INCREMENT <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'名称'</span>,</span><br><span class="line">	f_date <span class="built_in">date</span> <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'日期测试'</span>,</span><br><span class="line">	f_datetime datetime <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'日期时间测试'</span>,</span><br><span class="line">	f_createtime <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'时间戳'</span>,</span><br><span class="line">	f_updatetime <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'数据库级别更新时间戳'</span>,</span><br><span class="line">	PRIMARY <span class="keyword">key</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span>=utf8_unicode_ci  <span class="keyword">COMMENT</span> <span class="string">'日期测试表'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>002-mysql-基础操作-连接、库表操作、字段</title>
    <url>/articles/20200205/8d83348a.html</url>
    <content><![CDATA[<p>摘要：mysql 库表操作</p>
<a id="more"></a>

<p>其他：<a href="https://www.cnblogs.com/bjlhx/category/998292.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/998292.html</a></p>
<h1 id="连接登录"><a href="#连接登录" class="headerlink" title="连接登录"></a>连接登录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 帮助</span></span><br><span class="line">mysql -?</span><br><span class="line"><span class="comment"># 常用参数</span></span><br><span class="line"><span class="comment"># -h 表示服务器名字。localhost表示本地 可以省略</span></span><br><span class="line"><span class="comment"># -P 端口</span></span><br><span class="line"><span class="comment"># -u 表示用户名</span></span><br><span class="line"><span class="comment"># -p 表示密码。直接在-p后面输入密码即可，中间不能有空格。 新版本不能指定，需要手工输入</span></span><br><span class="line"><span class="comment"># -D 指定数据库，权限不够时。</span></span><br></pre></td></tr></table></figure>
<p>连接 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p123456</span><br></pre></td></tr></table></figure>
<p>进入后，语句以 ; 结尾</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul>
<li>查看所有数据库: <code>show databases;</code></li>
<li>进入数据库: <code>use 库名;</code></li>
<li>查看数据库使用端口:<code>show variables like &#39;port&#39;;</code></li>
<li>数据库编码:<code>show variables like &#39;character%&#39;;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">character_set_client      为客户端编码方式；</span><br><span class="line">character_set_connection  为建立连接使用的编码；</span><br><span class="line">character_set_database    为数据库的编码；</span><br><span class="line">character_set_results     为结果集的编码；</span><br><span class="line">character_set_server      为数据库服务器的编码；</span><br></pre></td></tr></table></figure></li>
<li>查看数据库最大连接数:<code>show variables like &#39;%max_connections%&#39;;</code></li>
<li>查看数据库当前连接数，并发数:<code>show status like &#39;Threads%&#39;;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Threads_cached : 代表当前此时此刻线程缓存中有多少空闲线程。</span><br><span class="line">Threads_connected :代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。</span><br><span class="line">Threads_created :代表从最近一次服务启动，已创建线程的数量。</span><br><span class="line">Threads_running :代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态，这里相对应的线程也是sleep状态。</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><ul>
<li>查看正在使用的数据库：<code>select database();</code></li>
<li>查看库中所有的表: <code>show tables;</code></li>
<li>查看表结构: <code>desc/describe 表名</code>;或：<code>show columns from table_name [from database_name];</code></li>
<li>查看表-列结构: <code>desc/describe 表名 列名;</code></li>
<li>查看表生成的DDL sql语句:<code>show create table tname;</code></li>
<li>查看库表信息：<code>SHOW TABLE STATUS [{FROM | IN} db_name] [LIKE &#39;pattern&#39; | WHERE expr]</code><figure class="highlight plain"><figcaption><span>字段含义</span></figcaption><table><tr><td class="code"><pre><span class="line">返回列	说明</span><br><span class="line">Name	表名称</span><br><span class="line">Engine	表的存储引擎</span><br><span class="line">Version	版本</span><br><span class="line">Row_format	行格式</span><br><span class="line">Rows	表中的行数。对于非事务性表，这个值是精确的，对于事务性引擎，这个值通常是估算的。</span><br><span class="line">Avg_row_length	平均每行的大下（字节）</span><br><span class="line">Data_length	表的数据量(单位：字节)</span><br><span class="line">Max_data_length	表可以容纳的最大数据量</span><br><span class="line">Index_length	索引占用磁盘的空间大小</span><br><span class="line">Data_free	标识已分配，但现在未使用的空间，并且包含了已被删除行的空间。</span><br><span class="line">Auto_increment	下一个Auto_increment的值</span><br><span class="line">Create_time	表的创建时间</span><br><span class="line">Update_time	表的最近更新时间</span><br><span class="line">Check_time	最近一次使用 check table 或myisamchk工具检查表的时间</span><br><span class="line">Collation	表的字符集和字符排序规则</span><br><span class="line">Checksum	如果启用，则对整个表的内容计算时的校验和</span><br><span class="line">Create_options	表创建时的其它</span><br><span class="line">Comment	表在创建是添加的注释说明</span><br></pre></td></tr></table></figure>
或者 <code>select * from information_schema.tables where TABLE_SCHEMA=&#39;库名&#39;</code></li>
</ul>
<h2 id="库、表"><a href="#库、表" class="headerlink" title="库、表"></a>库、表</h2><ul>
<li>显示数据库状态：<code>status;</code></li>
<li>退出/断开连接:<code>exit;或quit;或 \q;或ctrl+c;</code></li>
</ul>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p>字符集： 1.若没有显式设置，则自动使用服务器级的配置 ； 2.显式设置：在创建库时指定 ，如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span>  <span class="keyword">exists</span>  库名 <span class="keyword">default</span> <span class="keyword">charset</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
<p>查看 库信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.schemata <span class="keyword">where</span> schema_name = <span class="string">'test_sql'</span>; </span><br><span class="line"><span class="comment">-- def	test_sql	utf8	utf8_general_ci</span></span><br></pre></td></tr></table></figure>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><p>创建表时, 除了要给每个列指定对应的数据类型, 有时也需要给列添加约束。常见的约束有：主键约束、唯一约束、非空约束、外键约束。</p>
<h4 id="主键-primary-key-【主键索引，聚集索引】"><a href="#主键-primary-key-【主键索引，聚集索引】" class="headerlink" title="主键(primary key)【主键索引，聚集索引】"></a>主键(primary key)【主键索引，聚集索引】</h4><p>主键是数据表中，一行记录的唯一标识。比如学生的编号，人的身份证号;<br>当主键为数值时，为了方便维护，可以设置主键为自增（auto_increment）</p>
<h4 id="唯一-unique"><a href="#唯一-unique" class="headerlink" title="唯一(unique)"></a>唯一(unique)</h4><p>保证所约束的列必须是唯一的，即不能重复出现，例如：用户注册时，保存的用户名不可以重复。</p>
<blockquote>
<ul>
<li>约束 全称完整性约束，它是关系数据库中的对象，用来存放插入到一个表中一列数据的规则，用来确保数据的准确性和一致性。</li>
<li>索引 数据库中用的最频繁的操作是数据查询，索引就是为了加速表中数据行的检索而创建的一种分散的数据结构。可以把索引类比成书的目录，有目录的肯定比没有目录的书，更方便查找。</li>
<li>唯一约束 保证在一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一约束允许为 NULL，只是只能有一行。</li>
<li>唯一索引 不允许具有索引值相同的行，从而禁止重复的索引或键值。</li>
</ul>
</blockquote>
<p>在mysql 中唯一约束 与 唯一索引 一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 唯一约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> AUTO_INCREMENT  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> <span class="keyword">comment</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> AUTO_INCREMENT  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">TABLE</span>  <span class="string">`t2`</span>  <span class="keyword">ADD</span>  <span class="keyword">UNIQUE</span> (<span class="string">`username`</span> ) ;</span><br></pre></td></tr></table></figure>
<p>查看 ddl t1,t2均为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'非空约束'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'默认为空'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`username`</span> (<span class="string">`username`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</span><br></pre></td></tr></table></figure>

<h5 id="后添加"><a href="#后添加" class="headerlink" title="后添加"></a>后添加</h5><p>mysql提供了两种方式：</p>
<ol>
<li>unique key<br>alter table data_account_table add unique key traceaccount_srctable(traceaccount,srctabname)</li>
<li>unique index<br>alter table data_account_table add unique no_account_index(no,collection_account);</li>
</ol>
<h4 id="非空-not-null"><a href="#非空-not-null" class="headerlink" title="非空(not null)"></a>非空(not null)</h4><p>保证所约束的列必须是不为空的，即在插入记录时，该列必须要赋值，例如：用户注册时，保存的密码不能为空。<br>创建user表, 指定密码不能为空</p>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>外键是用于表和表之间关系的列</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increament  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span> <span class="keyword">comment</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span>,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 库名;</span><br></pre></td></tr></table></figure>

<h2 id="表、字段操作"><a href="#表、字段操作" class="headerlink" title="表、字段操作"></a>表、字段操作</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><ol>
<li>是否需要删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li>创建【推荐】<br>create table 表名 (字段设定列表) default charset=utf8 default collate=utf8_bin; <ul>
<li>字符集：1.若没有显式设置，则自动使用数据库级的配置 ；2.显式设置：在创建表时指定 </li>
<li>字段列表类型：查看下文</li>
<li>成功后，可以使用<code>desc 表名</code>或<code>show create table 表名</code>查看</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>(</span><br><span class="line">   <span class="string">`user_id`</span> <span class="built_in">INT</span>(<span class="number">20</span>) AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`user_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`user_age`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`regist_date`</span> <span class="built_in">DATE</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`user_id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span>=utf8_unicode_ci  <span class="keyword">COMMENT</span> <span class="string">'用户信息表'</span>;</span><br></pre></td></tr></table></figure>


<h3 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure>

<h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> [<span class="keyword">TO</span>|<span class="keyword">AS</span>] 新表名;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure>

<h3 id="表字段操作"><a href="#表字段操作" class="headerlink" title="表字段操作"></a>表字段操作</h3><h4 id="改表-加字段"><a href="#改表-加字段" class="headerlink" title="改表-加字段"></a>改表-加字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">COLUMN</span> new_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="改表-删段名"><a href="#改表-删段名" class="headerlink" title="改表-删段名"></a>改表-删段名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">drop</span> <span class="keyword">column</span> old_name;</span><br></pre></td></tr></table></figure>

<h4 id="改表-改字段名"><a href="#改表-改字段名" class="headerlink" title="改表-改字段名"></a>改表-改字段名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">change</span> <span class="keyword">column</span> old_name new_name <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">comment</span> <span class="string">'注释'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="改表-改字段类型或大小"><a href="#改表-改字段类型或大小" class="headerlink" title="改表-改字段类型或大小"></a>改表-改字段类型或大小</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">modify</span> <span class="keyword">column</span> column1  <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'注释'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>参看：<a href="https://www.cnblogs.com/bjlhx/p/11953939.html" target="_blank" rel="noopener">012-MySQL 索引添加以及优化说明</a></p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>001-mysql-主键设计</title>
    <url>/articles/20200205/dd81f687.html</url>
    <content><![CDATA[<p>摘要：MySQL InnoDB数据存储是以B+树索引方式存储<br>存储单元、mysql InnoDB-B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>

<h1 id="mysql知识储备"><a href="#mysql知识储备" class="headerlink" title="mysql知识储备"></a>mysql知识储备</h1><p>参看：<a href="http://blog.bjlhx.top/categories/db-mysql-core/" target="_blank" rel="noopener">http://blog.bjlhx.top/categories/db-mysql-core/</a></p>
<ol>
<li>InnoDB为聚集主键类型的引擎，数据会按照主键进行排序</li>
<li>mysql 的索引是B+tree，聚集索引使用主键，没有主键默认生成一个隐式主键rowId，辅助索引保存的是主键</li>
<li>innodb 存储单元是页，每页 16k，数据类型过大，会跨页，溢出等</li>
<li>每张表都会有主键，如没有显式设置主键，则<br>（1）、表中的非空唯一索引作为主键<br>（2）、自动创建一个6字节大小的指针</li>
</ol>
<h1 id="主键定义"><a href="#主键定义" class="headerlink" title="主键定义"></a>主键定义</h1><p>表中经常有一个列或多列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。</p>
<h1 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h1><p>总原则：根据数据库表的具体使用范围来决定采用不同的表主键定义。</p>
<p>数据库设计的三大范式</p>
<ul>
<li><p>第一范式（1NF）：指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。<br>即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。</p>
</li>
<li><p>第二范式（2NF）：首先要满足它是1NF，另外还需要包含两部分内容：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。简而言之，第二范式就是非主属性非部分依赖于主关键字</p>
</li>
<li><p>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p>
</li>
</ul>
<p>反范式主键的设计原则</p>
<ul>
<li>主键应当是对用户没有意义的。业务上的‘主键’可以通过唯一键（Unique Key）或唯一索引（Unique Index）和其它约束条件实现</li>
<li>主键应该是单列的，以便提高连接和筛选操作的效率</li>
<li>不要更新主键。实际上，因为主键除了惟一地标识一行之外再没有其他的用途了，所以也就没有理由去对它更新。另外，主键的值通常不重用，意味着记录被删除后，该主键值不再使用</li>
<li>主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等</li>
<li>主键应当由计算机自动生成。</li>
</ul>
<p>反范式跟范式所要求的正好相反，在反范式的设计模式，可以允许适当的数据的冗余，用这个冗余去取操作数据时间的缩短。<br>本质上就是用空间来换取时间，把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联（手册中也有禁止三表以上 JOIN 的条款）。</p>
<p>但需要注意的是，采用代理主键是为了避免业务逻辑变化导致主键变更，以及提高 JOIN 效率等。但在实际查询中，数据查询还是需要通过业务上的唯一键进行匹配的，<br>而不应该将代理主键作为查询条件，尤其不能将代理主键作为查询条件输入项提供给用户。</p>
<p>总体来说，实际应用中应当具体问题具体分析，结合范式和反范式两种设计思想。<br>对数据一致性和完整性较高、而对查询效率要求并不严格的地方，应当更倾向于遵从范式；而类似分布式、高并发集群的场景，则应当更考虑反范式的设计方案。</p>
<h2 id="确保主键的无意义性"><a href="#确保主键的无意义性" class="headerlink" title="确保主键的无意义性"></a>确保主键的无意义性</h2><p>在开发过程中，有意义的字段例如“用户登录信息表”将“登录名”（英文名）作为主键，“订单表”中将“订单编号”作为主键，如此设计主键一般都是没什么问题，因为将这些主键基本不具有“意义更改”的可能性。</p>
<p>但是，也有一些例外的情况，例如“订单表”需要支持需求“订单可以作废，并重新生成订单，而且订单号要保持原订单号一致”，那将“订单编号”作为主键就满足不了要求了。</p>
<p>因此在使用具有实际意义的字段作为主键时，需要考虑是否存在这种可能性。</p>
<p>要用代理主键，不要使用业务主键。任何一张表，强烈建议不要使用有业务含义的字段充当主键。我们通常都是在表中单独添加一个整型的编号充当主键字段。</p>
<h2 id="采用整型主键"><a href="#采用整型主键" class="headerlink" title="采用整型主键"></a>采用整型主键</h2><p>主键通常都是整数，不建议使用字符串当主键。（如果主键是用于集群式服务，可以采用字符串类型）</p>
<h2 id="减少主键的变动"><a href="#减少主键的变动" class="headerlink" title="减少主键的变动"></a>减少主键的变动</h2><p>主键的值通常都不允许修改，除非本记录被删除。</p>
<h2 id="避免重复使用主键"><a href="#避免重复使用主键" class="headerlink" title="避免重复使用主键"></a>避免重复使用主键</h2><p>主键的值通常不重用，意味着记录被删除后，该主键值不再使用。</p>
<h2 id="主键字段定义区分"><a href="#主键字段定义区分" class="headerlink" title="主键字段定义区分"></a>主键字段定义区分</h2><p>主键不要直接定义成【id】，而要加上前缀，定义成【表名id】或者【表名_id】</p>
<h1 id="主键设计的常用方案"><a href="#主键设计的常用方案" class="headerlink" title="主键设计的常用方案"></a>主键设计的常用方案</h1><h2 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h2><ul>
<li><p>方案：数据库设置：AUTO_INCREMENT</p>
</li>
<li><p>使用场景：不拆分库的情况下，推荐使用</p>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利。</li>
<li>数字型，占用空间小，易排序，在程序中传递方便。<br>同样数据量的情况下，自增id主键的数据量是字符串主键的1/2，对于考虑成本的公司来说无疑是一件好事，并且数据量小对备份还原数据都有大大的好处。</li>
<li>Mysql会按照键值的大小进行顺序存放，如果设置自增id为主键，这个时候主键是按照一种紧凑的接近顺序写入的方式进行存储数据。<br>如果用其他字段作为主键的话，此时Mysql不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，<br>此时又要从磁盘上读回来，这增加了很多额外的开销，同时频繁的移动、分页操作造成了大量的碎片。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>不支持水平分片架构，水平分片的设计当中，这种方法显然不能保证全局唯一。</li>
<li>表锁<br>在MySQL5.1.22之前，InnoDB自增值是通过其本身的自增长计数器来获取值，该实现方式是通过表锁机制来完成的（AUTO-INC LOCKING）。<br>锁不是在每次事务完成后释放，而是在完成对自增长值插入的SQL语句后释放，要等待其释放才能进行后续操作。<br>比如说当表里有一个auto_increment字段的时候，innoDB会在内存里保存一个计数器用来记录auto_increment的值，当插入一个新行数据时，<br>就会用一个表锁来锁住这个计数器，直到插入结束。如果大量的并发插入，表锁会引起SQL堵塞。<br>在5.1.22之后，InnoDB为了解决自增主键锁表的问题，引入了参数innodb_autoinc_lock_mode：<br>0：通过表锁的方式进行，也就是所有类型的insert都用AUTO-inc locking（表锁机制）。<br>1：默认值，对于simple insert 自增长值的产生使用互斥量对内存中的计数器进行累加操作，对于bulk insert 则还是使用表锁的方式进行。<br>2：对所有的insert-like 自增长值的产生使用互斥量机制完成，性能最高，并发插入可能导致自增值不连续，可能会导致Statement 的 Replication 出现不一致，使用该模式，需要用 Row Replication的模式。</li>
<li>可能不连续</li>
<li>当系统与其他系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突。</li>
<li>如果其他系统主键不是数字型，会导致修改主键数据类型，导致其他相关表的修改。</li>
</ol>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。在UUID的算法中，可能会用到诸如网卡MAC地址，IP，主机名，进程ID等信息以保证其独立性。</p>
<ul>
<li><p>方案：mysql uuid()函数，应用程序UUID函数</p>
</li>
<li><p>使用场景：不推荐使用，针对mysql缺点过于严重</p>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>全局唯一性、安全性、可移植性。</li>
<li>能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响。</li>
<li>保证生成的ID不仅是表独立的，而且是库独立的，在你切分数据库的时候尤为重要</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>针对InnoDB引擎会徒增IO压力，InnoDB为聚集主键类型的引擎，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力。InnoDB主键索引和数据存储位置相关（簇类索引），uuid 主键可能会引起数据位置频繁变动，严重影响性能。</li>
<li>UUID长度过长，一个UUID占用128个比特（16个字节）。主键索引KeyLength长度过大，而影响能够基于内存的索引记录数量，进而影响基于内存的索引命中率，而基于硬盘进行索引查询性能很差。严重影响数据库服务器整体的性能表现。</li>
</ol>
<h2 id="自建的id生成器"><a href="#自建的id生成器" class="headerlink" title="自建的id生成器"></a>自建的id生成器</h2><p>当数据量比较大，又是分布式架构的时候，可能需要考虑各种分库分表方案了。<br>自建id生成器，可以保证全局唯一，可以参考snowflake的算法（18位）方案，具体实施也可以根据自身业务进行调整算法。其次需要考虑的就是服务的高可用。</p>
<h2 id="业务编号做主键"><a href="#业务编号做主键" class="headerlink" title="业务编号做主键"></a>业务编号做主键</h2><ul>
<li><p>优点<br>此方法就是采用实际业务中的唯一字段的“编号”作为主键设计，这在小型的项目中是推荐这样做的，因为这可以使项目比较简单化，</p>
</li>
<li><p>缺点：<br>但在使用中却可能带来一些麻烦，比如要进行编号修改”时，可能要涉及到很多相关联的其他表，后果很严重”;或“业务要求允许编号重复时”</p>
</li>
</ul>
<h2 id="max加1"><a href="#max加1" class="headerlink" title="max加1"></a>max加1</h2><ul>
<li><p>优点：<br>由于自动编号存在那些问题，采用自己生成，同样是数字型的，只是把自动增长去掉了，采用在Insert时，读取Max值后加一，这种方法可 以避免自动编号的问题，</p>
</li>
<li><p>缺点：<br>但也存在一个效率问题，如果记录非常大的话，那么Max()也会影响效率的;更严重的是并发性问题，如果同时有两人读到相同的Max后，加一后插入的ID值会重复。</p>
</li>
</ul>
<h2 id="自制加一"><a href="#自制加一" class="headerlink" title="自制加一"></a>自制加一</h2><ul>
<li><p>优点：<br>考虑Max加一的效率后，采用自制加一，也就是建一个特别的表，字段为：表名，当前序列值。这样在往表中插入值时，先从此表中找到相应表的最大值后加 一，进行插入，<br>也可能会存在并发处理，这个并发处理，我们可以采用lock线程的方式来避免，在生成此值的时，先Lock，取到值以后，再unLock出来，这样不会有两人同时生成了。<br>这比Max加一的速度要快多了。</p>
</li>
<li><p>缺点：<br>但同样存在一个问题：在与其他系统集成时，脱离了系统中的生成方法后，很麻 烦保证自制表中的最大值与导入后的保持一致，而且数字型都存在老数据的导入问题。<br>因此在“自制加一”中可以把主键设为字符型的。字符型的 自制加一我倒是蛮推荐的，应该字符型主键可以应付很多我们意想不到的情况。</p>
</li>
</ul>
<h1 id="主键的选取建议"><a href="#主键的选取建议" class="headerlink" title="主键的选取建议"></a>主键的选取建议</h1><p>此处的分布式主要指 分库分表。非应用分布式</p>
<ol>
<li><p>非分布式架构直接套用自增id做主键</p>
</li>
<li><p>小规模分布式架构用uuid或者自增id+步长做主键</p>
</li>
<li><p>大规模分布式架构用自建的id生成器做主键，参考twitter的[snowflake算法][2]</p>
</li>
</ol>
<p>（1）单实例或者单节点组：<br>经过500W、1000W的单机表测试，自增ID相对UUID来说，自增ID主键性能高于UUID，磁盘存储费用比UUID节省一半的钱。所以在单实例上或者单节点组上，使用自增ID作为首选主键。</p>
<p>（2）分布式架构场景：<br>20个节点组下的小型规模的分布式场景，为了快速实现部署，可以采用多花存储费用、牺牲部分性能而使用UUID主键快速部署；</p>
<p>20到200个节点组的中等规模的分布式场景，可以采用自增ID+步长的较快速方案。</p>
<p>200以上节点组的大数据下的分布式场景，可以借鉴类似twitter雪花算法构造的全局自增ID作为主键。</p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>11-InnoDB-事务隔离级别、ACID模型</title>
    <url>/articles/20200205/3890ccea.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。<br>理解为：事务对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。</p>
<p>同一行数据会有多个版本，某事务对该数据的修改并不会直接覆盖老版本，而是产生一个新版本和老版共存。<br>然后在该行追加两个虚拟的列，列就是进行数据操作的事务的ID（created_by_txn_id），是一个单调递增的ID；还有一个deleted_by_txn_id，将来用来做删除的。</p>
<p>那么在另一个事务在读取该行数据时，由具体的隔离级别来控制到底读取该行的哪个版本。同时，在读取过程中完全不加锁，除非用select * xxx for update强行加锁。</p>
<p>譬如read committed级别，每次读取，总是取事务ID最大的那个就好了。</p>
<p>对于Repeatable read，每次读取时，总是取事务ID小于等于当前事务的ID的那些数据记录。在这个范围内，如果某一数据有多个版本，则取最新的。</p>
<p>MVCC在mysql中的实现依赖的是undo log与read view</p>
<p>undo log记录某行数据的多个版本的数据；read view用来判断当前版本数据的可见性。</p>
<p>mysql就是用MVCC来实现读写分离不加锁的。</p>
<p>那么MVCC里多出来的那些版本的数据最终是要删除的，支持MVCC的数据库套路一般差不多，都会有一个后台线程来定时清理那些肯定没用的数据。只要一个数据的deleted_by_txn_id不为空，并且比当前还没结束的事务ID最小的一个还小，该数据就可以被清理掉了。在PostgreSQL中，该清理任务叫“vacuum”，在Innodb中，叫做“purge”。</p>
<h1 id="InnoDB-事务隔离级别"><a href="#InnoDB-事务隔离级别" class="headerlink" title="InnoDB 事务隔离级别"></a>InnoDB 事务隔离级别</h1><p>InnoDB的多版本并发控制是基于事务隔离级别实现的，而事务隔离级别则是依托前面提到的 Undo Log 实现的。<br>当读取一个数据记录时，每个事务会使用一个读视图(Read View)，读视图用于控制事务能读取到的记录的版本。</p>
<p>InnoDB的事务隔离级别分为：Read UnCommitted，Read Committed，Repeatable Read以及Serializable。<br>其中Serializable是基于锁实现的串行化方式，严格来说不是事务可见性范畴。</p>
<ul>
<li>Read Uncommitted：未提交读也称为脏读，它读取的是当前最新修改的记录，即便这个修改最后并未生效。</li>
<li>Read Committed：提交读。它基于的是当前事务内的语句开始执行时的最大的事务ID。如果其他事务修改同一个记录，在没有提交前，则该语句读取的记录还是不会变。<br>但是这种情况会产生不可重复读，即一个事务内多次读取同一条记录可能得到不同的结果(该记录被其他事务修改并提交了)。</li>
<li>Repeatable Read：可重复读。它基于的是事务开始时的读视图，直到事务结束。不读取其他新的事务对该记录的修改，保证同一个事务内的可重复读取。<br>InnoDB提供了 next-key lock来解决幻读问题，不过在一些特殊场景下，可重复读还是可能出现幻读的情况。在实际开发中影响不大。</li>
</ul>
<h1 id="ACID-模型"><a href="#ACID-模型" class="headerlink" title="ACID 模型"></a>ACID 模型</h1><p>事务有 ACID 四个属性， InnoDB 是支持事务的，它实现 ACID 的机制如下：</p>
<h2 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h2><p>innodb的原子性主要是通过提供的事务机制实现，与原子性相关的特性有：</p>
<ul>
<li>Autocommit 设置。</li>
<li>COMMIT 和 ROLLBACK 语句(通过 Undo Log实现)。</li>
</ul>
<h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>innodb的一致性主要是指保护数据不受系统崩溃影响，相关特性包括：</p>
<ul>
<li>InnoDB 的双写缓冲区(doublewrite buffer)。</li>
<li>InnoDB 的故障恢复机制(crash recovery)。</li>
</ul>
<h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>innodb的隔离性也是主要通过事务机制实现，特别是为事务提供的多种隔离级别，相关特性包括：</p>
<ul>
<li>Autocommit设置。</li>
<li>SET ISOLATION LEVEL 语句。</li>
<li>InnoDB 锁机制。</li>
</ul>
<h2 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h2><p>innodb的持久性相关特性：</p>
<ul>
<li>Redo log。</li>
<li>双写缓冲功能。可以通过配置项 innodb_doublewrite 开启或者关闭。</li>
<li>配置 innodb_flush_log_at_trx_commit。用于配置innodb如何写入和刷新 redo 日志缓存到磁盘。默认为1，表示每次事务提交都会将日志缓存写入并刷到磁盘。innodb_flush_log_at_timeout 可以配置刷新日志缓存到磁盘的频率，默认是1秒。</li>
<li>配置 sync_binlog。用于设置同步 binlog 到磁盘的频率，为0表示禁止MySQL同步binlog到磁盘，binlog刷到磁盘的频率由操作系统决定，性能最好但是最不安全。为1表示每次事务提交前同步到磁盘，性能最差但是最安全。MySQL文档推荐是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置为 1。</li>
<li>操作系统的 fsync 系统调用。</li>
<li>UPS设备和备份策略等。</li>
</ul>
<p>参考资料<br><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html</a><br><a href="http://ourmysql.com/archives/1228" target="_blank" rel="noopener">http://ourmysql.com/archives/1228</a><br><a href="https://www.jianshu.com/p/d4cc0ea9d097" target="_blank" rel="noopener">https://www.jianshu.com/p/d4cc0ea9d097</a><br><a href="https://zhuanlan.zhihu.com/p/103487968?utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103487968?utm_source=wechat_session</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>10-存储引擎层-innodb框架-内存架构</title>
    <url>/articles/20200205/ddb6eda9.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>


<h1 id="InnoDB-内存中的结构"><a href="#InnoDB-内存中的结构" class="headerlink" title="InnoDB 内存中的结构"></a>InnoDB 内存中的结构</h1><p>参看原理图 03-存储引擎层、InnoDB 架构</p>
<p><img src="/images/post/db-mysql/innodb-struct.webp" alt></p>
<p>内存中的结构主要包括 Buffer Pool，Change Buffer、Adaptive Hash Index以及 Log Buffer 四部分。</p>
<p>如果从内存上来看，Change Buffer 和 Adaptive Hash Index 占用的内存都属于 Buffer Pool，Log Buffer占用的内存与 Buffer Pool独立。</p>
<p>缓冲池缓存的数据包括Page Cache、Change Buffer、Data Dictionary Cache等，通常 MySQL 服务器的 80% 的物理内存会分配给 Buffer Pool。</p>
<p>基于效率考虑，InnoDB中数据管理的最小单位为页，默认每页大小为16KB，每页包含若干行数据。为了提高缓存管理效率，InnoDB的缓存池通过一个页链表实现，很少访问的页会通过缓存池的 LRU 算法淘汰出去。</p>
<p>InnoDB 的缓冲池页链表分为两部分：New sublist(默认占5/8缓存池) 和 Old sublist(默认占3/8缓存池，可以通过 innodb_old_blocks_pct修改，默认值为 37)，</p>
<p>其中新读取的页会加入到 Old sublist的头部，而 Old sublist中的页如果被访问，则会移到 New sublist的头部。</p>
<p>缓冲池的使用情况可以通过 <code>show engine innodb status</code> 命令查看。其中一些主要信息如下：</p>
<p>由于MySQL不同版本采用InnoDB引擎版本不同，5.6后对show engine innodb status信息进行了优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL版本	InnoDB引擎版本</span><br><span class="line">5.1.x	1.0.x版本（官方称为InnoDB Plugin）</span><br><span class="line">5.5.x	5.5（1.1.x版本），InnoDB被Oracle收购后</span><br><span class="line">5.6.x	5.6（1.2.x版本）</span><br><span class="line">5.7.x	5.7</span><br><span class="line">8.0.x	8.0</span><br></pre></td></tr></table></figure>
<p>show engine innodb status显示的不是当前状态，而是过去某个时间范围内InnoDB存储引擎的状态。</p>
<p>向右拉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Per second averages calculated from the last 59 seconds</span><br></pre></td></tr></table></figure>
<p>在显示前端可看到以上信息，代表查询的信息为过去59秒内每2秒的平均值。</p>
<p>show engine innodb status主要包括以下几个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BACKGROUND THREAD	后台Master线程</span><br><span class="line">SEMAPHORES	信号量信息</span><br><span class="line">LATEST DETECTED DEADLOCK	最近一次死锁信息，只有产生过死锁才会有</span><br><span class="line">TRANSACTIONS	事物信息</span><br><span class="line">FILE I&#x2F;O	IO Thread信息</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX	INSERT BUFFER和自适应HASH索引</span><br><span class="line">LOG	日志</span><br><span class="line">BUFFER POOL AND MEMORY	BUFFER POOL和内存</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO	如果设置了多个BUFFER POOL实例，这里显示每个BUFFER POOL信息。可通过innodb_buffer_pool_instances参数设置</span><br><span class="line">ROW OPERATIONS	行操作统计信息</span><br><span class="line">END OF INNODB MONITOR OUTPU	输出结束语</span><br></pre></td></tr></table></figure>

<h2 id="Buffer-pool"><a href="#Buffer-pool" class="headerlink" title="Buffer pool"></a>Buffer pool</h2><p>查看：BUFFER POOL AND MEMORY</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992 # 分配给InnoDB缓存池的内存(字节)</span><br><span class="line">Dictionary memory allocated 102398  # 分配给InnoDB数据字典的内存(字节)</span><br><span class="line">Buffer pool size   8191 # 缓存池的页数目</span><br><span class="line">Free buffers       7893 # 缓存池空闲链表的页数目</span><br><span class="line">Database pages     298  # 缓存池LRU链表的页数目</span><br><span class="line">Modified db pages  0    # 修改过的页数目</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>Innodb的这个缓存区就是Innodb_buffer_pool，当读取数据时，就会先从缓存中查看是否数据的页（page）存在，不存在的话才去磁盘上检索，查到后缓存到这个pool里。<br>同理，插入、修改、删除也是先操作缓存里数据，之后再以一定频率更新到磁盘上。控制刷盘的机制，叫做Checkpoint。</p>
<p><img src="/images/post/db-mysql/innodb_buffer_pool.png" alt></p>
<p>注意，左边那两个不在Innodb_buffer_pool里，是另外一块内存。只不过大部分的内存都属于Innodb_buffer_pool的。</p>
<p>mysql安装后，默认pool的大小是128M，可以通过show variables like ‘innodb_buffer_pool%’;命令查看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer_pool%'</span>;</span><br><span class="line"><span class="comment"># innodb_buffer_pool_dump_at_shutdown	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_dump_now	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_filename	ib_buffer_pool</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_instances	8</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_abort	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_at_startup	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_now	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_size	134217728</span></span><br></pre></td></tr></table></figure>
<p>可以通过show global status like ‘%innodb_buffer_pool_pages%’;  查看已经被占用的和空闲的。共计8000多个page。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%innodb_buffer_pool_pages%'</span>;</span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_data	7167</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_dirty	0</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_flushed	120861</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_free	1024</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_misc	1</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_total	8192</span></span><br></pre></td></tr></table></figure>

<p>所以如果数据很多，而pool很小，那么性能就好不了。</p>
<p>理论上来说，如果你给pool的内存足够大，够装下所有数据，要访问的所有数据都在pool里，那么你的所有请求都是走内存，性能将是最好的，和redis类似。</p>
<p>官方建议pool的空间设置为物理内存的50%-75%。</p>
<p>在mysql5.7.5之后，可以在mysql不重启的情况下动态修改pool的size，如果你设置的pool的size超过了1G的话，应该再修改一下Innodb_buffer_pool_instances=N，将pool分成N个pool实例，将来操作的数据会按照page的hash来映射到不同的pool实例。</p>
<p>这样可以大幅优化多线程情况下，并发读取同一个pool造成的锁的竞争。</p>
<h3 id="缓冲区LRU淘汰算法"><a href="#缓冲区LRU淘汰算法" class="headerlink" title="缓冲区LRU淘汰算法"></a>缓冲区LRU淘汰算法</h3><p>当pool的大小不够用了，满了，就会根据LRU算法（最近最少使用）来淘汰老的页面。最频繁使用的页在LRU列表的前端，最少使用的页在LRU列表的尾端。淘汰的话，就首先释放尾端的页。</p>
<p>InnoDB的LRU和普通的不太一样，Innodb的加入了midpoint位置的概念。最新读取到的页，并不是直接放到LRU列表的头部的，而是放到midpoint位置。<br>这个位置大概是LRU列表的5/8处，该参数由innodb_old_blocks_pct控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_old_blocks_pct%&#39;;</span><br><span class="line">innodb_old_blocks_pct	37</span><br></pre></td></tr></table></figure>
<p>如37是默认值，表示新读取的页插入到LRU尾端37%的位置。在midpoint之后的列表都是old列表，之前的是new列表，可以简单理解为new列表的页都是最活跃的数据。</p>
<p>为什么不直接放头部？因为某些数据扫描操作需要访问的页很多，有时候这些页仅仅在本次查询有效，以后就不怎么用了，并不算是活跃的热点数据。那么真正活跃的还是希望放到头部去，这些新的暂不确定是否真正未来要活跃。所以，这可以理解为预热。还引入了一个参数innodb_old_blocks_time用来表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p>
<p>重要的查询命令可以看到这些信息，show engine innodb status;<br>Database pages表示LRU列表中页的数量，pages made young显示了LRU列表中页移动到前端的次数，Buffer pool hit rate表示缓冲池的命中率，100%表示良好，该值小于95%时，需要考虑是否因为全表扫描引起了LRU列表被污染。里面还有其他的参数，可以自行查阅一下代表什么意思。</p>
<h3 id="Pool的主要空间"><a href="#Pool的主要空间" class="headerlink" title="Pool的主要空间"></a>Pool的主要空间</h3><p>其实更多的、对性能影响更大的是读缓存。毕竟多数数据库是读多写少。</p>
<p>读缓存主要数据是索引页和数据页，如果要读取的数据在pool里没有，那就去磁盘读，读到后的新页放到pool的3/8位置，后续根据情况再决定是否放到LRU列表的头部。</p>
<p>注意，最小单位是页，哪怕只读一条数据，也会加载整个页进去。如果是顺序读的话，刚好又在同一个页里，譬如读了id=1的，那么再读id=2的时，大概率直接从缓存里读。 </p>
<h2 id="BACKGROUND-THREAD"><a href="#BACKGROUND-THREAD" class="headerlink" title="BACKGROUND THREAD"></a>BACKGROUND THREAD</h2><p>InnoDB存储引擎的核心操作大部分都集中在Mater Thread后台线程中。</p>
<p>MySQL5.5版本之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 846676 1_second, 846675 sleeps, 84665 10_second, 17 background, 17 flush</span><br><span class="line">srv_master_thread log flush and writes: 854189</span><br></pre></td></tr></table></figure>
<p>MySQL 5.6之后对Master Thread进行了优化，去除了sleeps的信息，srv_active为之前的每秒的循环，srv_idle为每10秒的的循环，srv_shutdown为停止的循环，通常为0，只在MySQL关闭时才会增加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 3911776 srv_active, 0 srv_shutdown, 309625 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 4221384</span><br></pre></td></tr></table></figure>
<p>上面可以看出主循环每10秒进行了309625次，每秒进行了3911776次，每10秒的操作符合1：10。</p>
<p>负载低的情况下日志缓冲刷盘次数，4221384 ≈ 3911776+309625。</p>
<p>根据循环次数可大概判断当前数据库负载情况。如果每秒循环次数少，每10秒次数多，证明当前负载很低；如果每秒循环次数多，每10秒次数少，远大于10：1，证明当前负载很高。</p>
<h2 id="SEMAPHORES"><a href="#SEMAPHORES" class="headerlink" title="SEMAPHORES"></a>SEMAPHORES</h2><p>当前等待线程的列表及事件计数器，可以评估当前负载情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 58961200</span><br><span class="line">OS WAIT ARRAY INFO: signal count 125268732</span><br><span class="line">Mutex spin waits 770371493, rounds 6482840874, OS waits 20699077</span><br><span class="line">RW-shared spins 0, rounds 115276716, OS waits 14655922</span><br><span class="line">RW-excl spins 0, rounds 987115172, OS waits 12384598</span><br><span class="line">RW-sx spins 40484350, rounds 419545112, OS waits 4476477</span><br><span class="line">Spin rounds per wait: 115276716.00 RW-shared, 987115172.00 RW-excl, 10.36 RW-sx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OS WAIT ARRAY INFO	reservation count：表示InnoDB产生了多少次OS WAIT；</span><br><span class="line">                    signal count：表示进入OS WAIT的线程被唤醒次数</span><br><span class="line">Mutex(5.7后去除)	spins：空转次数，通过innodb_sync_spin_loops控制，超过则转到OS waits；</span><br><span class="line">                spin waits：spin线程无法获取锁而进入Spin wait；</span><br><span class="line">                rounds：spin wait进行轮询检查mutexes的次数；</span><br><span class="line">                OS waits：线程放弃spin wait进入挂起状态。</span><br><span class="line">RW-shared	RW-shared 共享锁</span><br><span class="line">RW-excl	RW-excl 排他锁</span><br><span class="line">RW-sx	5.7后新增；RW-sx 共享排他锁</span><br><span class="line">Spin rounds per wait	rounds &#x2F; spins &#x3D; 值</span><br></pre></td></tr></table></figure>

<p>要明白InnoDB如何处理互斥量(Mutexes)，以及什么是两步获得锁(two-step approach)。</p>
<ol>
<li>首先进程试图获得一个锁，如果此锁被它人占用。它就会执行所谓的spin wait，即所谓循环的查询“锁被释放了吗？”。</li>
<li>如果在循环过程中，一直未得到锁释放的信息，则其转入OS WAIT，即所谓线程进入挂起(suspended)状态。</li>
<li>直到锁被释放后，通过信号(singal)唤醒线程。</li>
</ol>
<p>Spin wait的消耗远小于OSwaits。Spin wait利用cpu的空闲时间，检查锁的状态，OS Wait会有所谓content switch，从CPU内核中换出当前执行线程以供其它线程使用。</p>
<p>所以应尽量减少OS waits，可以通过innodb_sync_spin_loops参数来平衡spin wait和os wait。Mutex信息可通过show engine innodb mutex查看。</p>
<h2 id="LATEST-DETECTED-DEADLOCK"><a href="#LATEST-DETECTED-DEADLOCK" class="headerlink" title="LATEST DETECTED DEADLOCK"></a>LATEST DETECTED DEADLOCK</h2><p>记录最近一次死锁信息，只有产生过死锁才会有记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">190425 18:00:13</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 231E7C5DF, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1248, 3 row lock(s)</span><br><span class="line">MySQL thread id 1346996, OS thread handle 0x7fd968454700, query id 760545285 10.10.x.x app_user updating</span><br><span class="line">DELETE </span><br><span class="line">    FROM db_0.table_0</span><br><span class="line">    WHERE ORDER_ID IN (  456787464 , 456787465 )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DF lock_mode X waiting</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 231E7C5DD, ACTIVE 0 sec starting index read, thread declared inside InnoDB 1</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">5 lock struct(s), heap size 1248, 4 row lock(s)</span><br><span class="line">MySQL thread id 1348165, OS thread handle 0x7fd96669f700, query id 760545283 10.10.x.x app_user updating</span><br><span class="line">DELETE </span><br><span class="line">    FROM db_0.table_0</span><br><span class="line">    WHERE ORDER_ID IN (  456787464 , 456787465 )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DD lock_mode X locks rec but not gap</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;;</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DD lock_mode X waiting</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;;</span><br><span class="line">*** WE ROLL BACK TRANSACTION （1）</span><br></pre></td></tr></table></figure>

<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。正常死锁会自动释放，innodb有一个内在的死锁检测工具，</p>
<p>当死锁超过一定时间后，会回滚其中一个事务，innodb_lock_wait_timeout可配置死锁等待超时时间。</p>
<ul>
<li><p>死锁在两情况下最容易产生：</p>
</li>
<li><p>高并发同时操作同一条数据</p>
</li>
</ul>
<p>存在主键和辅助索引，加锁顺序相反</p>
<p>避免死锁方法即降低并发，操作数据时使加锁顺序相同。  </p>
<h2 id="TRANSACTIONS"><a href="#TRANSACTIONS" class="headerlink" title="TRANSACTIONS"></a>TRANSACTIONS</h2><p>包含了InnoDB事务(transaction)的统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 2409176</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 2409171 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 31</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421224214038352, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421224214044736, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421224214039264, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 2409171, ACTIVE 1549 sec fetching rows, thread declared inside InnoDB 3871</span><br><span class="line">mysql tables in use 1, locked 0</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">MySQL thread id 653597, OS thread handle 140289889908480, query id 2528936 127.0.0.1 root Sending data</span><br><span class="line">SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; * FROM &#96;table&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trx id counter	当前事物ID</span><br><span class="line">Purge done for trx&#39;s	正在清理掉的transaction ID</span><br><span class="line">History list length	记录了undo spaces内未清掉的事务个数，Purge的原则是记录没有被其它事务继续使用。</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION	每个session的事物状态</span><br></pre></td></tr></table></figure>
<p>当前活跃的事物状态为ACTIVE，事物的详细信息，包括线程ID、执行时间、用户、SQL等。正在使用1个表，涉及锁的表0个。</p>
<h2 id="FILE-I-O"><a href="#FILE-I-O" class="headerlink" title="FILE I/O"></a>FILE I/O</h2><p>在InnoDB中大量使用了AIO（Async IO）来处理IO 请求，IO Thread主要是负责这些IO请求的回调处理，通过调用fsync()函数协调内存与磁盘之间的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for completed aio requests (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for completed aio requests (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 10 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 11 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 12 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 13 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 14 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 15 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 16 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 17 state: waiting for completed aio requests (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0, 0, 0, 0, 0] , aio writes: [0, 0, 0, 0, 0, 0, 0, 0] ,</span><br><span class="line">ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">15234061 OS file reads, 304461183 OS file writes, 73899457 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.24 writes&#x2F;s, 0.17 fsyncs&#x2F;s</span><br></pre></td></tr></table></figure>
<p>InnoDB1.0版本之前有4个IO线程，1.1后做了优化，Purge Thread从Master Thread独立出来，Purge Cleaner Thread从InnoDB1.2版本引入，都是为了减轻Master Thread的工作，提高CPU利用率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert buffer thread	合并插入缓冲，insert buffer维护非唯一辅助索引</span><br><span class="line">log thread	负责异步刷新事物日志</span><br><span class="line">read thread	预读，innodb_read_io_threads 默认4</span><br><span class="line">write thread	刷新脏页缓冲，innodb_write_io_threads 默认4</span><br><span class="line">purge thread	回收已经使用并分配的undo页，可设置多个</span><br><span class="line">purge cleaner Thread	刷新脏页</span><br></pre></td></tr></table></figure>
<p>显示各个I/O thread的pending operations,pending的log和buffer pool thread的fsync()调用；</p>
<ul>
<li>aio：代表的是异步IO(asynchronous I/O)；</li>
<li>OS file：显示了reads writes fsync() 调用次数。</li>
</ul>
<h2 id="Change-Buffer-INSERT-BUFFER-AND-ADAPTIVE-HASH-INDEX"><a href="#Change-Buffer-INSERT-BUFFER-AND-ADAPTIVE-HASH-INDEX" class="headerlink" title="(Change Buffer)INSERT BUFFER AND ADAPTIVE HASH INDEX"></a>(Change Buffer)INSERT BUFFER AND ADAPTIVE HASH INDEX</h2><h3 id="插入缓冲insert-buffer"><a href="#插入缓冲insert-buffer" class="headerlink" title="插入缓冲insert buffer"></a>插入缓冲insert buffer</h3><p>它是buffer_pool的一部分，用来做insert操作时的缓存的。</p>
<p>如b+tree，以及数据的存放格式，那么当新插入数据时，倘若直接就插入到b+ tree里，那么可能会比较缓慢，需要读取、找到要插入的地方，还要做树的扩容、校验、寻址、落盘等等一大堆操作。</p>
<p>在Innodb中，主键是行唯一标识，如果你的插入顺序是按照主键递增进行插入的，那么还好，它不需要磁盘的随机读取，找到了页，就能插，这样速度还是可以的。</p>
<p>然而，如果你的表上有多个别的索引（二级索引），那么当插入时，对于那个二级索引树，就不是顺序的了，它需要根据自己的索引列进行排序，这就需要随机读取了。<br>二级索引越多，那么插入就会越慢，因为要寻找的树更多了。还有，如果你频繁地更新同一条数据，倘若也频繁地读写磁盘，那就不合适了，最好是将多个对同一page的操作，合并起来，统一操作。</p>
<p>所以，Innodb设计了Insert Buffer，对于非聚簇索引的插入、更新操作，不是每次都插入到索引页中，而是先判断该二级索引页是否在缓冲池中，<br>若在，就直接插入，若不在，则先插入一个insert buffer里，再以一定的频率进行真正的插入到二级索引的操作，这时就可以聚合多个操作，一起去插入，就能提高性能。</p>
<p>然而，insert buffer需要同时满足两个条件时，才会被使用：</p>
<ul>
<li>索引是二级索引</li>
<li>索引不是unique</li>
</ul>
<p>注意，索引不能是unique，因为在插入缓冲时，数据库并不去查询索引页来判断插入的记录的唯一性，如果查找了，就又会产生随机读取。</p>
<p>insert buffer的问题是，在写密集的情况下，内存会占有很大，默认最大可以占用1/2的Innodb_buffer_pool的空间。<br>很明显，如果占用过大，就会对其他的操作有影响，譬如能缓存的查询页就变少了。可以通过IBUF_POOL_SIZE_PER_MAX_SIZE来进行控制。</p>
<h3 id="变更缓冲change-buffer"><a href="#变更缓冲change-buffer" class="headerlink" title="变更缓冲change buffer"></a>变更缓冲change buffer</h3><p>INSERT BUFFER即合并插入缓存，从innodb 1.0.x(MySQL5.5 之前)版本开始引入Change Buffer，是INSERT BUFFER升级版，即MySQL 5.1.x以上版本都支持，<br>不仅包括INSERT BUFFER，还包括UPDATE BUFFER、DELETE BUFFER、PURGE BUFFER。</p>
<p>也就是所有DML操作，都会先进缓冲区，进行逻辑操作，后面才会真正落地。</p>
<p>通过参数Innodb_change_buffering开始查看修改各种buffer的选项。可选值有inserts\deletes\purges\changes\all\none。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'Innodb_change_buffering%'</span>;</span><br><span class="line"><span class="comment">-- innodb_change_buffering	all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'Innodb_change_buffer_max_size'</span>;</span><br><span class="line"><span class="comment">-- innodb_change_buffer_max_size	25</span></span><br></pre></td></tr></table></figure>
<p>默认是所有操作都入buffer，参数是控制内存大小的，25代表最多使用1/4的缓冲池空间。</p>
<p>通常来说，InnoDB辅助索引不同于聚集索引的顺序插入，如果每次修改二级索引都直接写入磁盘，则会有大量频繁的随机IO。<br>Change buffer 的主要目的是将对 非唯一 辅助索引页的操作缓存下来，以此减少辅助索引的随机IO，并达到操作合并的效果。它会占用部分Buffer Pool 的内存空间。<br>在 MySQL5.5 之前 Change Buffer其实叫 Insert Buffer，最初只支持 insert 操作的缓存，随着支持操作类型的增加，改名为 Change Buffer。<br>如果辅助索引页已经在缓冲区了，则直接修改即可；如果不在，则先将修改保存到 Change Buffer。<br>Change Buffer的数据在对应辅助索引页读取到缓冲区时合并到真正的辅助索引页中。Change Buffer 内部实现也是使用的 B+ 树。</p>
<p>查看Change Buffer信息也可以通过 show engine innodb status 命令。更多信息见 <a href="https://mysqlserverteam.com/the-innodb-change-buffer/" target="_blank" rel="noopener">mysqlserverteam: the-innodb-change-buffer</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1356, free list len 149402, seg size 149404, 2004231 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1373793, delete mark 316276978, delete 5341003</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 2 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">193.03 hash searches&#x2F;s, 713.40 non-hash searches&#x2F;s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ibuf：size	已经合并页的数量</span><br><span class="line">free list len	空闲列表长度</span><br><span class="line">seg size	Insert Buffer大小</span><br><span class="line">merges	合并次数</span><br><span class="line">merged operations 	</span><br><span class="line">                    Change Buffer中每个操作次数；</span><br><span class="line">                    insert代表Insert Buffer;</span><br><span class="line">                    delete mark代表Delete Buffer；</span><br><span class="line">                    delete代表Purge Buffer;</span><br><span class="line">discarded operations	Change Buffer中无需合并的次数</span><br><span class="line">hash searches&#x2F;s	通过hash索引查询</span><br><span class="line">non-hash searches&#x2F;s	不能通过hash索引查询</span><br></pre></td></tr></table></figure>

<p>可以通过 innodb_change_buffering 配置是否缓存辅助索引页的修改，默认为 all，即缓存 insert/delete-mark/purge 操作<br>(注：MySQL 删除数据通常分为两步，第一步是delete-mark，即只标记，而purge才是真正的删除数据)。</p>
<p><img src="/images/post/db-mysql/changebuffer.webp" alt></p>
<h3 id="ADAPTIVE-HASH-INDEX"><a href="#ADAPTIVE-HASH-INDEX" class="headerlink" title="ADAPTIVE HASH INDEX"></a>ADAPTIVE HASH INDEX</h3><p>自适应哈希索引(AHI)查询非常快，一般时间复杂度为 O(1)，相比 B+ 树通常要查询 3~4次，效率会有很大提升。</p>
<p>innodb 通过观察索引页上的查询次数，如果发现建立哈希索引可以提升查询效率，则会自动建立哈希索引，称之为自适应哈希索引，不需要人工干预，可以通过 innodb_adaptive_hash_index 开启，MySQL5.7 默认开启。</p>
<p>考虑到不同系统的差异，有些系统开启自适应哈希索引可能会导致性能提升不明显，而且为监控索引页查询次数增加了多余的性能损耗，</p>
<p> MySQL5.7 更改了 AHI 实现机制，每个 AHI 都分配了专门分区，通过 innodb_adaptive_hash_index_parts配置分区数目，默认是8个，如前一节命令列出所示。</p>
<p>通过(Change Buffer)INSERT BUFFER 可以看到自适应哈希索引大小、使用情况、每秒使用自适应哈希索引搜索情况。<br>自适应HASH索引，由INNODB存储引擎控制，只适合等值查询，不适合范围查询。</p>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><p>事物日志的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 33859450169594</span><br><span class="line">Log flushed up to   33859450169564</span><br><span class="line">Pages flushed up to 33859450169210</span><br><span class="line">Last checkpoint at  33859450169201</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">15044267 log i&#x2F;o&#39;s done, 0.10 log i&#x2F;o&#39;s&#x2F;second</span><br></pre></td></tr></table></figure>
<p>InnoDB事物采用Write-Ahead log策略，即事物在提交时，先写重做日志，在修改页。</p>
<p>Write-Ahead Log：如果一个页在写入磁盘时，必须先将内存中小于该页LSN的日志先写入到磁盘中。</p>
<p>重做日志有LSN、每个页有LSN、Checkpoint也有LSN。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Log sequence number	最新产生的日志序列号</span><br><span class="line">Log flushed up to	已刷到磁盘的重做日志的日志号</span><br><span class="line">Pages flushed up to	已刷到磁盘的页的日志号</span><br><span class="line">Last checkpoint at	最后一次检查点位置，数据和日志一致的状态</span><br><span class="line">pending	当前挂起的日志读写操作</span><br></pre></td></tr></table></figure>
<p>LSN记录的是重做日志的总量，单位是字节。以下三种情况会将重做日志缓存刷到重做日志文件：</p>
<ul>
<li><p>Master Thread 每秒刷重做日志缓存到重做日志文件</p>
</li>
<li><p>innodb_flush_log_at_trx_commit=1时，控制Log Buffer如何写入和刷到磁盘，每次事务提交刷重做日志缓存到重做日志文件</p>
</li>
<li><p>重做日志缓冲池剩余空间小于1/2时，刷重做日志缓存到重做日志文件</p>
</li>
</ul>
<p>innodb_flush_log_at_trx_commit 说明：</p>
<ul>
<li>默认为1，表示每次事务提交都会将 Log Buffer 写入操作系统缓存，并调用配置的 “flush” 方法将数据写到磁盘。设置为 1 因为频繁刷磁盘效率会偏低，但是安全性高，最多丢失 1个 事务数据。而设置为 0 和 2 则可能丢失 1秒以上 的事务数据。</li>
<li>为 0 则表示每秒才将 Log Buffer 写入内核缓冲区并调用 “flush” 方法将数据写到磁盘。</li>
<li>为 2 则是每次事务提交都将 Log Buffer写入内核缓冲区，但是每秒才调用 “flush” 将内核缓冲区的数据刷到磁盘。</li>
</ul>
<p>注意，除了 MySQL 的缓冲区，操作系统本身也有内核缓冲区。</p>
<p>Log Buffer是 重做日志在内存中的缓冲区，大小由 innodb_log_buffer_size 定义，默认是 16M。</p>
<p>一个大的 Log Buffer可以让大事务在提交前不必将日志中途刷到磁盘，可以提高效率。如果你的系统有很多修改很多行记录的大事务，可以增大该值。</p>
<p><img src="/images/post/db-mysql/innodb_flush_log_at_trx_commit.png" alt></p>
<p>innodb_flush_log_at_timeout 可以配置刷新日志缓存到磁盘的频率，默认是1秒。注意刷磁盘的频率并不保证就正好是这个时间，可能因为MySQL的一些操作导致推迟或提前。<br>而这个 “flush” 方法并不是C标准库的 fflush 方法(fflush是将C标准库的缓冲写到内核缓冲区，并不保证刷到磁盘)，它通过 innodb_flush_method 配置的，默认是 fsync，即日志和数据都通过 fsync 系统调用刷到磁盘。</p>
<p>可以发现，InnoDB 基本每秒都会将 Log buffer落盘。而InnoDB中使用的 redo log 和 undo log，它们是分开存储的。<br>redo log在内存中有log buffer，在磁盘对应ib_logfile文件。而undo log是记录在表空间ibd文件中的，InnoDB为undo log会生成undo页，对undo log本身的操作（比如向undo log插入一条记录），也会记录redo log，因此undo log并不需要马上落盘。<br>而 redo log则通常会分配一块连续的磁盘空间，然后先写到log buffer，并每秒刷一次磁盘。redo log必须在数据落盘前先落盘(Write Ahead Log)，从而保证数据持久性和一致性。而数据本身的修改可以先驻留在内存缓冲池中，再根据特定的策略定期刷到磁盘。</p>
<h2 id="BUFFER-POOL-AND-MEMORY"><a href="#BUFFER-POOL-AND-MEMORY" class="headerlink" title="BUFFER POOL AND MEMORY"></a>BUFFER POOL AND MEMORY</h2><p>innodb_buffer_pool包含数据页、索引页、undo页、insert buffer、数据字典、自适应哈希索引、锁信息等。数据库缓冲池是通过LRU列表管理的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 19789774848</span><br><span class="line">Dictionary memory allocated 3944999</span><br><span class="line">Buffer pool size   1179504</span><br><span class="line">Free buffers       8192</span><br><span class="line">Database pages     1116347</span><br><span class="line">Old database pages 411925</span><br><span class="line">Modified db pages  3</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 74514305, not young 649973267</span><br><span class="line">0.21 youngs&#x2F;s, 0.17 non-youngs&#x2F;s</span><br><span class="line">Pages read 15233915, created 7356668, written 264739684</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.10 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 1116347, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[48]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total large memory allocated	为innodb 分配的总内存数(byte)</span><br><span class="line">Dictionary memory allocated	为innodb数据字典分配的内存数(byte)</span><br><span class="line">Buffer pool size	innodb_buffer_pool的页数量</span><br><span class="line">Free buffers	lru列表中的空闲页数量</span><br><span class="line">Database pages	lru列表中的非空闲页数量</span><br><span class="line">Old database pages	old子列表的页数量</span><br><span class="line">Modified db pages	脏页的数量</span><br><span class="line">Pending reads	挂起读的数量</span><br></pre></td></tr></table></figure>
<p>可以看到当前Buffer Pool Size共有1179504页，即1179504*16K。新读取到的页默认插入LRU列表的5/8的位置。</p>
<p>此值由innodb_old_blocks_pct控制，即前5/8称为new list，后面3/8的称为old list。</p>
<p>Pages made young 显示LRU列表中old list移到new list的次数，not young显示仍在old list的次数。</p>
<p>这两个值受innodb_old_blocks_time影响，此值为微秒。如果old list中超过30微秒不再读取，则记录not young，反之记录为Pages made young。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show global variables like &#39;%blocks%&#39;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| innodb_old_blocks_pct  | 37    |</span><br><span class="line">| innodb_old_blocks_time | 30    |</span><br><span class="line">+------------------------+-------+</span><br></pre></td></tr></table></figure>
<p>youngs/s,non-youngs/s，表示每秒这两类操作的次数。</p>
<p>Pages read,created,written，表示innodb被读取，创建，写入了多少页及每秒的次数。</p>
<p>Buffer pool hit rate，表示缓冲池命中率，如果低于95%需要具体排查。</p>
<p>Pages read ahead，表示页面预读，随机预读的每秒页数。</p>
<p>LRU中包含unzip_LRU，unzip_LRU是管理非16KB的压缩表。</p>
<h2 id="INDIVIDUAL-BUFFER-POOL-INFO"><a href="#INDIVIDUAL-BUFFER-POOL-INFO" class="headerlink" title="INDIVIDUAL BUFFER POOL INFO"></a>INDIVIDUAL BUFFER POOL INFO</h2><p>可通过innodb_buffer_pool_instances 来配置多个缓冲池实例，默认为1。可减少数据库内部资源竞争，增加并发处理能力。如果分配多个缓冲池实例，每个缓冲池大小为 innodb_buffer_pool_size / innodb_buffer_pool_instances 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   147438</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     139530</span><br><span class="line">Old database pages 51486</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 8790743, not young 77467460</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 1856892, created 916430, written 30727167</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 139530, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[6]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">---BUFFER POOL 3</span><br></pre></td></tr></table></figure>
<p>可以通过information_schema.INNODB_BUFFER_POOL_STATS视图查看每个buffer_pool实例的信息，MySQL默认一个page大小为16K，</p>
<p>可以得出POOL_SIZE * innodb_buffer_pool_instances * 16K = innodb_buffer_pool_size。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(root@localhost) [information_schema] &gt;select POOL_ID,POOL_SIZE,FREE_BUFFERS,DATABASE_PAGES,OLD_DATABASE_PAGES,MODIFIED_DATABASE_PAGES,PAGES_MADE_YOUNG,PAGES_NOT_MADE_YOUNG from information_schema.INNODB_BUFFER_POOL_STATS;</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br><span class="line">| POOL_ID | POOL_SIZE | FREE_BUFFERS | DATABASE_PAGES | OLD_DATABASE_PAGES | MODIFIED_DATABASE_PAGES | PAGES_MADE_YOUNG | PAGES_NOT_MADE_YOUNG |</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br><span class="line">|       0 |     90112 |            0 |          90109 |              33279 |                       0 |            18064 |            132278807 |</span><br><span class="line">|       1 |     90112 |            0 |          90109 |              33282 |                       0 |            18342 |            132086061 |</span><br><span class="line">|       2 |     90112 |            0 |          90110 |              33282 |                       0 |            17631 |            132149779 |</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br></pre></td></tr></table></figure>
<p>详细说明同上。</p>
<h2 id="ROW-OPERATIONS"><a href="#ROW-OPERATIONS" class="headerlink" title="ROW OPERATIONS"></a>ROW OPERATIONS</h2><p>显示了row 操作及其他一些统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;444943, Main thread ID&#x3D;139899621590784, state: sleeping</span><br><span class="line">Number of rows inserted 172887566, updated 227534242, deleted 56676133, read 709667077</span><br><span class="line">8.77 inserts&#x2F;s, 8.04 updates&#x2F;s, 0.00 deletes&#x2F;s, 10.92 reads&#x2F;s</span><br></pre></td></tr></table></figure>
<p>queries，表示innodb内核中有多少个线程，队列中有多少个线程。</p>
<p>read views open inside InnoDB，表示有多少个read view 被打开，一个read view 包含事物开始点数据库内容的MVCC快照。</p>
<p>Process ID=444943，表示内核的主线程状态。</p>
<p>Number of rows inserted、updated、deleted、read，表示多少行被插入，更新和删除，读取及每秒信息，可用于监控。</p>
<p>可通过以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(root@localhost) [(none)] &gt;show global status like &#39;Innodb_rows_%&#39;;</span><br><span class="line">+----------------------+-----------+</span><br><span class="line">| Variable_name        | Value     |</span><br><span class="line">+----------------------+-----------+</span><br><span class="line">| Innodb_rows_deleted  | 56676133  |</span><br><span class="line">| Innodb_rows_inserted | 172887566 |</span><br><span class="line">| Innodb_rows_read     | 709667077 |</span><br><span class="line">| Innodb_rows_updated  | 227534242 |</span><br><span class="line">+----------------------+-----------+</span><br><span class="line"></span><br><span class="line">(root@localhost) [(none)] &gt;show global status like &#39;Uptime&#39;;</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Variable_name | Value   |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Uptime        | 1757270 |</span><br><span class="line">+---------------+---------+</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB信息结束语。"><a href="#InnoDB信息结束语。" class="headerlink" title="InnoDB信息结束语。"></a>InnoDB信息结束语。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">如果看不到这行输出，可能是有大量事务或者有一个大的死锁截断了输出信息。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>09-存储引擎层-innodb框架-索引-使用B+树组织数据、实例查看数据</title>
    <url>/articles/20200205/190e6be3.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>


<h2 id="mysql-InnoDB-B-树组织数据、查询数据"><a href="#mysql-InnoDB-B-树组织数据、查询数据" class="headerlink" title="mysql InnoDB-B+树组织数据、查询数据"></a>mysql InnoDB-B+树组织数据、查询数据</h2><p>在MySQL中，InnoDB页的大小默认是16k，当然也可以通过参数设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_page_size&#39;;</span><br><span class="line">-- innodb_page_size	16384</span><br></pre></td></tr></table></figure>
<h3 id="方式一、直接按页存储【假想】"><a href="#方式一、直接按页存储【假想】" class="headerlink" title="方式一、直接按页存储【假想】"></a>方式一、直接按页存储【假想】</h3><p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是 1K，那么一个页可以存放 16 行这样的数据。</p>
<p>如果数据库按这样的方式存储，那么查找数据就成为一个问题。不知道要查找的数据存在哪个页中，每次查询都需要把所有的页遍历一遍，时间复杂度为 n。</p>
<h3 id="方式二、用-B-树的方式组织数据【实际】"><a href="#方式二、用-B-树的方式组织数据【实际】" class="headerlink" title="方式二、用 B+ 树的方式组织数据【实际】"></a>方式二、用 B+ 树的方式组织数据【实际】</h3><p>示例一、2层b+ tree</p>
<p><img src="source/images/post/db-mysql/ecengbtree.png" alt></p>
<p>这个树只有2层，首先每个page都有自己的唯一编号，将来就要通过编号来找对应的page。根页做为一个第一层的索引页，里面是不存在叶子数据（行数据）的，只存放Key，同时还包含了pageNo信息，用来将来去找对应的页。</p>
<p>所有的记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接（双向指针）。所以查询时，无论正序倒序，其实是一样的扫描速度。</p>
<p>每一层的最左边节点页面的最左边位置，会有一个Min记录，该记录由2部分组成，第一部分就是一个Min标记，代表这就是 最小值；第二部分是一个pageNo指针，指向下一层中最左边的记录。注意看根页的Min记录，就是这样的。而33号page的Min记录由于没有下一层了，所以没有pageNo指针。</p>
<p>可以看到，上一层的Key，在下一层对应的page中，也会重复存在，譬如Key=10的记录。但是，每个page，只有第一条数据会和上层有重复，其他的不会有重复。</p>
<p>每一个page还会有一个最大记录和最小记录，用来标记该page的边界，便于查询。</p>
<p>由此结构可以看到，做一次查询的耗时，每一层只需要一次内存级的二分查找，定位后就进入下一层，再一次二分查找。</p>
<p>譬如查询Key=11，那么可以定位到56号page，因为11小于78号page的最小值，之后找到56号page，在做一次二分查询。就能找到11。2层只需要2次IO，就能找到一条数据。3层3次，之前已经说过，3层和4层分别能存多少数据，这个查询效率其实是非常高的。</p>
<p>通过这样的方式，我们就知道了一颗树是怎么构成的了。</p>
<p>示例解说：</p>
<ol>
<li>B+树-组织数据<br><img src="/images/post/db-mysql/001/index-01.jpg" alt></li>
</ol>
<p>先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解这里一个页中只存放 3 条记录，实际情况可以存放很多）。</p>
<p>除了存放数据的页以外，还有存放键值+指针的页，如图中 page number=3 的页，该页存放键值和指向数据页的指针，这样的页由 N 个键值+指针组成。</p>
<p>当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。  </p>
<ol start="2">
<li>B+树-查询数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
id 是主键，我们通过这棵 B+ 树来查找，首先找到根页，怎么知道 user 表的根页在哪呢？</li>
</ol>
<p>其实每张表的根页位置在表空间文件中是固定的，即 page number=3 的页（后续说明）。</p>
<p>找到根页后通过二分查找法，定位到 id=5 的数据应该在指针 P5 指向的页中，那么进一步去 page number=5 的页中查找，同样通过二分查询法即可找到 id=5 的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5    zhao2   27</span><br></pre></td></tr></table></figure>
<p>小结：  InnoDB 中主键索引 B+ 树是如何组织数据、查询数据</p>
<p>InnoDB 存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在 B+ 树中叶子节点存放数据，非叶子节点存放键值+指针。</p>
<p>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。</p>
<h3 id="Page内详细结构"><a href="#Page内详细结构" class="headerlink" title="Page内详细结构"></a>Page内详细结构</h3><p><img src="/images/post/db-mysql/page.png" alt></p>
<p>page内的存储，共16K的空间,分为几个部分，文件管理头信息、页面头信息、页面尾信息、最小记录最大记录、用户记录、可重用空间、未使用空间、页面槽信息。</p>
<p>用户记录就是行数据，可重用就是曾经被分配过数据后来被删了，未使用就是没分配过的空间。</p>
<h4 id="文件管理头信息"><a href="#文件管理头信息" class="headerlink" title="文件管理头信息"></a>文件管理头信息</h4><p>它占用38个字节，里面存储的东西主要有:</p>
<ul>
<li>该页面的checkSum信息，校验文件是否被损坏的；</li>
<li>该页面在当前表空间的页面号（pageNo）；</li>
<li>当前页面的上一个页面的pageNo；</li>
<li>下一个页面的pageNo；</li>
<li>当前页面最后一次被修改时，对应日志的LSN值，与后面的日志系统有关；</li>
<li>当前页面的类型；</li>
<li>只有第0号页面会存一个LSN值，用来存储当前Innodb引擎最大的被flush的LSN值，将来做checkPoint时用；</li>
<li>标记属于哪个表空间的（避免多个表空间，有相同的pageNo的页）</li>
</ul>
<h4 id="页面头信息"><a href="#页面头信息" class="headerlink" title="页面头信息"></a>页面头信息</h4><ul>
<li>槽的个数；</li>
<li>未使用空间的指针；</li>
<li>存储的记录数，包括最大最小记录的管理；</li>
<li>已被删除的记录的链表的首指针；</li>
<li>已被标记删除的记录数；</li>
<li>最后被插入的记录的位置；</li>
<li>当前节点在b+ tree处于第几层，叶子就是0，往上就加1；</li>
</ul>
<h4 id="页面尾部："><a href="#页面尾部：" class="headerlink" title="页面尾部："></a>页面尾部：</h4><ul>
<li>这8个字节还是用来做完整性校验的。</li>
</ul>
<h4 id="页面重组"><a href="#页面重组" class="headerlink" title="页面重组"></a>页面重组</h4><p>一个页面会频繁的插入删除，在插入过程中，都会去已经删除的可重用链表去找合适的空间，如果放得下，就会放进去，放不下，另寻空间。<br>时间一长，就会有空间碎片产出，譬如累计的空闲空间还有很多呢，但就是找不到能放下一条新数据的合适空间。</p>
<p>那么带来的问题很明显，page增加，每个page存储数据量下降，磁盘占用很大，但存的数据并不多，IO数增加，性能下降。</p>
<p>如果是一张表的话，如果大量数据被删，就需要及时处理回收空间，可以通过一个空的alter命令，如alter table tablename engine innodb，就可以将表的空间给回收重组了。</p>
<p>对于页面也一样，在数据库向某一个页面插入时，如果找不到大小合适的空间，就会做一次页面重组操作。</p>
<p>重组的方式是，新建一个buffer pool页面，然后将老页面的数据一条一条插入到新页面，插入完成后，将老页面空间释放掉，再修改指针位置，指向新页面。</p>
<h2 id="mysql-InnoDB-B-树存储数据量"><a href="#mysql-InnoDB-B-树存储数据量" class="headerlink" title="mysql InnoDB-B+树存储数据量"></a>mysql InnoDB-B+树存储数据量</h2><h3 id="数据量估算"><a href="#数据量估算" class="headerlink" title="数据量估算"></a>数据量估算</h3><p><strong>以B+ 树高为 2为例计算</strong></p>
<p>假设 B+ 树高为 2，即存在一个根节点和若干个叶子节点，那么这棵 B+ 树的存放总记录数为：根节点指针数*单个叶子节点记录行数。</p>
<p>上文已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为 1K，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。</p>
<p>那么现在需要计算出非叶子节点能存放多少指针？假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。</p>
<p>一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。</p>
<p>可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。</p>
<p>根据同样的原理可以算出一个高度为 3 的 B+ 树可以存放：1170<em>1170</em>16=21902400 条这样的记录。</p>
<p>所以在 InnoDB 中 B+ 树高度一般为 1-3 层，它就能满足千万级的数据存储。</p>
<p>在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。</p>
<h3 id="InnoDB-主键索引-B-树的高度"><a href="#InnoDB-主键索引-B-树的高度" class="headerlink" title="InnoDB 主键索引 B+ 树的高度"></a>InnoDB 主键索引 B+ 树的高度</h3><p>上面通过推断得出 B+ 树的高度通常是 1-3，下面我们从另外一个侧面证明这个结论。</p>
<p>在 InnoDB 的表空间文件中，约定 page number 为 3 的代表主键索引的根页，而在根页偏移量为 64 的地方存放了该 B+ 树的 page level。</p>
<p>如果 page level 为 1，树高为 2，page level 为 2，则树高为 3。即 B+ 树的高度=page level+1；</p>
<p>查询系统表：page level。</p>
<p>在实际操作之前，可以通过 InnoDB 元数据表确认主键索引根页的 page number 为 3，也可以从《InnoDB 存储引擎》这本书中得到确认：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO</span><br><span class="line">FROM</span><br><span class="line">    information_schema.INNODB_SYS_INDEXES a,</span><br><span class="line">    information_schema.INNODB_SYS_TABLES b</span><br><span class="line">WHERE a.table_id &#x3D; b.table_id AND a.space &lt;&gt; 0;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blockchain_manager&#x2F;member	    PRIMARY	    22	3	6	3</span><br><span class="line">blockchain_manager&#x2F;member_group	PRIMARY	    23	3	7	3</span><br><span class="line">blockchain_manager&#x2F;permission	PRIMARY	    24	3	8	3</span><br><span class="line">blockchain_manager&#x2F;permission	idx_group	56	0	8	4</span><br></pre></td></tr></table></figure>
<p>可以看出数据库 blockchain_manager 下的 member 表、member 表、permission表主键索引根页的 page number 均为 3，而其他的二级索引 page number 为 4。</p>
<p>关于二级索引与主键索引的区别请参考 MySQL 相关书籍，</p>
<h2 id="实际操作查看"><a href="#实际操作查看" class="headerlink" title="实际操作查看"></a>实际操作查看</h2><h3 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h3><h4 id="测试表"><a href="#测试表" class="headerlink" title="测试表"></a>测试表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;table5hang&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<p>修改表名，依次创建 table15w、table500w、table1000w</p>
<h4 id="测试数据-添加"><a href="#测试数据-添加" class="headerlink" title="测试数据 添加"></a>测试数据 添加</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter //  <span class="comment">#定义标识符为双斜杠</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_procedure ; <span class="comment">#如果存在 my_procedure 存储过程则删除</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_procedure () <span class="comment">#创建无参存储过程</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> n <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> ; <span class="comment"># 申明变量</span></span><br><span class="line">    <span class="keyword">set</span> @execSql=<span class="string">'insert into table5hang(username,age)  values '</span>;</span><br><span class="line">    <span class="keyword">set</span> @execdata = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    WHILE n &lt; 6 DO</span><br><span class="line">        <span class="keyword">set</span> @execdata=<span class="keyword">concat</span>(@execdata,<span class="string">"("</span>,<span class="string">"'name-"</span>,n,<span class="string">"',"</span>,n%<span class="number">100</span>,<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">        if n%5=0</span><br><span class="line">        then</span><br><span class="line">            <span class="keyword">set</span> @execSql = <span class="keyword">concat</span>(@execSql,@execdata,<span class="string">";"</span>);</span><br><span class="line">            <span class="comment">#select @execSql;</span></span><br><span class="line">            <span class="keyword">prepare</span> stmt <span class="keyword">from</span> @execSql;</span><br><span class="line">            <span class="keyword">execute</span> stmt;</span><br><span class="line">            <span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br><span class="line">            <span class="keyword">commit</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">set</span> @execSql=<span class="string">'insert into table5hang (username,age)  values '</span>;</span><br><span class="line">            <span class="keyword">set</span> @execdata = <span class="string">''</span>;</span><br><span class="line">        ELSE</span><br><span class="line">            <span class="keyword">set</span> @execdata = <span class="keyword">concat</span>(@execdata,<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">SET</span> n = n + <span class="number">1</span> ; <span class="comment">#循环一次,i加一</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span> ; <span class="comment">#结束while循环</span></span><br><span class="line">    <span class="comment">#select count(*) from test_table;</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> my_procedure(); <span class="comment">#调用存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_procedure ; <span class="comment">#如果存在 my_procedure 存储过程则删除</span></span><br></pre></td></tr></table></figure>
<p>插入数据，依次修改表名：table15w、table500w、table1000w 以及插入条数</p>
<p>根据性能 500w、1000w 数据量的需要分批插入。</p>
<p>查看文件结构，mysql每次建库，会在data下创建以库名为名的文件夹，内部文件是表名，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-rw----  1    54B  1 31 11:36 db.opt</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table1000w.frm</span><br><span class="line">-rw-rw----  1   460M  1 31 12:41 table1000w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table15w.frm</span><br><span class="line">-rw-rw----  1    15M  1 31 11:54 table15w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table500w.frm</span><br><span class="line">-rw-rw----  1   236M  1 31 12:19 table500w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:40 table5hang.frm</span><br><span class="line">-rw-rw----  1    96K  1 31 11:51 table5hang.ibd</span><br></pre></td></tr></table></figure>

<p>因为主键索引 B+ 树的根页在整个表空间文件中的第 3 个页开始，所以可以算出它在文件中的偏移量：16384*3=49152（16384 为页大小）。</p>
<p>另外根据《InnoDB 存储引擎》中描述在根页的 64 偏移量位置前 2 个字节，保存了 page level 的值。</p>
<p>因此想要的 page level 的值在整个文件中的偏移量为：16384*3+64=49152+64=49216，前 2 个字节中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -s 49216 -n 10 table5hang.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 00 00 00 00 00 00 00 00 3c                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table15w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 01 00 00 00 00 00 00 00 3b                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table500w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 02 00 00 00 00 00 00 00 3a                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table1000w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 02 00 00 00 00 00 00 00 39                  </span><br><span class="line">000c04a</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>table5hang 表数据行数为 5 条，B+ 树高度为 1，<br>table15w   表数据行数为 15 万，B+ 树高度为 2，<br>table500w  表数据行数为 500 万，B+ 树高度为 3，<br>table1000w 表数据行数为 1000 万，B+ 树高度为 3。</p>
<p>500w、1000w 两个表树的高度都是 3。换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做 3 次 IO。<br>那么如果有一张表行数是一千万，那么他的 B+ 树高度依旧是 3，查询效率仍然不会相差太大。region 表只有 5 行数据，当然他的 B+ 树高度为 1。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">4230000</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1000w <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">4230000</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>08-存储引擎层-innodb框架-索引-树到B+树演变、聚集索引与非聚集索引</title>
    <url>/articles/20200205/4e769343.html</url>
    <content><![CDATA[<p>摘要：从树到B+树解释索引演变过程，聚集索引与非聚集索引</p>
<p>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。</p>
<p>索引在 MySQL 数据库中分三类：</p>
<ul>
<li>B+ 树索引</li>
<li>Hash 索引</li>
<li>全文索引</li>
</ul>
<p>B+ 树索引，由二叉查找树，平衡二叉树和 B 树这三种数据结构 演化来的。</p>
<a id="more"></a>

<h1 id="用树的概念理解mysql数据库"><a href="#用树的概念理解mysql数据库" class="headerlink" title="用树的概念理解mysql数据库"></a>用树的概念理解mysql数据库</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>树的基础：<a href="https://www.cnblogs.com/bjlhx/p/10870875.html" target="_blank" rel="noopener">006-数据结构-树形结构-二叉树、二叉查找树、平衡二叉查找树-AVL树</a></p>
<p>数据库表 对应 二叉查找树</p>
<p><img src="/images/post/db-mysql/002/erchachazhao.jpg" alt></p>
<p>从图中可以看到，为 user 表（用户信息表）建立了一个二叉查找树的索引。</p>
<p>图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。</p>
<p>二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。</p>
<p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p>
<ol>
<li>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来把当前节点&gt;的右子节点作为当前节点。</li>
<li>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</li>
<li>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</li>
</ol>
<p>利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，需要 6 次才能找到。</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>上面利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造【以5为根节点】：</p>
<p><img src="/images/post/db-mysql/002/pinghengerchashu.jpg" alt></p>
<p>可以看到二叉查找树变成了一个链表。如果需要查找 id=17 的用户信息，需要查找 7 次，也就相当于全表扫描了。</p>
<p>导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。</p>
<p>为了解决这个问题，需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树。</p>
<p>平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。</p>
<p>下面是平衡二叉树和非平衡二叉树的对比：</p>
<p><img src="/images/post/db-mysql/002/pinghengerchashu-2.jpg" alt></p>
<p>由平衡二叉树的构造可以发现第一张图中的二叉树其实就是一棵平衡二叉树。</p>
<p>平衡二叉树保证了树的构造是平衡的，当插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式,参看。</p>
<p>平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>因为内存的易失性。一般情况下，都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。</p>
<p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，应当尽量减少从磁盘中读取数据的次数。</p>
<p>另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。</p>
<p>如果能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那查找数据的时间也会大幅度降低。</p>
<p>如果用树这种数据结构作为索引的数据结构，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块。</p>
<p>平衡二叉树是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果要存储海量的数据呢</p>
<p>可以想象到二叉树的节点将会非常多，高度也会极其高，查找数据时也会进行很多次磁盘 IO，查找数据的效率将会极低！</p>
<p><img src="/images/post/db-mysql/002/btree-1.jpg" alt></p>
<p>为了解决平衡二叉树的这个弊端，应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。</p>
<p>B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树：</p>
<p>B树，<a href="https://www.cnblogs.com/bjlhx/p/10898059.html" target="_blank" rel="noopener">参看</a></p>
<p><img src="/images/post/db-mysql/002/btree-2.jpg" alt></p>
<p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有。</p>
<p>图中的每个节点称为页，页就是上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以这里叫做页更符合 MySQL 中索引的底层数据结构。</p>
<p>从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。</p>
<p>基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p>
<p>假如要查找 id=28 的用户信息，那么在上图 B 树中查找的流程如下：</p>
<ul>
<li>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么根据页 1 中的指针 p2 找到页 3。</li>
<li>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，根据页 3 中的指针 p2 找到页 8。</li>
<li>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><a href="https://www.cnblogs.com/bjlhx/p/10898373.html" target="_blank" rel="noopener">参看</a></p>
<p>B+ 树是对 B 树的进一步优化。看下 B+ 树的结构图：</p>
<p><img src="/images/post/db-mysql/002/btree-3.jpg" alt></p>
<p>根据上图看下 B+ 树和 B 树有什么不同：</p>
<p>①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p>
<p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。</p>
<p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p>
<p>另外，B+ 树的阶数是等于键值的数量的，如果 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。</p>
<p>一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p>
<p>②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。</p>
<p>那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p>
<p>上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p>
<p>其实上面的 B 树也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。</p>
<p>也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引。</p>
<p>通过上图可以看到，在 InnoDB 中，通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p>
<p>MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>
<h1 id="mysql聚集索引-VS-非聚集索引"><a href="#mysql聚集索引-VS-非聚集索引" class="headerlink" title="mysql聚集索引 VS 非聚集索引"></a>mysql聚集索引 VS 非聚集索引</h1><p>InnoDB数据文件本身就是索引文件，其索引分聚集索引和辅助索引，聚集索引的叶节点包含了完整的数据记录，辅助索引叶节点数据部分是主键的值，</p>
<p>除了空间索引外，InnoDB的索引实现基本都是 B+ 树，如图所示。</p>
<p>其中非叶子结点存储的是子页的最小的键值和子页的页号，叶子结点存储的是数据，数据按照索引键排序。</p>
<p>同一层的页之间用双向链表连接(前面提到的FIL Header中PREV PAGE 和 NEXT PAGE)，同一页内的记录用单向链表连接(Record Header中记录了下一条记录的偏移)。</p>
<p>每一页设置了两个虚拟记录Infimum和Supremum用于标识页的开始和结束。</p>
<p><img src="/images/post/db-mysql/bptreestruct.webp" alt></p>
<p>在InnoDB中根据辅助索引查询，如果除了主键外还有其他字段，则需要查询两遍，先根据辅助索引查询主键的值，然后再到主索引中查询得到记录。</p>
<p>此外，因为辅助索引的数据部分是主键值，主键不能过大，否则会导致辅助索引占用空间变大，用自增ID做主键是个不错的选择。</p>
<h2 id="聚集索引-VS-非聚集索引-概念"><a href="#聚集索引-VS-非聚集索引-概念" class="headerlink" title="聚集索引 VS 非聚集索引 概念"></a>聚集索引 VS 非聚集索引 概念</h2><p>在上面介绍 B+ 树索引的时候，提到了图中的索引其实是聚集索引的实现方式。</p>
<p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p>
<p>主要说明下 InnoDB 中的聚集索引和非聚集索引：</p>
<p>①聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使不创建主键，系统也会帮你创建一个隐式的主键。</p>
<p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p>
<p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，称之为聚集索引。</p>
<p>②非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p>
<p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，称为回表。</p>
<h2 id="利用聚集索引-和-非聚集索引-查找数据"><a href="#利用聚集索引-和-非聚集索引-查找数据" class="headerlink" title="利用聚集索引 和 非聚集索引 查找数据"></a>利用聚集索引 和 非聚集索引 查找数据</h2><p>聚簇索引和二级索引（非聚簇索引）</p>
<p>二级索引就是手工创建的非聚集索引，可以建多个，建在一个列或者多个列上。这些索引也会构成B+tree，和聚簇索引的区别就是它不需要存每行的详细数据，它的叶子节点只需要存primary key或（rowId）（当然还有主键索引所在磁盘的位置PageNo）。</p>
<p>将来能通过这个索引找到数据行的ID。要查数据时，就根据ID去聚簇索引那棵B+tree去查，这就是回表。</p>
<p>最后，索引是方便查询的，索引列的数据不适合放大的，它占用的空间一多，那么B+tree一层中能放的个数就越少。</p>
<p>索引列一多，插入就越慢，如果没有索引，插入一行时只需要对主键进行排序即可。如果有很多列都有索引，那么插入时，就要做很多次排序,以及多个B+tree的结构变化。</p>
<h3 id="利用聚集索引查找数据"><a href="#利用聚集索引查找数据" class="headerlink" title="利用聚集索引查找数据"></a>利用聚集索引查找数据</h3><p><img src="/images/post/db-mysql/002/btree-3.jpg" alt></p>
<p>聚集索引，表中的数据存储在其中。</p>
<p>现在假设要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">18</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt;<span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>其中 id 为主键，具体的查找过程如下：</p>
<p>①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。</p>
<p>从内存中读取到页 1，要查找这个 id&gt;=18 and id&lt;40 或者范围值，我们首先需要找到 id=18 的键值。</p>
<p>从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。</p>
<p>②要从页 3 中查找数据，需要拿着 p2 指针去磁盘中进行读取页 3。</p>
<p>从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。</p>
<p>③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。</p>
<p>将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。</p>
<p>此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。</p>
<p>因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。</p>
<p>可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。</p>
<p>④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</p>
<p>最终我们找到满足条件的所有数据，总共 12 条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)。</span><br></pre></td></tr></table></figure>
<p>具体的查找流程图：</p>
<p><img src="/images/post/db-mysql/002/jucu-chazhao.jpeg" alt></p>
<h3 id="利用非聚集索引查找数据"><a href="#利用非聚集索引查找数据" class="headerlink" title="利用非聚集索引查找数据"></a>利用非聚集索引查找数据</h3><p>上述表结构 只有主键 和 名称，扩展下表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name    luckyNum</span><br><span class="line">1   zs      23</span><br><span class="line">2   ls      7</span><br></pre></td></tr></table></figure>
<p>使用 luckyNum 建立非聚集索引</p>
<p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。</p>
<p><img src="/images/post/db-mysql/002/feijuji-1.jpeg" alt></p>
<p>如果要找到幸运数字为 33 的用户信息，对应的 sql 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> luckNum=<span class="number">33</span></span><br></pre></td></tr></table></figure>
<p>查找的流程跟聚集索引一样，最终会找到主键值 47，找到主键后,需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。</p>
<p><img src="/images/post/db-mysql/002/feijuji-chazhao.jpeg" alt></p>
<p>在 MyISAM 中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。</p>
<p>因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出）。<br>指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</p>
<p>参看地址：<a href="https://blog.51cto.com/14480698/2451603" target="_blank" rel="noopener">https://blog.51cto.com/14480698/2451603</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>07-存储引擎层-innodb框架-表空间-系统表空间</title>
    <url>/articles/20200205/da9f4def.html</url>
    <content><![CDATA[<p>摘要：系统表空间包含内容有：数据字典，双写缓冲，修改缓冲，undo日志，以及在系统表空间创建的表的数据和索引。</p>
<a id="more"></a>

<h1 id="表空间物理结构-页、区、段"><a href="#表空间物理结构-页、区、段" class="headerlink" title="表空间物理结构-页、区、段"></a>表空间物理结构-页、区、段</h1><p>可以看到，除了分配未使用的页外， UNDO_LOG，SYS, INDEX 页占据了不少的空间。</p>
<p>UNDO_LOG 页存储的是Undo log，SYS 页存储的是数据字典、回滚段、修改缓存等信息，INDEX 是索引页，TRX_SYS 页用于InnoDB的事务系统。</p>
<p>数据字典就是数据表的元信息，修改缓冲前面提到是为了提高IO性能也不再赘述，这里主要分析下 Undo 日志和双写缓冲。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 space-page-type-summary</span><br><span class="line"><span class="built_in">type</span>                count       percent     description         </span><br><span class="line">ALLOCATED           4392        90.30       Freshly allocated   </span><br><span class="line">UNDO_LOG            210         4.32        Undo <span class="built_in">log</span>            </span><br><span class="line">SYS                 141         2.90        System internal     </span><br><span class="line">INDEX               110         2.26        B+Tree index        </span><br><span class="line">INODE               7           0.14        File segment inode  </span><br><span class="line">FSP_HDR             2           0.04        File space header   </span><br><span class="line">TRX_SYS             1           0.02        Transaction system header</span><br><span class="line">IBUF_BITMAP         1           0.02        Insert buffer bitmap</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MySQL的MVCC(多版本并发控制)依赖Undo Log实现</p>
<p>MySQL的表空间文件 *.ibd 存储的是记录最新值，每个记录都有一个回滚指针(见前面图中的Roll Ptr)，指向该记录的最近一条Undo记录，</p>
<p>而每条Undo记录都会指向它的前一条Undo记录，如下图所示。默认情况下 undo log存储在系统表空间 ibdata1 中。</p>
<p>示例<br>这是最初的 插入后的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 -R 127 record-history</span><br><span class="line"><span class="comment"># Transaction   Type                Undo record</span></span><br><span class="line"><span class="comment"># (n/a)         insert              (id=1) → ()</span></span><br><span class="line"><span class="comment"># (base)</span></span><br></pre></td></tr></table></figure>
<p>执行一个更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table5hang <span class="keyword">set</span> age=<span class="number">12</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> table5hang <span class="keyword">set</span> age=<span class="number">13</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>再次查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 -R 127 record-history</span><br><span class="line"><span class="comment"># Transaction   Type                Undo record</span></span><br><span class="line"><span class="comment"># 29910         update_existing     (id=1) → (age=12)</span></span><br><span class="line"><span class="comment"># 29904         update_existing     (id=1) → (age=1)</span></span><br><span class="line"><span class="comment"># (n/a)         insert              (id=1) → ()</span></span><br><span class="line"><span class="comment"># (base)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，Undo Log 在事务执行过程中就会产生，事务提交后才会持久化，如果事务回滚了则Undo Log也会删除。</p>
<p>另外，删除记录并不会立即在表空间中删除该记录，而只是做个标记(delete-mark)，真正的删除则是等由后台运行的 purge 进程处理。</p>
<p>除了每条记录有Undo Log的列表外，整个数据库也会有一个历史列表，purge 进程会根据该历史列表真正删除已经没有再被其他事务使用的 delete-mark 的记录。</p>
<p>purge 进程会删除该记录以及该记录的 Undo Log。</p>
<h2 id="双写缓冲"><a href="#双写缓冲" class="headerlink" title="双写缓冲"></a>双写缓冲</h2><p>InnoDB的记录更新流程：先在Buffer Pool中更新，并将更新记录到 Redo Log 文件中，Buffer Pool中的记录会标记为脏数据并定期刷到磁盘。</p>
<p>由于InnoDB默认Page大小是16KB，而磁盘通常以扇区为单位写入，每次默认只能写入512个字节，无法保证16K数据可以原子的写入。</p>
<p>如果写入过程发生故障(比如机器掉电或者操作系统崩溃)，会出现页的部分写入(partial page writes)，导致难以恢复。</p>
<p>因为 MySQL 的重做日志采用的是物理逻辑日志，即页间是物理信息，而页内是逻辑信息，在发生页部分写入时，无法确认数据页的具体修改而导致难以恢复。</p>
<p>MySQL 的数据页在真正写入到表空间文件前，会先写到系统表空间文件的一段连续区域双写缓冲(Double-Write Buffer，默认大小为 2MB，128个页)并 fsync 落盘，</p>
<p>等双写缓冲写入成功后才会将数据页写到实际表空间的位置。</p>
<p>因为双写缓冲和数据页的写入时机不一致，如果在写入双写缓冲出错，可以直接丢弃该缓冲页，而如果是写入数据页时出错，则可以根据双写缓冲区数据恢复表空间文件。</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>002-cmd-hexdump进制文件查看工具</title>
    <url>/articles/20200203/653046b.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。</p>
<p>指令所在路径：/usr/bin/hexdump</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump: [-bcCdovx] [-e fmt] [-f fmt_file] [-n length] [-s skip] [file ...]</span><br></pre></td></tr></table></figure>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>此命令参数是Red Hat Enterprise Linux Server release 5.7下hexdump命令参数，不同版本Linux的hexdump命令参数有可能不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b              one-byte octal display           8进制显示</span><br><span class="line">-c              one-byte character display       ASCII显示</span><br><span class="line">-C              canonical hex+ASCII display       十六进制+ASCII显示</span><br><span class="line">-d              two-byte decimal display        两字节计算，显示为10进制方式</span><br><span class="line">-o              two-byte octal display         两字节计算，显示为8进制方式</span><br><span class="line">-x              two-byte hexadecimal display    两字节计算，显示为16进制方式</span><br><span class="line">-e format       format string to be used for displaying data   格式化输出</span><br><span class="line">-f format_file  file that contains format strings</span><br><span class="line">-n length       interpret only length bytes of input    输出多少个bytes的字符长度的内容</span><br><span class="line">-s offset       skip offset bytes from the beginning    输出文件的开始偏移量  【注意：偏移量从0开始的！】</span><br><span class="line">-v              display without squeezing similar lines    </span><br><span class="line">-V              output version information and exit</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li>帮助<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li>
<li>案例<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;test.txt</span><br><span class="line">ABCDEF    </span><br><span class="line">GHIJKM</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C test.txt</span><br><span class="line">00000000  41 42 43 44 45 46 0a 47  48 49 4a 4b 4d 0a 31 32  |ABCDEF.GHIJKM.12|</span><br><span class="line">00000010  33 34 35 36 0a                                    |3456.|</span><br><span class="line">00000015</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>跳过 7 个取6个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C -s 7 -n 6 test.txt</span><br><span class="line">00000007  47 48 49 4a 4b 4d                                 |GHIJKM|</span><br><span class="line">0000000d</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-shell-概述与命令行区别</title>
    <url>/articles/20200203/d189e05e.html</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>shell翻译成壳的意思，它是包裹在linux内核外层的，一个可通过一系列的linux命令对操作系统发出相关指令的人机界面。</p>
<p>shell可以通过其条件语句和循环语句等，把一系列linux命令结合在一起，形成一个相当于面向过程的程序，shell script，来实现一些较为复杂的功能。</p>
<p>总括，shell是linux命令集的概称，是属于命令行的人机界面。Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。<br>Shell既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。<br>Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。Shell 和Shell Script不是一回事，通常我们说的都是Shell Script。</p>
<p>由定义可知， shell相当于经过装饰的命令行，和命令行一样，都能操作linux。但是shell是面向过程的，相当于有了一定的逻辑和过程，而命令行只是单一的操作。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol>
<li>直接在命令行执行 就是在当前的shell环境下执行 比如涉及到一些环境变量的时候 必须在当前shell环境里执行</li>
</ol>
<p>在脚本里执行的话 脚本执行的时候 会fork一个子进程 所有操作都在子进程进行 如果涉及到一些在脚本里设置环境变量的东西 脚本结束了 环境变量也就消失了。 </p>
<p>这个修改环境变量的话，需要特别注意下。</p>
<ol start="2">
<li>shell可以重复执行一些命令。也可以把自己要重复执行的命令写到脚本里面执行。而命令行的话就需要一个一个的输入命令，相对而言麻烦一些。</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>06-存储引擎层-innodb框架-表空间-段、区、页与组织结构</title>
    <url>/articles/20200202/12fe7f8a.html</url>
    <content><![CDATA[<p>摘要：InnoDB表空间文件.ibd文件内部存储单元是页，初始大小为 96K，而InnoDB默认页大小为 16K。当然页大小也可以通过 innodb_page_size 配置为 4K, 8K…64K 等。</p>
<p>如果用二进制打开，以16K划分一页。在ibd文件中，0-16KB偏移量即为0号数据页，16KB-32KB的为1号数据页，以此类推。</p>
<a id="more"></a>

<h1 id="表空间物理结构-页、区、段"><a href="#表空间物理结构-页、区、段" class="headerlink" title="表空间物理结构-页、区、段"></a>表空间物理结构-页、区、段</h1><p>磁盘最小单位是512字节，操作系统是4KB，mysql里最小的是page（页面）有16K。</p>
<p>ibd就是放索引树的，但总不能一个树就摊在一个txt文档里，所以必须还要有一种文件组织结构。所有的数据都放在page里，用一种规则来把N个page连一起，让它们形成一些关联，才能便于查询，要先找到page，再找到page内的数据。</p>
<p>B+树是离不开页面page</p>
<p><img src="/images/post/db-mysql/006/tablespace.webp" alt></p>
<h2 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h2><p>段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。</p>
<p>表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。</p>
<p>InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。</p>
<p>创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据（分裂、增长、删除等），叶子段用来管理（存储）B+树叶子节点的数据，负责行数据的相关动作；</p>
<p>也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。一个段包含256个区(256M大小)。</p>
<h2 id="区-簇（extents）"><a href="#区-簇（extents）" class="headerlink" title="区/簇（extents）"></a>区/簇（extents）</h2><p>段是个逻辑概念，innodb引入了簇的概念，在代码中被称为extent；</p>
<p>簇是由64个连续的页组成的，每个页大小为16KB，即每个簇的大小为1MB硬盘空间。即默认大小为 1MB (64*16K)。</p>
<p>簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。</p>
<p>如果存储数据时，即往段里写入数据，就是往簇里写数据，簇是硬盘空间，当一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据，等于又多了一块64*16K的连续硬盘空间。</p>
<p>一个段所管理的空间大小是无限的，可一直扩展下去，但是扩展的最小单位就是簇。注意，每个簇是一块连续的硬盘空间，但多个簇之间可不是连续的。</p>
<p>同样，两个段之间，在硬盘上也没有什么关系。</p>
<h2 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h2><h3 id="页存储单元"><a href="#页存储单元" class="headerlink" title="页存储单元"></a>页存储单元</h3><p>磁盘扇区、文件系统、InnoDB 存储引擎都有各自的最小存储单元。存储数据的最小单位。</p>
<p><img src="/images/post/db-mysql/001/mysql-disk.jpg" alt></p>
<ul>
<li><p>磁盘扇区存储单元-扇区-512字节<br>在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是 512 字节</p>
</li>
<li><p>文件系统存储单元-块-4k<br>文件系统(例如 XFS/EXT4)他的最小单元是块，一个块的大小是 4K。<br>文件系统中一个文件大小只有 1 个字节，但不得不占磁盘上 4KB 的空间。[0k不占空间]<br><img src="/images/post/db-mysql/001/file-0k.jpg" alt>  <img src="/images/post/db-mysql/001/file-1k.jpg" alt></p>
</li>
<li><p>InnoDB存储单元-页-16k<br>InnoDB 存储引擎也有自己的最小储存单元——页(Page)，一个页的大小是 16K。<br>InnoDB 的所有数据文件(后缀为 ibd 的文件)，他的大小始终都是 16384(16K)的整数倍。  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ll |grep ibd </span><br><span class="line">-rw…………    96K 10 31 11:22 innodb_index_stats.ibd</span><br><span class="line">-rw…………    96K 10 31 11:22 innodb_table_stats.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_master_info.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_relay_log_info.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_worker_info.ibd</span><br></pre></td></tr></table></figure>

<p>InnoDB有页（page）的概念，可以理解为簇的细化。页是InnoDB磁盘管理的最小单位。</p>
<h3 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h3><p>所有页的结构都是一样的，分为文件头(前38字节)，页数据和文件尾(后8字节)。页数据根据页的类型不同而不一样。</p>
<p>页的头尾除了一些元信息外，还有Checksum校验值，这些校验值在写入磁盘前计算得到，当从磁盘中读取时，重新计算校验值并与数据页中存储的对比，如果发现不同，则会导致 MySQL 崩溃。</p>
<p><img src="/images/post/db-mysql/page-struct.jpg" alt></p>
<h4 id="File-Header-记录页的一些头信息，共占用38字节，组成部分如"><a href="#File-Header-记录页的一些头信息，共占用38字节，组成部分如" class="headerlink" title="File Header 记录页的一些头信息，共占用38字节，组成部分如:"></a>File Header 记录页的一些头信息，共占用38字节，组成部分如:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_SPACE_OR_CHKSUM	4	当mysql4.0.14之前，值是0，之后该值代表页的checksum值</span><br><span class="line">FIL_PAGE_OFFSET	        4	表空间中页的偏移量。。如某独立表空间a.ibd的大小为1GB，如果页的大小为16KB，那么总共有65536个页。</span><br><span class="line">                            FILE_PAGE_OFFSET表示该页在所有页中的位置。若此表空间的ID为10，那么搜索页（10，1）就表示查找表a中的第二页</span><br><span class="line">FIL_PAGE_PREV	        4	该页的上一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_NEXT	        4	该页的下一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_LSN	        8	该页最后被修改的LSN日志序列位置（Log Sequence Number）</span><br><span class="line">FIL_PAGE_TYPE	        2	该页的类型，0x45BF为数据页,实际行记录的存储空间</span><br><span class="line">FIL_PAGE_FILE_FLUSH_LSN	8	独立表空间中为0，如在系统表空间表示一个页的定义，代表文件至少被更新到了该LSN值</span><br><span class="line">FIL_PAGE_ARCH_LOG_NO	4	从4.1开始，该页属于哪一个表空间</span><br></pre></td></tr></table></figure>

<h5 id="页类型【innodb存储引擎中】"><a href="#页类型【innodb存储引擎中】" class="headerlink" title="页类型【innodb存储引擎中】"></a>页类型【innodb存储引擎中】</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_INDEX          0x45BF  数据页，B+树叶节点，索引页的叶子结点的data就是数据，如聚集索引存储的行数据，辅助索引存储的主键值。</span><br><span class="line">FIL_PAGE_UNDO_LOG	    0x0002  Undo页（Undo Log Page）</span><br><span class="line">FIL_PAGE_INODE	        0x0003  索引节点</span><br><span class="line">FIL_PAGE_IBUF_FREE_LIST 0x0004  插入缓冲空闲列表页（Insert Buffer Free List）</span><br><span class="line">FIL_PAGE_TYPE_ALLOCATED 0x0000  最新分配</span><br><span class="line">FIL_PAGE_IBUF_BITMAP	0x0005  插入缓冲位图页（Insert Buffer Bitmap）。用于记录 change buffer的使用情况。</span><br><span class="line">FIL_PAGE_TYPE_SYS       0x0006  系统页（System Page）</span><br><span class="line">FIL_PAGE_TYPE_TRX_SYS   0x0007  事务数据页（Transaction system Page）</span><br><span class="line">FIL_PAGE_TYPE_FSP_HDR   0x0008  File Space Header，主要用于跟踪表空间，空闲链表、碎片页以及区等信息。</span><br><span class="line">FIL_PAGE_TYPE_XDES      0x0009  扩展描述也</span><br><span class="line">FIL_PAGE_TYPE_BLOB      0x000A  BLOB Page</span><br></pre></td></tr></table></figure>
<ul>
<li><p>FIL_PAGE_INODE：用于记录文件段(FSEG)的信息，每页有85个INODE entry，每个INODE entry占用192字节，用于描述一个文件段。每个INODE entry包括文件段ID、属于该段的区的信息以及碎片页数组。区信息包括 FREE(完全空闲的区), NOT_FULL(至少使用了一个页的区), FULL(没空闲页的区)三种类型的区的List Base Node(包含链表长度和头尾页号和偏移的结构体)。碎片页数组则是不同于分配整个区的单独分配的32个页。</p>
</li>
<li><p>FIL_PAGE_TYPE_FSP_HDR 页：用于存储区的元信息。<br>ibd文件的第一页 FSP_HDR 页通常就用于存储区的元信息，里面的256个 XDES(extent descriptors) 项存储了256个区的元信息，包括区的使用情况和区里面页的使用情况。</p>
<p>更多 参看 附表 </p>
</li>
</ul>
<h4 id="Page-Header：记录数据页的状态信息，共占56个字节，组成部分如图："><a href="#Page-Header：记录数据页的状态信息，共占56个字节，组成部分如图：" class="headerlink" title="Page Header：记录数据页的状态信息，共占56个字节，组成部分如图："></a>Page Header：记录数据页的状态信息，共占56个字节，组成部分如图：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">PAGE_N_DIR_SLOTS	2	在Page Directory中Slot的数量，初始值为2</span><br><span class="line">PAGE_HEAP_TOP	    2	堆中第一个记录的指针,记录在页中是根据堆的形式存放</span><br><span class="line">PAGE_N_HEAP	        2	堆中的记录数，初始值为2，但是第15位表示行记录格式</span><br><span class="line">PAGE_FREE	        2	指向可重用空间的首指针</span><br><span class="line">PAGE_GARBAGE	    2	已标记为删除（deleted_flag）的记录的字节数</span><br><span class="line">PAGE_LAST_INSERT	2	最后插入记录的位置</span><br><span class="line">PAGE_DIRECTION	    2	最后插入的方向，PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0X03),PAGE_SAME_PAGE(0X04),PAGE_NO_DIRECTION(0x05)</span><br><span class="line">PAGE_N_DIRECTION	2	一个方向上连续插入记录的数量</span><br><span class="line">PAGE_N_RECS	        2	该页中记录（User Record）的数量</span><br><span class="line">PAGE_MAX_TRX_ID	    8	修改该页的最大事务ID（仅在辅助索引中定义）</span><br><span class="line">PAGE_LEVEL	        2	该页在索引树中位置，0000代表叶子节点</span><br><span class="line">PAGE_INDEX_ID	    8	索引ID，表示该页属于哪个索引</span><br><span class="line">PAGE_BTR_SEG_LEAF	10	B+Tree叶子节点所在Leaf Node Segment的Segment Header（无关紧要）</span><br><span class="line">PAGE_BTR_SEG_TOP	10	B+Tree非叶子节点所在Non-Leaf Node Segment的Segment Header（无关紧要）</span><br></pre></td></tr></table></figure>

<h4 id="infimum和supermum-record"><a href="#infimum和supermum-record" class="headerlink" title="infimum和supermum record"></a>infimum和supermum record</h4><ul>
<li>每个数据页中都有两个虚拟的行记录，用来限定记录（User Record）的边界（Infimum为下界，Supremum为上界）</li>
<li>Infimum和Supremum在页被创建是自动创建，不会被删除</li>
<li>在Compact和Redundant行记录格式下，Infimum和Supremum占用的字节数是不一样的<br><img src="/images/post/db-mysql/insupermum.jpg" alt></li>
<li>5.1后有Compact（默认）和Redundant两种格式<ul>
<li>Compact行记录格式<br>设计目标为高效存放数据，行数据越多，性能越高。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变长字段长度列表    |   NULL标志位     |   记录头信息   |   列1数据    |   列2数据    |   ……  |</span><br></pre></td></tr></table></figure>
<ul>
<li>变长字段长度列表，按照列的顺序逆序放置。列长度小于255字节，用1字节表示，大于255字节，则用2个字节表示</li>
<li>NULL标志位，一个字节，表示对应列为NULL</li>
<li>记录头信息，5个字节，含义见下表</li>
<li>下面即为数据列，NULL不占用存储空间</li>
<li>每行除了用户定义的列，还有两个隐藏列，事务ID列（6字节）和回滚指针列（7字节），若没有定义主键，每行还会有一个6字节的RowID列<figure class="highlight plain"><figcaption><span>Compact行记录格式</span></figcaption><table><tr><td class="code"><pre><span class="line">名称          大小（bit） 描述</span><br><span class="line">（）          1           未知</span><br><span class="line">（）          1           未知</span><br><span class="line">deleted_flag  1         该行是否被删除</span><br><span class="line">min_rec_flag  1         为1，如果该记录是预先被定义为最小的记录</span><br><span class="line">n_owned       4         该记录拥有的记录数</span><br><span class="line">heap_no       13        索引堆中该条记录的排序记录</span><br><span class="line">record_type   3         记录类型 000&#x3D;普通 001&#x3D;B+树节点指针 010-Infimum 011&#x3D;Supremum 1xx&#x3D;保留</span><br><span class="line">next_recorder 16        页中下一条记录的相对位置</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Redundant行记录格式</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字段长度偏移列表    |   记录头信息   |   列1数据    |   列2数据    |   ……  |</span><br></pre></td></tr></table></figure>
<ul>
<li>字段长度偏移列表，按照列的顺序逆序放置。列长度小于255字节，用1字节表示，大于255字节，则用2个字节表示</li>
<li>记录头信息，固定占用6个字节，含义见下表。n_fields、1byte_offs_flag两个值值得注意</li>
<li>数据列，varchar的NULL值不占用存储空间，但是char值需要占用空间</li>
</ul>
<figure class="highlight plain"><figcaption><span>Compact行记录格式</span></figcaption><table><tr><td class="code"><pre><span class="line">名称          大小（bit） 描述</span><br><span class="line">（）          1           未知</span><br><span class="line">（）          1           未知</span><br><span class="line">deleted_flag  1         该行是否被删除</span><br><span class="line">min_rec_flag  1         为1，如果该记录是预先被定义为最小的记录</span><br><span class="line">n_owned       4         该记录拥有的记录数</span><br><span class="line">heap_no       13        索引堆中该条记录的排序记录</span><br><span class="line">lbyte_offs_flag 1       偏移列表为1字节还是2字节</span><br><span class="line">next_recorder 16        页中下一条记录的相对位置</span><br></pre></td></tr></table></figure>

<h4 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h4><ul>
<li>存储实际插入的行记录</li>
<li>在Page Header中PAGE_HEAP_TOP、PAGE_N_HEAP的HEAP，实际上指的是Unordered User Record List<ul>
<li>InnoDB不想每次都依据B+Tree键的顺序来插入新行，因为这可能需要移动大量的数据</li>
<li>因此InnoDB插入新行时，通常是插入到当前行的后面（Free Space的顶部）或者是已删除行留下来的空间</li>
</ul>
</li>
<li>为了保证访问B+Tree记录的顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表</li>
</ul>
<h4 id="Free-Space"><a href="#Free-Space" class="headerlink" title="Free Space"></a>Free Space</h4><ul>
<li>空闲空间，数据结构是链表，在一个记录被删除后，该空间会被加入到空闲链表中</li>
</ul>
<h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><ul>
<li>存放着行记录（User Record）的相对位置（不是偏移量）</li>
<li>这里的行记录指针称为Slot或Directory Slot，每个Slot占用2Byte</li>
<li>并不是每一个行记录都有一个Slot，一个Slot中可能包含多条行记录，通过行记录中n_owned字段标识</li>
<li>Infimum的n_owned总是1，Supremum的n_owned为[1,8]，User Record的n_owned为[4,8]</li>
<li>Slot是按照索引键值的顺序进行逆序存放（Infimum是下界，Supremum是上界），可以利用二分查找快速地定位一个粗略的结果，然后再通过next_record进行精确查找</li>
<li>B+Tree索引本身并不能直接找到具体的一行记录，只能找到该行记录所在的页<ul>
<li>数据库把页载入到内存中，然后通过Page Directory再进行二分查找</li>
<li>二分查找时间复杂度很低，又在内存中进行查找，这部分的时间基本开销可以忽略</li>
</ul>
</li>
</ul>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><ul>
<li>总共8 Bytes，为了检测页是否已经完整地写入磁盘</li>
<li>变量innodb_checksums，InnoDB从磁盘读取一个页时是否会检测页的完整性</li>
<li>变量innodb_checksum_algorithm，检验和算法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_END_LSN	8	前4Bytes与File Header中的FIL_PAGE_SPACE一致，后4Bytes与File Header中的FIL_PAGE_LSN的后4Bytes一致</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE 'innodb_checksums';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| innodb_checksums | ON    |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'innodb_checksum_algorithm'</span>;</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| innodb_checksum_algorithm | crc32 |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/images/post/db-mysql/index-page-extents1.jpg" alt></p>
<ol>
<li><p>每个簇里有64个页面，都会进行编号，页面就是最小的存储单元了。在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。</p>
</li>
<li><p>在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；</p>
<ul>
<li>一个页面16K，放主键如int型能放几千，放一行数据，如1K一行，能放十几行。</li>
<li>这里需要注意，一行数据尽量不要过大，一旦跨page，就会对性能产生影响。本来一个page就能查出来，结果每次要查2个page，那性能就丢了一倍。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><figcaption><span>官网</span></figcaption><table><tr><td class="code"><pre><span class="line">Pages, Extents, Segments, and Tablespaces</span><br><span class="line"></span><br><span class="line">Each tablespace consists of database pages. Every tablespace in a MySQL instance has the same page size. By default, all tablespaces have a page size of 16KB; you can reduce the page size to 8KB or 4KB by specifying the innodb_page_size option when you create the MySQL instance. You can also increase the page size to 32KB or 64KB. For more information, refer to the innodb_page_sizedocumentation.</span><br><span class="line"></span><br><span class="line">The pages are grouped into extents of size 1MB for pages up to 16KB in size (64 consecutive 16KB pages, or 128 8KB pages, or 256 4KB pages). For a page size of 32KB, extent size is 2MB. For page size of 64KB, extent size is 4MB. The “files” inside a tablespace are called segments in InnoDB. (These segments are different from the rollback segment, which actually contains many tablespace segments.)</span><br><span class="line"></span><br><span class="line">When a segment grows inside the tablespace, InnoDB allocates the first 32 pages to it one at a time. After that, InnoDB starts to allocate whole extents to the segment. InnoDB can add up to 4 extents at a time to a large segment to ensure good sequentiality of data.</span><br><span class="line"></span><br><span class="line">Two segments are allocated for each index in InnoDB. One is for nonleaf nodes of the B-tree, the other is for the leaf nodes. Keeping the leaf nodes contiguous on disk enables better sequential I&#x2F;O operations, because these leaf nodes contain the actual table data.</span><br><span class="line"></span><br><span class="line">Some pages in the tablespace contain bitmaps of other pages, and therefore a few extents in an InnoDB tablespace cannot be allocated to segments as a whole, but only as individual pages.</span><br></pre></td></tr></table></figure>

<h1 id="表空间ibd与页关系"><a href="#表空间ibd与页关系" class="headerlink" title="表空间ibd与页关系"></a>表空间ibd与页关系</h1><p>一个表，占用一个表空间，创建一个表空间时，至少有一个文件（0号文件），这个文件的第一个页面page，page_no=0，这个page中存储了这个表空间中，所有段、簇、页管理的入口。</p>
<p>InnoDB表空间文件.ibd文件内部存储单元是页，初始大小为 96K，而InnoDB默认页大小为 16K。当然页大小也可以通过 innodb_page_size 配置为 4K, 8K…64K 等。</p>
<p>如果用二进制打开，以16K划分一页。在ibd文件中，0-16KB偏移量即为0号数据页，16KB-32KB的为1号数据页，以此类推。</p>
<h2 id="ibd文件存储结构【页】"><a href="#ibd文件存储结构【页】" class="headerlink" title="ibd文件存储结构【页】"></a>ibd文件存储结构【页】</h2><ol>
<li>图形<br><img src="/images/post/db-mysql/ibdfile.webp" alt><br>更为抽象一点的<br><img src="/images/post/db-mysql/index-page-extents2.png" alt></li>
<li>sql查询<br>可以在 innodb_sys_tables 表中查到表t的表空间ID为 36，然后可以在 innodb_buffer_page查到所有页信息，一共4个页。<br>分别是 FSP_HDR, IBUF_BITMAP, INODE, INDEX。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table15w'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_buffer_page <span class="keyword">where</span> <span class="keyword">SPACE</span>=<span class="number">36</span>;</span><br></pre></td></tr></table></figure></li>
<li>实际文件结构：</li>
</ol>
<ul>
<li>第0页是 FSP_HDR 页，主要用于跟踪表空间，空闲链表、碎片页以及区等信息。</li>
<li>第1页是 IBUF_BITMAP 页，保存Change Buffer的位图。</li>
<li>第2页是 INODE 页，用于存储区和单独分配的碎片页信息，包括FULL、FREE、NOT_FULL 等页列表的基础结点信息(基础结点信息记录了列表的起始和结束页号和偏移等)，这些结点指向的是 FSP_HDR 页中的项，用于记录页的使用情况，它们之间关系如下图所示。</li>
<li>第3页开始是索引页 INDEX(B-tree node)，从 0xc000(每页16K) 开始，后面还有些分配的未使用的页。</li>
</ul>
<h1 id="表空间文件ibd-页类型-实操说明"><a href="#表空间文件ibd-页类型-实操说明" class="headerlink" title="表空间文件ibd-页类型-实操说明"></a>表空间文件ibd-页类型-实操说明</h1><h2 id="FSP-HDR-PAGE【File-Space-Header-Page】"><a href="#FSP-HDR-PAGE【File-Space-Header-Page】" class="headerlink" title="FSP_HDR PAGE【File Space Header Page】"></a>FSP_HDR PAGE【File Space Header Page】</h2><p>数据文件.ibd的第一个Page类型为FIL_PAGE_TYPE_FSP_HDR，在创建一个新的表空间时进行初始化(fsp_header_init)，</p>
<p>该page同时用于跟踪随后的256个Extent(约256MB文件大小)的空间管理，所以每隔256MB就要创建一个类似的数据页，类型为FIL_PAGE_TYPE_XDES ，XDES Page除了文件头部外，</p>
<p>其他都和FSP_HDR页具有相同的数据结构，可以称之为Extent描述页，每个Extent占用40个字节，一个XDES Page最多描述256个Extent。</p>
<p>FSP_HDR页的头部使用FSP_HEADER_SIZE个字节来记录文件的相关信息，具体的包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">FSP_SPACE_ID	4	该文件对应的space id</span><br><span class="line">FSP_NOT_USED	4	如其名，保留字节，当前未使用</span><br><span class="line">FSP_SIZE	4	当前表空间总的PAGE个数，扩展文件时需要更新该值（fsp_try_extend_data_file_with_pages）</span><br><span class="line">FSP_FREE_LIMIT	4	当前尚未初始化的最小Page No。从该Page往后的都尚未加入到表空间的FREE LIST上。</span><br><span class="line">FSP_SPACE_FLAGS	4	当前表空间的FLAG信息，见下文</span><br><span class="line">FSP_FRAG_N_USED	4	FSP_FREE_FRAG链表上已被使用的Page数，用于快速计算该链表上可用空闲Page数</span><br><span class="line">FSP_FREE	16	当一个Extent中所有page都未被使用时，放到该链表上，可以用于随后的分配</span><br><span class="line">FSP_FREE_FRAG	16	FREE_FRAG链表的Base Node，通常这样的Extent中的Page可能归属于不同的segment，用于segment frag array page的分配（见下文）</span><br><span class="line">FSP_FULL_FRAG	16	Extent中所有的page都被使用掉时，会放到该链表上，当有Page从该Extent释放时，则移回FREE_FRAG链表</span><br><span class="line">FSP_SEG_ID	8	当前文件中最大Segment ID + 1，用于段分配时的seg id计数器</span><br><span class="line">FSP_SEG_INODES_FULL	16	已被完全用满的Inode Page链表</span><br><span class="line">FSP_SEG_INODES_FREE	16	至少存在一个空闲Inode Entry的Inode Page被放到该链表上</span><br></pre></td></tr></table></figure>
<p>第一页的 前38字节</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C  -n 38 table5hang.ibd</span><br><span class="line">00000000  ff 64 a5 b7 00 00 00 00  00 00 00 00 00 00 00 00  |.d..............|</span><br><span class="line">00000010  00 00 00 00 80 eb 9d 23  00 08 00 00 00 00 00 00  |.......<span class="comment">#........|</span></span><br><span class="line">00000020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00000026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<p>通过 ：File Header 记录页的一些头信息 参看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_SPACE_OR_CHKSUM	4	ff 64 a5 b7：checksum值</span><br><span class="line">FIL_PAGE_OFFSET	        4	00 00 00 00：表空间中页的偏移量</span><br><span class="line">FIL_PAGE_PREV	        4	00 00 00 00：该页的上一个页</span><br><span class="line">FIL_PAGE_NEXT	        4	00 00 00 00：该页的下一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_LSN	        8	00 00 00 00 80 eb 9d 23：该页最后被修改的LSN日志序列位置（Log Sequence Number）</span><br><span class="line">FIL_PAGE_TYPE	        2	00 08：&#x3D; FSP_HDR 该页的类型，</span><br><span class="line">FIL_PAGE_FILE_FLUSH_LSN	8	00 00 00 00 00 00 00 00 ：独立表空间中为0</span><br><span class="line">FIL_PAGE_ARCH_LOG_NO	4	00 00 00 2c：&#x3D;2*16+12&#x3D;44 该页属于哪一个表空间，与上文sql 查询一致</span><br></pre></td></tr></table></figure>

<h2 id="IBUF-BITMAP-Page"><a href="#IBUF-BITMAP-Page" class="headerlink" title="IBUF_BITMAP Page"></a>IBUF_BITMAP Page</h2><p>第2个page类型为FIL_PAGE_IBUF_BITMAP，主要用于跟踪随后的每个page的change buffer信息，使用4个bit来描述每个page的change buffer信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">IBUF_BITMAP_FREE	2	使用2个bit来描述page的空闲空间范围：0（0 bytes）、1（512 bytes）、2（1024 bytes）、3（2048 bytes）</span><br><span class="line">IBUF_BITMAP_BUFFERED	1	是否有ibuf操作缓存</span><br><span class="line">IBUF_BITMAP_IBUF	1	该Page本身是否是Ibuf Btree的节点</span><br></pre></td></tr></table></figure>
<p>由于bitmap page的空间有限，同样每隔256个Extent Page之后，也会在XDES PAGE之后创建一个ibuf bitmap page。</p>
<p>offsets:16<em>1024</em>1=16384</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 16384 -n 38 table5hang.ibd</span><br><span class="line">00004000  a0 58 07 7e 00 00 00 01  00 00 00 00 00 00 00 00  |.X.~............|</span><br><span class="line">00004010  00 00 00 00 80 eb 93 80  00 05 00 00 00 00 00 00  |................|</span><br><span class="line">00004020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00004026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前 38也是  File Header<br>00 05 : FIL_PAGE_IBUF_BITMAP    0x0005  插入缓冲位图页（Insert Buffer Bitmap）。用于记录 change buffer的使用情况。 </p>
<h2 id="FIL-PAGE-INODE"><a href="#FIL-PAGE-INODE" class="headerlink" title="FIL_PAGE_INODE"></a>FIL_PAGE_INODE</h2><p>数据文件的第3个page的类型为FIL_PAGE_INODE，用于管理数据文件中的segement，每个索引占用2个segment，分别用于管理叶子节点和非叶子节点。</p>
<p>每个inode页可以存储FSP_SEG_INODES_PER_PAGE（默认为85）个记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_INODE_PAGE_NODE	12	INODE页的链表节点，记录前后Inode Page的位置，BaseNode记录在头Page的FSP_SEG_INODES_FULL或者FSP_SEG_INODES_FREE字段。</span><br><span class="line">Inode Entry 0	192	Inode记录</span><br><span class="line">Inode Entry 1	 	 </span><br><span class="line">……	 	 </span><br><span class="line">Inode Entry 84</span><br></pre></td></tr></table></figure>
<p>每个Inode Entry的结构如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_ID	8	该Inode归属的Segment ID，若值为0表示该slot未被使用</span><br><span class="line">FSEG_NOT_FULL_N_USED	8	FSEG_NOT_FULL链表上被使用的Page数量</span><br><span class="line">FSEG_FREE	16	完全没有被使用并分配给该Segment的Extent链表</span><br><span class="line">FSEG_NOT_FULL	16	至少有一个page分配给当前Segment的Extent链表，全部用完时，转移到FSEG_FULL上，全部释放时，则归还给当前表空间FSP_FREE链表</span><br><span class="line">FSEG_FULL	16	分配给当前segment且Page完全使用完的Extent链表</span><br><span class="line">FSEG_MAGIC_N	4	Magic Number</span><br><span class="line">FSEG_FRAG_ARR 0	4	属于该Segment的独立Page。总是先从全局分配独立的Page，当填满32个数组项时，就在每次分配时都分配一个完整的Extent，并在XDES PAGE中将其Segment ID设置为当前值</span><br><span class="line">……	……	 </span><br><span class="line">FSEG_FRAG_ARR 31	4	总共存储32个记录项</span><br></pre></td></tr></table></figure>

<p>offsets:16<em>1024</em>2=32768</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 32768 -n 38 table5hang.ibd</span><br><span class="line">00008000  86 d5 41 60 00 00 00 02  00 00 00 00 00 00 00 00  |..A ............|</span><br><span class="line">00008010  00 00 00 00 80 eb 9d 23  00 03 00 00 00 00 00 00  |.......<span class="comment">#........|</span></span><br><span class="line">00008020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00008026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前 38也是  File Header<br>00 03 : 索引节点 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_INODE_PAGE_NODE	12	INODE页的链表节点，记录前后Inode Page的位置，BaseNode记录在头Page的FSP_SEG_INODES_FULL或者FSP_SEG_INODES_FREE字段。</span><br><span class="line">Inode Entry 0	192	Inode记录</span><br><span class="line">Inode Entry 1	 	 </span><br><span class="line">……	 	 </span><br><span class="line">Inode Entry 84</span><br></pre></td></tr></table></figure>
<p>每个Inode Entry的结构如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_ID	8	该Inode归属的Segment ID，若值为0表示该slot未被使用</span><br><span class="line">FSEG_NOT_FULL_N_USED	8	FSEG_NOT_FULL链表上被使用的Page数量</span><br><span class="line">FSEG_FREE	16	完全没有被使用并分配给该Segment的Extent链表</span><br><span class="line">FSEG_NOT_FULL	16	至少有一个page分配给当前Segment的Extent链表，全部用完时，转移到FSEG_FULL上，全部释放时，则归还给当前表空间FSP_FREE链表</span><br><span class="line">FSEG_FULL	16	分配给当前segment且Page完全使用完的Extent链表</span><br><span class="line">FSEG_MAGIC_N	4	Magic Number</span><br><span class="line">FSEG_FRAG_ARR 0	4	属于该Segment的独立Page。总是先从全局分配独立的Page，当填满32个数组项时，就在每次分配时都分配一个完整的Extent，并在XDES PAGE中将其Segment ID设置为当前值</span><br><span class="line">……	……	 </span><br><span class="line">FSEG_FRAG_ARR 31	4	总共存储32个记录项</span><br></pre></td></tr></table></figure>


<h2 id="Index-索引页"><a href="#Index-索引页" class="headerlink" title="Index 索引页"></a>Index 索引页</h2><p>需要跳过3页面，即 49152，索引页 结构也符合基础页结构。</p>
<p><img src="/images/post/db-mysql/index-struct.webp" alt></p>
<p>同上述步骤类似</p>
<h3 id="FIL-Header（38字节-记录文件头信息。"><a href="#FIL-Header（38字节-记录文件头信息。" class="headerlink" title="FIL Header（38字节): 记录文件头信息。"></a>FIL Header（38字节): 记录文件头信息。</h3><p>offsets:16<em>1024</em>3=49152</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49152 -n 38 table5hang.ibd</span><br><span class="line">0000c000  3b 03 ff eb 00 00 00 03  ff ff ff ff ff ff ff ff  |;...............|</span><br><span class="line">0000c010  00 00 00 00 80 eb af c9  45 bf 00 00 00 00 00 00  |........E.......|</span><br><span class="line">0000c020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">0000c026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前4字节 3b 03 ff eb 是 checksum，接着4个 00 00 00 03 是页偏移值 3，即这是第2+1页。【数组下标方式，这是真实的第四页】</p>
<p>接着 4 字节是上一页偏移值，ff ff ff ff 第一个数据页 无上一页，接着 4 字节是下一页偏移值 ff ff ff ff 无下一页。</p>
<p>然后 8 字节 00 00 00 00 80 eb af c9 是日志序列号 LSN。</p>
<p>随后的 2 字节 45 bf 是页类型，代表是 INDEX 页。</p>
<p>接着 8 字节 00 00 00 00 00 00 00 00 表示被更新到的LSN，在 File-Per-Table 表空间中都是0。</p>
<p>然后 4 字节 00 00 00 2c 表示该数据页属于的表t的表空间ID是 0x2c(44)。 与上文sql 查询一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table5hang'</span></span><br></pre></td></tr></table></figure>

<h3 id="PageHeader-INDEX-Header（56字节-记录的是-INDEX-页的状态信息"><a href="#PageHeader-INDEX-Header（56字节-记录的是-INDEX-页的状态信息" class="headerlink" title="PageHeader-INDEX Header（56字节): 记录的是 INDEX 页的状态信息"></a>PageHeader-INDEX Header（56字节): 记录的是 INDEX 页的状态信息</h3><p>offsets:16<em>1024</em>3+38=49190</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49190 -n 56 table5hang.ibd</span><br><span class="line">0000c026  00 02 01 36 80 07 00 00  00 00 01 17 00 02 00 04  |...6............|</span><br><span class="line">0000c036  00 05 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">0000c046  00 00 00 3c 00 00 00 2c  00 00 00 02 00 f2 00 00  |...&lt;...,........|</span><br><span class="line">0000c056  00 2c 00 00 00 02 00 32                           |.,.....2|</span><br><span class="line">0000c05e</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">PAGE_N_DIR_SLOTS	2	00 02：在Page Directory中Slot的数量，初始值为2</span><br><span class="line">PAGE_HEAP_TOP	    2	01 36：堆中第一个记录的指针,记录在页中是根据堆的形式存放</span><br><span class="line">PAGE_N_HEAP	        2	80 07：堆中的记录数，初始值为2，但是第15位表示行记录格式</span><br><span class="line">PAGE_FREE	        2	00 00：指向可重用空间的首指针</span><br><span class="line">PAGE_GARBAGE	    2	00 00：已标记为删除（deleted_flag）的记录的字节数</span><br><span class="line">PAGE_LAST_INSERT	2	01 17：最后插入记录的位置</span><br><span class="line">PAGE_DIRECTION	    2	00 02：最后插入的方向，PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0X03),PAGE_SAME_PAGE(0X04),PAGE_NO_DIRECTION(0x05)</span><br><span class="line">PAGE_N_DIRECTION	2	00 04：一个方向上连续插入记录的数量</span><br><span class="line">PAGE_N_RECS	        2	00 05：该页中记录（User Record）的数量</span><br><span class="line">PAGE_MAX_TRX_ID	    8	00 00 00 00 00 00  00 00：修改该页的最大事务ID（仅在辅助索引中定义）</span><br><span class="line">PAGE_LEVEL	        2	00 00：该页在索引树中位置，0000代表叶子节点</span><br><span class="line">PAGE_INDEX_ID	    8	00 00 00 00 00 00 00 3c：索引ID，表示该页属于哪个索引</span><br><span class="line">PAGE_BTR_SEG_LEAF	10	00 00 00 2c 00 00 00 02 00 f2：B+Tree叶子节点所在Leaf Node Segment的Segment Header（无关紧要）</span><br><span class="line">PAGE_BTR_SEG_TOP	10	00 00 00 2c 00 00 00 02 00 32：B+Tree非叶子节点所在Non-Leaf Node Segment的Segment Header（无关紧要）</span><br></pre></td></tr></table></figure>
<p>PAGE_INDEX_ID = 3c =3*16+12=60  索引ID可以在information_schema.INNODB_SYS_INDEXES 中查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.INNODB_SYS_INDEXES </span><br><span class="line"><span class="keyword">where</span> TABLE_ID <span class="keyword">in</span> (<span class="keyword">SELECT</span> TABLE_ID <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table5hang'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index_id    name    table_id    type    n_fields    page_no space</span><br><span class="line">60          PRIMARY 58          3       1           3       44</span><br></pre></td></tr></table></figure>

<p>PAGE_BTR_SEG_LEAF和PAGE_BTR_SEG_TOP INDEX页中的根结点才有的，非根结点的为0。<br>前10字节 00 00 00 2c 00 00 00 02 00 f2 是叶子结点所在段的segment header，分别记录了叶子结点的表空间ID 0x24，INODE页的页号 2 和 INODE项偏移 0xf2。<br>后10字节 00 00 00 2c 00 00 00 02 00 32 是非叶子结点所在段的segment header，偏移分别是0xf2 和 0x32，即INODE页的前2个Entry，文件段ID分别是1和2。<br>FSEG Header中存储了该 INDEX 页的INODE项，INODE项里面则记录了该页存储所在的文件段以及文件段页的使用情况。对于 File-Per-Table情况下，每个单独的表空间文件的 FSP_HDR 页负责管理页使用情况。</p>
<p><img src="/images/post/db-mysql/fseg.webp" alt></p>
<h3 id="System-Records-26字节-infimum和supermum-record"><a href="#System-Records-26字节-infimum和supermum-record" class="headerlink" title="System Records(26字节)-infimum和supermum record"></a>System Records(26字节)-infimum和supermum record</h3><p>offset:16<em>1024</em>3+38+56 = 49246</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49246 -n 60 table5hang.ibd</span><br><span class="line">0000c05e  01 00 02 00 1c 69 6e 66  69 6d 75 6d 00 06 00 0b  |.....infimum....|</span><br><span class="line">0000c06e  00 00 73 75 70 72 65 6d  75 6d 06 00 00 00 10 00  |..supremum......|</span><br><span class="line">0000c07e  26 80 00 00 00 00 00 00  01 00 00 00 00 74 d0 9e  |&amp;............t..|</span><br><span class="line">0000c08e  00 00 01 57 01 10 6e 61  6d 65 2d 31              |...W..name-1|</span><br><span class="line">0000c09a</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 00 02 00 1c 69 6e 66 69 6d 75 6d 00 |.....infimum....|</span><br><span class="line">06 00 0b 00 00 73 75 70 72 65 6d 75 6d |..supremum......|</span><br></pre></td></tr></table></figure>
<p>每个 INDEX 页都有两条虚拟记录 infimum 和 supremum，用于限定记录的边界，各占 13 个字节。<br>其中记录头的5个字节分别标识了拥有记录的数目和类型(拥有记录数目是即后面页目录部分的owned值，当前页目录只有两个槽，infimum拥有记录数只有它自己为1，<br>而supremum拥有我们插入的5条记录和它自己，故为6)、下一条记录的偏移 0x1c=28 向后【当前位置】偏移 28个，即位置是 0xC062+0x1c=0xc07e 的后一个 0xco7f，这就是我们实际数据记录开始位置。<br>后面8个字节为 infimum + 空值，supremum类似，只是它下一条记录偏移为0。</p>
<h3 id="User-Records-1"><a href="#User-Records-1" class="headerlink" title="User Records"></a>User Records</h3><p>offset:16<em>1024</em>3+38+56 +26 = 49272</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49272 -n 1000 table5hang.ibd</span><br><span class="line">0000c078  06 00 00 00 10 00 26 80  00 00 00 00 00 00 01 00  |......&amp;.........|</span><br><span class="line">0000c088  00 00 00 74 d0 9e 00 00  01 57 01 10 6e 61 6d 65  |...t.....W..name|</span><br><span class="line">0000c098  2d 31 80 00 00 01 06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line">0000c0a8  00 00 00 00 02 00 00 00  00 74 d0 9e 00 00 01 57  |.........t.....W|</span><br><span class="line">0000c0b8  01 20 6e 61 6d 65 2d 32  80 00 00 02 06 00 00 00  |. name-2........|</span><br><span class="line">0000c0c8  20 00 26 80 00 00 00 00  00 00 03 00 00 00 00 74  | .&amp;............t|</span><br><span class="line">0000c0d8  d0 9e 00 00 01 57 01 30  6e 61 6d 65 2d 33 80 00  |.....W.0name-3..|</span><br><span class="line">0000c0e8  00 03 06 00 00 00 28 00  26 80 00 00 00 00 00 00  |......(.&amp;.......|</span><br><span class="line">0000c0f8  04 00 00 00 00 74 d0 9e  00 00 01 57 01 40 6e 61  |.....t.....W.@na|</span><br><span class="line">0000c108  6d 65 2d 34 80 00 00 04  06 00 00 00 30 ff 59 80  |me-4........0.Y.|</span><br><span class="line">0000c118  00 00 00 00 00 00 05 00  00 00 00 74 d0 9e 00 00  |...........t....|</span><br><span class="line">0000c128  01 57 01 50 6e 61 6d 65  2d 35 80 00 00 05 00 00  |.W.Pname-5......|</span><br><span class="line">0000c138  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">0000c458  00 00 00 00 00 00 00 00                           |........|</span><br><span class="line">0000c460</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>查看 行记录格式 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">from</span> test_innodb <span class="keyword">like</span> <span class="string">'table5hang'</span></span><br><span class="line"><span class="comment">--- Compact</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接下来是插入的记录。Compact 【变长字段长度列表 小于255 1字节，大于 255 2】</span><br><span class="line">06  1字节记录的是可变变量的长度06，因为我们记录中c的值是 name-5。</span><br><span class="line">00  1字节记录的是可为NULL的变量是否是NULL，这里不为 NULL，故为0。</span><br><span class="line">记录头：00 00 10 00 26</span><br><span class="line">    Compact行记录格式 头格式</span><br><span class="line">    00  </span><br><span class="line">    00 10 &#x3D; 10110</span><br><span class="line">    00 26 &#x3D; 下一记录相对位置</span><br><span class="line">    后面就是记录内容。第2条记录同理。这里的事务ID可以通过 select * from information_schema.innodb_trx 进行验证。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line">0000c078  06 00 00 00 10 00 26 80  00 00 00 00 00 00 01 00  |......&amp;.........|</span><br><span class="line">0000c088  00 00 00 74 d0 9e 00 00  01 57 01 10 6e 61 6d 65  |...t.....W..name|</span><br><span class="line">0000c098  2d 31 80 00 00 01 06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line"></span><br><span class="line"> 06 00 00 00 10 00 26 # 列长+null标记+记录头</span><br><span class="line"> 80 00 00 00 00 00 00 01   # 主键值1  bigint</span><br><span class="line"> 00 00 00 00 74 d0    # 事务ID</span><br><span class="line"> 9e 00 00 01 57 01 10 # 回滚指针</span><br><span class="line"> 6e 61 6d 65 2d 31    # username的值 name-1  6个字节</span><br><span class="line"> 80 00 00 01          # 列 age &#x3D;1  int 4字节</span><br><span class="line"> </span><br><span class="line">第二行</span><br><span class="line">                            06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line">0000c0a8  00 00 00 00 02 00 00 00  00 74 d0 9e 00 00 01 57  |.........t.....W|</span><br><span class="line">0000c0b8  01 20 6e 61 6d 65 2d 32  80 00 00 02 06 00 00 00  |. name-2........|</span><br><span class="line"></span><br><span class="line"> 06 00 00 00 18 00 26 # 第2条记录头</span><br><span class="line"> 80 00 00 00 00 00 00 02   # 主键值1  bigint</span><br><span class="line"> 00 00 00 00 74 d0    # 事务ID</span><br><span class="line"> 9e 00 00 01 57 01 20 # 回滚指针</span><br><span class="line"> 6e 61 6d 65 2d 32    # username的值 name-1  6个字节</span><br><span class="line"> 80 00 00 01          # 列 age &#x3D;1  int 4字节</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">![](&#x2F;images&#x2F;post&#x2F;db-mysql&#x2F;bptree.webp)</span><br><span class="line"></span><br><span class="line">### Page Directory(4字节)</span><br><span class="line"></span><br><span class="line">因为页目录的slot只有2个，每个slot占2字节，故页目录为 00 70 00 63 这4字节，存储的是相对于最初行的位置。</span><br><span class="line"></span><br><span class="line">其中 0xc063 正好是 infimum 记录的开始位置，而 0xc070 正好是 supremum 记录的开始位置。使用页目录进行二分查找，可以加速查询，详细见后面分析。</span><br><span class="line"></span><br><span class="line">offset:16*1024*4 - 4 - 8 &#x3D; 65524</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">hexdump -C -s 65524 -n 4 table5hang.ibd</span><br><span class="line">0000fff4  00 70 00 63                                       |.p.c|</span><br><span class="line">0000fff8</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<h3 id="FIL-Tail-8字节"><a href="#FIL-Tail-8字节" class="headerlink" title="FIL Tail (8字节)"></a>FIL Tail (8字节)</h3><p>offset:16<em>1024</em>4 - 8 = 65528</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 65528 -n 8 table5hang.ibd</span><br><span class="line">0000fff8  bd 11 4b e6 80 eb af c9                           |..K.....|</span><br><span class="line">00010000</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>其中 bd 11 4b e6 为 checknum，跟 FIL Header的checksum一样。【没有匹配上，需要继续查看资料】</p>
<p>后4字节80 eb af c9 与 FIL Header的LSN的后4个字节一致。</p>
<h2 id="通过-innodb-ruby-工具来分析表空间文件"><a href="#通过-innodb-ruby-工具来分析表空间文件" class="headerlink" title="通过 innodb_ruby 工具来分析表空间文件"></a>通过 innodb_ruby 工具来分析表空间文件</h2><p>mac安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ruby</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rubygems/rubygems.git</span><br><span class="line"><span class="built_in">cd</span> rubygems/bin/</span><br><span class="line">./gem install innodb_ruby</span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang space-page-type-regions</span><br><span class="line">start       end         count       <span class="built_in">type</span>                </span><br><span class="line">0           0           1           FSP_HDR             </span><br><span class="line">1           1           1           IBUF_BITMAP         </span><br><span class="line">2           2           1           INODE               </span><br><span class="line">3           3           1           INDEX               </span><br><span class="line">4           5           2           FREE (ALLOCATED)    </span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>查看具体数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 page-records</span><br><span class="line"><span class="comment"># Record 127: (id=1) → (username="name-1", age=1)</span></span><br><span class="line"><span class="comment"># Record 165: (id=2) → (username="name-2", age=2)</span></span><br><span class="line"><span class="comment"># Record 203: (id=3) → (username="name-3", age=3)</span></span><br><span class="line"><span class="comment"># Record 241: (id=4) → (username="name-4", age=4)</span></span><br><span class="line"><span class="comment"># Record 279: (id=5) → (username="name-5", age=5)</span></span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<h2 id="其他-XDES页"><a href="#其他-XDES页" class="headerlink" title="其他-XDES页"></a>其他-XDES页</h2><p>簇或者分区（extent）是段的组成元素，在文件头使用FLAG描述了创建表信息，除此之外其他部分的数据结构和XDES PAGE都是相同的，<br>使用连续数组的方式，每个XDES PAGE最多存储256个XDES Entry，每个Entry占用40个字节，描述64个Page（即一个Extent）。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">XDES_ID	8	如果该Extent归属某个segment的话，则记录其ID</span><br><span class="line">XDES_FLST_NODE	12(FLST_NODE_SIZE)	维持Extent链表的双向指针节点</span><br><span class="line">XDES_STATE	4	该Extent的状态信息，包括：XDES_FREE，XDES_FREE_FRAG，XDES_FULL_FRAG，XDES_FSEG，详解见下文</span><br><span class="line">XDES_BITMAP	16	总共16*8&#x3D; 128个bit，用2个bit表示Extent中的一个page，一个bit表示该page是否是空闲的(XDES_FREE_BIT)，另一个保留位，尚未使用（XDES_CLEAN_BIT）</span><br></pre></td></tr></table></figure>
<p>XDES_STATE表示该Extent的四种不同状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	Desc</span><br><span class="line">XDES_FREE(1)	存在于FREE链表上</span><br><span class="line">XDES_FREE_FRAG(2)	存在于FREE_FRAG链表上</span><br><span class="line">XDES_FULL_FRAG(3)	存在于FULL_FRAG链表上</span><br><span class="line">XDES_FSEG(4)	该Extent归属于ID为XDES_ID记录的值的SEGMENT。</span><br></pre></td></tr></table></figure>
<p>通过XDES_STATE信息，我们只需要一个FLIST_NODE节点就可以维护每个Extent的信息，是处于全局表空间的链表上，还是某个btree segment的链表上。</p>
<h2 id="文件维护"><a href="#文件维护" class="headerlink" title="文件维护"></a>文件维护</h2><p>从上文我们可以看到，InnoDB通过Inode Entry来管理每个Segment占用的数据页，每个segment可以看做一个文件页维护单元。Inode Entry所在的inode page有可能存放满，因此又通过头Page维护了Inode Page链表。</p>
<p>在ibd的第一个Page中还维护了表空间内Extent的FREE、FREE_FRAG、FULL_FRAG三个Extent链表；而每个Inode Entry也维护了对应的FREE、NOT_FULL、FULL三个Extent链表。这些链表之间存在着转换关系，以高效的利用数据文件空间。</p>
<p>注意区别：表空间中的链表管理的是整个表空间中所有的簇，包括满簇、半满簇及空闲簇，而段的iNode信息中管理的是属于自己段中的满簇、半满簇及空闲簇。</p>
<p>当创建一个新的索引时，实际上构建一个新的btree(btr_create)，先为非叶子节点Segment分配一个inode entry，再创建root page，并将该segment的位置记录到root page中，然后再分配leaf segment的Inode entry，并记录到root page中。当删除某个索引后，该索引占用的空间需要能被重新利用起来。</p>
<p>创建一个segment：</p>
<p>函数入口：fseg_create_general。</p>
<ol>
<li><p>根据空间id得到表空间头信息。</p>
</li>
<li><p>从得到的表空间头信息分配Inode:具体实现为读取文件头Page并加锁（fsp_get_space_header），然后开始为其分配Inode Entry(fsp_alloc_seg_inode)。</p>
<p> 为了管理Inode Page，在文件头存储了两个Inode Page链表，一个链接已经用满的inode page，一个链接尚未用满的inode page。如果当前Inode Page的空间使用完了，<br> 就需要再分配一个inode page，并加入到FSP_SEG_INODES_FREE链表上(fsp_alloc_seg_inode_page)。对于独立表空间，通常一个inode page就足够了。</p>
</li>
</ol>
<p>具体查找inode Page过程：首先判断FSP_SEG_INODES_FREE链表是否还有空闲页面，如果有，则从页面的数据存储位置开始扫描，没找一个Inode，先判断是否空闲（空闲表示其不归属任何segment，即FSEG_ID置为0）。<br>找到则返回。找到这个且这个Inode为这个页最后一个Inode.则该inode page中的记录用满了，就从FSP_SEG_INODES_FREE链表上转移到FSP_SEG_INODES_FULL链表。<br>如果FSP_SEG_INODES_FREE没有空闲的Inode页面，则重新分配一个inode页面，分配后把所有描述符里面的FSEG_ID置为0，重复上面过程。</p>
<ol start="3">
<li><p>给新分配的Inode设置SEG_ID. 这个ID号要从表空间头信息的FSP_SEG_ID作为当前segment的seg id写入到inode entry中。同时更新FSP_SEG_ID的值为ID+1，作为下一个段的ID号。</p>
</li>
<li><p>在完成inode entry的提取后，初始化这个Inode信息。把FSEG_NOT_FULL_N_USED置为0，初始化FSEG_FREE、FSEG_NOT_FULL，FSEG_FULL。</p>
</li>
<li><p>从这个段分配出一个页面。（这块逻辑不太懂）</p>
</li>
<li><p>分配好页面后，通过缓存找到段的首页面（页面号为page+index）。就将该inode entry所在inode page的位置及页内偏移量存储到段首页，10个字节的inode信息包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">FSEG_HDR_SPACE	4	描述该segment的inode page所在的space id （目前的实现来看，感觉有点多余…）</span><br><span class="line">FSEG_HDR_PAGE_NO	4	描述该segment的inode page的page no</span><br><span class="line">FSEG_HDR_OFFSET	2	inode page内的页内偏移量</span><br></pre></td></tr></table></figure>
<p>至此段就分配完成了，以后如果需要在这个段中分配空间，只需要找到其首页，然后根据对应的Inode分配空间。</p>
</li>
</ol>
<p>分配数据页函数 fsp_alloc_free_page</p>
<p>表空间Extent的分配函数fsp_alloc_free_extent。</p>
<p>对应的还有释放Segment 当我们删除索引或者表时，需要删除btree（btr_free_if_exists），先删除除了root节点外的其他部分(btr_free_but_not_root)，再删除root节点(btr_free_root)</p>
<p>由于数据操作都需要记录redo，为了避免产生非常大的redo log，leaf segment通过反复调用函数fseg_free_step来释放其占用的数据页。</p>
<h2 id="创建B-索引"><a href="#创建B-索引" class="headerlink" title="创建B+索引"></a>创建B+索引</h2><p>innodb的文件管理方式，核心目的是为了管理好B+索引。</p>
<p>ibd文件中真正构建起用户数据的结构是BTREE，在你创建一个表时，已经基于显式或隐式定义的主键构建了一个btree，其叶子节点上记录了行的全部列数据（加上事务id列及回滚段指针列）；</p>
<p>如果你在表上创建了二级索引，其叶子节点存储了键值加上聚集索引键值。所以书上贴一段创建B+索引的代码。网上找了5.6.15版本的。</p>
<p>这个函数就是创建一个B+树，只是概念上的，还没有真正的数据写入。</p>
<h1 id="页内-页目录"><a href="#页内-页目录" class="headerlink" title="页内-页目录"></a>页内-页目录</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(<span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>, ch <span class="built_in">varchar</span>(<span class="number">10</span>), <span class="keyword">key</span>(ch));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(ch) <span class="keyword">values</span>(<span class="string">'ab'</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个新的测试表 t2，有主索引 id 和 辅助索引 ch，分析 t2.ibd 文件可验证：</p>
<ul>
<li>对比没有辅助索引的表，表t2多一个INDEX页，用于存储辅助索引的根结点。</li>
<li>辅助索引的INDEX页也有两个系统记录 infimum 和 supremum。而用户记录内容格式跟前面分析基本一致，内容为辅助索引 ch 列的值 ab 和 主键值1。</li>
</ul>
<p>INDEX页内的记录是通过单向链表连接在一起的，遍历列表性能会比较差，而INDEX页的页目录就是为了加速记录搜索。</p>
<p>表 t2 中的页目录只有两项，分别是 0x63 和 0x70，即 99 和 112。</p>
<p>下面的ownedkey为这个页目录槽拥有的小于等于它的记录数目，显然 infimum 的ownedkey为 1，即只有它自己，没有key会比infimum小。</p>
<p>而 supremum 的owned是3，分别是我们插入的两条记录和它自己。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slot    offset  type          owned  key</span><br><span class="line">0       99      infimum       1       </span><br><span class="line">1       112     supremum      3</span><br></pre></td></tr></table></figure>
<p>每个页目录槽最少要包含4个记录，最多包含8个记录(包括它自己)。如果我们在表 t2 中另外插入 7 条记录，则会增加一个新的slot，即 id 为 4 的记录，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slot    offset  type          owned   key</span><br><span class="line">0       99      infimum       1       </span><br><span class="line">1       207     conventional  4       (i&#x3D;4)</span><br><span class="line">2       112     supremum      5</span><br></pre></td></tr></table></figure>
<p>下图是页目录结构图，可以通过页目录的二分查找提高页内数据的查询性能。</p>
<p><img src="/images/post/db-mysql/bptreepagestruct.webp" alt></p>
<p>参考：</p>
<p><a href="http://mysql.taobao.org/monthly/2016/02/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/02/01/</a></p>
<p>《MYSQL运维内参》<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html</a></p>
<p>链接：<a href="https://blog.csdn.net/bohu83/article/details/81086474" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/article/details/81086474</a><br><a href="http://mysql.taobao.org/monthly/2016/02/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/02/01/</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>05-存储引擎层-innodb框架-表空间-ibd</title>
    <url>/articles/20200202/20b74871.html</url>
    <content><![CDATA[<p>摘要：<br>innodb文件系统是由一些log和每个表的ibd（16K的整数倍）等文件组成的。内部结构如下。</p>
<a id="more"></a>

<h1 id="表空间-idb简述"><a href="#表空间-idb简述" class="headerlink" title="表空间-idb简述"></a>表空间-idb简述</h1><p>ibd是存表数据的，那么在计算机里，所有的存储都是有最小存储单元的。</p>
<p>在磁盘上，最小的单元是扇区，一个扇区是512字节，操作系统中最小单元是块（block），最小单位是4K。而innodb也有自己的最小存储单元——页（page），一页是16K。</p>
<p>这意味着一个文件放到电脑上，哪怕它是空的，也要占用4K，它占用的空间永远是4K的整数倍。</p>
<p>可以去查看每个ibd文件的大小，它永远是16384（16k）的整数倍。</p>
<p>后续说明索引加载表数据的前提，mysql的数据最小是16K，也就是哪怕你只取一条，可能还不到1K，那么mysql也会取出16K的数据。</p>
<p>因为“页”是最小单位。“页”还决定了b+ tree在某个高度下，能存放的数据量，为什么一个表存2万数据，和存1500万数据，查询速度一样。</p>
<h2 id="单个文件表空间-frm、ibd"><a href="#单个文件表空间-frm、ibd" class="headerlink" title="单个文件表空间-frm、ibd"></a>单个文件表空间-frm、ibd</h2><p>如果想让两个表共用一个数据文件的话,共用一个ibdata，可以通过<strong>innodb_file_per_table</strong>控制。默认每个表一个。</p>
<p>创建了一个数据库test_innodb，并且创建了几个表，可以在数据目录看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.opt</span><br><span class="line">table5hang.frm</span><br><span class="line">table5hang.ibd</span><br><span class="line">table15w.frm</span><br><span class="line">table15w.ibd</span><br><span class="line">table500w.frm</span><br><span class="line">table500w.ibd</span><br><span class="line">table1000w.frm</span><br><span class="line">table1000w.ibd</span><br></pre></td></tr></table></figure>
<p>当新建一个库时，首先文件系统上会多一个以库名命名的文件夹。里面有ibd、frm文件，每个表对应一个ibd文件。</p>
<ul>
<li><p>db.opt 保存了数据库test的默认字符集 utf8mb4 和校验方法utf8mb4_general_ci；<br>存储的是mysql的一些配置信息，如编码、排序的信息，如果在创建数据库时指定了一些非默认参数的话，也会存到该文件。</p>
</li>
<li><p>每个表会对应一个frm文件，一个ibd文件。</p>
<ul>
<li><p>frm文件是表结构，无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。<br>数据字典信息(InnoDB数据字典信息主要是存储在系统表空间ibdata1文件中，由于历史原因才在 t.frm 多保留了一份)</p>
</li>
<li><p>ibd是表的数据和索引，是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p>
</li>
</ul>
</li>
</ul>
<p>独立的表空间文件之存储对应表的B+树数据、索引和插入缓冲等信息，其余信息还是存储在默认表空间中。</p>
<p>这个文件所存储的内容主要就是B+树（索引），一个表可以有多个索引，也就是在一个文件中，可以存储多个索引，而如果一个表没有索引的话，用来存储数据的被称为聚簇索引，也就是说这也是一个索引。</p>
<h3 id="采用-File-Per-Table-的优缺点"><a href="#采用-File-Per-Table-的优缺点" class="headerlink" title="采用 File-Per-Table 的优缺点"></a>采用 File-Per-Table 的优缺点</h3><ul>
<li>优点：可以方便回收删除表所占的磁盘空间。如果使用系统表空间的话，删除表后空闲空间只能被 InnoDB 数据使用。TRUNCATE TABLE 操作会更快。<br>可以单独拷贝表空间数据到其他数据库(使用 transportable tablespace 特性)，可以更方便的观测每个表空间数据的大小。</li>
<li>缺点：fsync 操作需要作用的多个表空间文件，比只对系统表空间这一个文件进行fsync操作会多一些 IO 操作。此外，mysqld需要维护更多的文件描述符。</li>
</ul>
<h2 id="当新建库时，innodb内部操作"><a href="#当新建库时，innodb内部操作" class="headerlink" title="当新建库时，innodb内部操作"></a>当新建库时，innodb内部操作</h2><p>innodb存储引擎在存储设计上模仿了Oracle的存储结构，其数据是按照表空间进行管理的。</p>
<p>新建一个数据库时，innodb存储引擎会初始化一个名为ibdata1 的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表sys_tables、sys_columns、sys_indexes 、sys_fields等。</p>
<p>此外，还会存储用来保证数据完整性的回滚段数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了；</p>
<p>注：不同的表既可以共用一个ibd文件，也可以每个表自己一个ibd文件，默认是一个表一个。</p>
<p>虽然是一个表一个ibd，但这个ibd里只存储了该表的B+树数据、索引、插入缓存等信息，其余的信息如列、属性等信息还是存储在默认的ibdata1里面的。</p>
<figure class="highlight plain"><figcaption><span>官网介绍</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A data file that can hold data for one or more InnoDB tables and associated indexes.</span><br><span class="line"> </span><br><span class="line">The system tablespace contains the InnoDB data dictionary, and prior to MySQL 5.6 holds all other InnoDB tables by default.</span><br><span class="line"> </span><br><span class="line">The innodb_file_per_table option, enabled by default in MySQL 5.6 and higher, allows tables to be created in their own tablespaces.</span><br><span class="line"> </span><br><span class="line">File-per-table tablespaces support features such as efficient storage of off-page columns, table compression, and transportable tablespaces.</span><br><span class="line">See Section 14.7.4, “InnoDB File-Per-Table Tablespaces” for details.</span><br></pre></td></tr></table></figure>

<h2 id="ibd存储的数据"><a href="#ibd存储的数据" class="headerlink" title="ibd存储的数据"></a>ibd存储的数据</h2><p>该表的所有索引数据【聚集索引】。</p>
<p>这里使用了B+tree,B+ tree的叶子节点，就会存放所有的数据。整个表，其实就是一棵B+ tree，一个ibd就是1-N个b+ tree。N等于你的索引数量</p>
<p>当新建一个表时，会给表创建一个主键primary Key，然后这个key就带着整行数据占据着一块空间，作为B+ tree的一个叶子节点里元素。</p>
<p>可以理解为一个key-value键值对，key就是主键，value就是整行数据。如果你根本就没创建主键（不推荐），那innodb也会给你分配一个RowId来作为将来找它的主键，只是看不到。</p>
<p>这棵拥有全量数据的b+ tree，就是将来提供数据的树，一般来说，这棵树最大一般4层，3层就能存2千万数据了，4层能达到n个亿，将来通过主键查询时，通过2-4次IO就能找到数据行。这个索引树，即——聚簇索引。</p>
<h1 id="表空间-ibd内文件结构"><a href="#表空间-ibd内文件结构" class="headerlink" title="表空间-ibd内文件结构"></a>表空间-ibd内文件结构</h1><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>04-存储引擎层-innodb框架-磁盘上的结构-表空间</title>
    <url>/articles/20200202/e9a15921.html</url>
    <content><![CDATA[<p>摘要：<br>物理存储， InnoDB 里的所有表数据，都以索引（聚簇索引+二级索引）的形式存储起来，索引包含了表数据。</p>
<a id="more"></a>

<h1 id="磁盘上的结构"><a href="#磁盘上的结构" class="headerlink" title="磁盘上的结构"></a>磁盘上的结构</h1><p>磁盘中的结构分为两大类：表空间和重做日志。</p>
<ul>
<li>表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。<br>系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等。</li>
<li>Redo日志：存储的就是 Log Buffer 刷到磁盘的数据。</li>
</ul>
<h2 id="innodb整体文件结构"><a href="#innodb整体文件结构" class="headerlink" title="innodb整体文件结构"></a>innodb整体文件结构</h2><p>物理存储文件结构中黑框里的就是innodb。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ibdata1</span><br><span class="line">ib_logfile0</span><br><span class="line">ib_logfile1</span><br></pre></td></tr></table></figure>
<p>有两个默认的日志文件，logfile0和logfile1，大小可以手工设定。</p>
<p>InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。另一部分是idb。</p>
<h3 id="InnoDB-表结构"><a href="#InnoDB-表结构" class="headerlink" title="InnoDB 表结构"></a>InnoDB 表结构</h3><p>InnoDB 与 MyISAM 不同，它在系统表空间存储数据字典信息，因此它的表不能像 MyISAM 那样直接拷贝数据表文件移动。</p>
<p>MySQL5.7 采用的文件格式是 Barracuda，它支持 COMPACT 和 DYNAMIC 这两种新的行记录格式。</p>
<p>创建表时可以通过 ROW_FORMAT 指定行记录格式，默认是 DYNAMIC。查看表信息，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table15w'</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">from</span> test_innodb <span class="keyword">like</span> <span class="string">'table15w'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: table15w</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 149641</span><br><span class="line"> Avg_row_length: 52</span><br><span class="line">    Data_length: 7880704</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 4194304</span><br><span class="line"> Auto_increment: 150001</span><br><span class="line">    Create_time: 2020-01-31 03:40:25</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment:</span><br></pre></td></tr></table></figure>
<p>InnoDB表使用上有一些限制，如一个表最多只能有64个辅助索引，一行大小不能超过65535等，组合索引不能超过16个字段等，一般应该不会突破限制，详细见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-restrictions.html" target="_blank" rel="noopener">innodb-restrictions</a>。</p>
<h3 id="InnoDB-表空间"><a href="#InnoDB-表空间" class="headerlink" title="InnoDB 表空间"></a>InnoDB 表空间</h3><p>表空间根据类型可以分为：系统表空间，File-Per-Table 表空间{即ibd}，常规表空间，Undo表空间，临时表空间等。</p>
<ul>
<li><p>系统表空间：包含内容有数据字典，双写缓冲，修改缓冲以及undo日志，以及在系统表空间创建的表的数据和索引。</p>
</li>
<li><p>常规表空间：类似系统表空间，也是一种共享的表空间，可以通过 CREATE TABLESPACE 创建常规表空间，多个表可共享一个常规表空间，也可以修改表的表空间。<br>注意：必须删除常规表空间中的表后才能删除常规表空间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">`ts1`</span> <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">'ts1.ibd'</span> <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c2 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t2 <span class="keyword">TABLESPACE</span>=innodb_file_per_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLESPACE</span> ts1;</span><br></pre></td></tr></table></figure></li>
<li><p>File-Per-Table表空间：MySQL InnoDB新版本提供了 innodb_file_per_table 选项，每个表可以有单独的表空间数据文件(.ibd)，而不是全部放到系统表空间数据文件 ibdata1 中。在 MySQL5.7 中该选项默认开启。</p>
</li>
<li><p>其他表空间：其他表空间中Undo表空间存储的是Undo日志。除了存储在系统表空间外，Undo日志也可以存储在单独的Undo表空间中。<br>临时表空间则是非压缩的临时表的存储空间，默认是数据目录的 ibtmp1 文件，所有临时表共享，压缩的临时表用的是 File-Per-Table 表空间。</p>
</li>
</ul>
<h1 id="innodb承上启下的结构"><a href="#innodb承上启下的结构" class="headerlink" title="innodb承上启下的结构"></a>innodb承上启下的结构</h1><p><img src="/images/post/db-mysql/005/innodb-jiegou.png" alt></p>
<p>Handler API是供mysql server层调用的，server层定义了一些接口，譬如insert、delete，具体怎么实现，是由每个存储引擎自己实现的。</p>
<p>以上图中间虚线为分界，上面的是逻辑层，每个访问都会产生事务，事务处理会产生锁（表锁、行锁），操作对象是表、索引、b+ tree。对数据页面的访问需要物理事务，为了读写一致性，需要读写锁（物理锁）。为了高效定位和管理“页”，需要用到文件管理系统。</p>
<p>这些都是基于逻辑的处理，再往下就是物理层。</p>
<p>在逻辑处理和磁盘文件之间，都是有一层缓存的，这里主要是日志缓冲区和innodb_buffer_pool。和其他常用的kafka、elasticsearch、rocksDB等等一样，要保持性能，必然都遵循相同或类似的规则，那就是写pageCache、顺序写磁盘，这是决定任何一个带存储功能的性能的关键点。</p>
<p>innodb_buffer_pool，未来能对性能起决定性作用的一个重要因子。决定读写速度的都是内存，只要要读的数据在内存里，它就比在磁盘上快。redis就是靠内存，mysql的数据缓存，就取决于innodb_buffer_pool。</p>
<p>缓冲层提供了高效的读写性能，再下面就是物理文件层了，是落到磁盘上的。</p>
<p>磁盘上重要的地方有REDO日志，和表数据（页）</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>03-存储引擎层、InnoDB 架构</title>
    <url>/articles/20200201/4ced7854.html</url>
    <content><![CDATA[<p>摘要：物理存储文件结构</p>
<a id="more"></a>

<h1 id="物理存储文件结构"><a href="#物理存储文件结构" class="headerlink" title="物理存储文件结构"></a>物理存储文件结构</h1><p><img src="/images/post/db-mysql/005/jiegou.png" alt></p>
<p>my.cnf，配置文件。</p>
<p>slow.log，记录慢查询日志，当语句执行时间超过参数long_query_time的值时，会被记录到该log，需要开启配置后才有。</p>
<p>error.log，记录错误和警告信息。</p>
<p>general.log，记录所有在数据库上执行的语句，可以用来追踪问题，文件增长很快，也很大，一般不会打开，需要要调试时可以打开。</p>
<p>系统默认库有4个，存储系统信息的，表名、列名、列属性等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">information_scherma</span><br><span class="line">mysql</span><br><span class="line">performance_scherma</span><br><span class="line">sys</span><br></pre></td></tr></table></figure>

<h1 id="InnoDB-架构"><a href="#InnoDB-架构" class="headerlink" title="InnoDB 架构"></a>InnoDB 架构</h1><p><img src="/images/post/db-mysql/innodb-struct.webp" alt></p>
<p>从上面第二张图可以看到，InnoDB 主要分为两大块：</p>
<ul>
<li>InnoDB In-Memory Structures【内存中的结构】</li>
<li>InnoDB On-Disk Structures【磁盘上的结构】</li>
</ul>
<p>InnoDB 使用日志先行策略，将数据修改先在内存中完成，并且将事务记录成重做日志(Redo Log)，转换为顺序IO高效的提交事务。</p>
<p>这里日志先行，说的是日志记录到数据库以后，对应的事务就可以返回给用户，表示事务完成。</p>
<p>但是实际上，这个数据可能还只在内存中修改完，并没有刷到磁盘上去。内存是易失的，如果在数据落地前，机器挂了，那么这部分数据就丢失了。</p>
<p>InnoDB 通过 redo 日志来保证数据的一致性。如果保存所有的重做日志，显然可以在系统崩溃时根据日志重建数据。</p>
<p>当然记录所有的重做日志不太现实，所以 InnoDB 引入了检查点机制。即定期检查，保证检查点之前的日志都已经写到磁盘，则下次恢复只需要从检查点开始。</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>02-Server服务层</title>
    <url>/articles/20200201/73b4253b.html</url>
    <content><![CDATA[<p>摘要：Server服务层聚集了mysql的最多的逻辑，包括了请求解析、查询缓存、语义分析、查询优化、各种计算函数、扫描记录、binlog、缓存、锁、内存管理等等。</p>
<a id="more"></a>

<h1 id="表对象缓存"><a href="#表对象缓存" class="headerlink" title="表对象缓存"></a>表对象缓存</h1><p><img src="/images/post/db-mysql/store.jpg" alt><br><img src="/images/post/db-mysql/004/zhixing.png" alt></p>
<p>创建一个表，设置列、列属性，索引等，并且指定好了存储引擎（默认innodb）。</p>
<h2 id="表结构缓存、表对象缓存"><a href="#表结构缓存、表对象缓存" class="headerlink" title="表结构缓存、表对象缓存"></a>表结构缓存、表对象缓存</h2><p>客户端发过来一个sql，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tableA <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>此时mysql获取到此请求，会先到查询缓存中查看，是不是执行过这个语句。缓存里key就是这个查询语句，如果查询缓存有，那么就直接返回value给客户端。这个查询缓存比较没有意义，新版8.0已经把它删掉了。</p>
<p>mysql收到请求后，会进行sql语句解析，会分析出，你是查询（插入、删除），哪个表（tableA、tableB），条件。然后先判断sql语句是否合法，假如你写了个selector * 那么就会报错。</p>
<p>解析出了表之后，要得到这个表的各种信息。</p>
<h3 id="一级表结构缓存"><a href="#一级表结构缓存" class="headerlink" title="一级表结构缓存"></a>一级表结构缓存</h3><p>要操作这个表，首先要找到这个表。先从缓存中（源码里的table_def_cache，是一个Hash结构）找，根据表名做为Key去找，由于是第一次访问这个表，缓存里没有。</p>
<p>那么会从System表里去找，mysql元数据里有每个表的定义，列信息等。找到这个表，就会构建出这个表的结构体TABLE_SHARE。</p>
<p>这个TABLE_SHARE是一个静态的、不允许修改的（在内存中）结构体TABLE_SHARE，并将其放入缓存中（一个Hash结构里，key就是表名+模式名）。</p>
<p>可以理解为一个java里的类，每个字段已经被赋了初始值。这个缓存是属于mysql server层的，与后面的存储引擎无关。里面保存了表名、库名、所有列信息、列默认值、表的字符集、对应的frm文件路径、对应的存储引擎、主键等。</p>
<p>注意，这个结构体就是一级缓存，它被所有用户共享，并且不可修改，从系统表被读入直到该表被修改或删除，这个缓存都会一直存在。</p>
<h3 id="二级表对象缓存"><a href="#二级表对象缓存" class="headerlink" title="二级表对象缓存"></a>二级表对象缓存</h3><p>表已经找到了，结构也已经被缓存了，此时还不能操作这个表。因为缺少一个表对象。</p>
<p>上面的TABLE_SHARE可以理解为一个模板类，包含了表的基本信息，能被所有用户共享。</p>
<p>但是里面还缺少一些信息，譬如不同用户对该表的权限、譬如存储引擎信息。那么要想操作这个表，就需要创建一个表对象来供当前用户（线程）使用。</p>
<p>创建表对象就是实例化的过程，每个用户独享一个实例，我们称之为table实例，不会影响其他用户。</p>
<p>创建的这个实例，里面有一个指向TABLE_SHARE的引用，用以获取基本信息，还有一些其他属性，譬如存储引擎层的信息也会被初始化（引擎的handler）。</p>
<p>表对象创建完毕后，就具备了和存储引擎交互的能力（通过handler）。创建后，也会放入缓存，供下次使用时避免反复创建实例。</p>
<p>mysql层与存储引擎层，就是从这里开始区分，table对象就是沟通的桥梁。对于各个存储引擎，需要提供公共的接口来供上层（mysql server）层来调用，并由各自的table实例来完成各自的操作。<br>譬如插入一条记录，就可以调用table实例中被初始化过的存储引擎的句柄接口函数ha_write_row，进行写入。</p>
<p>这个table实例在一次操作完成之后就不需要了，系统此时并没有将其释放掉，而是保存下来，用一个状态标志位标记一下，并且会调用handler.reset()来重置引擎表状态，目的是handler会被复用，如果不reset，可能导致信息错误。缓存后，当下次用户再访问时，就不需要重新实例化了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到，当你想操作一个表时，系统对于这个表，会有两层缓存。第一层是SHARE缓存，第二层就是实例化后的对象缓存Table。</p>
<ul>
<li>缓存淘汰策略，<ul>
<li>SHARE缓存只有在表结构定义改变时，才会被删除，但是倘若表巨多，SHARE缓存超出限制，也会淘汰那些不经常使用的SHARE。</li>
<li>第二层的实例缓存，也是有最大值的，超出后则开始淘汰。</li>
</ul>
</li>
</ul>
<p>涉及的参数变量有两个，table_open_cache和table_definition_cache，一些淘汰策略数值就是靠这两个参数来计算得到的。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>不同于某些数据库，一启动就加载了所有表信息。mysql是按需加载，由于mysql的插件式存储引擎，mysql做了两层的缓存模型，第二层才加载引擎的handler。</p>
<ul>
<li>优点：<br>按需加载，提高内存利用率，避免启动时加载所有表信息带来的内存占用。</li>
</ul>
<ul>
<li>缺点：<br>两层缓存带来了效率的损失，每个用户（线程）都要实例化table对象。<br>在并发情况下，有可能会实例化多个table对象，导致table_open_cache增长过快，导致淘汰掉其他的table对象。同时倘若table比较大，譬如有N多的列，那么会占用非常多的内存。</li>
</ul>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>01-网络连接层</title>
    <url>/articles/20200201/3a03a839.html</url>
    <content><![CDATA[<p>摘要：数据库三层架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网络层</span><br><span class="line">  ↓</span><br><span class="line">server层</span><br><span class="line">  ↓</span><br><span class="line">存储层</span><br></pre></td></tr></table></figure>
<p>存储层：mysql作为一个插件式的数据库，在存储层支持多种引擎，譬如默认的innodb，和之前版本默认的MyIsam。由不同的引擎提供相同的接口给server层调用，来完成数据的增删改查。</p>
<p>server层：是mysql比较复杂的地方，里面包含了大量的逻辑，譬如语义分析、查询优化、日志、缓存等等。</p>
<p>网络层：主要是提供socket连接。</p>
<a id="more"></a>

<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在mysql的网络层，主要关注3点</p>
<ol>
<li>Poll、Select模型</li>
<li>Max-connections</li>
<li>connection复用</li>
</ol>
<p>mysql在启动后，创建了socket server，绑定了3306端口，并对其进行监听。和java里的写法类似，用一个while循环来监听新来的connection，如果有了新连接，就创建一个新的连接线程去处理（不能超过max-connections）。</p>
<p>这种就是典型的BIO的模式，为每一个连接创建一个线程。并且，mysql在这里采用了IO多路复用，会有一个if语句来判断当前系统是否支持Poll模式，否则就走Select模型（各个系统默认都有实现）。</p>
<p>Poll模型和Select非常类似，只是少了1024个fd的限制，都是采用遍历数组轮询有没有新IO事件的方式，在连接数较少的情况下，性能优异，要好于epoll。</p>
<p>mysql基于BIO，本质上是不接受大量的socket连接的，所以设置了max-connections这个限制，超过设置的max，那么新来的连接会被拒绝。</p>
<p>那么，第一个问题，为什么是BIO，而不是可以承受更大连接数的NIO和AIO呢？是否用NIO就会更好呢？</p>
<h3 id="mysql的BIO"><a href="#mysql的BIO" class="headerlink" title="mysql的BIO"></a>mysql的BIO</h3><h4 id="bio和nio的区别"><a href="#bio和nio的区别" class="headerlink" title="bio和nio的区别"></a>bio和nio的区别</h4><p>在BIO模式下，调用read，如果发现没数据，就会Block住。</p>
<p>在NIO模式下，调用read，如果发现没数据，就会立刻返回-1, 并且errno被设为EAGAIN。</p>
<h5 id="基于NIO-IO多路复用的模式"><a href="#基于NIO-IO多路复用的模式" class="headerlink" title="基于NIO+IO多路复用的模式"></a>基于NIO+IO多路复用的模式</h5><p>server开发使用的web容器：tomcat、netty等，都是基于NIO+IO多路复用的模式，来大幅提升性能，承载高并发访问的。但是到了DB层，则使用hakiri、druid之类的线程池，开启10个线程去连接mysql，反复复用这个线程池。</p>
<p>NIO+IO多路复用，并不是指多个用户socket共享一个IO，从而使得服务端的socket数量大减。而是把多个socket连接，归并到一个进程进行管理，如用一个大数组来聚合起来，然后循环遍历这个数组，来一次性把多个连接的事件通知业务代码进行处理。<br>这样就大幅减少了server的压力，高效利用资源。</p>
<p>对mysql来说，一般都会有多个连接，毕竟并发肯定是要有的。不可能做个查询，也要大家一起排队等上一个人查询完。所以线程池和并发是一定的。</p>
<h5 id="mysql和web-Server区别"><a href="#mysql和web-Server区别" class="headerlink" title="mysql和web Server区别"></a>mysql和web Server区别</h5><p>Web请求，往往是无状态的，一问一答的时候居多，请求也往往比较短促，对于顺序性也不是十分严格，哪怕是后请求的响应比先请求的提前到，也是有可能的。</p>
<p>DB请求，DB采用session作为一个连接会话，这一个session里，SQL的执行必须是串行、同步、有序的，而不能是异步乱序的。原因是，一个session内可能有多个操作，增删改查、事务隔离，必须保证顺序不能乱。<br>DB维护这样一个session，是要花费远大于web Server处理一个请求的资源才能完成的。</p>
<p>对于DB来说，连接是非常耗资源的事情，限制连接数是非常有必要的。</p>
<p>注意，当连接mysql出问题时，随便加大应用服务的连接池和增大mysql的max-connection。不能改善mysql的性能。当进行非常密集的数据库操作时，连接池的数量对性能产生的巨大影响。</p>
<h4 id="为什么用BIO，而不是NIO。"><a href="#为什么用BIO，而不是NIO。" class="headerlink" title="为什么用BIO，而不是NIO。"></a>为什么用BIO，而不是NIO。</h4><p>原因是JDBC不支持，JDBC出现了20年，它是一个标准，在它被提出时，只有BIO模型，导致数据库驱动对JDBC的实现都是BIO的形式，mysql驱动connector早早地实现了JDBC标准，就是采用阻塞的方式。</p>
<p>当进行一个select查询，在查询没有完成之前，整个调用线程会被卡住，等到天荒地老也要等下去，绝不是一请求立马收到返回，然后等mysql回调你结果。</p>
<p>其实，也有人修改了mysql的协议，增加了NIO+多路复用的功能，最后失败，主要原因是mysql和web server功能意义都不一样，确切地说，90%的场景下，不需要一个NIO的数据库。</p>
<p>BIO+连接池，已经发展了很多年，大部分问题都已经解决，在目前的java环境中，是非常靠谱的方案。已经出现了很多优秀的连接池框架，你只需要配置好账号密码和连接池数量，就能很开心的使用mysql了。</p>
<p>从mysql的角度来说，客户端多是一些IO密集型的应用，应该在一个线程里频繁做大量IO操作，而不是说有大量的客户端来反复连接我。毕竟，mysql的用户是你写的几个程序应用，而web server的用户是海量的。</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>mysql能支撑的连接数是有限的，那么就需要应用程序来利用好连接池。对于连接池来说，就是做好这10个连接的管理就好。</p>
<p>对于mysql来说，管理好自己的所有连接也是很重要，哪些空闲的该休息就休息，让出资源，该复用就复用，避免创建太多线程。</p>
<h4 id="IO密集的时候，要减少连接数。"><a href="#IO密集的时候，要减少连接数。" class="headerlink" title="IO密集的时候，要减少连接数。"></a>IO密集的时候，要减少连接数。</h4><p>譬如要读写几千万数据，非常密集的IO操作，那么你可以尝试一下开启少量的mysql连接（和cpu的核数相同）和开启大量的连接（成百上千），来做同样的事。你会发现，更少的连接数，会给你带来几百倍的性能提升。</p>
<p>譬如，你有4辆车（4核），要从仓库里拉一大堆货物到另一个地方。如果只有4条路，简单操作，一个车走一路，反复折返跑。现在有了100条路，还是4个车，车要频繁的在100条路上来回切换，每条路都必须要走到。</p>
<p>线程间的轮转会耗费大量的资源，尤其在密集操作时。但是当不密集时，情况就变了，大量的线程处于休息状态，那么你即便多开了几个连接，CPU还是能很快的照顾到你，并没有什么大的影响。</p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>作为RPC的连接，内部rpc数据协议</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>008-模板-NexT-版权、打赏</title>
    <url>/articles/20200130/7021388e.html</url>
    <content><![CDATA[<p>摘要：文章底部版权、文章底部打赏</p>
<a id="more"></a>

<h1 id="文章底部版权"><a href="#文章底部版权" class="headerlink" title="文章底部版权"></a>文章底部版权</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Next7.2.0官方对版权声明的设置做出了大改动，在主题配置文件_config.yml中已经找不到设置版权声明的post_copyright选项</p>
<p>旧版本：Next下，设置post_copyright为true，或是修改themes/next/layout/_macro/post-copyright.swig文件，自定义版权声明样式</p>
<p>新版本：Next下，网上一片教程，没有post_copyright选项了，各种改代码。</p>
<h2 id="探究新版版权"><a href="#探究新版版权" class="headerlink" title="探究新版版权"></a>探究新版版权</h2><p>发现：themes/next/layout/_partials/post/post-copyright.swig 还是有版权定义。</p>
<p>查看版权配置文件：themes/next/layout/_macro/post.swig</p>
<p>打开，直接搜搜：post-copyright.swig，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.creative_commons.license and theme.creative_commons.post %&#125;</span><br><span class="line">  &#123;&#123; partial(&#39;_partials&#x2F;post&#x2F;post-copyright.swig&#39;) &#125;&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>查看样式什么时候导入：themes/next/source/css/_common/components/post/post.styl<br><code>@import &#39;post-copyright&#39; if (hexo-config(&#39;creative_commons.post&#39;));</code><br>即配置文件中 有creative_commons</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<h1 id="文章底部打赏"><a href="#文章底部打赏" class="headerlink" title="文章底部打赏"></a>文章底部打赏</h1><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><p>查看 源码 发现 reward，配置：reward_settings</p>
<ol>
<li><p>打赏图片增加<br>支付宝，微信获取付款图片<br>source/images/reward/bjlhx-wx.bmp<br>source/images/reward/bjlhx-wx.bmp</p>
</li>
<li><p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">一分也是爱，两分情更浓【还没有人赞赏，支持一下呗】</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/reward/bjlhx-wx.bmp</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/reward/bjlhx-zfb.bmp</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>002-github pages建站，绑定主题</title>
    <url>/articles/20200130/e012e91a.html</url>
    <content><![CDATA[<p>搭建属于自己的博客网站，这里使用 github pages建站，绑定主题</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>基于github建站，使用仓库存放静态代码</p>
<h2 id="基础储备"><a href="#基础储备" class="headerlink" title="基础储备"></a>基础储备</h2><p>github账号注册</p>
<p>git使用：<a href="https://www.cnblogs.com/bjlhx/category/993475.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/993475.html</a>　　</p>
<p><strong>基础步骤</strong></p>
<ul>
<li>Github Pages</li>
<li>Hexo 博客框架</li>
<li>部署</li>
<li>Next 主题</li>
</ul>
<p><strong>涉及三个仓库</strong></p>
<ul>
<li>静态代码部署仓库：username.github.io 作用：username 需要设置成每个人仓库自己的，主要是基于Github Pages 的 部署代码。</li>
<li>静态代码开发仓库：hexo-src.bjlhx15.github.io 作用：开发代码的仓库。</li>
<li>基于github评论仓库：ment.bjlhx15.github.io 作用：使用基于github issues机制的评论仓库</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Github-Pages使用"><a href="#Github-Pages使用" class="headerlink" title="Github Pages使用"></a>Github Pages使用</h2><p>Github Pages 其实本身就是 Github 提供的博客服务。 我们在 Github 中创建一个特定格式的 Repository，Github Pages 就会将里面的信息生成一个网页，展示出来。</p>
<p>创建仓库：username.github.io：</p>
<p>创建即可，访问：<a href="https://bjlhx15.github.io/" target="_blank" rel="noopener">https://bjlhx15.github.io/</a>  博客首页</p>
<h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p>Hexo：是一个博客框架。它把本地文件里的信息生成一个网页。</p>
<p>使用 Hexo 之前，需要先安装 Node.js 和 Git。检测安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>hexo安装：<code>npm install -g hexo-cli</code></p>
<p>查看：<code>hexo -v</code></p>
<p>备注：<a href="https://www.cnblogs.com/bjlhx/p/12239748.html" target="_blank" rel="noopener">006-node npm 报错 rollbackFailedOptional: verb npm-session</a></p>
<h3 id="框架结合源码"><a href="#框架结合源码" class="headerlink" title="框架结合源码"></a>框架结合源码</h3><p>在其他目录下使用：hexo init，下载代码，因为 init 初始化需要一个空目录，否则报错</p>
<p>github上新建一个仓库：hexo-src.bjlhx15.github.io.git，拉取到本地，将上述代码拷贝至在仓库中即可</p>
<p>npm install 安装依赖包</p>
<p>hexo g 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</p>
<p>hexo s 将生成的网页放在了本地服务器（server）</p>
<p><a href="https://blog.bjlhx.top/categories/hexo/" target="_blank" rel="noopener">更多</a></p>
<h3 id="新建博客并发布"><a href="#新建博客并发布" class="headerlink" title="新建博客并发布"></a>新建博客并发布</h3><p>source/_posts 放置 XX.md 文章即可，执行hexo g、hexo s查看</p>
<p>发布，将生成的前端代码发布到：bjlhx15.github.io.git  仓库，注意不是2.3中的源码仓库 hexo-src</p>
<p>在根目录：_config.yml 下修改deploy：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#39;git&#39;</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;bjlhx15&#x2F;bjlhx15.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>输入 <code>npm install hexo-deployer-git --save</code> 安装 hexo-deployer-git 此步骤只需要做一次。</p>
<p>输入 <code>hexo d</code>，会将本地代码部署至 部署仓库地址</p>
<p>至此基础版本搭建完成：<a href="https://bjlhx15.github.io/" target="_blank" rel="noopener">https://bjlhx15.github.io/</a></p>
<h2 id="使用Next主题"><a href="#使用Next主题" class="headerlink" title="使用Next主题"></a>使用Next主题</h2><p>以 Next 为例。 大概思路就是把整个主题的文件克隆到我们的主题文件夹中。在配置文件中注明使用该主题。【更多】</p>
<ol>
<li>下载主题</li>
</ol>
<p>在hexo-src源码的根目录下：<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p>
<p>这样，该主题的文件就全部克隆到:   themes\next 下面。</p>
<ol start="2">
<li>切换主题<pre><code class="text"># theme: landscape  next
theme: next</code></pre>
访问<a href="https://bjlhx15.github.io" target="_blank" rel="noopener">https://bjlhx15.github.io</a>即可</li>
</ol>
<h1 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h1><pre><code>将：src 源码下载，使用idea，eclipse等打开
在：source/_posts 下分目录 编写文章即可</code></pre>]]></content>
      <categories>
        <category>build_site</category>
      </categories>
  </entry>
  <entry>
    <title>001-建站系统系列</title>
    <url>/articles/20200130/f87cfa7a.html</url>
    <content><![CDATA[<p>一步一步，搭建网站系统<br>域名申请与绑定、</p>
<p><a href="https://blog.bjlhx.top/categories/build-site/" target="_blank" rel="noopener">build-site</a></p>
<a id="more"></a>

<h1 id="域名申请与绑定"><a href="#域名申请与绑定" class="headerlink" title="域名申请与绑定"></a>域名申请与绑定</h1><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p><a href="https://www.aliyun.com" target="_blank" rel="noopener">https://www.aliyun.com</a></p>
<p>控制台→域名，可以注册域名，top域名比较便宜，个人申请使用：bjlhx.top</p>
<p><a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="noopener">https://wanwang.aliyun.com/domain/</a>  首年1块</p>
<h3 id="CNAME-域名解析"><a href="#CNAME-域名解析" class="headerlink" title="CNAME 域名解析"></a>CNAME 域名解析</h3><p>主要是一个域名解析到另一个域名</p>
<h4 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h4><p><img src="/images/post/build_site/domain.png" alt></p>
<h4 id="站点根目录增加"><a href="#站点根目录增加" class="headerlink" title="站点根目录增加"></a>站点根目录增加</h4><p>文件：CNAME</p>
<p>内容：blog.bjlhx.top</p>
<p>等待10分钟，然后访问 <a href="http://blog.bjlhx.top/" target="_blank" rel="noopener">http://blog.bjlhx.top/</a> 就能看到 <a href="http://bjlhx15.github.io" target="_blank" rel="noopener">http://bjlhx15.github.io</a> 一样的页面，证明绑定成功了。 </p>
<h3 id="IP解析"><a href="#IP解析" class="headerlink" title="IP解析"></a>IP解析</h3><p>域名解析到指定的IP，A记录</p>
]]></content>
      <categories>
        <category>build_site</category>
      </categories>
  </entry>
  <entry>
    <title>007-hero-config配置说明</title>
    <url>/articles/20200130/6fe23d4d.html</url>
    <content><![CDATA[<p>位于站点根目录下的 _config.yml 文件，可以直接用记事本打开进行编辑，文件中的具体配置项.<br>Site、URL、Directory、Writing、Home page setting、Category &amp; Tag、Date / Time format、Pagination、Extensions、Deployment</p>
<a id="more"></a>

<h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><p>网站的个性化描述，大家需要根据自己的实际情况认真填写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">title	网站标题</span><br><span class="line">subtitle	网站副标题</span><br><span class="line">description	网站描述</span><br><span class="line">keywords	网站关键字</span><br><span class="line">author	网站作者</span><br><span class="line">language	网站使用的语言，默认是en ，中文网站填zh-Hans</span><br><span class="line">timezone	网站使用的时区，默认为 计算机的预设置，可以不填</span><br></pre></td></tr></table></figure>

<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>关于博客文章 URL 的设置，一般不用进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">url	网站的网址</span><br><span class="line">root	网站的根目录， 也是存放文章的目录</span><br><span class="line">permalink	文章的链接格式 ，默认为 :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults	永久链接中每个段的默认值</span><br></pre></td></tr></table></figure>

<h1 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h1><p>关于文件夹的设置，也是一般不用进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">source_dir	资源文件夹 ，存放用户的资源文件，默认为 source</span><br><span class="line">public_dir	公用文件夹 ，存放生成的静态文件，默认为 public</span><br><span class="line">tag_dir	标签目录 ，默认为 tags</span><br><span class="line">archive_dir	档案目录 ，默认为 archives</span><br><span class="line">category_dir	分类目录 ，默认为 categories</span><br><span class="line">code_dir	代码目录 ，默认为 downloads&#x2F;code</span><br><span class="line">i18n_dir	i18n目录 ，默认为 :lang</span><br><span class="line">skip_render	储存站长验证文件，跳过指定文件的渲染</span><br></pre></td></tr></table></figure>

<h1 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h1><p>这里是比较常用的写作设置，可以根据自己的写作习惯随时进行调整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">new_post_name	文章的文件名格式，默认为 :title.md</span><br><span class="line">default_layout	预设的布局模板，默认为 post</span><br><span class="line">titlecase	标题是否使用首字母大写 ，默认为 false</span><br><span class="line">external_link	链接是否在新标签页中打开，默认为 true</span><br><span class="line">filename_case	将文件名转换为 1 小写 或 2 大写，默认为 0</span><br><span class="line">render_drafts	是否显示渲染草稿，默认为 false</span><br><span class="line">post_asset_folder	是否启用 Asset 文件夹，默认为 false</span><br><span class="line">relative_link	是否建立相对于根文件夹的链接，默认为 false</span><br><span class="line">future	是否显示未来文章，默认为 true</span><br><span class="line">highlight	代码块设置</span><br></pre></td></tr></table></figure>
<h2 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">enable	是否使用代码高亮 ，默认为 true</span><br><span class="line">line_number	是否显示行号 ，默认为 true</span><br><span class="line">auto_detect	是否自动检测语言 ，默认为 false</span><br><span class="line">tab_replace	tab 替代设置</span><br></pre></td></tr></table></figure>

<h1 id="Home-page-setting"><a href="#Home-page-setting" class="headerlink" title="Home page setting"></a>Home page setting</h1><p>首页设置，可以自己决定每页显示的文章数量和显示文章的顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">index_generator	主页设置</span><br></pre></td></tr></table></figure>

<p>index_generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">path	首页的根目录</span><br><span class="line">per_page	每页显示文章的数量，默认为 10</span><br><span class="line">order_by	显示文章的顺序，默认为 -date</span><br></pre></td></tr></table></figure>

<h1 id="Category-amp-Tag"><a href="#Category-amp-Tag" class="headerlink" title="Category &amp; Tag"></a>Category &amp; Tag</h1><p>这里是关于分类和标签的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">default_category	预设分类，默认为 uncategorized</span><br><span class="line">category_map	分类别名</span><br><span class="line">tag_map	标签别名</span><br></pre></td></tr></table></figure>

<h1 id="Date-Time-format"><a href="#Date-Time-format" class="headerlink" title="Date / Time format"></a>Date / Time format</h1><p>时间和日期的显示格式，一般没特殊要求的也不需要改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">date_format	日期格式，默认为 YYYY-MM-DD</span><br><span class="line">time_format	时间格式，默认为 HH:mm:ss</span><br></pre></td></tr></table></figure>

<h1 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h1><p>这里是分页设置，可以自己决定单个页面上显示的文章数量和分页目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">per_page	单个页面上显示的文章数量，默认为 10 ，用 0 表示禁用分页</span><br><span class="line">pagination_dir	分页目录，默认为 page</span><br></pre></td></tr></table></figure>

<h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><p>这里可以设置主题类型和插件，之后的文章讲到更换博客主题时需要进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">theme	博客使用的主题，默认为 landscape</span><br></pre></td></tr></table></figure>

<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>这里是关于网站部署的配置，常用的有部署类型和部署地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">deploy	网站部署配置</span><br></pre></td></tr></table></figure>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">type	网站部署类型</span><br><span class="line">repo	网站部署地址</span><br></pre></td></tr></table></figure>
<p><a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">【参考资料】</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>006-模板-NexT-三方服务-搜索、统计分析、评论</title>
    <url>/articles/20200129/f6f5115.html</url>
    <content><![CDATA[<p>包含了 站内搜索、埋点统计等，注意：凡是网络上写着改代码的配置，几乎都不用，一般都有人写好git能直接用npm了</p>
<a id="more"></a>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p>本地搜索不需要任何外部第三方服务，并且可以由搜索引擎额外索引。该搜索方法推荐给大多数用户。</p>
<p>通过在站点根目录中运行以下命令来安装hexo-generator-searchdb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>config配置</p>
<figure class="highlight plain"><figcaption><span>hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>

<h1 id="统计和分析"><a href="#统计和分析" class="headerlink" title="统计和分析"></a>统计和分析</h1><h2 id="1、分析-百度"><a href="#1、分析-百度" class="headerlink" title="1、分析-百度"></a>1、分析-百度</h2><ol>
<li>登录 <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度 分析</a>并找到网站代码获取页面。</li>
<li>将脚本ID复制到hm.js？之后，如下图：<br><img src="/images/post/hexo/analytics-baidu-id.png" alt="avatar"></li>
<li>配置<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Baidu Analytics ID</span><br><span class="line">baidu_analytics: your_id</span><br></pre></td></tr></table></figure>
代码检测是否成功，一般20分钟，可以看浏览器控制台 <a href="https://tongji.baidu.com/web/help/article?id=93&type=0" target="_blank" rel="noopener">代码手工检查攻略</a></li>
</ol>
<p>查看百度<a href="https://tongji.baidu.com/web/10000139146/homepage/index" target="_blank" rel="noopener">统计</a></p>
<h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><p>Hexo支持的评论比较多，Disqus、DisqusJS、LiveRe、Gitalk、Valine (China)、Changyan (China)<br>支持多个评论：Multiple Comment System Support<br>多说和网易云 不做了，其次畅言需要备案<br>Disqus，Hypercomments和LiveRe都是国外的，加载速度慢，甚至有被墙的可能，<br>valine 账户增加了 短信验证，实名认证等，需要个人信息 太多<br>Gitment 基于git的issues,由于 Next 更新，Gitment 已经预置了，所以不需要自己再添加代码。但是 作者 又不更新了，授权比较多,目前gitment.browser.js内使用授权，作者暂不维护<br>utterances 版本集成了utterances评论。这一工具原理和GITALK类似，但是索取的权限少，并且不用指定某个人来初始化。<em>推荐</em></p>
<ul>
<li>页面关闭评论<br><code>comments: false</code></li>
</ul>
<h2 id="utterances-【推荐】"><a href="#utterances-【推荐】" class="headerlink" title="utterances 【推荐】"></a>utterances <em>【推荐】</em></h2><p>源码<a href="https://github.com/theme-next/hexo-next-utteranc" target="_blank" rel="noopener">地址</a><br>首先来<a href="https://github.com/apps/utterances" target="_blank" rel="noopener">这里</a>为utterances在github上授权。<br>只有这样，才能让utterances有资格访问你的issue。还可指定utterances能够访问的仓库，可见其权限控制做的非常好。</p>
<p>授权完毕后，来到博客根目录，打开Git Bash，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save github:theme-next/hexo-next-utteranc</span><br></pre></td></tr></table></figure>
<p>后运行可能缺少依赖next-util ，原因是设置了<a href="https://www.cnblogs.com/bjlhx/p/12239748.html" target="_blank" rel="noopener">淘宝的 npm 源</a></p>
<p>打开主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Demo: https:&#x2F;&#x2F;utteranc.es&#x2F;  http:&#x2F;&#x2F;trumandu.github.io&#x2F;about&#x2F;</span><br><span class="line">utteranc:</span><br><span class="line">  enable: true</span><br><span class="line">  repo: #Github repo such as :TrumanDu&#x2F;comments</span><br><span class="line">  pathname: pathname</span><br><span class="line">  # theme: github-light,github-dark,github-dark-orange</span><br><span class="line">  theme: github-light</span><br><span class="line">  cdn: https:&#x2F;&#x2F;utteranc.es&#x2F;client.js</span><br></pre></td></tr></table></figure>

<h2 id="LiveRe"><a href="#LiveRe" class="headerlink" title="LiveRe"></a>LiveRe</h2><p>LiveRe是基于社交网站评论的内容平台，可帮助用户自由交流。</p>
<p>创建一个帐户或登录<a href="http://livere.com" target="_blank" rel="noopener">LiveRe</a>，单击安装按钮并选择免费的城市版本，然后单击立即安装按钮。</p>
<p>复制安装代码中的data-uid字段以获取LiveRe UID。</p>
<p>将获得的LiveRe UID添加到主题配置文件中的livere_uid部分，如下所示</p>
<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https:&#x2F;&#x2F;livere.com&#x2F;insight&#x2F;myCode (General web site)</span><br><span class="line">livere_uid: your_uid</span><br></pre></td></tr></table></figure>

<h2 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h2><p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。<br>支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>
<ol>
<li><p>github注册<br>首先要有github帐号<br>接着注册 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">OAuth Application</a>→<a href="https://github.com/settings/developers" target="_blank" rel="noopener">OAuth App</a><br>注册特别简单。之后能够查看 clientId,sercet等</p>
</li>
<li><p>引入gitment<br>在站点目录下，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save gitment</span><br></pre></td></tr></table></figure>
<p>打开主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true # 是否开启gitment评论系统</span><br><span class="line">  mint: true #</span><br><span class="line">  count: true # 是否显示评论数</span><br><span class="line">  lazy: true # 懒加载，设置为ture时需手动展开评论</span><br><span class="line">  cleanly: true # 是否隐藏&#39;Powered by ...&#39;</span><br><span class="line">  language: en # 语言，置空则随主题的语言</span><br><span class="line">  github_user: iamsea # Github用户名</span><br><span class="line">  github_repo: comment # 在Github新建一个仓库用于存放评论，这是仓库名</span><br><span class="line">  client_id: a6df579b14f7da8aAAAAc # 注册OAuth Application时生成</span><br><span class="line">  client_secret: 1f6568974d6f3ed28055d2243d05457f7eAAAAAAAA # 注册OAuth Application时生成</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https:&#x2F;&#x2F;github.com&#x2F;aimingoo&#x2F;intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure>
<p>github_repo # 在Github新建一个空仓库用于存放评论，这是仓库名</p>
</li>
<li><p>之后生成并且部署才会生效，本地有时没有效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>部署之后，有可能碰到 Not Found Error，先不要着急，等一段时间再看看。<br>之后文章底部会出现 初始化本文的评论页，点击初始化。</p>
</li>
</ol>
<h1 id="日历插件"><a href="#日历插件" class="headerlink" title="日历插件"></a>日历插件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save github:theme-next/theme-next-calendar</span><br><span class="line">``` </span><br><span class="line">在NexT的主题配置文件中添加配置</span><br><span class="line">``` text</span><br><span class="line">CloudCalendar:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  language: zh-CN</span><br><span class="line">  single: <span class="literal">true</span></span><br><span class="line">  root: /calendar/</span><br><span class="line">  calendarCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js</span><br><span class="line">  langCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js</span><br><span class="line">  <span class="comment">#disableSidebar: false</span></span><br></pre></td></tr></table></figure>
<p>即可使用。</p>
<p>此插件会在侧边栏的最下方添加一个日历。如侧边栏比较窄，视觉效果可能会稍差。此外，在低分辨率的屏幕上，增加日历会使侧边栏出现一个滚动条，可能会影响美观。</p>
<p>使用CDN的缺点是无法进行细节上的自定义配置，只能照着默认的来。如果想自己修改日历的颜色、位置等信息，请用这种方法安装，就可以自行修改文件。</p>
<h1 id="更多服务"><a href="#更多服务" class="headerlink" title="更多服务"></a>更多服务</h1><p><a href="https://theme-next.org/docs/third-party-services/" target="_blank" rel="noopener">third-party-services</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>005-模板-NexT-其他优化-页脚、菜单显示数量、代码块</title>
    <url>/articles/20200129/12b9aaef.html</url>
    <content><![CDATA[<p>关闭页脚的powered、hexo 首页文章只显示一部分、菜单显示数量、代码块</p>
<a id="more"></a>

<h1 id="关闭页脚的powered"><a href="#关闭页脚的powered" class="headerlink" title="关闭页脚的powered"></a>关闭页脚的powered</h1><p>进入：themes/next/_config.yml，找到footer 下 powered、theme 关闭即可</p>
<h1 id="hexo首页文章只显示一部分"><a href="#hexo首页文章只显示一部分" class="headerlink" title="hexo首页文章只显示一部分"></a>hexo首页文章只显示一部分</h1><p>方式一、Front-matter<br>在Front-matter中添加了描述并将其值设置为文章摘要，则默认情况下，NexT会将描述摘录为首页的前导文本。如果没有描述，则全部内容将为首页中的前导文字。<br>您可以通过在主题配置文件中将excerpt_description的值设置为false来禁用它。</p>
<p>方式二、在文章中加上<code>&lt;!--more--&gt;</code> 标记 ，该标记以后部分就不在显示了，只有展开全部才显示，这是hexo定义的。</p>
<p>方式三、插件【不推荐】</p>
<h1 id="菜单标签显示数值"><a href="#菜单标签显示数值" class="headerlink" title="菜单标签显示数值"></a>菜单标签显示数值</h1><p>在menu_settings如果设置icon: false则无图标，badges: true则标签都会显示数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true #默认是false</span><br></pre></td></tr></table></figure>

<h1 id="代码块设置"><a href="#代码块设置" class="headerlink" title="代码块设置"></a>代码块设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">  highlight_theme: normal</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: false</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: false</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>004-模板-NexT-菜单、侧栏、头像、阅读量</title>
    <url>/articles/20200129/8ecccc4b.html</url>
    <content><![CDATA[<p>Hexo 框架允许我们更换合适的主题，以便于构建不同风格的网站，这里介绍目前最常使用的一款主题之NexT</p>
<p>设置Scheme、设置动态背景、设置侧栏行为、设置菜单、设置头像、添加社交链接、添加文字统计功能、添加阅读量统计功能</p>
<a id="more"></a>
<h1 id="NexT-安装"><a href="#NexT-安装" class="headerlink" title="NexT 安装"></a>NexT 安装</h1><p>几个概念：</p>
<p>在使用 Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml</p>
<p>一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置</p>
<p>另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置</p>
<p>不同的主题会有不同的主题配置文件，由主题作者所提供</p>
<h2 id="下载-NexT"><a href="#下载-NexT" class="headerlink" title="下载 NexT"></a>下载 NexT</h2><p>在 站点根目录 中打开 git bash 窗口，使用如下命令下载 NexT 主题文件到 themes 目录 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line">或</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">或</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h2 id="启用-NexT"><a href="#启用-NexT" class="headerlink" title="启用 NexT"></a>启用 NexT</h2><p>打开 站点配置文件， 将 theme 选项的值改为 next，注意要在属性和值之间要加上一个空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>此时，登陆自己的站点，应该可以看到更改已经成功</p>
<h1 id="NexT-配置"><a href="#NexT-配置" class="headerlink" title="NexT 配置"></a>NexT 配置</h1><h2 id="设置Scheme"><a href="#设置Scheme" class="headerlink" title="设置Scheme"></a>设置Scheme</h2><p>Scheme 是用于 改变网站布局 的一个设置项，NexT 目前提供四种 Scheme：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Muse ：默认 Scheme，黑白主调，大量留白</span><br><span class="line">Mist：Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">Pisces：双栏 Scheme，小家碧玉的清新</span><br><span class="line">Gemini：新增 Scheme</span><br></pre></td></tr></table></figure>
<p>更改时，打开 主题配置文件，通过搜索关键字 Scheme Settings 定位，然后将使用的 scheme 打开注释即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h2 id="设置动态背景"><a href="#设置动态背景" class="headerlink" title="设置动态背景"></a>设置动态背景</h2><p>更改时，打开 主题配置文件，通过搜索关键字 Canvas-nest 定位，然后将 canvas_nest 的值改成 true 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure>


<h2 id="设置侧栏行为"><a href="#设置侧栏行为" class="headerlink" title="设置侧栏行为"></a>设置侧栏行为</h2><p>默认情况下，侧栏仅在文章页面（拥有目录列表时）才显示，并放置于右侧位置</p>
<p>可以通过修改 主题配置文件 中的 Sidebar Settings 字段控制侧栏的行为</p>
<p>（1）侧栏位置：position<br>left：靠左放置;<br>right：靠右放置;</p>
<p>（2）侧栏显示时机：display<br>post：默认行为，在文章页面（拥有目录列表时）显示;<br>always：在所有页面中都显示;<br>hide：在所有页面中都隐藏;<br>remove：完全移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">position: left</span><br><span class="line">#position: right</span><br><span class="line"></span><br><span class="line"># Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line">#  - post    expand on posts automatically. Default.</span><br><span class="line">#  - always  expand for all pages automatically</span><br><span class="line">#  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">#  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line">display: post</span><br><span class="line">#display: always</span><br><span class="line">#display: hide</span><br><span class="line">#display: remove</span><br></pre></td></tr></table></figure>


<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><p>（1）设置菜单项</p>
<p>打开 主题配置文件，搜索关键字 Menu Settings 进行定位，各个菜单项通过 # 注释开启或关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running the site in a subdirectory (e.g. domain.tld&#x2F;blog), remove the leading slash from link value (&#x2F;archives -&gt; archives).</span><br><span class="line"># Usage: &#96;Key: &#x2F;link&#x2F; || icon&#96;</span><br><span class="line"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span><br><span class="line"># Value before &#96;||&#96; delimeter is the target link.</span><br><span class="line"># Value after &#96;||&#96; delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>
<p>部分菜单项的功能描述如下：<br>home：主页;about：关于;tags：标签;categories：分类;archives：归档;</p>
<p>菜单具体 参看002</p>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>打开 主题配置文件， 搜索关键字 Sidebar Avatar 进行定位，将 avatar 的值设置成头像图片的链接地址即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class="line"># in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class="line">avatar: &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>头像图片的链接地址可以是：  </p>
<ul>
<li>完整的互联网地址：例如，<a href="https://www.example.com/avatar.jpg" target="_blank" rel="noopener">https://www.example.com/avatar.jpg</a></li>
<li>站点内的相对地址：例如，假设图片命名为 avatar.jpg，存放在 source/images/ 目录下，则链接地址可以写成 /images/avatar.jpg</li>
</ul>
<h2 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h2><p>打开 主题配置文件，搜索关键字 Social Links 进行定位，social 的值按 Key: permalink || icon 格式设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Social Links.</span><br><span class="line"># Usage: &#96;Key: permalink || icon&#96;</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before &#96;||&#96; delimeter is the target permalink.</span><br><span class="line"># Value after &#96;||&#96; delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;Forwhfang || Github</span><br><span class="line">  CSDN: https:&#x2F;&#x2F;blog.csdn.net&#x2F;wsmrzx || CSDN</span><br><span class="line">  cnblogs: https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wsmrzx || cnblogs</span><br></pre></td></tr></table></figure>


<h2 id="添加文字统计功能"><a href="#添加文字统计功能" class="headerlink" title="添加文字统计功能"></a>添加文字统计功能</h2><p>进入 站点根目录，打开 git bash 窗口，输入如下命令安装插件<br><code>pm install hexo-wordcount --save</code><br>然后打开 主题配置文件，进行如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;willin&#x2F;hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure>


<h2 id="添加阅读量统计功能"><a href="#添加阅读量统计功能" class="headerlink" title="添加阅读量统计功能"></a>添加阅读量统计功能</h2><p>在 主题配置文件 中修改 busuanzi_count 字段启用不蒜子统计功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_uv_footer: </span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_pv_footer: </span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure>
<p>【参考资料】</p>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">iissnan/hexo-theme-start</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="noopener">iissnan/hexo-theme-next</a></li>
<li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">third-party-services</a></li>
<li><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">hexo.io/plugins</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>003-模板-scaffolds、permalink永久链接</title>
    <url>/articles/20200129/5c36d9d6.html</url>
    <content><![CDATA[<p>模板以scaffolds/post.md为例，对updated、permalink等参数进行说明</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="scaffolds-post-md-说明"><a href="#scaffolds-post-md-说明" class="headerlink" title="scaffolds\post.md 说明"></a>scaffolds\post.md 说明</h2><p>打开.\scaffolds\post.md文件，默认参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>当我们在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new ABC</span><br></pre></td></tr></table></figure>
<p>则会在.\source_post\目录下产生一个ABC.md文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: ABC</span><br><span class="line">date: 2015-12-29 20:20:47</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="permalink设置"><a href="#permalink设置" class="headerlink" title="permalink设置"></a>permalink设置</h2><p>修改.\scaffolds\post.md，增加一个permalink属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">permalink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>让permalink为空，则Hexo会使用默认设置。默认设置是什么呢？就是你的根目录下的_config.yml中定义好的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;blog.bjlhx.top</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>
<p>:year表示年份，:month表示月份，:date表示日期。最终的展示效果为<a href="https://likianta.coding.me/2017/09/04/title/这种形式。" target="_blank" rel="noopener">https://likianta.coding.me/2017/09/04/title/这种形式。</a></p>
<p>方式一、可以把图中的斜杠改为短横线，效果会变成<a href="https://likianta.coding.me/2017-09-04/title/。" target="_blank" rel="noopener">https://likianta.coding.me/2017-09-04/title/。</a></p>
<p>方式二、将默认设置改成了permalink: :year/:category/:title，其最终的网址就是<a href="https://likianta.coding.me/2017/xx分组/xx标题。" target="_blank" rel="noopener">https://likianta.coding.me/2017/xx分组/xx标题。</a></p>
<p>分类设置:参看上文</p>
<p>另外需要注意的是，.\scaffolds\post.md中的permalink请一定要留空。</p>
<p>官网中虽然说.\scaffolds\post.md中的permalink内容可以覆盖根目录的默认设置，但实测发现会引起网址bug。</p>
<p>比如说你在.\scaffolds\post.md中修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :year:month&#x2F;:title</span><br></pre></td></tr></table></figure>

<p>Hexo会误把它当成一个字符串进行解析，结果就会生成：<a href="https://likianta.coding.me/2017/09/04/:year:month/:title/（一个错误的URL路径）。" target="_blank" rel="noopener">https://likianta.coding.me/2017/09/04/:year:month/:title/（一个错误的URL路径）。</a></p>
<p>不过如果我们在具体的文章中手动写上的话是不会报错的：</p>
<p>.\source_post\ABC.md:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 003-scaffolds.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">permalink: https:&#x2F;&#x2F;bjlhx.top&#x2F;2020&#x2F;01&#x2F;29&#x2F;ABC&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="Hexo-abbrlink生成唯一永久文章链接"><a href="#Hexo-abbrlink生成唯一永久文章链接" class="headerlink" title="Hexo-abbrlink生成唯一永久文章链接"></a>Hexo-abbrlink生成唯一永久文章链接</h3><p>hexo-next文章链接默认的生成规则是：:year/:month/:day/:title，是按照年、月、日、标题来生成的。</p>
<p>如果文章标题是中文的话，URL链接是也会是中文，</p>
<p>方案一、使用hexo-permalink-pinyin插件，将中文转英文</p>
<p>缺陷，比如修改了文章标题，重新hexo三连后，URL就变了，以前的文章地址变成了404。而且这样生成的URL层级也很深，不利于SEO。</p>
<p>方案二、Hexo-abbrlink</p>
<p>一、不用增加属性，也不用考虑分类中文化的问题。二、URL层级更短，更利于SEO。(一般SEO只爬三层)</p>
<p>在执行 <code>hexo g</code> 的时候根据 文件内的title 生成CRC，为了降低碰撞，建议文件内的title，date最好修改</p>
<p>并且 URL ：articles/:abbrlink.html 可设置为：<code>articles/:year:month:day/:abbrlink.html</code></p>
<ol>
<li>插件安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li>
<li>配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">articles/:year:month:day/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">    <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure>
生成的链接将会是这样的(官方样例)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br></pre></td></tr></table></figure>
生成完后，原md文件的Front-matter 内会增加abbrlink 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>002-命令new-页面分类标签</title>
    <url>/articles/20200129/1a1ce396.html</url>
    <content><![CDATA[<p>hexo new 命令使用：创建普通页面、创建”分类”选项、创建“标签”选项</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] title</span><br></pre></td></tr></table></figure>
<p>创建一个新文章。如果未提供布局，则Hexo将使用_config.yml中的default_layout: post。如果标题包含空格，请用引号引起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Option	Description</span><br><span class="line">-p, --path	Post path. Customize the path of the post.</span><br><span class="line">-r, --replace	Replace the current post if existed.</span><br><span class="line">-s, --slug	Post slug. Customize the URL of the post.</span><br></pre></td></tr></table></figure>
<h2 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h2><p>默认情况下，Hexo将使用标题定义文件的路径。对于页面，它将创建该名称的目录以及其中的index.md文件。使用–path选项覆盖该行为并定义文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">"About me"</span></span><br></pre></td></tr></table></figure>
<p>将创建源/about/me.md文件，文件的标题设置为“关于我”。 请注意，标题是必填项。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建普通页面"><a href="#创建普通页面" class="headerlink" title="创建普通页面"></a>创建普通页面</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br><span class="line">或</span><br><span class="line">hexo new post <span class="string">"My New Post 2"</span></span><br></pre></td></tr></table></figure>

<h2 id="创建”分类”选项"><a href="#创建”分类”选项" class="headerlink" title="创建”分类”选项"></a>创建”分类”选项</h2><h3 id="生成“分类”页并添加tpye属性"><a href="#生成“分类”页并添加tpye属性" class="headerlink" title="生成“分类”页并添加tpye属性"></a>生成“分类”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>成功后，会有路径提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="built_in">source</span>/categories/index.md</span><br></pre></td></tr></table></figure>
<p>打开 index.md 修改如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存关闭即可。主要是为了生存的分类有超链接，不执行此步，也会有分类，但是点击分类时候，没有超链接</p>
<h3 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h3><p>打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 002-分类标签.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h2 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h2><h3 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>成功后会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/<span class="built_in">source</span>/tags/index.md</span><br></pre></td></tr></table></figure>
<p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：<br>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-01-29 17:41:12</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h3 id="给文章添加“tags”属性"><a href="#给文章添加“tags”属性" class="headerlink" title="给文章添加“tags”属性"></a>给文章添加“tags”属性</h3><p>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的 - hexo - hexo分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 002-分类标签.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- hexo分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。</p>
<p>其实，这两个的设置几乎一样！可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。</p>
<p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo分类</tag>
      </tags>
  </entry>
  <entry>
    <title>001-命令-服务、生成、部署、清理</title>
    <url>/articles/20200129/82195907.html</url>
    <content><![CDATA[<p>初始化代码库：<code>hexo init</code>；<br>本地服务运行 ：<code>hexo s</code>；生成静态文件：<code>hexo g</code>；部署远程站点：<code>hexo d</code>；清理缓存：<code>hexo clean</code></p>
<a id="more"></a>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="初始化代码库"><a href="#初始化代码库" class="headerlink" title="初始化代码库"></a>初始化代码库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>下载代码，因为 init 初始化需要一个空目录，否则报错</p>
<h3 id="本地服务运行"><a href="#本地服务运行" class="headerlink" title="本地服务运行"></a>本地服务运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="部署远程站点"><a href="#部署远程站点" class="headerlink" title="部署远程站点"></a>部署远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">或</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="命令用于清理缓存文件，是一个比较常用的命令"><a href="#命令用于清理缓存文件，是一个比较常用的命令" class="headerlink" title="命令用于清理缓存文件，是一个比较常用的命令"></a>命令用于清理缓存文件，是一个比较常用的命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>更过官方帮助：<br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br><a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a><br><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a><br><a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a><br><a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">commands</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础</title>
    <url>/articles/20190526/26856f5b.html</url>
    <content><![CDATA[<p>第一个测试程序</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
