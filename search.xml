<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>002-TIg集成一体化监控</title>
    <url>/articles/20200421/181299f3.html</url>
    <content><![CDATA[<p>通过TICK(Telegraf+Influxdb+Chronograf+Kapacitor)进行主机性能监控告警，职责描述如下：</p>
<p>Telegraf：数据采集，用于主机性能数据，包括主机CPU、内存、IO、进程状态、服务状态等<br>Influxdb的：时序数据库，用于存储Telegraf采集来的数据<br>grafana：数据可视化，用于将Influxdb数据库的性能数据时序展示：规则告警，用于配置告警规则将Influxdb数据库查询触发规则的数据进行告警</p>
<p>其中，时序数据库可使用刚开源的TDEngine，可视化可以使用Grafana替代使用</p>
<a id="more"></a>
<h2 id="概述-Telegraf、InfluxDB"><a href="#概述-Telegraf、InfluxDB" class="headerlink" title="概述-Telegraf、InfluxDB"></a>概述-Telegraf、InfluxDB</h2><p>参看：上文 001-TICK集成一体化监控</p>
<h2 id="可视化-2：Grafana"><a href="#可视化-2：Grafana" class="headerlink" title="可视化-2：Grafana"></a>可视化-2：Grafana</h2><p>一般可以使用 Grafana 替代 Chronograf +Kapacitor 组合</p>
<p>Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。它主要有以下六大特点：</p>
<p>1、展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式；</p>
<p>2、数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等；</p>
<p>3、通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知；</p>
<p>4、混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源；</p>
<p>5、注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记；</p>
<p>6、过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="原始安装"><a href="#原始安装" class="headerlink" title="原始安装"></a>原始安装</h4><p><a href="https://grafana.com/grafana/download" target="_blank" rel="noopener">https://grafana.com/grafana/download</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.grafana.com&#x2F;oss&#x2F;release&#x2F;grafana-6.7.2-1.x86_64.rpm</span><br><span class="line">sudo yum install grafana-6.7.2-1.x86_64.rpm</span><br><span class="line">systemctl start grafana-server</span><br></pre></td></tr></table></figure>
<h4 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h4><p>启动服务，打开浏览器，输入IP+端口，3000为Grafana的默认侦听端口。</p>
<p>系统默认用户名和密码为admin/admin，第一次登陆系统会要求修改密码，修改密码后登陆</p>
<h3 id="Grafana使用方法"><a href="#Grafana使用方法" class="headerlink" title="Grafana使用方法"></a>Grafana使用方法</h3><p>1、添加数据源</p>
<p>首先是添加数据源，点击左上角的grafana图标，示例如下：</p>
<p>PS：选择influxdb作为数据源，需要在influxdb中创建该用户以及对应的数据库！</p>
<p>2、创建DashBoard</p>
<p>创建好数据源之后，就需要创建DashBoard（仪表盘），可以自定义，也可以导入你需要的仪表盘，官方提供了很多的可选仪表盘。</p>
<p>BashBoard地址：<a href="https://grafana.com/dashboards?dataSource=influxdb" target="_blank" rel="noopener">https://grafana.com/dashboards?dataSource=influxdb</a><br>①、搜索对应仪表盘<br>②、选择对应的仪表盘ID<br>③、复制ID，填入导入界面<br>④、展示仪表盘</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>001-TICK集成一体化监控</title>
    <url>/articles/20200410/95a952d4.html</url>
    <content><![CDATA[<p>通过TICK(Telegraf+Influxdb+Chronograf+Kapacitor)进行主机性能监控告警，职责描述如下：</p>
<p>Telegraf：数据采集，用于主机性能数据，包括主机CPU、内存、IO、进程状态、服务状态等<br>Influxdb的：时序数据库，用于存储Telegraf采集来的数据<br>Chronograf：数据可视化，用于将Influxdb数据库的性能数据时序展示<br>Kapacitor：规则告警，用于配置告警规则将Influxdb数据库查询触发规则的数据进行告警</p>
<p>其中，时序数据库可使用刚开源的TDEngine，可视化可以使用Grafana替代使用</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 数据采集：Telegraf 和 数据存储：InfluxDB</p>
<p>下载地址：<br><a href="https://portal.influxdata.com/downloads/" target="_blank" rel="noopener">https://portal.influxdata.com/downloads/</a></p>
<p>环境：CentOS7.4 64位</p>
<p>在平台监控系统中，可以使用 Telegraf 采集多种组件的运行信息，而不需要自己手写脚本定时采集，大大降低数据获取的难度；且 Telegraf 配置极为简单，只要有基本的 Linux 基础即可快速上手。Telegraf 按照时间序列采集数据，数据结构中包含时序信息，时序数据库就是为此类数据设计而来，使用 Influxdb 可以针采集得到的数据完成各种分析计算操作。</p>
<h3 id="为什么要用telegraf和influxdb？"><a href="#为什么要用telegraf和influxdb？" class="headerlink" title="为什么要用telegraf和influxdb？"></a>为什么要用telegraf和influxdb？</h3><p>①、在数据采集和平台监控系统中，Telegraf 可以采集多种组件的运行信息，而不需要自己手写脚本定时采集，降低数据获取的难度；</p>
<p>②、Telegraf 配置简单，只要有基本的 Linux 基础即可快速上手；</p>
<p>③、Telegraf 按照时间序列采集数据，数据结构中包含时序信息，influxdb就是为此类数据设计而来，使用 Influxdb 可以针采集得到的数据完成各种分析计算操作；</p>
<h2 id="数据采集：Telegraf"><a href="#数据采集：Telegraf" class="headerlink" title="数据采集：Telegraf"></a>数据采集：Telegraf</h2><p>Telegraf 是一个用 Go 编写的代理程序，可收集系统和服务的统计数据，并写入到 InfluxDB 数据库。内存占用小，通过插件系统可轻松添加支持其他服务的扩展。</p>
<p>Telegraf 是收集和报告指标和数据的代理。</p>
<p>Telegraf是TICK Stack的一部分，是一个插件驱动的服务器代理，用于收集和报告指标。</p>
<p>Telegraf 集成了直接从其运行的容器和系统中提取各种指标，事件和日志，从第三方API提取指标，甚至通过StatsD和Kafka消费者服务监听指标。</p>
<p>它还具有输出插件，可将指标发送到各种其他数据存储，服务和消息队列，包括InfluxDB，Graphite，OpenTSDB，Datadog，Librato，Kafka，MQTT，NSQ等等。</p>
<p>常用的输入插件（mysql、redis、prometheus）配置可参见 附录说明</p>
<p>Telegraf由4个独立的插件驱动</p>
<p>Input Plugins：输入插件，收集系统、服务、第三方组件的数据<br>Processor Plugins：处理插件，转换、处理、过滤数据<br>Aggregator Plugins：聚合插件，数据特征聚合<br>Output Plugins：输出插件，写metrics数据</p>
<p>相比zabbix，对主流开源应用的探测支持的更好，并且无需安装agent。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.influxdata.com&#x2F;telegraf&#x2F;releases&#x2F;telegraf-1.14.1-1.x86_64.rpm</span><br><span class="line">rpm -ivh telegraf-1.14.1-1.x86_64.rpm</span><br><span class="line">systemctl start telegraf</span><br></pre></td></tr></table></figure>

<h2 id="数据存储：InfluxDB"><a href="#数据存储：InfluxDB" class="headerlink" title="数据存储：InfluxDB"></a>数据存储：InfluxDB</h2><p>Influxdb 是一个开源的分布式时序、时间和指标数据库，使用 Go 语言编写，无需外部依赖。Influxdb 有如下三大特性：</p>
<p>①、基于时间序列(Time Series)，支持与时间有关的相关函数（如最大，最小，求和等）；</p>
<p>②、可度量性（Metrics）：你可以实时对大量数据进行计算；</p>
<p>③、基于事件（Event）：它支持任意的事件数据；</p>
<h3 id="安装使用-1"><a href="#安装使用-1" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.8.0.x86_64.rpm</span><br><span class="line">rpm -ivh influxdb-1.8.0.x86_64.rpm</span><br><span class="line">systemctl start influxd </span><br><span class="line"><span class="comment"># 检测</span></span><br><span class="line">curl <span class="string">"http://localhost:8086/query?q=show+databases"</span></span><br></pre></td></tr></table></figure>

<h3 id="创建-Influxdb-用户和数据库"><a href="#创建-Influxdb-用户和数据库" class="headerlink" title="创建 Influxdb 用户和数据库"></a>创建 Influxdb 用户和数据库</h3><p>上述服务启动后，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入数据库</span></span><br><span class="line">influx</span><br><span class="line"><span class="comment"># Connected to http://localhost:8086 version 1.8.0</span></span><br><span class="line"><span class="comment"># InfluxDB shell version: 1.8.0</span></span><br><span class="line">create user <span class="string">"telegraf"</span> with password <span class="string">'password'</span></span><br><span class="line">show users</span><br><span class="line"><span class="comment"># user     admin</span></span><br><span class="line"><span class="comment"># ----     -----</span></span><br><span class="line"><span class="comment"># telegraf false</span></span><br><span class="line">create database telegraf</span><br><span class="line">show databases</span><br><span class="line"><span class="comment"># name: databases</span></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line"><span class="comment"># ----</span></span><br><span class="line"><span class="comment"># telegraf</span></span><br><span class="line"><span class="comment"># _internal</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Telegraf-监听本机cpu信息"><a href="#配置Telegraf-监听本机cpu信息" class="headerlink" title="配置Telegraf 监听本机cpu信息"></a>配置Telegraf 监听本机cpu信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/telegraf/telegraf.conf</span><br><span class="line">   <span class="comment">## 修改内容如下： </span></span><br><span class="line">   [[outputs.influxdb]]</span><br><span class="line">     urls = [<span class="string">"http://localhost:8086"</span>] <span class="comment"># required </span></span><br><span class="line">     database = <span class="string">"telegraf"</span> <span class="comment"># required</span></span><br><span class="line">     retention_policy = <span class="string">""</span></span><br><span class="line">     precision = <span class="string">"s"</span></span><br><span class="line">     timeout = <span class="string">"5s"</span></span><br><span class="line">     username = <span class="string">"telegraf"</span></span><br><span class="line">     password = <span class="string">"password"</span></span><br></pre></td></tr></table></figure>
<p>systemctl restart telegraf</p>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>vim /etc/influxdb/influxdb.conf</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.8/administration/config/" target="_blank" rel="noopener">https://docs.influxdata.com/influxdb/v1.8/administration/config/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局配置</span><br><span class="line"></span><br><span class="line">reporting-disabled &#x3D; false  # 该选项用于上报influxdb的使用信息给InfluxData公司，默认值为false</span><br><span class="line">bind-address &#x3D; &quot;:8088&quot;  # 备份恢复时使用，默认值为8088</span><br><span class="line"></span><br><span class="line">1、meta相关配置</span><br><span class="line"></span><br><span class="line">[meta]</span><br><span class="line">dir &#x3D; &quot;&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;meta&quot;  # meta数据存放目录</span><br><span class="line">retention-autocreate &#x3D; true  # 用于控制默认存储策略，数据库创建时，会自动生成autogen的存储策略，默认值：true</span><br><span class="line">logging-enabled &#x3D; true  # 是否开启meta日志，默认值：true</span><br><span class="line"></span><br><span class="line">2、data相关配置</span><br><span class="line"></span><br><span class="line">[data]</span><br><span class="line">dir &#x3D; &quot;&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;data&quot;  # 最终数据（TSM文件）存储目录</span><br><span class="line">wal-dir &#x3D; &quot;&#x2F;var&#x2F;lib&#x2F;influxdb&#x2F;wal&quot;  # 预写日志存储目录</span><br><span class="line">query-log-enabled &#x3D; true  # 是否开启tsm引擎查询日志，默认值： true</span><br><span class="line">cache-max-memory-size &#x3D; 1048576000  # 用于限定shard最大值，大于该值时会拒绝写入，默认值：1000MB，单位：byte</span><br><span class="line">cache-snapshot-memory-size &#x3D; 26214400  # 用于设置快照大小，大于该值时数据会刷新到tsm文件，默认值：25MB，单位：byte</span><br><span class="line">cache-snapshot-write-cold-duration &#x3D; &quot;10m&quot;  # tsm引擎 snapshot写盘延迟，默认值：10Minute</span><br><span class="line">compact-full-write-cold-duration &#x3D; &quot;4h&quot;  # tsm文件在压缩前可以存储的最大时间，默认值：4Hour</span><br><span class="line">max-series-per-database &#x3D; 1000000  # 限制数据库的级数，该值为0时取消限制，默认值：1000000</span><br><span class="line">max-values-per-tag &#x3D; 100000  # 一个tag最大的value数，0取消限制，默认值：100000</span><br><span class="line"></span><br><span class="line">3、coordinator查询管理的配置选项</span><br><span class="line"></span><br><span class="line">[coordinator]</span><br><span class="line">write-timeout &#x3D; &quot;10s&quot;  # 写操作超时时间，默认值： 10s</span><br><span class="line">max-concurrent-queries &#x3D; 0  # 最大并发查询数，0无限制，默认值： 0</span><br><span class="line">query-timeout &#x3D; &quot;0s  # 查询操作超时时间，0无限制，默认值：0s</span><br><span class="line">log-queries-after &#x3D; &quot;0s&quot;  # 慢查询超时时间，0无限制，默认值：0s</span><br><span class="line">max-select-point &#x3D; 0  # SELECT语句可以处理的最大点数（points），0无限制，默认值：0</span><br><span class="line">max-select-series &#x3D; 0  # SELECT语句可以处理的最大级数（series），0无限制，默认值：0</span><br><span class="line">max-select-buckets &#x3D; 0  # SELECT语句可以处理的最大&quot;GROUP BY time()&quot;的时间周期，0无限制，默认值：0</span><br><span class="line"></span><br><span class="line">4、retention旧数据的保留策略</span><br><span class="line"></span><br><span class="line">[retention]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ： true</span><br><span class="line">check-interval &#x3D; &quot;30m&quot;  # 检查时间间隔，默认值 ：&quot;30m&quot;</span><br><span class="line"></span><br><span class="line">5、shard-precreation分区预创建</span><br><span class="line"></span><br><span class="line">[shard-precreation]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ： true</span><br><span class="line">check-interval &#x3D; &quot;10m&quot;  # 检查时间间隔，默认值 ：&quot;10m&quot;</span><br><span class="line">advance-period &#x3D; &quot;30m&quot;  # 预创建分区的最大提前时间，默认值 ：&quot;30m&quot;</span><br><span class="line"></span><br><span class="line">6、monitor 控制InfluxDB自有的监控系统。 默认情况下，InfluxDB把这些数据写入_internal 数据库，如果这个库不存在则自动创建。 _internal 库默认的retention策略是7天，如果你想使用一个自己的retention策略，需要自己创建。</span><br><span class="line"></span><br><span class="line">[monitor]</span><br><span class="line">store-enabled &#x3D; true  # 是否启用该模块，默认值 ：true</span><br><span class="line">store-database &#x3D; &quot;_internal&quot;  # 默认数据库：&quot;_internal&quot;</span><br><span class="line">store-interval &#x3D; &quot;10s  # 统计间隔，默认值：&quot;10s&quot;</span><br><span class="line"></span><br><span class="line">7、admin web管理页面[1.3界面已删除使用 1：chronograf]</span><br><span class="line"></span><br><span class="line">[admin]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ： false</span><br><span class="line">bind-address &#x3D; &quot;:8083&quot;  # 绑定地址，默认值 ：&quot;:8083&quot;</span><br><span class="line">https-enabled &#x3D; false  # 是否开启https ，默认值 ：false</span><br><span class="line">https-certificate &#x3D; &quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;  # https证书路径，默认值：&quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;</span><br><span class="line"></span><br><span class="line">8、http API</span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ：true</span><br><span class="line">bind-address &#x3D; &quot;:8086&quot;  # 绑定地址，默认值：&quot;:8086&quot;</span><br><span class="line">auth-enabled &#x3D; false  # 是否开启认证，默认值：false</span><br><span class="line">realm &#x3D; &quot;InfluxDB&quot;  # 配置JWT realm，默认值: &quot;InfluxDB&quot;</span><br><span class="line">log-enabled &#x3D; true  # 是否开启日志，默认值：true</span><br><span class="line">write-tracing &#x3D; false  # 是否开启写操作日志，如果置成true，每一次写操作都会打日志，默认值：false</span><br><span class="line">pprof-enabled &#x3D; true  # 是否开启pprof，默认值：true</span><br><span class="line">https-enabled &#x3D; false  # 是否开启https，默认值：false</span><br><span class="line">https-certificate &#x3D; &quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;  # 设置https证书路径，默认值：&quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;</span><br><span class="line">https-private-key &#x3D; &quot;&quot;  # 设置https私钥，无默认值</span><br><span class="line">shared-secret &#x3D; &quot;&quot;  # 用于JWT签名的共享密钥，无默认值</span><br><span class="line">max-row-limit &#x3D; 0  # 配置查询返回最大行数，0无限制，默认值：0</span><br><span class="line">max-connection-limit &#x3D; 0  # 配置最大连接数，0无限制，默认值：0</span><br><span class="line">unix-socket-enabled &#x3D; false  # 是否使用unix-socket，默认值：false</span><br><span class="line">bind-socket &#x3D; &quot;&#x2F;var&#x2F;run&#x2F;influxdb.sock&quot;  # unix-socket路径，默认值：&quot;&#x2F;var&#x2F;run&#x2F;influxdb.sock&quot;</span><br><span class="line"></span><br><span class="line">9、subscriber 控制Kapacitor接受数据的配置</span><br><span class="line"></span><br><span class="line">[subscriber]</span><br><span class="line">enabled &#x3D; true  # 是否启用该模块，默认值 ：true</span><br><span class="line">http-timeout &#x3D; &quot;30s&quot;  # http超时时间，默认值：&quot;30s&quot;</span><br><span class="line">insecure-skip-verify &#x3D; false  # 是否允许不安全的证书</span><br><span class="line">ca-certs &#x3D; &quot;&quot;  # 设置CA证书</span><br><span class="line">write-concurrency &#x3D; 40  # 设置并发数目，默认值：40</span><br><span class="line">write-buffer-size &#x3D; 1000  # 设置buffer大小，默认值：1000</span><br><span class="line"></span><br><span class="line">10、graphite 相关配置</span><br><span class="line"></span><br><span class="line">[[graphite]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值 ：false</span><br><span class="line">database &#x3D; &quot;graphite&quot;  # 数据库名称，默认值：&quot;graphite&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">bind-address &#x3D; &quot;:2003&quot;  # 绑定地址，默认值：&quot;:2003&quot;</span><br><span class="line">protocol &#x3D; &quot;tcp&quot;  # 协议，默认值：&quot;tcp&quot;</span><br><span class="line">consistency-level &#x3D; &quot;one&quot;  # 一致性级别，默认值：&quot;one</span><br><span class="line">batch-size &#x3D; 5000  # 批量size，默认值：5000</span><br><span class="line">batch-pending &#x3D; 10  # 配置在内存中等待的batch数，默认值：10</span><br><span class="line">batch-timeout &#x3D; &quot;1s&quot;  # 超时时间，默认值：&quot;1s&quot;</span><br><span class="line">udp-read-buffer &#x3D; 0  # udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。 该配置的默认值：0</span><br><span class="line">separator &#x3D; &quot;.&quot;  # 多个measurement间的连接符，默认值： &quot;.&quot;</span><br><span class="line"></span><br><span class="line">11、collectd</span><br><span class="line"></span><br><span class="line">[[collectd]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值 ：false</span><br><span class="line">bind-address &#x3D; &quot;:25826&quot;  # 绑定地址，默认值： &quot;:25826&quot;</span><br><span class="line">database &#x3D; &quot;collectd&quot;  # 数据库名称，默认值：&quot;collectd&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">typesdb &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;share&#x2F;collectd&quot;  # 路径，默认值：&quot;&#x2F;usr&#x2F;share&#x2F;collectd&#x2F;types.db&quot;</span><br><span class="line">auth-file &#x3D; &quot;&#x2F;etc&#x2F;collectd&#x2F;auth_file&quot;</span><br><span class="line">batch-size &#x3D; 5000</span><br><span class="line">batch-pending &#x3D; 10</span><br><span class="line">batch-timeout &#x3D; &quot;10s&quot;</span><br><span class="line">read-buffer &#x3D; 0  # udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。默认值：0</span><br><span class="line"></span><br><span class="line">12、opentsdb</span><br><span class="line"></span><br><span class="line">[[opentsdb]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值：false</span><br><span class="line">bind-address &#x3D; &quot;:4242&quot;  # 绑定地址，默认值：&quot;:4242&quot;</span><br><span class="line">database &#x3D; &quot;opentsdb&quot;  # 默认数据库：&quot;opentsdb&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">consistency-level &#x3D; &quot;one&quot;  # 一致性级别，默认值：&quot;one&quot;</span><br><span class="line">tls-enabled &#x3D; false  # 是否开启tls，默认值：false</span><br><span class="line">certificate&#x3D; &quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;  # 证书路径，默认值：&quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem&quot;</span><br><span class="line">log-point-errors &#x3D; true  # 出错时是否记录日志，默认值：true</span><br><span class="line">batch-size &#x3D; 1000</span><br><span class="line">batch-pending &#x3D; 5</span><br><span class="line">batch-timeout &#x3D; &quot;1s&quot;</span><br><span class="line"></span><br><span class="line">13、udp</span><br><span class="line"></span><br><span class="line">[[udp]]</span><br><span class="line">enabled &#x3D; false  # 是否启用该模块，默认值：false</span><br><span class="line">bind-address &#x3D; &quot;:8089&quot;  # 绑定地址，默认值：&quot;:8089&quot;</span><br><span class="line">database &#x3D; &quot;udp&quot;  # 数据库名称，默认值：&quot;udp&quot;</span><br><span class="line">retention-policy &#x3D; &quot;&quot;  # 存储策略，无默认值</span><br><span class="line">batch-size &#x3D; 5000</span><br><span class="line">batch-pending &#x3D; 10</span><br><span class="line">batch-timeout &#x3D; &quot;1s&quot;</span><br><span class="line">read-buffer &#x3D; 0  # udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。 该配置的默认值：0</span><br><span class="line">　</span><br><span class="line">14、continuous_queries</span><br><span class="line"></span><br><span class="line">[continuous_queries]</span><br><span class="line">enabled &#x3D; true  # enabled 是否开启CQs，默认值：true</span><br><span class="line">log-enabled &#x3D; true  # 是否开启日志，默认值：true</span><br><span class="line">run-interval &#x3D; &quot;1s&quot;  # 时间间隔，默认值：&quot;1s&quot;</span><br></pre></td></tr></table></figure>

<p>telegraph会和influxDB的HTTP APi通信来写入数据。</p>
<h2 id="可视化-1：chronograf"><a href="#可视化-1：chronograf" class="headerlink" title="可视化-1：chronograf"></a>可视化-1：chronograf</h2><p>influxdb 在1.3之后取消web 界面后 使用的一个新的管理界面<br>Chronograf是InfluxData的TICK堆栈的用户界面组件。它使您的基础架构的监控和警报易于设置和维护。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.influxdata.com&#x2F;chronograf&#x2F;releases&#x2F;chronograf-1.8.2.x86_64.rpm</span><br><span class="line">rpm -ivh chronograf-1.8.2.x86_64.rpm</span><br><span class="line">systemctl start chronograf</span><br></pre></td></tr></table></figure>
<p>修改配置启动：<br>vim /etc/influxdb/influxdb.conf<br>基础配置<br><a href="http://116.198.1.1:8888/" target="_blank" rel="noopener">http://116.198.1.1:8888/</a></p>
<p>查看界面输入基础数据库连接即可</p>
<p>一个操作界面。</p>
<h2 id="规则告警：Kapacitor"><a href="#规则告警：Kapacitor" class="headerlink" title="规则告警：Kapacitor"></a>规则告警：Kapacitor</h2><p>Kapacitor是TICK堆栈的数据处理平台。Kapacitor负责在Chronograf中创建和发送警报。</p>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.influxdata.com/kapacitor/releases/kapacitor-1.5.4-1.x86_64.rpm</span><br><span class="line">yum localinstall kapacitor-1.5.4-1.x86_64.rpm</span><br><span class="line">systemctl start kapacitor</span><br><span class="line">kapacitor list tasks</span><br><span class="line"><span class="comment"># ID Type      Status    Executing Databases and Retention Policies</span></span><br></pre></td></tr></table></figure>

<p>对于Kapacitor URL，输入运行Kapacitor的计算机的主机名或IP，并确保包含Kapacitor的默认端口：9092。<br>接下来，命名连接字符串; 这可以是你想要的任何东西。由于在Kapacitor的默认配置中禁用了授权，因此无需为Username和Password输入输入任何信息。最后，点击Connect。</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>004-tools-chrome插件开发</title>
    <url>/articles/20200323/bb0aad89.html</url>
    <content><![CDATA[<p>概述:004-tools-chrome插件开发</p>
<a id="more"></a>
<h1 id="什么是Chrome插件"><a href="#什么是Chrome插件" class="headerlink" title="什么是Chrome插件"></a>什么是Chrome插件</h1><pre><code>叫Chrome扩展(Chrome Extension)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯。</code></pre><p>Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包.</p>
<p>另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。<br>helper.dll</p>
<p>由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。</p>
<h2 id="开发Chrome插件意义"><a href="#开发Chrome插件意义" class="headerlink" title="开发Chrome插件意义"></a>开发Chrome插件意义</h2><p>Chrome插件提供了很多实用API供我们使用，包括但不限于：<br>书签控制；下载控制；窗口控制；标签控制；网络请求控制，各类事件监听；自定义原生菜单；完善的通信机制；</p>
<h1 id="开发与调试"><a href="#开发与调试" class="headerlink" title="开发与调试"></a>开发与调试</h1><p>Chrome插件没有严格的项目结构要求，只要保证本目录有一个manifest.json即可，也不需要专门的IDE，普通的web开发工具即可。</p>
<p>从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 chrome://extensions 访问。</p>
<p>勾选开发者模式即可以文件夹的形式直接加载插件，否则只能安装.crx格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把crx文件解压，然后通过开发者模式直接加载。<br>开发者模式：一般是打开扩展工具后，右上角有个开关</p>
<p>开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下Ctrl+R即可，以防万一最好还把页面刷新一下。</p>
<h1 id="核心开发"><a href="#核心开发" class="headerlink" title="核心开发"></a>核心开发</h1><h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p>这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。</p>
<p>下面给出的是一些常见的配置项，均有中文注释，<a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="noopener">完整的配置文档</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 清单文件的版本，这个必须写，而且必须是2</span></span><br><span class="line">	<span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="comment">// 插件的名称</span></span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"demo"</span>,</span><br><span class="line">	<span class="comment">// 插件的版本</span></span><br><span class="line">	<span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">	<span class="comment">// 插件描述</span></span><br><span class="line">	<span class="attr">"description"</span>: <span class="string">"简单的Chrome扩展demo"</span>,</span><br><span class="line">	<span class="comment">// 图标，一般偷懒全部用一个尺寸的也没问题</span></span><br><span class="line">	<span class="attr">"icons"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"16"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="attr">"48"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="attr">"128"</span>: <span class="string">"img/icon.png"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line">	<span class="attr">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">		<span class="attr">"page"</span>: <span class="string">"background.html"</span></span><br><span class="line">		<span class="comment">//"scripts": ["js/background.js"]</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 浏览器右上角图标设置，browser_action、page_action、app必须三选一</span></span><br><span class="line">	<span class="attr">"browser_action"</span>: </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line">		<span class="attr">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">		<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 当某些特定页面打开才显示的图标</span></span><br><span class="line">	<span class="comment">/*"page_action":</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		"default_icon": "img/icon.png",</span></span><br><span class="line"><span class="comment">		"default_title": "我是pageAction",</span></span><br><span class="line"><span class="comment">		"default_popup": "popup.html"</span></span><br><span class="line"><span class="comment">	&#125;,*/</span></span><br><span class="line">	<span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line">	<span class="attr">"content_scripts"</span>: </span><br><span class="line">	[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//"matches": ["http://*/*", "https://*/*"],</span></span><br><span class="line">			<span class="comment">// "&lt;all_urls&gt;" 表示匹配所有地址</span></span><br><span class="line">			<span class="attr">"matches"</span>: [<span class="string">"&lt;all_urls&gt;"</span>],</span><br><span class="line">			<span class="comment">// 多个JS按顺序注入</span></span><br><span class="line">			<span class="attr">"js"</span>: [<span class="string">"js/jquery-1.8.3.js"</span>, <span class="string">"js/content-script.js"</span>],</span><br><span class="line">			<span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line">			<span class="attr">"css"</span>: [<span class="string">"css/custom.css"</span>],</span><br><span class="line">			<span class="comment">// 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line">			<span class="attr">"run_at"</span>: <span class="string">"document_start"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// 这里仅仅是为了演示content-script可以配置多个规则</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"matches"</span>: [<span class="string">"*://*/*.png"</span>, <span class="string">"*://*/*.jpg"</span>, <span class="string">"*://*/*.gif"</span>, <span class="string">"*://*/*.bmp"</span>],</span><br><span class="line">			<span class="attr">"js"</span>: [<span class="string">"js/show-image-content-size.js"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="comment">// 权限申请</span></span><br><span class="line">	<span class="attr">"permissions"</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">"contextMenus"</span>, <span class="comment">// 右键菜单</span></span><br><span class="line">		<span class="string">"tabs"</span>, <span class="comment">// 标签</span></span><br><span class="line">		<span class="string">"notifications"</span>, <span class="comment">// 通知</span></span><br><span class="line">		<span class="string">"webRequest"</span>, <span class="comment">// web请求</span></span><br><span class="line">		<span class="string">"webRequestBlocking"</span>,</span><br><span class="line">		<span class="string">"storage"</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line">		<span class="string">"http://*/*"</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">		<span class="string">"https://*/*"</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">	],</span><br><span class="line">	<span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line">	<span class="attr">"web_accessible_resources"</span>: [<span class="string">"js/inject.js"</span>],</span><br><span class="line">	<span class="comment">// 插件主页，这个很重要，不要浪费了这个免费广告位</span></span><br><span class="line">	<span class="attr">"homepage_url"</span>: <span class="string">"https://www.baidu.com"</span>,</span><br><span class="line">	<span class="comment">// 覆盖浏览器默认页面</span></span><br><span class="line">	<span class="attr">"chrome_url_overrides"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 覆盖浏览器默认的新标签页</span></span><br><span class="line">		<span class="attr">"newtab"</span>: <span class="string">"newtab.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line">	<span class="attr">"options_page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">	<span class="comment">// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个</span></span><br><span class="line">	<span class="attr">"options_ui"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">		<span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line">		<span class="attr">"chrome_style"</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line">	<span class="attr">"omnibox"</span>: &#123; <span class="attr">"keyword"</span> : <span class="string">"go"</span> &#125;,</span><br><span class="line">	<span class="comment">// 默认语言</span></span><br><span class="line">	<span class="attr">"default_locale"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">	<span class="comment">// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line">	<span class="attr">"devtools_page"</span>: <span class="string">"devtools.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content-scripts"></a>content-scripts</h3><p>所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。</p>
<p>配置如上，特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'我被执行了！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种：</p>
<ul>
<li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li>
<li>chrome.i18n</li>
<li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li>
<li>chrome.storage</li>
</ul>
<p>常用API，非要调用其它API的话，可以通过通信来实现让background来帮你调用。</p>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p>
<p>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。</p>
<p>经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。</p>
<p>配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line">	<span class="attr">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">		<span class="attr">"page"</span>: <span class="string">"background.html"</span></span><br><span class="line">		<span class="comment">//"scripts": ["js/background.js"]</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别说明的是，虽然你可以通过chrome-extension://xxx/background.html直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个background.html，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。</p>
<h3 id="event-pages"><a href="#event-pages" class="headerlink" title="event-pages"></a>event-pages</h3><p>鉴于background生命周期太长，长时间挂载后台可能会影响性能，在配置文件上，它与background的唯一区别就是多了一个persistent参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"scripts"</span>: [<span class="string">"event-page.js"</span>],</span><br><span class="line">		<span class="attr">"persistent"</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。</p>
<p>一般情况下background也不会很消耗性能的。</p>
<h3 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h3><p>是点击browser_action或者page_action图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。<br>popup可以包含任意你想要的HTML内容，并且会自适应大小。可以通过default_popup字段来指定popup页面，也可以调用setPopup()方法。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"browser_action"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line">		<span class="attr">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">		<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。</p>
<p>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。</p>
<h3 id="js注入"><a href="#js注入" class="headerlink" title="js注入"></a>js注入</h3><p>指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？</p>
<p>这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。</p>
<p>在content-script中通过DOM方式向页面注入inject-script代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向页面注入JS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectCustomJs</span>(<span class="params">jsPath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jsPath = jsPath || <span class="string">'js/inject.js'</span>;</span><br><span class="line">	<span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">	temp.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span><br><span class="line">	<span class="comment">// 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js</span></span><br><span class="line">	temp.src = chrome.extension.getURL(jsPath);</span><br><span class="line">	temp.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 放在页面不好看，执行完后移除掉</span></span><br><span class="line">		<span class="keyword">this</span>.parentNode.removeChild(<span class="keyword">this</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">document</span>.head.appendChild(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接访问报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Denying load of chrome-extension:&#x2F;&#x2F;efbllncjkjiijkppagepehoekjojdclc&#x2F;js&#x2F;inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</span><br></pre></td></tr></table></figure>
<p>在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line">	<span class="attr">"web_accessible_resources"</span>: [<span class="string">"js/inject.js"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="homepage-url"><a href="#homepage-url" class="headerlink" title="homepage_url"></a>homepage_url</h3><p>开发者或者插件主页设置，一般会在如下2个地方显示：详细信息，开发者网站等</p>
<h1 id="Chrome插件的8种展示形式"><a href="#Chrome插件的8种展示形式" class="headerlink" title="Chrome插件的8种展示形式"></a>Chrome插件的8种展示形式</h1><h2 id="browserAction-浏览器右上角"><a href="#browserAction-浏览器右上角" class="headerlink" title="browserAction(浏览器右上角)"></a>browserAction(浏览器右上角)</h2><p>通过配置browser_action可以在浏览器的右上角增加一个图标，一个browser_action可以拥有一个图标，一个tooltip，一个badge和一个popup。</p>
<p>示例配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">"browser_action":</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">	<span class="attr">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">	<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>browser_action 图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中default_icon字段配置，也可以调用setIcon()方法。</p>
<h3 id="tooltip"><a href="#tooltip" class="headerlink" title="tooltip"></a>tooltip</h3><p>修改browser_action的manifest中default_title字段，或者调用setTitle()方法。</p>
<h3 id="badge"><a href="#badge" class="headerlink" title="badge"></a>badge</h3><p>所谓badge就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用setBadgeText()和setBadgeBackgroundColor()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.browserAction.setBadgeText(&#123;<span class="attr">text</span>: <span class="string">'new'</span>&#125;);</span><br><span class="line">chrome.browserAction.setBadgeBackgroundColor(&#123;<span class="attr">color</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="pageAction-地址栏右侧"><a href="#pageAction-地址栏右侧" class="headerlink" title="pageAction(地址栏右侧)"></a>pageAction(地址栏右侧)</h2><p>所谓pageAction，指的是只有当某些特定页面打开才显示的图标，它和browserAction最大的区别是一个始终都显示，一个只在特定情况才显示。</p>
<p>需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单：</p>
<p>而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项。</p>
<p>调整之后的pageAction我们可以简单地把它看成是可以置灰的browserAction。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.pageAction.show(tabId) 显示图标；</span><br><span class="line">chrome.pageAction.hide(tabId) 隐藏图标；</span><br></pre></td></tr></table></figure>
<p>示例(只有打开百度才显示图标)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"page_action"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="attr">"default_title"</span>: <span class="string">"我是pageAction"</span>,</span><br><span class="line">		<span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"permissions"</span>: [<span class="string">"declarativeContent"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.runtime.onInstalled.addListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	chrome.declarativeContent.onPageChanged.removeRules(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		chrome.declarativeContent.onPageChanged.addRules([</span><br><span class="line">			&#123;</span><br><span class="line">				conditions: [</span><br><span class="line">					<span class="comment">// 只有打开百度才显示pageAction</span></span><br><span class="line">					<span class="keyword">new</span> chrome.declarativeContent.PageStateMatcher(&#123;<span class="attr">pageUrl</span>: &#123;<span class="attr">urlContains</span>: <span class="string">'baidu.com'</span>&#125;&#125;)</span><br><span class="line">				],</span><br><span class="line">				actions: [<span class="keyword">new</span> chrome.declarativeContent.ShowPageAction()]</span><br><span class="line">			&#125;</span><br><span class="line">		]);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="右键菜单"><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h2><p>通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里</p>
<h3 id="最简单的右键菜单示例"><a href="#最简单的右键菜单示例" class="headerlink" title="最简单的右键菜单示例"></a>最简单的右键菜单示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; manifest.json</span><br><span class="line">&#123;&quot;permissions&quot;: [&quot;contextMenus&quot;]&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; background.js</span><br><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	title: &quot;测试右键菜单&quot;,</span><br><span class="line">	onclick: function()&#123;alert(&#39;您点击了右键菜单！&#39;);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="添加右键百度搜索"><a href="#添加右键百度搜索" class="headerlink" title="添加右键百度搜索"></a>添加右键百度搜索</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; manifest.json</span><br><span class="line">&#123;&quot;permissions&quot;: [&quot;contextMenus&quot;， &quot;tabs&quot;]&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; background.js</span><br><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	title: &#39;使用百度搜索：%s&#39;, &#x2F;&#x2F; %s表示选中的文字</span><br><span class="line">	contexts: [&#39;selection&#39;], &#x2F;&#x2F; 只有当选中文字时才会出现此右键菜单</span><br><span class="line">	onclick: function(params)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; 注意不能使用location.href，因为location是属于background的window对象</span><br><span class="line">		chrome.tabs.create(&#123;url: &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;utf-8&amp;wd&#x3D;&#39; + encodeURI(params.selectionText)&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>完整API参见：<a href="https://developer.chrome.com/extensions/contextMenus" target="_blank" rel="noopener">https://developer.chrome.com/extensions/contextMenus</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	type: &#39;normal&#39;， &#x2F;&#x2F; 类型，可选：[&quot;normal&quot;, &quot;checkbox&quot;, &quot;radio&quot;, &quot;separator&quot;]，默认 normal</span><br><span class="line">	title: &#39;菜单的名字&#39;, &#x2F;&#x2F; 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本</span><br><span class="line">	contexts: [&#39;page&#39;], &#x2F;&#x2F; 上下文环境，可选：[&quot;all&quot;, &quot;page&quot;, &quot;frame&quot;, &quot;selection&quot;, &quot;link&quot;, &quot;editable&quot;, &quot;image&quot;, &quot;video&quot;, &quot;audio&quot;]，默认page</span><br><span class="line">	onclick: function()&#123;&#125;, &#x2F;&#x2F; 单击时触发的方法</span><br><span class="line">	parentId: 1, &#x2F;&#x2F; 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单</span><br><span class="line">	documentUrlPatterns: &#39;https:&#x2F;&#x2F;*.baidu.com&#x2F;*&#39; &#x2F;&#x2F; 只在某些页面显示此右键菜单</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 删除某一个菜单项</span><br><span class="line">chrome.contextMenus.remove(menuItemId)；</span><br><span class="line">&#x2F;&#x2F; 删除所有自定义右键菜单</span><br><span class="line">chrome.contextMenus.removeAll();</span><br><span class="line">&#x2F;&#x2F; 更新某一个菜单项</span><br><span class="line">chrome.contextMenus.update(menuItemId, updateProperties);</span><br></pre></td></tr></table></figure>

<h2 id="override-覆盖特定页面"><a href="#override-覆盖特定页面" class="headerlink" title="override(覆盖特定页面)"></a>override(覆盖特定页面)</h2><p>使用override页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。</p>
<p>扩展可以替代如下页面：</p>
<ul>
<li>历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history</li>
<li>新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab</li>
<li>书签：浏览器的书签，或者直接输入 chrome://bookmarks</li>
</ul>
<p>注意：</p>
<ul>
<li>一个扩展只能替代一个页面；</li>
<li>不能替代隐身窗口的新标签页；</li>
<li>网页必须设置title，否则用户可能会看到网页的URL，造成困扰；</li>
<li>下面的截图是默认的新标签页和被扩展替换掉的新标签页。</li>
</ul>
<p>代码（注意，一个插件只能替代一个默认页，以下仅为演示）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;chrome_url_overrides&quot;:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;newtab&quot;: &quot;newtab.html&quot;,</span><br><span class="line">	&quot;history&quot;: &quot;history.html&quot;,</span><br><span class="line">	&quot;bookmarks&quot;: &quot;bookmarks.html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="devtools-开发者工具"><a href="#devtools-开发者工具" class="headerlink" title="devtools(开发者工具)"></a>devtools(开发者工具)</h2><h3 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h3><p>Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在：</p>
<ul>
<li>自定义一个和多个和Elements、Console、Sources等同级别的面板；</li>
<li>自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏；</li>
</ul>
<h3 id="devtools扩展介绍"><a href="#devtools扩展介绍" class="headerlink" title="devtools扩展介绍"></a>devtools扩展介绍</h3><p>主页：<a href="https://developer.chrome.com/extensions/devtools" target="_blank" rel="noopener">https://developer.chrome.com/extensions/devtools</a></p>
<p>每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的DevTools API以及有限的扩展API，这组特有的DevTools API只有devtools页面才可以访问，background都无权访问，这些API包括：</p>
<ul>
<li>chrome.devtools.panels：面板相关；</li>
<li>chrome.devtools.inspectedWindow：获取被审查窗口的有关信息；</li>
<li>chrome.devtools.network：获取有关网络请求的信息；</li>
</ul>
<p>大部分扩展API都无法直接被DevTools页面调用，但它可以像content-script一样直接调用chrome.extension和chrome.runtimeAPI，同时它也可以像content-script一样使用Message交互的方式与background页面进行通信。</p>
<h3 id="实例：创建一个devtools扩展"><a href="#实例：创建一个devtools扩展" class="headerlink" title="实例：创建一个devtools扩展"></a>实例：创建一个devtools扩展</h3><p>首先，要针对开发者工具开发插件，需要在清单文件声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 只能指向一个HTML文件，不能是JS文件</span><br><span class="line">	&quot;devtools_page&quot;: &quot;devtools.html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个devtools.html里面一般什么都没有，就引入一个js：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/devtools.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再来看devtools.js的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建自定义面板，同一个插件可以创建多个自定义面板</span><br><span class="line">&#x2F;&#x2F; 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调</span><br><span class="line">chrome.devtools.panels.create(&#39;MyPanel&#39;, &#39;img&#x2F;icon.png&#39;, &#39;mypanel.html&#39;, function(panel)</span><br><span class="line">&#123;</span><br><span class="line">	console.log(&#39;自定义面板创建成功！&#39;); &#x2F;&#x2F; 注意这个log一般看不到</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建自定义侧边栏</span><br><span class="line">chrome.devtools.panels.elements.createSidebarPane(&quot;Images&quot;, function(sidebar)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; sidebar.setPage(&#39;..&#x2F;sidebar.html&#39;); &#x2F;&#x2F; 指定加载某个页面</span><br><span class="line">	sidebar.setExpression(&#39;document.querySelectorAll(&quot;img&quot;)&#39;, &#39;All Images&#39;); &#x2F;&#x2F; 通过表达式来指定</span><br><span class="line">	&#x2F;&#x2F;sidebar.setObject(&#123;aaa: 111, bbb: &#39;Hello World!&#39;&#125;); &#x2F;&#x2F; 直接设置显示某个对象</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>mypanel.js代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检测jQuery</span><br><span class="line">document.getElementById(&#39;check_jquery&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 访问被检查的页面DOM需要使用inspectedWindow</span><br><span class="line">	&#x2F;&#x2F; 简单例子：检测被检查页面是否使用了jQuery</span><br><span class="line">	chrome.devtools.inspectedWindow.eval(&quot;jQuery.fn.jquery&quot;, function(result, isException)</span><br><span class="line">	&#123;</span><br><span class="line">		var html &#x3D; &#39;&#39;;</span><br><span class="line">		if (isException) html &#x3D; &#39;当前页面没有使用jQuery。&#39;;</span><br><span class="line">		else html &#x3D; &#39;当前页面使用了jQuery，版本为：&#39;+result;</span><br><span class="line">		alert(html);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打开某个资源</span><br><span class="line">document.getElementById(&#39;open_resource&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	chrome.devtools.inspectedWindow.eval(&quot;window.location.href&quot;, function(result, isException)</span><br><span class="line">	&#123;</span><br><span class="line">		chrome.devtools.panels.openResource(result, 20, function()</span><br><span class="line">		&#123;</span><br><span class="line">			console.log(&#39;资源打开成功！&#39;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 审查元素</span><br><span class="line">document.getElementById(&#39;test_inspect&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	chrome.devtools.inspectedWindow.eval(&quot;inspect(document.images[0])&quot;, function(result, isException)&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取所有资源</span><br><span class="line">document.getElementById(&#39;get_all_resources&#39;).addEventListener(&#39;click&#39;, function()</span><br><span class="line">&#123;</span><br><span class="line">	chrome.devtools.inspectedWindow.getResources(function(resources)</span><br><span class="line">	&#123;</span><br><span class="line">		alert(JSON.stringify(resources));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下Ctrl+R重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。</p>
<p>由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 chrome-extension://extid/devtools.html”的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。</p>
<h2 id="option-选项页"><a href="#option-选项页" class="headerlink" title="option(选项页)"></a>option(选项页)</h2><p>所谓options页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面：</p>
<p>在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。</p>
<p>老版的options：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; Chrome40以前的插件配置页写法</span><br><span class="line">	&quot;options_page&quot;: &quot;options.html&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版的optionsV2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;options_ui&quot;:</span><br><span class="line">	&#123;</span><br><span class="line">    	&quot;page&quot;: &quot;options.html&quot;,</span><br><span class="line">		&#x2F;&#x2F; 添加一些默认的样式，推荐使用</span><br><span class="line">    	&quot;chrome_style&quot;: true</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几点注意：</p>
<ul>
<li>为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式；</li>
<li>新版options中不能使用alert；</li>
<li>数据存储建议用chrome.storage，因为会随用户自动同步；<br>$$ omnibox<br>omnibox是向用户提供搜索建议的一种方式。</li>
</ul>
<p>注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。</p>
<p>首先，manifest.json配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span><br><span class="line">	&quot;omnibox&quot;: &#123; &quot;keyword&quot; : &quot;go&quot; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后background.js中注册监听事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; omnibox 演示</span><br><span class="line">chrome.omnibox.onInputChanged.addListener((text, suggest) &#x3D;&gt; &#123;</span><br><span class="line">	console.log(&#39;inputChanged: &#39; + text);</span><br><span class="line">	if(!text) return;</span><br><span class="line">	if(text &#x3D;&#x3D; &#39;美女&#39;) &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;content: &#39;中国&#39; + text, description: &#39;你要找“中国美女”吗？&#39;&#125;,</span><br><span class="line">			&#123;content: &#39;日本&#39; + text, description: &#39;你要找“日本美女”吗？&#39;&#125;,</span><br><span class="line">			&#123;content: &#39;泰国&#39; + text, description: &#39;你要找“泰国美女或人妖”吗？&#39;&#125;,</span><br><span class="line">			&#123;content: &#39;韩国&#39; + text, description: &#39;你要找“韩国美女”吗？&#39;&#125;</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(text &#x3D;&#x3D; &#39;微博&#39;) &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;content: &#39;新浪&#39; + text, description: &#39;新浪&#39; + text&#125;,</span><br><span class="line">			&#123;content: &#39;腾讯&#39; + text, description: &#39;腾讯&#39; + text&#125;,</span><br><span class="line">			&#123;content: &#39;搜狐&#39; + text, description: &#39;搜索&#39; + text&#125;,</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;content: &#39;百度搜索 &#39; + text, description: &#39;百度搜索 &#39; + text&#125;,</span><br><span class="line">			&#123;content: &#39;谷歌搜索 &#39; + text, description: &#39;谷歌搜索 &#39; + text&#125;,</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当用户接收关键字建议时触发</span><br><span class="line">chrome.omnibox.onInputEntered.addListener((text) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;inputEntered: &#39; + text);</span><br><span class="line">	if(!text) return;</span><br><span class="line">	var href &#x3D; &#39;&#39;;</span><br><span class="line">    if(text.endsWith(&#39;美女&#39;)) href &#x3D; &#39;http:&#x2F;&#x2F;image.baidu.com&#x2F;search&#x2F;index?tn&#x3D;baiduimage&amp;ie&#x3D;utf-8&amp;word&#x3D;&#39; + text;</span><br><span class="line">	else if(text.startsWith(&#39;百度搜索&#39;)) href &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;&#39; + text.replace(&#39;百度搜索 &#39;, &#39;&#39;);</span><br><span class="line">	else if(text.startsWith(&#39;谷歌搜索&#39;)) href &#x3D; &#39;https:&#x2F;&#x2F;www.google.com.tw&#x2F;search?q&#x3D;&#39; + text.replace(&#39;谷歌搜索 &#39;, &#39;&#39;);</span><br><span class="line">	else href &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;&#39; + text;</span><br><span class="line">	openUrlCurrentTab(href);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 获取当前选项卡ID</span><br><span class="line">function getCurrentTabId(callback)</span><br><span class="line">&#123;</span><br><span class="line">	chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function(tabs)</span><br><span class="line">	&#123;</span><br><span class="line">		if(callback) callback(tabs.length ? tabs[0].id: null);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当前标签打开某个链接</span><br><span class="line">function openUrlCurrentTab(url)</span><br><span class="line">&#123;</span><br><span class="line">	getCurrentTabId(tabId &#x3D;&gt; &#123;</span><br><span class="line">		chrome.tabs.update(tabId, &#123;url: url&#125;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：先输入go，然后 空格键 再输入“美女”</p>
<h2 id="桌面通知"><a href="#桌面通知" class="headerlink" title="桌面通知"></a>桌面通知</h2><p>Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。</p>
<p>在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chrome.notifications.create(null, &#123;</span><br><span class="line">	type: &#39;basic&#39;,</span><br><span class="line">	iconUrl: &#39;img&#x2F;icon.png&#39;,</span><br><span class="line">	title: &#39;这是标题&#39;,</span><br><span class="line">	message: &#39;您刚才点击了自定义右键菜单！&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通知的样式可以很丰富,有需要的可以看官方文档。</p>
<h1 id="5种类型的JS对比"><a href="#5种类型的JS对比" class="headerlink" title="5种类型的JS对比"></a>5种类型的JS对比</h1><p>Chrome插件的JS主要可以分为这5类：injected script、content-script、popup js、background js和devtools js，</p>
<h2 id="权限对比"><a href="#权限对比" class="headerlink" title="权限对比"></a>权限对比</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS种类               DOM访问情况     JS访问情况     直接跨域    调试方式                 可访问的API			</span><br><span class="line">injected script     可以访问        可以访问        不可以      直接普通的F12即可        和普通JS无任何差别，不能访问任何扩展API		</span><br><span class="line">content script      可以访问        不可以	       不可以       打开Console             只能访问 extension、runtime等部分API		</span><br><span class="line">popup js	        不可直接访问     不可以	        可以        popup页面右键审查元素     可访问绝大部分API，除了devtools系列		</span><br><span class="line">background js	    不可直接访问     不可以	        可以        插件管理页点击背景页即可   可访问绝大部分API，除了devtools系列		</span><br><span class="line">devtools js	        可以            可以	      不可以       暂无                   只能访问 devtools、extension、runtime等部分API</span><br></pre></td></tr></table></figure>

<h1 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h1><p>通信主页：<a href="https://developer.chrome.com/extensions/messaging" target="_blank" rel="noopener">https://developer.chrome.com/extensions/messaging</a></p>
<p>前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。</p>
<h2 id="互相通信概览"><a href="#互相通信概览" class="headerlink" title="互相通信概览"></a>互相通信概览</h2><p>注：-表示不存在或者无意义，或者待验证。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    injected-script         content-script	            popup-js	            background-js</span><br><span class="line">injected-script	        -	                window.postMessage	            -	                -</span><br><span class="line">content-script	    window.postMessage	        -	                chrome.runtime.sendMessage  chrome.runtime.sendMessage</span><br><span class="line">                                                                    chrome.runtime.connect	    chrome.runtime.connect</span><br><span class="line">popup-js	            -	                chrome.tabs.sendMessage          -                  chrome.extension. getBackgroundPage()</span><br><span class="line">                                            chrome.tabs.connect</span><br><span class="line">background-js	        -	                chrome.tabs.sendMessage  chrome.extension.getViews  -</span><br><span class="line">                                            chrome.tabs.connect		</span><br><span class="line">devtools-js	chrome.devtools.inspectedWindow.eval	-	             chrome.runtime.sendMessage	chrome.runtime.sendMessage</span><br></pre></td></tr></table></figure>
<h2 id="通信详细介绍"><a href="#通信详细介绍" class="headerlink" title="通信详细介绍"></a>通信详细介绍</h2><h3 id="popup和background"><a href="#popup和background" class="headerlink" title="popup和background"></a>popup和background</h3><p>popup可以直接调用background中的JS方法，也可以直接访问background的DOM：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; background.js</span><br><span class="line">function test()</span><br><span class="line">&#123;</span><br><span class="line">	alert(&#39;我是background！&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; popup.js</span><br><span class="line">var bg &#x3D; chrome.extension.getBackgroundPage();</span><br><span class="line">bg.test(); &#x2F;&#x2F; 访问bg的函数</span><br><span class="line">alert(bg.document.body.innerHTML); &#x2F;&#x2F; 访问bg的DOM</span><br></pre></td></tr></table></figure>
<p>至于background访问popup如下（前提是popup已经打开）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var views &#x3D; chrome.extension.getViews(&#123;type:&#39;popup&#39;&#125;);</span><br><span class="line">if(views.length &gt; 0) &#123;</span><br><span class="line">	console.log(views[0].location.href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="popup或者bg向content主动发送消息"><a href="#popup或者bg向content主动发送消息" class="headerlink" title="popup或者bg向content主动发送消息"></a>popup或者bg向content主动发送消息</h3><p>background.js或者popup.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		chrome.tabs.sendMessage(tabs[<span class="number">0</span>].id, message, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(response);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sendMessageToContentScript(&#123;<span class="attr">cmd</span>:<span class="string">'test'</span>, <span class="attr">value</span>:<span class="string">'你好，我是popup！'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'来自content的回复：'</span>+response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-script.js接收：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// console.log(sender.tab ?"from a content script:" + sender.tab.url :"from the extension");</span></span><br><span class="line">	<span class="keyword">if</span>(request.cmd == <span class="string">'test'</span>) alert(request.value);</span><br><span class="line">	sendResponse(<span class="string">'我收到了你的消息！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。</p>
<p>网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。</p>
<h3 id="content-script主动发消息给后台"><a href="#content-script主动发消息给后台" class="headerlink" title="content-script主动发消息给后台"></a>content-script主动发消息给后台</h3><p>content-script.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.runtime.sendMessage(&#123;<span class="attr">greeting</span>: <span class="string">'你好，我是content-script呀，我主动发消息给后台！'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到来自后台的回复：'</span> + response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>background.js 或者 popup.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听来自content-script的消息</span></span><br><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到来自content-script的消息：'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(request, sender, sendResponse);</span><br><span class="line">	sendResponse(<span class="string">'我是后台，我已收到你的消息：'</span> + <span class="built_in">JSON</span>.stringify(request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转；</li>
<li>如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；</li>
</ul>
<h3 id="injected-script和content-script"><a href="#injected-script和content-script" class="headerlink" title="injected script和content-script"></a>injected script和content-script</h3><p>content-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：</p>
<p>可以通过window.postMessage和window.addEventListener来实现二者消息通讯；</p>
<p>通过自定义DOM事件来实现；<br>第一种方法（推荐）：</p>
<p>injected-script中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(&#123;<span class="string">"test"</span>: <span class="string">'你好！'</span>&#125;, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure>
<p>content script中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>第二种方法：</p>
<p>injected-script中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customEvent = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line">customEvent.initEvent(<span class="string">'myCustomEvent'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fireCustomEvent</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	hiddenDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>);</span><br><span class="line">	hiddenDiv.innerText = data</span><br><span class="line">	hiddenDiv.dispatchEvent(customEvent);</span><br><span class="line">&#125;</span><br><span class="line">fireCustomEvent(<span class="string">'你好，我是普通JS！'</span>);</span><br></pre></td></tr></table></figure>
<p>content-script.js中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hiddenDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>);</span><br><span class="line"><span class="keyword">if</span>(!hiddenDiv) &#123;</span><br><span class="line">	hiddenDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">	hiddenDiv.style.display = <span class="string">'none'</span>;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(hiddenDiv);</span><br><span class="line">&#125;</span><br><span class="line">hiddenDiv.addEventListener(<span class="string">'myCustomEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> eventData = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>).innerText;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到自定义事件消息：'</span> + eventData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。</p>
<p>短连接的话，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。</p>
<p>短连接上面已经有代码示例了，这里只讲一下长连接。</p>
<p>popup.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getCurrentTabId(<span class="function">(<span class="params">tabId</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> port = chrome.tabs.connect(tabId, &#123;<span class="attr">name</span>: <span class="string">'test-connect'</span>&#125;);</span><br><span class="line">	port.postMessage(&#123;<span class="attr">question</span>: <span class="string">'你是谁啊？'</span>&#125;);</span><br><span class="line">	port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">'收到消息：'</span>+msg.answer);</span><br><span class="line">		<span class="keyword">if</span>(msg.answer &amp;&amp; msg.answer.startsWith(<span class="string">'我是'</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			port.postMessage(&#123;<span class="attr">question</span>: <span class="string">'哦，原来是你啊！'</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-script.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听长连接</span></span><br><span class="line">chrome.runtime.onConnect.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">port</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(port);</span><br><span class="line">	<span class="keyword">if</span>(port.name == <span class="string">'test-connect'</span>) &#123;</span><br><span class="line">		port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'收到长连接消息：'</span>, msg);</span><br><span class="line">			<span class="keyword">if</span>(msg.question == <span class="string">'你是谁啊？'</span>) port.postMessage(&#123;<span class="attr">answer</span>: <span class="string">'我是你爸！'</span>&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="其它补充"><a href="#其它补充" class="headerlink" title="其它补充"></a>其它补充</h1><h2 id="动态注入或执行JS"><a href="#动态注入或执行JS" class="headerlink" title="动态注入或执行JS"></a>动态注入或执行JS</h2><p>虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。</p>
<p>示例manifest.json配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"动态JS注入演示"</span>,</span><br><span class="line">	...</span><br><span class="line">	"permissions": [</span><br><span class="line">		"tabs", "http://*/*", "https://*/*"</span><br><span class="line">	],</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态执行JS代码</span></span><br><span class="line">chrome.tabs.executeScript(tabId, &#123;<span class="attr">code</span>: <span class="string">'document.body.style.backgroundColor="red"'</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行JS文件</span></span><br><span class="line">chrome.tabs.executeScript(tabId, &#123;<span class="attr">file</span>: <span class="string">'some-script.js'</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="动态注入CSS"><a href="#动态注入CSS" class="headerlink" title="动态注入CSS"></a>动态注入CSS</h2><p>示例manifest.json配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"动态CSS注入演示"</span>,</span><br><span class="line">	...</span><br><span class="line">	"permissions": [</span><br><span class="line">		"tabs", "http://*/*", "https://*/*"</span><br><span class="line">	],</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态执行CSS代码，TODO，这里有待验证</span></span><br><span class="line">chrome.tabs.insertCSS(tabId, &#123;<span class="attr">code</span>: <span class="string">'xxx'</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行CSS文件</span></span><br><span class="line">chrome.tabs.insertCSS(tabId, &#123;<span class="attr">file</span>: <span class="string">'some-style.css'</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前窗口ID"><a href="#获取当前窗口ID" class="headerlink" title="获取当前窗口ID"></a>获取当前窗口ID</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params">currentWindow</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'当前窗口ID：'</span> + currentWindow.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前标签页ID"><a href="#获取当前标签页ID" class="headerlink" title="获取当前标签页ID"></a>获取当前标签页ID</h2><p>一般有2种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId</span>(<span class="params">callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params">currentWindow</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">windowId</span>: currentWindow.id&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是：</p>
<p>chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到；<br>chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；<br>需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数据，第一个参数是指定要读取的key以及设置默认值</span></span><br><span class="line">chrome.storage.sync.get(&#123;<span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(items.color, items.age);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">chrome.storage.sync.set(&#123;<span class="attr">color</span>: <span class="string">'blue'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'保存成功！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="webRequest"><a href="#webRequest" class="headerlink" title="webRequest"></a>webRequest</h2><p>通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过beforeRequest来简单演示一下它的冰山一角：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 权限申请</span></span><br><span class="line">	<span class="attr">"permissions"</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">"webRequest"</span>, <span class="comment">// web请求</span></span><br><span class="line">		<span class="string">"webRequestBlocking"</span>, <span class="comment">// 阻塞式web请求</span></span><br><span class="line">		<span class="string">"storage"</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line">		<span class="string">"http://*/*"</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">		<span class="string">"https://*/*"</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">	],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="comment">// 是否显示图片</span></span><br><span class="line"><span class="keyword">var</span> showImage;</span><br><span class="line">chrome.storage.sync.get(&#123;<span class="attr">showImage</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	showImage = items.showImage;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking</span></span><br><span class="line">chrome.webRequest.onBeforeRequest.addListener(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// cancel 表示取消本次请求</span></span><br><span class="line">	<span class="keyword">if</span>(!showImage &amp;&amp; details.type == <span class="string">'image'</span>) <span class="keyword">return</span> &#123;<span class="attr">cancel</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	<span class="comment">// 简单的音视频检测</span></span><br><span class="line">	<span class="comment">// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义</span></span><br><span class="line">	<span class="keyword">if</span>(details.type == <span class="string">'media'</span>) &#123;</span><br><span class="line">		chrome.notifications.create(<span class="literal">null</span>, &#123;</span><br><span class="line">			type: <span class="string">'basic'</span>,</span><br><span class="line">			iconUrl: <span class="string">'img/icon.png'</span>,</span><br><span class="line">			title: <span class="string">'检测到音视频'</span>,</span><br><span class="line">			message: <span class="string">'音视频地址：'</span> + details.url,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">"&lt;all_urls&gt;"</span>]&#125;, [<span class="string">"blocking"</span>]);</span><br></pre></td></tr></table></figure>
<p>8.7. 国际化<br>插件根目录新建一个名为_locales的文件夹，再在下面新建一些语言的文件夹，如en、zh_CN、zh_TW，然后再在每个文件夹放入一个messages.json，同时必须在清单文件中设置default_locale。</p>
<p>_locales\en\messages.json内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"pluginDesc"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"A simple chrome extension demo"</span>&#125;,</span><br><span class="line">	<span class="attr">"helloWorld"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"Hello World!"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_locales\zh_CN\messages.json内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"pluginDesc"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"一个简单的Chrome插件demo"</span>&#125;,</span><br><span class="line">	<span class="attr">"helloWorld"</span>: &#123;<span class="attr">"message"</span>: <span class="string">"你好啊，世界！"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在manifest.json和CSS文件中通过<strong>MSG_messagename</strong>引入，如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"description"</span>: <span class="string">"__MSG_pluginDesc__"</span>,</span><br><span class="line">	<span class="comment">// 默认语言</span></span><br><span class="line">	<span class="attr">"default_locale"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS中则直接chrome.i18n.getMessage(“helloWorld”)。</p>
<p>测试时，通过给chrome建立一个不同的快捷方式chrome.exe –lang=en来切换语言，如：</p>
<h2 id="API总结"><a href="#API总结" class="headerlink" title="API总结"></a>API总结</h2><p>比较常用用的一些API系列：</p>
<ul>
<li>chrome.tabs</li>
<li>chrome.runtime</li>
<li>chrome.webRequest</li>
<li>chrome.window</li>
<li>chrome.storage</li>
<li>chrome.contextMenus</li>
<li>chrome.devtools</li>
<li>chrome.extension</li>
</ul>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="查看已安装插件路径"><a href="#查看已安装插件路径" class="headerlink" title="查看已安装插件路径"></a>查看已安装插件路径</h2><p>windows 已安装的插件源码路径：C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，源码。</p>
<p>如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。</p>
<h1 id="打包与发布"><a href="#打包与发布" class="headerlink" title="打包与发布"></a>打包与发布</h1><h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><p>打开插件管理页面：chrome://extensions/<br>开启开发者 模式<br>既可以部署解压的插件，以及打包插件</p>
<h2 id="打包插件"><a href="#打包插件" class="headerlink" title="打包插件"></a>打包插件</h2><p>打包的话直接在插件管理页有一个打包按钮：然后会生成一个.crx文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p>推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）：</p>
<p><a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">Chrome插件官方文档主页</a><br><a href="https://developer.chrome.com/extensions/samples" target="_blank" rel="noopener">Chrome插件官方示例</a><br><a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="noopener">manifest清单文件</a><br><a href="https://developer.chrome.com/extensions/permissions" target="_blank" rel="noopener">permissions权限</a><br><a href="https://developer.chrome.com/extensions/api_index" target="_blank" rel="noopener">chrome.xxx.api文档</a><br><a href="https://developer.chrome.com/extensions/match_patterns" target="_blank" rel="noopener">模糊匹配规则语法详解</a></p>
<p>参看地址：<a href="https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>009-Mysql 在线新建或重做主从</title>
    <url>/articles/20200319/4f016687.html</url>
    <content><![CDATA[<p>摘要：009-Mysql 在线新建或重做主从<br>以前停服做主从的主要目的是想锁表，是想找到 master_log_file 和 master_log_pos 两个参数。如果有方法在不停服的情况下，能确定这两个参数，那么在线建立主从架构的功能，就可以实现了。</p>
<a id="more"></a>
<p>注意：主端不停服的前提是，它已经开启了bin-log 日志！！</p>
<h1 id="主从新建过程"><a href="#主从新建过程" class="headerlink" title="主从新建过程"></a>主从新建过程</h1><p>如果之前在主库没有开启 bin-log 日志，那就没有办法，因为配置 bin-log 日志之后，主库一定要重启才能生效。不过，如果现在的情况是重做主库，那就证明之前是做过主从的，只是可能主从失效了需要重做。这种情况，主库也不需要重启，只要重新备份一下数据库，就可以重建从库了。</p>
<h2 id="主从新建过程-主库操作"><a href="#主从新建过程-主库操作" class="headerlink" title="主从新建过程-主库操作"></a>主从新建过程-主库操作</h2><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><p>在主库修改配置文件 my.cnf ，添加开启 bin-log 日志，格式用 row</p>
<p>server-id=1<br>log-bin=mysql-bin<br>binlog-format=ROW</p>
<p>如果之前已经开启了bin-log 功能，就不用修改了。</p>
<h3 id="主库创建用户以及授权"><a href="#主库创建用户以及授权" class="headerlink" title="主库创建用户以及授权"></a>主库创建用户以及授权</h3><p>接着在主库上进行备份用户的授权操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'repel'</span>@<span class="string">'172.10.0.1'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure>
<p>授权给从库的 ip 地址，备份的用户名是 repel，建议不要使用 ‘repel’@’%’ 这种方式进行授权操作，主要是为了安全问题，限制授权的 ip 白名单。</p>
<h3 id="主库将需要备份的数据库导出来："><a href="#主库将需要备份的数据库导出来：" class="headerlink" title="主库将需要备份的数据库导出来："></a>主库将需要备份的数据库导出来：</h3><p>用 mysqldump 的方式，以下是导出整个数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p  <span class="comment">--single-transaction --no-autocommit --master-data=2 -A &gt;test2.sql</span></span><br></pre></td></tr></table></figure>
<p>用 mysqldump 的方式，如果主端 Mysql 上有不止一个项目的业务库，但是只想导出其中一个业务库，假设叫做 hr_mysql 数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p  <span class="comment">--single-transaction --no-autocommit --master-data=2  hr_mysql &gt; hr_mysql_dump.sql</span></span><br></pre></td></tr></table></figure>
<p>关键的参数 “–master-data=2”，能帮助实现在线重建主从数据库。<br>将hr_mysql_dump.sql传输给从库。</p>
<h2 id="主从新建过程-从库操作"><a href="#主从新建过程-从库操作" class="headerlink" title="主从新建过程-从库操作"></a>主从新建过程-从库操作</h2><h3 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h3><p>修改从库 my.cnf ，只备份 hr_mysql 业务库，所以只增加了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id&#x3D;2</span><br><span class="line">replicate_wild_do_table&#x3D;hr_mysql.%</span><br></pre></td></tr></table></figure>
<p>其实如果进行的是全库备份，那么只要配置 server-id 和主库不一样就可以了，其他的不需要增加。<br>但是，如果只想备份某些特定的业务库，就需要使用 replicate_wild_do_table 这个参数了。它的作用是告诉从库只需要备份特定的库，如果有多个库，就继续用逗号隔开添加即可。<br>还有一个功能相反的参数 replicate_wild_ignore_table ,是配置忽略的数据库，即不备份的数据库，这个参数使用起来比较多限制，不熟悉最好不使用。</p>
<h3 id="导入主库数据"><a href="#导入主库数据" class="headerlink" title="导入主库数据"></a>导入主库数据</h3><p>接下来是导入数据库，在导入数据库前，需要重置一下从库binlog：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p   -e '<span class="keyword">reset</span> <span class="keyword">master</span><span class="string">'</span></span><br><span class="line"><span class="string">mysql -uroot -p   hr_mysql &lt; hr_mysql_dump.sql</span></span><br></pre></td></tr></table></figure>

<h3 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h3><p>在备份数据库的时候，使用了一个关键的参数 –master-data=2。在备份文件中，可以看到需要的 master_log_file 和 master_log_pos 两个参数。有了这两个参数，我们就不需要像以往那样停服锁表，来查看了。</p>
<p>具体怎么查找这两个参数？它们大概在dump文件的前 30 行以内，所以可以用 head 命令找到：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">head -n 30 feitian_dump.sql</span><br></pre></td></tr></table></figure>
<p>在上面的输出，可以看到 binlog 是 mysql-bin.000063，position 是 144333309.有了这两个参数，就可以配置从库同步了。</p>
<p>一般在从库 change master to 就可以了。</p>
<p>所以，在从库做以下配置：</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>005-mysql-查看MYSQL数据库中所有用户及拥有权限</title>
    <url>/articles/20200319/b9b0f2a9.html</url>
    <content><![CDATA[<p>摘要：005-mysql-查看MYSQL数据库中所有用户及拥有权限</p>
<a id="more"></a>

<h1 id="查看MYSQL数据库中所有用户"><a href="#查看MYSQL数据库中所有用户" class="headerlink" title="查看MYSQL数据库中所有用户"></a>查看MYSQL数据库中所有用户</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">CONCAT</span>(<span class="string">'User: '''</span>,<span class="keyword">user</span>,<span class="string">'''@'''</span>,host,<span class="string">''';'</span>) <span class="keyword">AS</span> <span class="keyword">query</span> <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"><span class="comment">-- +------------------------------------+</span></span><br><span class="line"><span class="comment">-- | query                              |</span></span><br><span class="line"><span class="comment">-- +------------------------------------+</span></span><br><span class="line"><span class="comment">-- | User: 'root'@'%';                  |</span></span><br><span class="line"><span class="comment">-- | User: 'mysql.session'@'localhost'; |</span></span><br><span class="line"><span class="comment">-- | User: 'mysql.sys'@'localhost';     |</span></span><br><span class="line"><span class="comment">-- | User: 'root'@'localhost';          |</span></span><br><span class="line"><span class="comment">-- +------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>查看数据库中具体某个用户的权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">'root'</span>@<span class="string">'%'</span>; </span><br><span class="line"><span class="comment">-- +-------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- | Grants for root@%                                           |</span></span><br><span class="line"><span class="comment">-- +-------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- | GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION |</span></span><br><span class="line"><span class="comment">-- +-------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- 1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.user <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span> \G   </span><br><span class="line"><span class="comment">-- *************************** 1. row ***************************</span></span><br><span class="line"><span class="comment">--                   Host: localhost</span></span><br><span class="line"><span class="comment">--                   User: root</span></span><br><span class="line"><span class="comment">--            Select_priv: Y</span></span><br><span class="line"><span class="comment">--            Insert_priv: Y</span></span><br><span class="line"><span class="comment">--            Update_pr</span></span><br><span class="line"><span class="comment">--              ……</span></span><br></pre></td></tr></table></figure>

<p>查看user表结构　需要具体的项可结合表结构来查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc mysql.user;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>008-mysql5.7配置文件</title>
    <url>/articles/20200319/c5078da8.html</url>
    <content><![CDATA[<p>摘要：008-mysql5.7配置文件</p>
<a id="more"></a>

<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 53306:3306 --name mymysql57 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">docker <span class="built_in">exec</span> -it mymysql57 /bin/bash</span><br></pre></td></tr></table></figure>
<p>进入docker后查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /etc</span><br></pre></td></tr></table></figure>
<p>没有 my.cnf,存在mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /etc/mysql</span><br><span class="line"><span class="comment"># conf.d	my.cnf	my.cnf.fallback  mysql.cnf  mysql.conf.d</span></span><br><span class="line">cat /etc/mysql/my.cnf</span><br><span class="line"><span class="comment"># 意思是配置文件在这两个目录下</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/conf.d/</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/mysql.conf.d/</span></span><br><span class="line">cat /etc/mysql/mysql.cnf</span><br><span class="line"><span class="comment"># 意思是配置文件在这两个目录下</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/conf.d/</span></span><br><span class="line"><span class="comment"># !includedir /etc/mysql/mysql.conf.d/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------</span></span><br><span class="line">ls /etc/mysql/conf.d/</span><br><span class="line"><span class="comment"># docker.cnf  mysql.cnf  mysqldump.cnf</span></span><br><span class="line">cat /etc/mysql/conf.d/docker.cnf</span><br><span class="line"><span class="comment"># [mysqld]</span></span><br><span class="line"><span class="comment"># skip-host-cache</span></span><br><span class="line"><span class="comment"># skip-name-resolve</span></span><br><span class="line">cat /etc/mysql/conf.d/mysql.cnf</span><br><span class="line"><span class="comment"># 空</span></span><br><span class="line">cat /etc/mysql/conf.d/mysqldump.cnf</span><br><span class="line"><span class="comment"># [mysqldump]</span></span><br><span class="line"><span class="comment"># quick</span></span><br><span class="line"><span class="comment"># quote-names</span></span><br><span class="line"><span class="comment"># max_allowed_packet	= 16M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------</span></span><br><span class="line">ls /etc/mysql/mysql.conf.d/</span><br><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line">cat /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"><span class="comment"># [mysqld]</span></span><br><span class="line"><span class="comment"># pid-file	= /var/run/mysqld/mysqld.pid</span></span><br><span class="line"><span class="comment"># socket		= /var/run/mysqld/mysqld.sock</span></span><br><span class="line"><span class="comment"># datadir		= /var/lib/mysql</span></span><br><span class="line"><span class="comment"># #log-error	= /var/log/mysql/error.log</span></span><br><span class="line"><span class="comment"># # By default we only accept connections from localhost</span></span><br><span class="line"><span class="comment"># #bind-address	= 127.0.0.1</span></span><br><span class="line"><span class="comment"># # Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line"><span class="comment"># symbolic-links=0</span></span><br></pre></td></tr></table></figure>

<p>故核心配置在： /etc/mysql/mysql.conf.d/mysqld.cnf</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>005-opencv中numpy数组与图像类型转换</title>
    <url>/articles/20200302/b2b98e8d.html</url>
    <content><![CDATA[<p>摘要：005-opencv中numpy数组与图像类型转换</p>
<p>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/005</p>
<a id="more"></a>

<h1 id="numpy数组与图像类型转换"><a href="#numpy数组与图像类型转换" class="headerlink" title="numpy数组与图像类型转换"></a>numpy数组与图像类型转换</h1><p>Python OpenCV存储图像使用的是Numpy存储，所以可以将Numpy当做图像类型操作，操作之前还需进行类型转换，转换到int8类型</p>
<h2 id="遍历图片三个通道像素点，并修改相应的RGB"><a href="#遍历图片三个通道像素点，并修改相应的RGB" class="headerlink" title="遍历图片三个通道像素点，并修改相应的RGB"></a>遍历图片三个通道像素点，并修改相应的RGB</h2>]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>004-opencv目标区域图像分割</title>
    <url>/articles/20200301/d2b99b52.html</url>
    <content><![CDATA[<p>摘要：004-opencv目标区域图像分割</p>
<p>使用OpenCV截取目标区域</p>
<p>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/004</p>
<a id="more"></a>

<h1 id="指定图像位置的裁剪处理"><a href="#指定图像位置的裁剪处理" class="headerlink" title="指定图像位置的裁剪处理"></a>指定图像位置的裁剪处理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 遍历指定目录，显示目录下的所有文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CropImage4File</span><span class="params">(filepath,destpath)</span>:</span></span><br><span class="line">    pathDir =  os.listdir(filepath)    <span class="comment"># 列出文件路径中的所有路径或文件</span></span><br><span class="line">    <span class="keyword">for</span> allDir <span class="keyword">in</span> pathDir:</span><br><span class="line">        child = os.path.join(filepath, allDir)</span><br><span class="line">        dest = os.path.join(destpath,allDir)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(child):</span><br><span class="line">            image = cv2.imread(child)</span><br><span class="line">            <span class="comment"># 获取图像形状 返回 行数值，列数值列表</span></span><br><span class="line">            sp=image.shape</span><br><span class="line">            <span class="comment">#图像的高度（行 范围）</span></span><br><span class="line">            sz1 = sp[<span class="number">0</span>]       </span><br><span class="line">            <span class="comment">#图像的宽度（列 范围）          </span></span><br><span class="line">            sz2 = sp[<span class="number">1</span>]                 </span><br><span class="line">            <span class="comment">#sz3 = sp[2]                #像素值由【RGB】三原色组成</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#你想对文件的操作</span></span><br><span class="line">            a=int(sz1/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># x start</span></span><br><span class="line">            b=int(sz1/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># x end</span></span><br><span class="line">            c=int(sz2/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># y start</span></span><br><span class="line">            d=int(sz2/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># y end</span></span><br><span class="line">            cropImg = image[a:b,c:d]   <span class="comment">#裁剪图像</span></span><br><span class="line">            cv2.imwrite(dest,cropImg)  <span class="comment">#写入图像路径</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    filepath =<span class="string">'src/python-opencv/'</span>             <span class="comment">#源图像</span></span><br><span class="line">    destpath=<span class="string">'src/python-opencv/003-cut/dist_img'</span>        <span class="comment"># resized images saved here</span></span><br><span class="line">    CropImage4File(filepath,destpath)</span><br></pre></td></tr></table></figure>

<h1 id="批量处理—指定图像位置的裁剪"><a href="#批量处理—指定图像位置的裁剪" class="headerlink" title="批量处理—指定图像位置的裁剪"></a>批量处理—指定图像位置的裁剪</h1><p>我这个是用来截取发票的印章区域，用于图像分割（公司的数据集保密）<br>各位可以用自己的增值发票裁剪。适当的更改截取区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    scale = len(img_paths)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">1000</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">1000</span>)-int(i/<span class="number">1000</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        print(<span class="string">'正在处理图像： %s'</span> % img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>])</span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        weight = img.shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> weight&gt;<span class="number">1600</span>:                         <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">50</span>:<span class="number">200</span>, <span class="number">700</span>:<span class="number">1500</span>]    <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            <span class="comment">#cropImg = cv2.resize(cropImg, None, fx=0.5, fy=0.5,</span></span><br><span class="line">                                 <span class="comment">#interpolation=cv2.INTER_CUBIC) #缩小图像</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                        <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span>+img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c,a,b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    print(<span class="string">'图片获取完成 。。。！'</span>)</span><br><span class="line">    cut_img(img_paths,output_dir)</span><br></pre></td></tr></table></figure>

<h1 id="多进程（加快处理）"><a href="#多进程（加快处理）" class="headerlink" title="多进程（加快处理）"></a>多进程（加快处理）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">采用多进程加快处理。添加了在读取图片时捕获异常，OpenCV对大分辨率或者tif格式图片支持不好</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    imread_failed = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        img = cv2.imread(img_paths)</span><br><span class="line">        height, weight = img.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1.0</span> * height / weight) &lt; <span class="number">1.3</span>:       <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]     <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/1'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                   <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">30</span>:<span class="number">60</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> r:</span><br><span class="line">        print(<span class="string">"error:"</span>,r)</span><br><span class="line">        imread_failed.append(img_paths)</span><br><span class="line">    <span class="keyword">return</span> imread_failed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(input_dir,output_dir)</span>:</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    scale = len(img_paths)</span><br><span class="line"></span><br><span class="line">    results = []</span><br><span class="line">    pool = multiprocessing.Pool(processes = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">10</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">10</span>)-int(i/<span class="number">10</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        results.append(pool.apply_async(cut_img, (img_path,output_dir )))</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c, a, b)) <span class="comment"># 进度条（可用tqdm）</span></span><br><span class="line">    pool.close()                        <span class="comment"># 调用join之前，先调用close函数，否则会出错。</span></span><br><span class="line">    pool.join()                         <span class="comment"># join函数等待所有子进程结束</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        print(<span class="string">'image read failed!:'</span>, result.get())</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"All done."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    main(input_dir, output_dir)</span><br><span class="line">    <span class="comment"># cv2.imshow('imgflip_1',imgflip_1)</span></span><br></pre></td></tr></table></figure>
<p>更多：<a href="https://blog.csdn.net/sinat_36458870/article/details/78825571" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36458870/article/details/78825571</a></p>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>003-opencv图像指定区域裁剪</title>
    <url>/articles/20200301/a2f0259b.html</url>
    <content><![CDATA[<p>摘要：003-opencv图像指定区域裁剪</p>
<p>在工作中。在做数据集时，需要对图片进行处理，照相的图片我们只需要特定的部分，所以就想到裁剪一种所需的部分。当然若是图片有规律可循则使用opencv对其进行膨胀腐蚀等操作。这样更精准一些。</p>
<p>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/003-cut</p>
<a id="more"></a>

<h1 id="指定图像位置的裁剪处理"><a href="#指定图像位置的裁剪处理" class="headerlink" title="指定图像位置的裁剪处理"></a>指定图像位置的裁剪处理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 遍历指定目录，显示目录下的所有文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CropImage4File</span><span class="params">(filepath,destpath)</span>:</span></span><br><span class="line">    pathDir =  os.listdir(filepath)    <span class="comment"># 列出文件路径中的所有路径或文件</span></span><br><span class="line">    <span class="keyword">for</span> allDir <span class="keyword">in</span> pathDir:</span><br><span class="line">        child = os.path.join(filepath, allDir)</span><br><span class="line">        dest = os.path.join(destpath,allDir)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(child):</span><br><span class="line">            image = cv2.imread(child)</span><br><span class="line">            <span class="comment"># 获取图像形状 返回 行数值，列数值列表</span></span><br><span class="line">            sp=image.shape</span><br><span class="line">            <span class="comment">#图像的高度（行 范围）</span></span><br><span class="line">            sz1 = sp[<span class="number">0</span>]       </span><br><span class="line">            <span class="comment">#图像的宽度（列 范围）          </span></span><br><span class="line">            sz2 = sp[<span class="number">1</span>]                 </span><br><span class="line">            <span class="comment">#sz3 = sp[2]                #像素值由【RGB】三原色组成</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#你想对文件的操作</span></span><br><span class="line">            a=int(sz1/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># x start</span></span><br><span class="line">            b=int(sz1/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># x end</span></span><br><span class="line">            c=int(sz2/<span class="number">2</span><span class="number">-64</span>) <span class="comment"># y start</span></span><br><span class="line">            d=int(sz2/<span class="number">2</span>+<span class="number">64</span>) <span class="comment"># y end</span></span><br><span class="line">            cropImg = image[a:b,c:d]   <span class="comment">#裁剪图像</span></span><br><span class="line">            cv2.imwrite(dest,cropImg)  <span class="comment">#写入图像路径</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    filepath =<span class="string">'src/python-opencv/'</span>             <span class="comment">#源图像</span></span><br><span class="line">    destpath=<span class="string">'src/python-opencv/003-cut/dist_img'</span>        <span class="comment"># resized images saved here</span></span><br><span class="line">    CropImage4File(filepath,destpath)</span><br></pre></td></tr></table></figure>

<h1 id="批量处理—指定图像位置的裁剪"><a href="#批量处理—指定图像位置的裁剪" class="headerlink" title="批量处理—指定图像位置的裁剪"></a>批量处理—指定图像位置的裁剪</h1><p>我这个是用来截取发票的印章区域，用于图像分割（公司的数据集保密）<br>各位可以用自己的增值发票裁剪。适当的更改截取区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    scale = len(img_paths)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">1000</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">1000</span>)-int(i/<span class="number">1000</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        print(<span class="string">'正在处理图像： %s'</span> % img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>])</span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        weight = img.shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> weight&gt;<span class="number">1600</span>:                         <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">50</span>:<span class="number">200</span>, <span class="number">700</span>:<span class="number">1500</span>]    <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            <span class="comment">#cropImg = cv2.resize(cropImg, None, fx=0.5, fy=0.5,</span></span><br><span class="line">                                 <span class="comment">#interpolation=cv2.INTER_CUBIC) #缩小图像</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                        <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span>+img_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c,a,b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    print(<span class="string">'图片获取完成 。。。！'</span>)</span><br><span class="line">    cut_img(img_paths,output_dir)</span><br></pre></td></tr></table></figure>

<h1 id="多进程（加快处理）"><a href="#多进程（加快处理）" class="headerlink" title="多进程（加快处理）"></a>多进程（加快处理）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">采用多进程加快处理。添加了在读取图片时捕获异常，OpenCV对大分辨率或者tif格式图片支持不好</span></span><br><span class="line"><span class="string">处理数据集 和 标签数据集的代码：（主要是对原始数据集裁剪）</span></span><br><span class="line"><span class="string">    处理方式：分别处理</span></span><br><span class="line"><span class="string">    注意修改 输入 输出目录 和 生成的文件名</span></span><br><span class="line"><span class="string">    output_dir = "./label_temp"</span></span><br><span class="line"><span class="string">    input_dir = "./label"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span><span class="params">(input_dir)</span>:</span></span><br><span class="line">    img_paths = []</span><br><span class="line">    <span class="keyword">for</span> (path,dirname,filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            img_paths.append(path+<span class="string">'/'</span>+filename)</span><br><span class="line">    print(<span class="string">"img_paths:"</span>,img_paths)</span><br><span class="line">    <span class="keyword">return</span> img_paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_img</span><span class="params">(img_paths,output_dir)</span>:</span></span><br><span class="line">    imread_failed = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        img = cv2.imread(img_paths)</span><br><span class="line">        height, weight = img.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1.0</span> * height / weight) &lt; <span class="number">1.3</span>:       <span class="comment"># 正常发票</span></span><br><span class="line">            cropImg = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">600</span>]     <span class="comment"># 裁剪【y1,y2：x1,x2】</span></span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/1'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg)</span><br><span class="line">        <span class="keyword">else</span>:                                   <span class="comment"># 卷帘发票</span></span><br><span class="line">            cropImg_01 = img[<span class="number">30</span>:<span class="number">150</span>, <span class="number">30</span>:<span class="number">60</span>]</span><br><span class="line">            cv2.imwrite(output_dir + <span class="string">'/'</span> + img_paths.split(<span class="string">'/'</span>)[<span class="number">-1</span>], cropImg_01)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> r:</span><br><span class="line">        print(<span class="string">"error:"</span>,r)</span><br><span class="line">        imread_failed.append(img_paths)</span><br><span class="line">    <span class="keyword">return</span> imread_failed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(input_dir,output_dir)</span>:</span></span><br><span class="line">    img_paths = get_img(input_dir)</span><br><span class="line">    scale = len(img_paths)</span><br><span class="line"></span><br><span class="line">    results = []</span><br><span class="line">    pool = multiprocessing.Pool(processes = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i,img_path <span class="keyword">in</span> enumerate(img_paths):</span><br><span class="line">        a = <span class="string">"#"</span>* int(i/<span class="number">10</span>)</span><br><span class="line">        b = <span class="string">"."</span>*(int(scale/<span class="number">10</span>)-int(i/<span class="number">10</span>))</span><br><span class="line">        c = (i/scale)*<span class="number">100</span></span><br><span class="line">        results.append(pool.apply_async(cut_img, (img_path,output_dir )))</span><br><span class="line">        print(<span class="string">'&#123;:^3.3f&#125;%[&#123;&#125;&gt;&gt;&#123;&#125;]'</span>.format(c, a, b)) <span class="comment"># 进度条（可用tqdm）</span></span><br><span class="line">    pool.close()                        <span class="comment"># 调用join之前，先调用close函数，否则会出错。</span></span><br><span class="line">    pool.join()                         <span class="comment"># join函数等待所有子进程结束</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        print(<span class="string">'image read failed!:'</span>, result.get())</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"All done."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    output_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>           <span class="comment"># 保存截取的图像目录</span></span><br><span class="line">    input_dir = <span class="string">"src/python-opencv/003-cut/dist_img"</span>                <span class="comment"># 读取图片目录表</span></span><br><span class="line">    main(input_dir, output_dir)</span><br><span class="line">    <span class="comment"># cv2.imshow('imgflip_1',imgflip_1)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>002-opencv图像压缩</title>
    <url>/articles/20200229/576a7ff9.html</url>
    <content><![CDATA[<p>摘要：002-opencv图像压缩<br>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/002-enhance</p>
<a id="more"></a>

<h1 id="简单的图像压缩"><a href="#简单的图像压缩" class="headerlink" title="简单的图像压缩"></a>简单的图像压缩</h1><p>cv2的ImageEnhance模块</p>
<ul>
<li>ImageEnhance.Color(image) 颜色增强类：用于调整图像的颜色均衡</li>
<li>ImageEnhance.Brightness(image) 亮度增强类：用于调整图像的亮度。</li>
<li>ImageEnhance.Contrast(image) 对比度增强类：用于调整图像的对比度。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------直接读取--------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(imgPath,enhance)</span>:</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,0)    #读取图像（直接读取）</span></span><br><span class="line"></span><br><span class="line">    image=cv2.imread(imgPath)</span><br><span class="line">    res = cv2.resize(image, (image.shape[<span class="number">1</span>],image.shape[<span class="number">0</span>]), interpolation=cv2.INTER_AREA)</span><br><span class="line">    imgE = Image.fromarray(cv2.cvtColor(res,cv2.COLOR_BGR2RGB))</span><br><span class="line">    imgEH = ImageEnhance.Contrast(imgE)</span><br><span class="line">    <span class="comment"># 当参数为1.2 灰度图243KB，当参数为2.8 灰度图124KB.（亮度提升后转灰度图，图片会黑白分化）</span></span><br><span class="line">    gray=imgEH.enhance(enhance).convert(<span class="string">"L"</span>)</span><br><span class="line">    gray.save(<span class="string">r"src/python-opencv/002-enhance/dist_img/test_001_simple.gray."</span>+str(enhance)+<span class="string">".png"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#图像增强</span></span><br><span class="line">    <span class="comment"># 创建滤波器，使用不同的卷积核</span></span><br><span class="line">    gray2=gray.filter(ImageFilter.DETAIL)</span><br><span class="line">    gray2.save(<span class="string">r"src/python-opencv/002-enhance/dist_img/test_001_simple.gray2."</span>+str(enhance)+<span class="string">".png"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># #图像点运算</span></span><br><span class="line">    gray3=gray2.point(<span class="keyword">lambda</span> i:i*<span class="number">0.9</span>)</span><br><span class="line">    gray3.save(<span class="string">r"src/python-opencv/002-enhance/dist_img/test_001_simple.gray3."</span>+str(enhance)+<span class="string">".png"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># k = cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># if k == 27:                     # 按 Esc 退出（关闭显示窗口）</span></span><br><span class="line">    <span class="comment">#     cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    enhance=<span class="number">1.2</span></span><br><span class="line">    func(imgPath,enhance)</span><br><span class="line">    enhance=<span class="number">2.8</span></span><br><span class="line">    func(imgPath,enhance)</span><br></pre></td></tr></table></figure>

<h1 id="基于机器学习的图像压缩方法"><a href="#基于机器学习的图像压缩方法" class="headerlink" title="基于机器学习的图像压缩方法"></a>基于机器学习的图像压缩方法</h1><p>关于PCA降维，SVD理论详情：<a href="https://blog.csdn.net/wsp_1138886114/article/details/80967843" target="_blank" rel="noopener">https://blog.csdn.net/wsp_1138886114/article/details/80967843</a></p>
<h2 id="SVD图像压缩"><a href="#SVD图像压缩" class="headerlink" title="SVD图像压缩"></a>SVD图像压缩</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild_img</span><span class="params">(u, sigma, v, p)</span>:</span>  <span class="comment"># p表示奇异值的百分比</span></span><br><span class="line">    print(<span class="string">'sigma.shape'</span>, sigma.shape)</span><br><span class="line">    print(<span class="string">'sum(sigma)'</span>, sum(sigma))</span><br><span class="line">    m , n= len(u),len(v)</span><br><span class="line">    a = np.zeros((m, n))         <span class="comment"># 创建空图片</span></span><br><span class="line"></span><br><span class="line">    count = (int)(sum(sigma))</span><br><span class="line">    curSum = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> curSum &lt;= count * p:</span><br><span class="line">        uk = u[:, k].reshape(m, <span class="number">1</span>)</span><br><span class="line">        vk = v[k].reshape(<span class="number">1</span>, n)</span><br><span class="line">        a += sigma[k] * np.dot(uk, vk)</span><br><span class="line">        curSum += sigma[k]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'==k===:'</span>, k)</span><br><span class="line"></span><br><span class="line">    a[a &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    a[a &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> np.rint(a).astype(<span class="string">"uint8"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> np.arange(<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">0.2</span>):</span><br><span class="line">        u, sigma, v = np.linalg.svd(img[:, :, <span class="number">0</span>])</span><br><span class="line">        R = rebuild_img(u, sigma, v, p)</span><br><span class="line"></span><br><span class="line">        u, sigma, v = np.linalg.svd(img[:, :, <span class="number">1</span>])</span><br><span class="line">        G = rebuild_img(u, sigma, v, p)</span><br><span class="line"></span><br><span class="line">        u, sigma, v = np.linalg.svd(img[:, :, <span class="number">2</span>])</span><br><span class="line">        B = rebuild_img(u, sigma, v, p)</span><br><span class="line"></span><br><span class="line">        I = np.stack((R, G, B), <span class="number">2</span>)</span><br><span class="line">        cv2.imshow(<span class="string">"svd_"</span> + str(p * <span class="number">100</span>),I)</span><br><span class="line">        <span class="comment"># cv2.imwrite("src/python-opencv/002-enhance/dist_img_" + str(p * 100) + ".jpg", I)</span></span><br><span class="line">    cv2.imshow(<span class="string">"img"</span> , img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>奇异值分解能够有效的降低数据的维数，以本文的图片为例，从450维降到149维后，还保留了90%的信息<br>虽然奇异值分解很有效，但是不能滥用，一般情况下要求降维后信息的损失度不能超过5%，甚至是1%<br>Ng的视频中提到常见的错误使用降维的情况，在这里也贴出来：<br>使用降维解决过拟合问题<br>不论什么情况，先用降维处理一下数据，即把降维当做模型训练的必须步骤</p>
<h2 id="PCA图像压缩"><a href="#PCA图像压缩" class="headerlink" title="PCA图像压缩"></a>PCA图像压缩</h2><p>pca函数实现图像的降维<br>关于PCA理论详情请点击：<a href="https://blog.csdn.net/wsp_1138886114/article/details/80967843" target="_blank" rel="noopener">https://blog.csdn.net/wsp_1138886114/article/details/80967843</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comp_2d</span><span class="params">(image_2d,rate)</span>:</span></span><br><span class="line">    height,width = image_2d.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行下面这一行报错显示无法广播。我修改了dtype还是报错，不知道为何。</span></span><br><span class="line">    <span class="comment"># cov_mat = image_2d - np.mean(image_2d, axis=1) 。</span></span><br><span class="line">    <span class="comment"># print("data.type:", image_2d.astype(np.float64).dtype)</span></span><br><span class="line">    <span class="comment"># print("mean.type:", np.mean(image_2d, axis=1).dtype)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># print("data.shape:", image_2d.astype(np.float64).shape)</span></span><br><span class="line">    <span class="comment"># print("mean.shape:", np.mean(image_2d, axis=1).shape)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我自己广播代码为如下三行代码</span></span><br><span class="line">    mean_array = np.mean(image_2d, axis=<span class="number">1</span>)</span><br><span class="line">    mean_array = mean_array[:, np.newaxis]</span><br><span class="line">    mean_array = np.tile(mean_array, width)</span><br><span class="line"></span><br><span class="line">    cov_mat = image_2d.astype(np.float64) - mean_array</span><br><span class="line">    eig_val, eig_vec = np.linalg.eigh(np.cov(cov_mat))  <span class="comment"># 求特征值 特征向量</span></span><br><span class="line">    p = np.size(eig_vec, axis=<span class="number">1</span>)</span><br><span class="line">    idx = np.argsort(eig_val)</span><br><span class="line">    idx = idx[::<span class="number">-1</span>]</span><br><span class="line">    eig_vec = eig_vec[:, idx]</span><br><span class="line">    numpc = rate</span><br><span class="line">    <span class="keyword">if</span> numpc &lt; p <span class="keyword">or</span> numpc &gt; <span class="number">0</span>:</span><br><span class="line">        eig_vec = eig_vec[:, range(numpc)]</span><br><span class="line">    score = np.dot(eig_vec.T, cov_mat)</span><br><span class="line">    recon = np.dot(eig_vec, score) + mean_array</span><br><span class="line">    recon_img_mat = np.uint8(np.absolute(recon))</span><br><span class="line">    <span class="keyword">return</span> recon_img_mat</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    height, width = data.shape[:<span class="number">2</span>]</span><br><span class="line">    a_g = data[:, :, <span class="number">0</span>]</span><br><span class="line">    a_b = data[:, :, <span class="number">1</span>]</span><br><span class="line">    a_r = data[:, :, <span class="number">2</span>]</span><br><span class="line">    rates = [<span class="number">30</span>,<span class="number">60</span>,<span class="number">90</span>]  <span class="comment">#主成分前30，60，90个k值</span></span><br><span class="line">    <span class="keyword">for</span> rate <span class="keyword">in</span> rates:</span><br><span class="line">        g_recon, b_recon, r_recon = comp_2d(a_g,rate), comp_2d(a_b,rate), comp_2d(a_r,rate)</span><br><span class="line">        result = cv2.merge([g_recon, b_recon, r_recon])</span><br><span class="line">        cv2.imshow(<span class="string">'result_'</span>+str(rate),result)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>显然，k=30时就包含了矩阵的至少70%的信息含量，当k=90时就包含了矩阵的至少90%信息含量。</p>
<h1 id="基于K-means图像压缩"><a href="#基于K-means图像压缩" class="headerlink" title="基于K-means图像压缩"></a>基于K-means图像压缩</h1><h2 id="肘部法则"><a href="#肘部法则" class="headerlink" title="肘部法则"></a>肘部法则</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cdist</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]= [<span class="string">'SimHei'</span>]    <span class="comment">#中文注释</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>     <span class="comment">#显示正负号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    cluster1 = np.random.uniform(<span class="number">0.5</span>,<span class="number">1.5</span>,(<span class="number">2</span>,<span class="number">5</span>))    <span class="comment">#生成（0.5,1.5）之间的随机数（2行5列）</span></span><br><span class="line">    cluster2 = np.random.uniform(<span class="number">3.5</span>,<span class="number">4.5</span>,(<span class="number">2</span>,<span class="number">5</span>))</span><br><span class="line">    X = np.hstack((cluster1,cluster2)).T           <span class="comment">#列拼接 并转置（10行2列）</span></span><br><span class="line"></span><br><span class="line">    K = range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    meandistortions = []    <span class="comment">#存放聚类中心列表</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> K:</span><br><span class="line">        kmeans = KMeans(n_clusters=k)</span><br><span class="line">        kmeans.fit(X)       <span class="comment">#拟合训练</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#任一点到 簇中心点（1,2,3,4,5）的最小距离（计算过程：求和再求平均值）</span></span><br><span class="line">        meandistortions.append(sum(np.min(cdist(X,kmeans.cluster_centers_,<span class="string">'euclidean'</span>), axis=<span class="number">1</span>)) / X.shape[<span class="number">0</span>])</span><br><span class="line">        print(<span class="string">"第 &#123;&#125; 次-聚类中心"</span>.format(k))</span><br><span class="line">        print(cdist(X,kmeans.cluster_centers_,<span class="string">'euclidean'</span>))</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">"第 &#123;&#125; 次聚类时----任一点到这&#123;&#125;个聚类中心其中一个的最小值"</span>.format(k,k))</span><br><span class="line">        print(np.min(cdist(X,kmeans.cluster_centers_,<span class="string">'euclidean'</span>), axis=<span class="number">1</span>))</span><br><span class="line">    print(meandistortions)</span><br><span class="line">    plt.plot(K, meandistortions,<span class="string">'bx-'</span>) <span class="comment"># 颜色blue，线条为-</span></span><br><span class="line">    plt.xlabel(<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">    plt.ylabel(<span class="string">'Ave Distor'</span>)           <span class="comment"># plt.ylabel('平均畸变程度',fontproperties=font)</span></span><br><span class="line">    plt.title(<span class="string">'Elbow method value K'</span>)  <span class="comment"># plt.title('用肘部法则来确定最佳的K值',fontproperties=font);</span></span><br><span class="line">    plt.scatter(K,meandistortions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>

<h2 id="轮廓系数验证K值"><a href="#轮廓系数验证K值" class="headerlink" title="轮廓系数验证K值"></a>轮廓系数验证K值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cdist</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]= [<span class="string">'SimHei'</span>]    <span class="comment">#中文注释</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>     <span class="comment">#显示正负号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">10</span>)) </span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    x1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">    x2 = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">    X = np.array(list(zip(x1, x2))).reshape(len(x1), <span class="number">2</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">10</span>])                                   <span class="comment"># x轴的刻度</span></span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">10</span>])                                   <span class="comment"># y轴的刻度</span></span><br><span class="line">    plt.title(<span class="string">'Sample'</span>)</span><br><span class="line">    plt.scatter(x1, x2)</span><br><span class="line">    colors = [<span class="string">'b'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'c'</span>, <span class="string">'m'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'b'</span>]  <span class="comment">#样本点颜色</span></span><br><span class="line">    markers = [<span class="string">'o'</span>, <span class="string">'s'</span>, <span class="string">'D'</span>, <span class="string">'v'</span>, <span class="string">'^'</span>, <span class="string">'p'</span>, <span class="string">'*'</span>, <span class="string">'+'</span>] <span class="comment">#样本点形状</span></span><br><span class="line">    tests = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]                            <span class="comment">#簇的个数</span></span><br><span class="line">    subplot_counter = <span class="number">1</span>                                <span class="comment">#训练模型</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> tests:</span><br><span class="line">        subplot_counter += <span class="number">1</span></span><br><span class="line">        plt.subplot(<span class="number">3</span>, <span class="number">2</span>, subplot_counter)</span><br><span class="line">        kmeans_model = KMeans(n_clusters=t).fit(X)</span><br><span class="line">        <span class="keyword">for</span> i, l <span class="keyword">in</span> enumerate(kmeans_model.labels_):</span><br><span class="line">            plt.plot(x1[i], x2[i], color=colors[l], marker=markers[l],ls=<span class="string">'None'</span>)</span><br><span class="line">            plt.xlim([<span class="number">0</span>, <span class="number">10</span>])</span><br><span class="line">            plt.ylim([<span class="number">0</span>, <span class="number">10</span>])                       <span class="comment">#SCoefficient:轮廓系数[-1,1]</span></span><br><span class="line">            plt.title(<span class="string">'K = %s, SCoefficient = %.03f'</span> % (t, metrics.silhouette_score</span><br><span class="line">                                                        (X, kmeans_model.labels_,metric=<span class="string">'euclidean'</span>)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>

<h2 id="Mini-Batch-K-Means（适合大数据的聚类算法）"><a href="#Mini-Batch-K-Means（适合大数据的聚类算法）" class="headerlink" title="Mini Batch K-Means（适合大数据的聚类算法）"></a>Mini Batch K-Means（适合大数据的聚类算法）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans, KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># make_blobs 自定义数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># X为样本特征，Y为样本簇类别， 共1000个样本，</span></span><br><span class="line">    <span class="comment"># 每个样本4个特征，共4个簇，</span></span><br><span class="line">    <span class="comment"># 簇中心在[-1,-1], [0,0],[1,1], [2,2]， </span></span><br><span class="line">    <span class="comment"># 簇方差分别为[0.4, 0.2, 0.2]</span></span><br><span class="line"></span><br><span class="line">    X, y = make_blobs(n_samples=<span class="number">1000</span>, n_features=<span class="number">2</span>, </span><br><span class="line">                    centers=[[<span class="number">-1</span>,<span class="number">-1</span>], [<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>]], </span><br><span class="line">                    cluster_std=[<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>], </span><br><span class="line">                    random_state =<span class="number">9</span>)</span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], marker=<span class="string">'o'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, k <span class="keyword">in</span> enumerate((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)):</span><br><span class="line">        plt.subplot(<span class="number">2</span>,<span class="number">2</span>,index+<span class="number">1</span>)</span><br><span class="line">        y_pred = MiniBatchKMeans(n_clusters=k, batch_size = <span class="number">200</span>, random_state=<span class="number">9</span>).fit_predict(X)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#用Calinski-Harabasz Index评估二分类的聚类分数 其方法是metrics.calinski_harabaz_score</span></span><br><span class="line">        score= metrics.calinski_harabaz_score(X, y_pred)  </span><br><span class="line">        plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred)</span><br><span class="line">        plt.text(<span class="number">.99</span>, <span class="number">.01</span>, (<span class="string">'k=%d, score: %.2f'</span> % (k,score)),</span><br><span class="line">                    transform=plt.gca().transAxes, size=<span class="number">10</span>,</span><br><span class="line">                    horizontalalignment=<span class="string">'right'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = cv2.imread(<span class="string">r'src/python-opencv/a.jpg'</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>

<h2 id="使用K-means压缩图片"><a href="#使用K-means压缩图片" class="headerlink" title="使用K-means压缩图片"></a>使用K-means压缩图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> pairwise_distances_argmin</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_sample_image</span><br><span class="line"><span class="keyword">from</span> sklearn.utils <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recreate_image</span><span class="params">(codebook, labels, w, h)</span>:</span></span><br><span class="line">    <span class="comment"># Recreate the (compressed) image from the code book &amp; labels</span></span><br><span class="line">    d = codebook.shape[<span class="number">1</span>]</span><br><span class="line">    image = np.zeros((w, h, d))</span><br><span class="line">    label_idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(h):</span><br><span class="line">            image[i][j] = codebook[labels[label_idx]]</span><br><span class="line">            label_idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    n_colors = <span class="number">64</span></span><br><span class="line">    china2 = load_sample_image(imgPath)  <span class="comment"># 加载图片</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#转换为浮点数，PLTIMSID行为在浮点数据上很好地工作</span></span><br><span class="line">    china2 = np.array(china2, dtype=np.float64) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#将图片转成二维数组</span></span><br><span class="line">    w, h, d = original_shape = tuple(china2.shape)</span><br><span class="line">    <span class="keyword">assert</span> d == <span class="number">3</span></span><br><span class="line">    image_array = np.reshape(china2, (w * h, d))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"一个小样本数据的拟合模型"</span>)</span><br><span class="line">    t0 = time()</span><br><span class="line">    image_array_sample = shuffle(image_array, random_state=<span class="number">0</span>)[:<span class="number">1000</span>]</span><br><span class="line">    kmeans = KMeans(n_clusters=n_colors, random_state=<span class="number">0</span>).fit(image_array_sample)</span><br><span class="line">    print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get labels for all points</span></span><br><span class="line">    print(<span class="string">"Predicting color indices on the full image (k-means)"</span>)</span><br><span class="line">    t0 = time()</span><br><span class="line">    labels = kmeans.predict(image_array)</span><br><span class="line">    print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># codebook_random = shuffle(image_array, random_state=0)[:n_colors + 1]</span></span><br><span class="line">    <span class="comment"># print("Predicting color indices on the full image (random)")</span></span><br><span class="line">    <span class="comment"># t0 = time()</span></span><br><span class="line">    <span class="comment"># labels_random = pairwise_distances_argmin(codebook_random,</span></span><br><span class="line">                                            <span class="comment"># image_array,</span></span><br><span class="line">                                            <span class="comment"># axis=0)</span></span><br><span class="line">    <span class="comment"># print("done in %0.3fs." % (time() - t0))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display all results, alongside original image</span></span><br><span class="line">    plt.figure(<span class="number">1</span>)</span><br><span class="line">    plt.clf()</span><br><span class="line">    ax = plt.axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.title(<span class="string">'Original image (96,615 colors)'</span>)</span><br><span class="line">    plt.imshow(china2)</span><br><span class="line"></span><br><span class="line">    plt.figure(<span class="number">2</span>)</span><br><span class="line">    plt.clf()</span><br><span class="line">    ax = plt.axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.title(<span class="string">'Quantized image (64 colors, K-Means)'</span>)</span><br><span class="line">    plt.imshow(recreate_image(kmeans.cluster_centers_, labels, w, h))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plt.figure(3)</span></span><br><span class="line">    <span class="comment"># plt.clf()</span></span><br><span class="line">    <span class="comment"># ax = plt.axes([0, 0, 1, 1])</span></span><br><span class="line">    <span class="comment"># plt.axis('off')</span></span><br><span class="line">    <span class="comment"># plt.title('Quantized image (64 colors, Random)')</span></span><br><span class="line">    <span class="comment"># plt.imshow(recreate_image(codebook_random, labels_random, w, h))</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    imgPath = <span class="string">'a.jpg'</span></span><br><span class="line">    func(imgPath)</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>001-opencv图像基本操作</title>
    <url>/articles/20200229/2c2f4b26.html</url>
    <content><![CDATA[<p>摘要：001-opencv图像基本操作<br>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/001-base</p>
<a id="more"></a>

<h1 id="图片-读、写、显示、属性查看"><a href="#图片-读、写、显示、属性查看" class="headerlink" title="图片 读、写、显示、属性查看"></a>图片 读、写、显示、属性查看</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------直接读取--------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">direct_read</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath,<span class="number">0</span>)    <span class="comment">#读取图像（直接读取）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,cv2.IMREAD_COLOR)   #读取图像（BGR，忽略alpha通道）</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,cv2.IMREAD_GRAYSCALE)   #读取图像（读入灰度图片）</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(imgPath,cv2.IMREAD_UNCHANGED)   #读取图像（完整图片，包括alpha通道）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># -----------------------------图片的属性 （长、宽、通道数）--------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    输出：</span></span><br><span class="line"><span class="string">        图片形状： (366, 445, 3)</span></span><br><span class="line"><span class="string">        图片大小： 488610</span></span><br><span class="line"><span class="string">        图片类型： uint8</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"图片形状："</span>,img.shape)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"图片大小："</span>,img.size)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"图片类型："</span>,img.dtype)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)         <span class="comment">#显示图像</span></span><br><span class="line">    k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:                     <span class="comment"># 按 Esc 退出（关闭显示窗口）</span></span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">    <span class="keyword">elif</span> k == ord(<span class="string">'s'</span>):             <span class="comment"># 按 's' 保存并退出 （关闭显示窗口）</span></span><br><span class="line">        cv2.imwrite(<span class="string">'test.png'</span>,img)</span><br><span class="line">        cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------保存------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">写入（保存）图片选取参数：</span></span><br><span class="line"><span class="string">	cv2.imwrite(file，img，num)</span></span><br><span class="line"><span class="string">	file：文件名</span></span><br><span class="line"><span class="string">	img： 图像</span></span><br><span class="line"><span class="string">	num： 可选参数（针对特定的格式）：</span></span><br><span class="line"><span class="string">		  对于JPEG，表示图像的质量，用0-100的整数表示，默认95，越高画质越好，文件越大</span></span><br><span class="line"><span class="string">		  对于png， 表示压缩级别。范围0到9，默认3，越高文件越小，画质越差</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    grayImage = cv2.imread(imgPath, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    cv2.imwrite(<span class="string">'test.png'</span>, grayImage) </span><br><span class="line">    cv2.imwrite(<span class="string">'test.jpeg'</span>, grayImage , (cv2.IMWRITE_JPEG_QUALITY, <span class="number">80</span>))</span><br><span class="line">    cv2.imwrite(<span class="string">'test.png'</span>, grayImage , (cv2.IMWRITE_PNG_COMPRESSION, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    direct_read(imgPath)</span><br></pre></td></tr></table></figure>

<h1 id="图像增强（缩放、平移、旋转、翻转）"><a href="#图像增强（缩放、平移、旋转、翻转）" class="headerlink" title="图像增强（缩放、平移、旋转、翻转）"></a>图像增强（缩放、平移、旋转、翻转）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># （缩放、平移、旋转、翻转）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像缩放--------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">cv2.resize(src,dsize,dst=None,fx=None,fy=None,interpolation=None)  </span></span><br><span class="line"><span class="string">	scr:   原图</span></span><br><span class="line"><span class="string">	dsize：输出图像尺寸</span></span><br><span class="line"><span class="string">	fx:    沿水平轴的比例因子(大于1放大图像；小于1缩小图像)</span></span><br><span class="line"><span class="string">	fy:    沿垂直轴的比例因子（同上）</span></span><br><span class="line"><span class="string">	interpolation：插值方法（见附录）</span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_resize</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># 方法1：直接设定缩放因子</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    res = cv2.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation = cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line">    print(img.shape)         <span class="comment">#输出为（366，445，3）【宽:x轴，高:y轴，通道数】</span></span><br><span class="line">    print(img.shape[:<span class="number">2</span>])     <span class="comment">#输出为（366，445）</span></span><br><span class="line">    cv2.imshow(<span class="string">'res'</span>, res)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#方法2：获取原图像的水平方向尺寸和垂直方向尺寸。再缩放</span></span><br><span class="line">    height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line">    res2 = cv2.resize(img,(<span class="number">2</span>*width, <span class="number">3</span>*height), interpolation = cv2.INTER_CUBIC)</span><br><span class="line">    cv2.imshow(<span class="string">'res2'</span>, res2)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像平移--------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_warp</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath,<span class="number">0</span>)</span><br><span class="line">    rows,cols = img.shape</span><br><span class="line">    </span><br><span class="line">    M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span><br><span class="line">    dst = cv2.warpAffine(img,M,(cols,rows))</span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,dst)                  <span class="comment">#展示图片并退出</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像旋转--------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">cv2.getRotationMatrix2D()</span></span><br><span class="line"><span class="string">详细参数：</span></span><br><span class="line"><span class="string">	得到变换的矩阵，通过这个矩阵再利用warpAffine来进行变换</span></span><br><span class="line"><span class="string">	第一个参数就是旋转中心，元组的形式，这里设置成相片中心</span></span><br><span class="line"><span class="string">	第二个参数90，是旋转的角度</span></span><br><span class="line"><span class="string">	第三个参数1，表示放缩的系数，1表示保持原图大小</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_rot</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    rows, cols,_ = img.shape</span><br><span class="line"></span><br><span class="line">    Matrix = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), <span class="number">90</span>, <span class="number">1</span>)</span><br><span class="line">    img1 = cv2.warpAffine(img, Matrix, (cols, rows))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>, img)</span><br><span class="line">    cv2.imshow(<span class="string">'img1'</span>, img1) </span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------图像(X,Y轴翻转)--------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"> cv2.flip(img,flipcode) 翻转图像，flipcode控制翻转效果。</span></span><br><span class="line"><span class="string">	flipcode = 0：沿x轴翻转</span></span><br><span class="line"><span class="string">	flipcode &gt; 0：沿y轴翻转</span></span><br><span class="line"><span class="string">	flipcode &lt; 0：x,y轴同时翻转</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_flip</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath,<span class="number">0</span>)</span><br><span class="line">    imgflip_1 = cv2.flip(img,<span class="number">1</span>)</span><br><span class="line">    imgflip_0 = cv2.flip(img,<span class="number">0</span>)</span><br><span class="line">    imgflip_2 = cv2.flip(img,<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'imgflip_1'</span>,imgflip_1) </span><br><span class="line">    cv2.imshow(<span class="string">'imgflip_0'</span>,imgflip_0) </span><br><span class="line">    cv2.imshow(<span class="string">'imgflip_2'</span>,imgflip_2) </span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_resize(imgPath)</span></span><br><span class="line">    <span class="comment"># img_warp(imgPath)</span></span><br><span class="line">    img_rot(imgPath)</span><br><span class="line">    <span class="comment"># img_flip(imgPath)</span></span><br></pre></td></tr></table></figure>

<h1 id="仿射变换（图像位置校正）"><a href="#仿射变换（图像位置校正）" class="headerlink" title="仿射变换（图像位置校正）"></a>仿射变换（图像位置校正）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment">#  仿射变换（图像位置校正）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_three</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># ---------------------------三点得到一个变换矩阵 ---------------------------</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        三点确定一个平面，通过确定三个点的关系来得到转换矩阵</span></span><br><span class="line"><span class="string">        然后再通过warpAffine来进行变换</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    rows,cols,_ = img.shape</span><br><span class="line">    points1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">    points2 = np.float32([[<span class="number">10</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span><br><span class="line"></span><br><span class="line">    matrix = cv2.getAffineTransform(points1,points2)</span><br><span class="line">    output = cv2.warpAffine(img,matrix,(cols,rows))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'input1'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'output1'</span>,output)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_four</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># ---------------------------四点得到一个变换矩阵---------------------------</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        进行透视变换</span></span><br><span class="line"><span class="string">        可以先用四个点来确定一个3*3的变换矩阵（cv2.getPerspectiveTransform）</span></span><br><span class="line"><span class="string">        然后通过cv2.warpPerspective和上述矩阵对图像进行变换</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    rows,cols,_ = img.shape</span><br><span class="line">    points1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">    points2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line"></span><br><span class="line">    matrix = cv2.getPerspectiveTransform(points1,points2)</span><br><span class="line">    <span class="comment"># 将四个点组成的平面转换成另四个点组成的一个平面</span></span><br><span class="line">    output = cv2.warpPerspective(img, matrix, (cols, rows))</span><br><span class="line">    <span class="comment"># 通过warpPerspective函数来进行变换</span></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'input2'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'output2'</span>,output)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_three(imgPath)</span></span><br><span class="line">    img_four(imgPath)</span><br></pre></td></tr></table></figure>

<h1 id="颜色变换（色调，明暗，直方图和Gamma曲线）"><a href="#颜色变换（色调，明暗，直方图和Gamma曲线）" class="headerlink" title="颜色变换（色调，明暗，直方图和Gamma曲线）"></a>颜色变换（色调，明暗，直方图和Gamma曲线）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment">#  颜色变换（色调，明暗，直方图和Gamma曲线）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_color</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    original_img = cv2.imread(imgPath)</span><br><span class="line">    img = cv2.resize(original_img,<span class="literal">None</span>,fx=<span class="number">0.8</span>,fy=<span class="number">0.8</span>,</span><br><span class="line">                    interpolation=cv2.INTER_AREA)            <span class="comment"># 图像缩小</span></span><br><span class="line"></span><br><span class="line">    Make_border_img = cv2.copyMakeBorder(img, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        cv2.BORDER_CONSTANT,</span><br><span class="line">                                        value=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))    <span class="comment"># 绘制边框(原图上下贴30像素黑边)</span></span><br><span class="line"></span><br><span class="line">    img_hsv = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)            <span class="comment"># 转成 HSV 格式</span></span><br><span class="line">    colorless_hsv = img_hsv.copy()</span><br><span class="line">    colorless_hsv[:,:,<span class="number">1</span>] = <span class="number">0.5</span> * colorless_hsv[:,:,<span class="number">1</span>]        <span class="comment"># 减小饱和度会让图像损失鲜艳，变得更灰</span></span><br><span class="line">    colorless_img = cv2.cvtColor(colorless_hsv,cv2.COLOR_HSV2BGR)</span><br><span class="line"></span><br><span class="line">    darker_hsv = img_hsv.copy()</span><br><span class="line">    darker_hsv[:,:,<span class="number">2</span>] = <span class="number">0.5</span> * darker_hsv[:,:,<span class="number">2</span>]             <span class="comment"># 减小明度为原来一半</span></span><br><span class="line">    darker_img = cv2.cvtColor(darker_hsv,cv2.COLOR_HSV2BGR)</span><br><span class="line"></span><br><span class="line">    img_corrected = gamma_trans(img,<span class="number">0.5</span>)                   <span class="comment"># 执行Gamma矫正</span></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"original_img"</span>,img)                         <span class="comment"># 原图</span></span><br><span class="line">    cv2.imshow(<span class="string">"Make_border_img"</span>,Make_border_img)          <span class="comment"># 添加黑边</span></span><br><span class="line">    cv2.imshow(<span class="string">'colorless_jpg'</span>,colorless_img)              <span class="comment"># 图像变灰</span></span><br><span class="line">    cv2.imshow(<span class="string">'darker_jpg'</span>,darker_img)                    <span class="comment"># 图像变暗</span></span><br><span class="line">    cv2.imshow(<span class="string">'gamma_corrected_jpg'</span>,img_corrected)        <span class="comment"># gamma校正</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line">    hist_b = cv2.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])    <span class="comment"># 分通道计算每个通道的直方图</span></span><br><span class="line">    hist_g = cv2.calcHist([img],[<span class="number">1</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    hist_r = cv2.calcHist([img],[<span class="number">2</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">    plt.plot(hist_b, label=<span class="string">'B'</span>, color=<span class="string">'blue'</span>)              <span class="comment"># 显示3个通道的颜色直方图</span></span><br><span class="line">    plt.plot(hist_g, label=<span class="string">'G'</span>, color=<span class="string">'green'</span>)</span><br><span class="line">    plt.plot(hist_r, label=<span class="string">'R'</span>, color=<span class="string">'red'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_trans</span><span class="params">(img,gamma)</span>:</span></span><br><span class="line">    gamma_table = [np.power(x/<span class="number">255.0</span>,gamma)*<span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> cv2.LUT(img,gamma_table)                    <span class="comment"># 实现这个映射用的是OpenCV的查表函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_three(imgPath)</span></span><br><span class="line">    img_color(imgPath)</span><br></pre></td></tr></table></figure>

<h2 id="本地摄像头，视频处理"><a href="#本地摄像头，视频处理" class="headerlink" title="本地摄像头，视频处理"></a>本地摄像头，视频处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">cv2.cvtColor(input_image, flag)函数实现图片颜色空间的转换：</span></span><br><span class="line"><span class="string">	flag 参数决定变换类型。如 BGR-&gt;Gray           </span></span><br><span class="line"><span class="string">	flag 就可以设置为 cv2.COLOR_BGR2GRAY</span></span><br><span class="line"><span class="string">		         cv2.COLOR_BGR2HSV 。</span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        _, frame = cap.read()                           <span class="comment"># 读取视频的每一帧</span></span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)    <span class="comment"># 将图片颜色空间从 BGR -&gt; HSV 空间</span></span><br><span class="line"></span><br><span class="line">        lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])              <span class="comment"># 定义在HSV空间中蓝色的范围</span></span><br><span class="line">        upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    </span><br><span class="line">        mask = cv2.inRange(hsv, lower_blue, upper_blue) <span class="comment"># 根据以上定义的蓝色的阈值得到蓝色的部分</span></span><br><span class="line">        res = cv2.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    </span><br><span class="line">        cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line">        cv2.imshow(<span class="string">'mask'</span>,mask)</span><br><span class="line">        cv2.imshow(<span class="string">'res'</span>,res)</span><br><span class="line">        k = cv2.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h1 id="通道的拆分-合并处理-添加边距"><a href="#通道的拆分-合并处理-添加边距" class="headerlink" title="通道的拆分/合并处理/添加边距"></a>通道的拆分/合并处理/添加边距</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通道的拆分/合并处理/添加边距</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    <span class="comment"># 拆分/合并处理</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    b,g,r = cv2.split(img)</span><br><span class="line">    img = cv2.merge((b,g,r)) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># -----------------------------添加边距--------------------------------</span></span><br><span class="line">    <span class="string">"""cv2.copyMakeBorder函数"""</span> </span><br><span class="line">    BLUE = [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    img1 = cv2.imread(imgPath)</span><br><span class="line">    </span><br><span class="line">    replicate = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REPLICATE)</span><br><span class="line">    reflect = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT)</span><br><span class="line">    reflect101 = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT_101)</span><br><span class="line">    wrap = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_WRAP)</span><br><span class="line">    constant= cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_CONSTANT,value=BLUE)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"img"</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">"replicate"</span>,replicate)</span><br><span class="line">    cv2.imshow(<span class="string">"reflect"</span>,reflect)</span><br><span class="line">    cv2.imshow(<span class="string">"reflect101"</span>,reflect101)</span><br><span class="line">    cv2.imshow(<span class="string">"wrap"</span>,wrap)</span><br><span class="line">    cv2.imshow(<span class="string">"constant"</span>,constant)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    <span class="comment"># img_three(imgPath)</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>

<h1 id="读取图像添加文字（可用于图像添加水印）"><a href="#读取图像添加文字（可用于图像添加水印）" class="headerlink" title="读取图像添加文字（可用于图像添加水印）"></a>读取图像添加文字（可用于图像添加水印）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通道的拆分/合并处理/添加边距</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,cv2.IMREAD_COLOR)    <span class="comment"># 打开文件</span></span><br><span class="line">    cv2.imshow(<span class="string">'Original_img'</span>,img )</span><br><span class="line">    font = cv2.FONT_HERSHEY_DUPLEX              <span class="comment"># 设置字体</span></span><br><span class="line">    img_word = cv2.putText(img, <span class="string">"liuyan"</span>, (<span class="number">5</span>, <span class="number">150</span>), font, <span class="number">2.5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>,)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    cv2.putText()</span></span><br><span class="line"><span class="string">    传入参数：图片对象、文本、像素、字体、字体大小、颜色、字体粗细</span></span><br><span class="line"><span class="string">    其中：像素为文字位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cv2.imshow('Original_img',img )</span></span><br><span class="line">    cv2.imshow(<span class="string">'Add_text_img'</span>,img_word )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cv2.imwrite('5.png',img_word )      # 保存</span></span><br><span class="line"></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()             <span class="comment"># 关闭所有窗口</span></span><br><span class="line">    <span class="comment"># cv2.destroyWindow(wname)            # 关闭指定窗口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interpolation   所用的插值方法</span><br><span class="line"></span><br><span class="line">	INTER_NEAREST 	最近邻插值</span><br><span class="line">	INTER_LINEAR 	双线性插值（默认设置）</span><br><span class="line">	INTER_AREA 	使用像素区域关系进行重采样。  </span><br><span class="line">	                它可能是图像抽取的首选方法，因为它会产生无云纹理的结果。 </span><br><span class="line">	                但是当图像缩放时，它类似于INTER_NEAREST方法。</span><br><span class="line">	                </span><br><span class="line">	INTER_CUBIC 	4x4像素邻域的双三次插值</span><br><span class="line">	INTER_LANCZOS4 	8x8像素邻域的Lanczos插值</span><br></pre></td></tr></table></figure>

<h1 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h1><p>将一个灰色的图片，变成要么是白色要么就是黑色。（大于规定thresh值就是设置的最大值（常为255，也就是白色））</p>
<p>Python: cv2.threshold(src, thresh, maxval, type[, dst]) → retval, dst</p>
<ul>
<li>src：表示的是图片源</li>
<li>thresh：表示的是阈值（起始值）</li>
<li>maxval：表示的是最大值</li>
<li>type：表示的是这里划分的时候使用的是什么类型的算法，常用值为0（cv2.THRESH_BINARY）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 通道的拆分/合并处理/添加边距</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,cv2.IMREAD_COLOR)    <span class="comment"># 打开文件</span></span><br><span class="line">    <span class="comment"># img = np.zeros((200, 200), dtype=np.uint8)</span></span><br><span class="line">    img[<span class="number">50</span>:<span class="number">150</span>, <span class="number">50</span>:<span class="number">150</span>] = <span class="number">255</span>  <span class="comment"># create a image with black color in the middle and its background is white.</span></span><br><span class="line">    cv2.imshow(<span class="string">"Image-Old"</span>, img)</span><br><span class="line">    ret, thresh = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">"Image-New"</span>, thresh)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>
<h1 id="反相"><a href="#反相" class="headerlink" title="反相"></a>反相</h1><h2 id="黑白反相（二值化图）"><a href="#黑白反相（二值化图）" class="headerlink" title="黑白反相（二值化图）"></a>黑白反相（二值化图）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 黑白反相（二值化图）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_color</span><span class="params">(image)</span>:</span></span><br><span class="line">    height,width = image.shape</span><br><span class="line">    img2 = image.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">            img2[i,j] = (<span class="number">255</span>-image[i,j])</span><br><span class="line">    <span class="keyword">return</span> img2 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,<span class="number">0</span>)    <span class="comment"># 打开文件</span></span><br><span class="line">    cv2.imshow(<span class="string">"Image-Old"</span>, img)</span><br><span class="line"></span><br><span class="line">    img_new = inverse_color(img)</span><br><span class="line">    cv2.imshow(<span class="string">"img_new"</span>, img_new)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>
<h2 id="彩色反相（原始图）"><a href="#彩色反相（原始图）" class="headerlink" title="彩色反相（原始图）"></a>彩色反相（原始图）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 彩色反相（二值化图）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_color</span><span class="params">(image)</span>:</span> </span><br><span class="line">    height,width,_ = image.shape </span><br><span class="line">    img2 = image.copy() </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(height): </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(width): </span><br><span class="line">            img2[i,j] = (<span class="number">255</span>-image[i,j][<span class="number">0</span>],<span class="number">255</span>-image[i,j][<span class="number">1</span>],<span class="number">255</span>-image[i,j][<span class="number">2</span>]) </span><br><span class="line">    <span class="keyword">return</span> img2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_channel</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img=cv2.imread(imgPath,cv2.IMREAD_COLOR)    <span class="comment"># 打开文件</span></span><br><span class="line">    cv2.imshow(<span class="string">"Image-Old"</span>, img)</span><br><span class="line"></span><br><span class="line">    img_new = inverse_color(img)</span><br><span class="line">    cv2.imshow(<span class="string">"img_new"</span>, img_new)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    imgPath = <span class="string">'src/python-opencv/a.jpg'</span></span><br><span class="line">    img_channel(imgPath)</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>000-图像基本信息</title>
    <url>/articles/20200229/50aaac91.html</url>
    <content><![CDATA[<p>摘要：000-图像基本信息<br>github:<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a> 下 src/python-opencv/001-base</p>
<a id="more"></a>

<p>opencv 提供了cvtColor()函数，用于在图像中不同的色彩空间进行转换，用于后续处理。在使用cvtColor之前首先需要了解下基本的图像色彩模式，色彩模式决定了打印或显示的图片颜色。</p>
<h1 id="图像色彩模式"><a href="#图像色彩模式" class="headerlink" title="图像色彩模式"></a>图像色彩模式</h1><h2 id="位图模式"><a href="#位图模式" class="headerlink" title="位图模式"></a>位图模式</h2><p>位图模式是图像中最基本的格式，图像只有黑色和白色像素，是色彩模式中占有空间最小的，同样也叫做黑白图，它包含的信息量最少，无法包含图像中的细节，相当于只有0或者1</p>
<p>一副彩色图如果要转换成黑白模式，则一般不能直接转换，需要首先将图像转换成灰度模式</p>
<h2 id="灰度模式"><a href="#灰度模式" class="headerlink" title="灰度模式"></a>灰度模式</h2><p>灰度模式即使用单一色调来表示图像，与位图模式不同，不像位图只有0和1，使用256级的灰度来表示图像，一个像素相当于占用8为一个字节，每个像素值使用0到255的亮度值代表，其中0为黑色，255为白色，相当于从黑-&gt;灰-&gt;白的过度，通常我们所说的黑白照片就是这种模式，与位图模式相比，能表现出一定的细节，占用空间也比位图模式较大</p>
<h2 id="RGB模式"><a href="#RGB模式" class="headerlink" title="RGB模式"></a>RGB模式</h2><p>RGB模式为我们经常见到的，被称为真色彩。RGB模式的图像有3个颜色通道，分布为红（Red）,绿（Green）和蓝（Bule），每个都占用8位一个字节来表示颜色信息，这样每个颜色的取值范围为0~255，那么就三种颜色就可以有多种组合，</p>
<p>当三种基色的值相等是，表现出为灰色，三种颜色都为255即为白色，三种颜色都为0，即为黑色</p>
<p>RGB模式的图像占用空间要比位图，灰度图都要大，但表现出的细节更加明显</p>
<h2 id="CMYK模式"><a href="#CMYK模式" class="headerlink" title="CMYK模式"></a>CMYK模式</h2><p>CMYK模式被称为印刷色彩模式，主要是来源于印刷行业，以打印油墨在纸张上的光线吸收特性为基础，与RGB类似，也是使用三种颜色，分别为青色（Cyan）,品红色（Magenta）,黄色（Yellow）,以及黑色（Black） </p>
<p>与RGB不同的是：RGB模式依靠的是自身发光的色彩模式，而CMYK是一种依靠反光的色彩模式。</p>
<p>H## SB模式<br>是根据日常生活中人眼的视觉对色彩的观察得而制定的一套色彩模式，最接近与人类对色彩的辨认的思考方式，所有的颜色都是用色彩三属性来描述</p>
<p>H:(色相）：是指从物体反射或透过物体传播的颜色</p>
<p>S:(饱和度)：是指颜色的强度或纯度，表示色相中灰色成分所占的比例</p>
<p>B:(亮度)：是指颜色对相对明暗程度，通常 100%定义为白色；0%为黑色 </p>
<p>除了上述以上之外，还有索引模式，多通道模式等等不再介绍</p>
<h2 id="YUV格式"><a href="#YUV格式" class="headerlink" title="YUV格式"></a>YUV格式</h2><p>除了上述图像模式之外，由于历史原因大部分摄像头输入的图片格式都是YUV格式，开始主要用于电视系统以及模拟视频领域。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。如果没用UV信息，只有Y信息，也可以进行成像不过只是黑白的，这样就能很好解决彩色电视与黑白电视的兼容问题，与RGB相比，YUV占用带宽较少，目前摄像头输出格式普遍采用YUV格式。具体介绍可以见<a href="https://blog.csdn.net/weixin_42730667/article/details/97233856" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42730667/article/details/97233856</a></p>
<p>而在图像的处理过程中，其实很少使用YUV格式，一般都需要转成RGB格式或者灰度图格式进行转换，而opencv的cvtColor()函数支持这种转换</p>
]]></content>
      <categories>
        <category>python-opencv</category>
      </categories>
  </entry>
  <entry>
    <title>007-特征提取算法-SURF-检测斑点</title>
    <url>/articles/20200229/4550d3a.html</url>
    <content><![CDATA[<p>摘要：007-特征提取算法-SURF-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SURF采用快速Hessian算法检测关键点，然后SURF提取特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>011-特征提取算法-边缘检测</title>
    <url>/articles/20200229/d3acbf6a.html</url>
    <content><![CDATA[<p>摘要：011-特征提取算法-边缘检测</p>
<a id="more"></a>

<h1 id="边缘定义及类型"><a href="#边缘定义及类型" class="headerlink" title="边缘定义及类型"></a>边缘定义及类型</h1><p>边缘类型：简单分为4中类型，阶跃型、屋脊型、斜坡型、脉冲型，其中阶跃型和斜坡型是类似的，只是变化的快慢不同。</p>
<h1 id="边缘检测算子类别"><a href="#边缘检测算子类别" class="headerlink" title="边缘检测算子类别"></a>边缘检测算子类别</h1><p>边缘检测算子：</p>
<ul>
<li>一阶导数： Roberts、Sobel、Prewitt</li>
<li>二阶导数： Laplacian、Log/Marr、(Kirsch、Nevitia)</li>
<li>非微分边缘检测算子： Canny<br>算子参看：<a href="https://blog.csdn.net/wsp_1138886114/article/details/81368890" target="_blank" rel="noopener">https://blog.csdn.net/wsp_1138886114/article/details/81368890</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算子        优缺点比较</span><br><span class="line">Roberts     对具有陡峭的低噪声的图像处理效果好，但利用Roberts算子提取边缘的结果是边缘比较粗，因此边缘定位不是很准确</span><br><span class="line">Sobel       对灰度渐变和噪声较多的图像处理效果比较好，Sobel算子对边缘定位比较准确</span><br><span class="line">Kirsch      对灰度渐变和噪声较多的图像处理效果较好。</span><br><span class="line">Prewitt     对灰度渐变和噪声较多的图像处理效果较好。</span><br><span class="line">Laplacian   对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，造成一些不连续的检测边缘</span><br><span class="line">LoG         LoG算子经常出现双边缘像素边界，而且该检测方法对噪声比较敏感，所以很少用LoG算子检测边缘，而是用来判断边缘像素是位于图像的明区还是暗区</span><br><span class="line">Canny       此方法不易受噪声的干扰，能够检测到真正的弱边缘。在edge函数中，最有效的边缘检测方法是Canny方法。</span><br><span class="line">            该方法的优点在于使用两种不同的阈值分别检测强边缘和弱边缘，并且仅当弱边缘与强边缘相连时，才将弱边缘包含在输出图像中。。</span><br><span class="line">            因此，这种方法不容易被噪声”填充“，更容易检测出真正的弱边缘</span><br></pre></td></tr></table></figure>

<h2 id="OpenCV-Python-中-Canny"><a href="#OpenCV-Python-中-Canny" class="headerlink" title="OpenCV-Python 中 Canny()"></a>OpenCV-Python 中 Canny()</h2><p>步骤：</p>
<ul>
<li>彩色图像转换为灰度图像（以灰度图或者单通道图读入）</li>
<li>对图像进行高斯模糊（去噪）</li>
<li>计算图像梯度，根据梯度计算图像边缘幅值与角度</li>
<li>沿梯度方向进行非极大值抑制（边缘细化）</li>
<li>双阈值边缘连接处理</li>
<li>二值化图像输出结果</li>
</ul>
<p>“””<br>cv2.Canny(image,            # 输入原图（必须为单通道图）<br>          threshold1,<br>          threshold2,       # 较大的阈值2用于检测图像中明显的边缘<br>          [, edges[,<br>          apertureSize[,    # apertureSize：Sobel算子的大小<br>          L2gradient ]]])   # 参数(布尔值)：<br>                              true： 使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放），<br>                              false：使用L1范数（直接将两个方向导数的绝对值相加）。<br>“””</p>
]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>009-特征提取算法-BRIEF-检测斑点</title>
    <url>/articles/20200229/6944d2af.html</url>
    <content><![CDATA[<p>摘要：009-特征提取算法-BRIEF-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>并不是特征检测算法，它是一个描述符。关键点描述符是图像的一种表示，因为可以比较两个图像的关键点描述符，并找到他们的共同之处，因此可以作为特征匹配的一种方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>009-特征提取算法-BRIEF-检测斑点</title>
    <url>/articles/20200229/6944d2af.html</url>
    <content><![CDATA[<p>摘要：009-特征提取算法-BRIEF-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>并不是特征检测算法，它是一个描述符。关键点描述符是图像的一种表示，因为可以比较两个图像的关键点描述符，并找到他们的共同之处，因此可以作为特征匹配的一种方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>007-特征提取算法-SURF-检测斑点</title>
    <url>/articles/20200229/4550d3a.html</url>
    <content><![CDATA[<p>摘要：005-特征提取算法-Harris-检测角点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SURF采用快速Hessian算法检测关键点，然后SURF提取特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>006-特征提取算法-SIFT-检测斑点</title>
    <url>/articles/20200229/811a1f63.html</url>
    <content><![CDATA[<p>摘要：006-特征提取算法-SIFT-检测斑点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Harris的cornerHarris函数可以很好的检测角点，并且在图像旋转的情况下也能检测到，然而减少或者增加图像的大小，可能会丢失图像的某些部分，甚至会增加角点的质量。所以采用一种与图像比例变化无关的角点检测方法来解决特特征损失现象！也就是尺度不变特征变换（SIFT）。</p>
<p>尺度不变特征变换匹配算法<br>Scale Invariant Feature Transform(SIFT)</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>005-特征提取算法-Harris-检测角点</title>
    <url>/articles/20200229/49e94f08.html</url>
    <content><![CDATA[<p>摘要：005-特征提取算法-Harris-检测角点</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>角点：三维图像亮度变化剧烈的点或者图像边缘曲线上曲率极大值的点</p>
<p>使用cornerHarris来识别角点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv2.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line">    dst = cv2.dilate(dst,<span class="literal">None</span>)</span><br><span class="line">    img[dst&gt;<span class="number">0.01</span> * dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">    cv2.imshow(<span class="string">'corners'</span>,img)</span><br><span class="line">    cv2.imwrite(<span class="string">'corners.png'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.destroyALLWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'---------检测角点------------'</span>)</span><br><span class="line">    a(<span class="string">"/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/feature/a.jpg"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>004-图形相似-特征提取算法概述</title>
    <url>/articles/20200229/414b8f31.html</url>
    <content><![CDATA[<p>摘要：004-图形相似-特征提取算法概述</p>
<a id="more"></a>

<h1 id="概述-特征，特征描述，特征匹配"><a href="#概述-特征，特征描述，特征匹配" class="headerlink" title="概述-特征，特征描述，特征匹配"></a>概述-特征，特征描述，特征匹配</h1><p>图像处理的基础就是要进行特征点的提取，feature(interest points) detect 的方法也在不断的进步，边检测，角点检测，直线检测，圆检测，SIFT特征点检测，同时描述符也在发展，为了匹配的高效，逐渐从高维特征向量到二进制向量</p>
<p>在一般的图像处理库中（如opencv, VLFeat, Boofcv等）都会实现。</p>
<p>什么是特征，什么是特征描述，什么是特征匹配</p>
<p>要匹配两张图像是否是同一个图像，比较好的方法就是找出图像中特征显著的内容然后来进行比较，如果这些特征都一致，那么就有很高的概率称他们为同一个图像。</p>
<ol>
<li>找出图像中特征性强的内容（Feature Detect），特征性强的图案。</li>
<li>但是只知道有显著特征没用，必须知道两张图像中的特征是不是一致的，如何判断特征是不是一致的，就需要对这个特征进行描述（Feature Descriptor），如果描述非常的相似或者说是相同，那么就可以判断为是同一特征。</li>
<li>该如何去描述一个特征，什么样的描述是一个好的描述呢。描述一个特征其实就是描述特征与他周围内容的相互关系。那么什么样的描述是一个好的描述呢，就要提到为什么要描述特征了？描述特征是为了能够更好的匹配特征，使得我们认为描述相同的特征是同一个特征的是可信的（概率高的）。所以描述必须是有代表性的，具有排他性的（discriminative）,而不是模棱两可泛泛而谈的。</li>
<li>最后就可以根据描述的相似性来判断这对特征是否是同一个特征。</li>
</ol>
<h2 id="特征不变性的理解："><a href="#特征不变性的理解：" class="headerlink" title="特征不变性的理解："></a>特征不变性的理解：</h2><p>常用特征，如Harris Corner、SIFT、SURF、BRIEF、BRISK等，而特征的一个重要特性就是特征不变性，常见的就是旋转不变性和尺度不变性，还有一些具有仿射不变性的特征。而这些特征该怎么理解呢？</p>
<h3 id="旋转不变性："><a href="#旋转不变性：" class="headerlink" title="旋转不变性："></a>旋转不变性：</h3><p>旋转不变性。只要对特征定义方向，然后在同一个方向上进行特征描述就可以实现旋转不变性。这称之为 Rotation Normalization。</p>
<h3 id="尺度不变性"><a href="#尺度不变性" class="headerlink" title="尺度不变性"></a>尺度不变性</h3><p>实现尺度不变性，需要给特征加上尺度因子，在进行描述的时候，将尺度统一就可以实现尺度不变性了。这过程称为Scale Normalization。</p>
<h3 id="不变性小结"><a href="#不变性小结" class="headerlink" title="不变性小结"></a>不变性小结</h3><p>所谓的旋转不变性和尺度不变性的原理，就是我们在描述一个特征之前，将两张图像都变换到同一个方向和同一个尺度上，然后再在这个统一标准上来描述这个特征。同样的，如果在描述一个特征之前，将图像变换到同一个仿射尺度或者投影尺度上，那么就可以实现仿射不变性和投影不变性。分别称为Affine Normalization 和 Projected Normalization.</p>
<h2 id="特征提取算法小结"><a href="#特征提取算法小结" class="headerlink" title="特征提取算法小结"></a>特征提取算法小结</h2><p>特征匹配的方法是先找出特征显著的特征点（Feature Detect），然后再分别描述两个特征点（Feature Descriptor），最后比较两个描述的的相似程度来判断是否为同一个特征（Feature Match）。</p>
<p>而在特征描述之前如果能够做到确定特征的方向，则可以实现旋转不变性（Rotation invarient），如果能确定尺度，则可以实现尺度不变性（Scale invarient）。</p>
<h3 id="fast"><a href="#fast" class="headerlink" title="fast"></a>fast</h3><h3 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h3><p>提点方法：DoG的最值点位置在通过二次拟合来确定位置</p>
<p>确定方向：特征邻域的梯度直方图的最值方向</p>
<p>确定尺度：通过建立确定尺度空间，尺度空间中DoG最值所在尺度为特征尺度</p>
<p>描述方法：在特征周围取一个region，分成4*4的sub-region，对每个sub-region使用八方向的梯度表示，总共128维</p>
<h3 id="SURF"><a href="#SURF" class="headerlink" title="SURF"></a>SURF</h3><p>受SIFT启发，比SIFT快，健壮，64-dim(256B).</p>
<p>提点方法：Hessian矩阵的行列式最值</p>
<p>确定方向：特征邻域对Haar wavelet的最大响应方向</p>
<p>确定尺度：通过建立确定尺度空间，尺度空间中DoG最值所在尺度为特征尺度</p>
<p>描述方法：在特征周围取一个region，分成4*4的sub-region，对每个sub-region计算haar wavelet响应，分别取x方向响应和，x方向响应绝对值之和，y方向响应和，y方向绝对值之和四个值描述，总共64维</p>
<h3 id="BRIEF"><a href="#BRIEF" class="headerlink" title="BRIEF"></a>BRIEF</h3><p>提点方法：无</p>
<p>确定方向：无</p>
<p>确定尺度：无</p>
<p>描述方法：在特征点周围随机抽取随机点对，比较两个点的像素强度，根据结果的大小记为1或0，取256组组成256位的二进制字符串</p>
<h3 id="ORB"><a href="#ORB" class="headerlink" title="ORB"></a>ORB</h3><p>基于FAST和BRIEF，比SIFT快两个数量级，可作为SIFT的替代(a fusion of FAST keypoint detector and BRIEF descriptor). 32B binary descriptor.</p>
<p>提点方法：使用FAST提点，使用Harris Corner去除非角点</p>
<p>确定方向：使用Intensity centroid方法来确定方向</p>
<p>确定尺度：无</p>
<p>描述方法：通过贪心方法抽取符合正态分布的随机点对，其他同BRIEF</p>
<h3 id="BRISK"><a href="#BRISK" class="headerlink" title="BRISK"></a>BRISK</h3><p>提点方法：使用FAST或AGAST提点</p>
<p>确定方向：使用邻域随机抽样点对，对远点对做梯度确定方向</p>
<p>确定尺度：尺度空间中FAST提点最显著的尺度</p>
<p>描述方法：使用短距离点对进行强度匹配，组成512位的二进制字符串</p>
<h3 id="MSER"><a href="#MSER" class="headerlink" title="MSER"></a>MSER</h3><p>斑点检测</p>
<h3 id="HARRIS"><a href="#HARRIS" class="headerlink" title="HARRIS"></a>HARRIS</h3><p>角点检测方法</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>GFTT、STAR</p>
<p>需要注意的地方：</p>
<ul>
<li>链接的时候加上pkg-config opencv –cflags –libs可以加入所有opencv的库</li>
<li>SIFT，SURF是nonfree的，使用的时候需要方法initModule_nonfree()，需要头文件opencv2/nonfree/nonfree.hpp</li>
<li>FAST只是检测角点，要结合其他extractor如ORB,SIFT.</li>
</ul>
]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>002-数据库分库分表架构与框架</title>
    <url>/articles/20200227/e129d172.html</url>
    <content><![CDATA[<p>摘要：github：<a href="https://github.com/bjlhx15/framework-middleware.git" target="_blank" rel="noopener">https://github.com/bjlhx15/framework-middleware.git</a></p>
<a id="more"></a>

<h1 id="分库分表方式"><a href="#分库分表方式" class="headerlink" title="分库分表方式"></a>分库分表方式</h1><h2 id="垂直拆分与水平拆分"><a href="#垂直拆分与水平拆分" class="headerlink" title="垂直拆分与水平拆分"></a>垂直拆分与水平拆分</h2><p>表结构与数据，user</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  address</span><br><span class="line">1   张三1  15    男      北京市大兴区</span><br><span class="line">2   李四2  17    男      北京市海淀区</span><br><span class="line">3   李四3  17    男      北京市海淀区</span><br><span class="line">4   李四4  17    男      北京市海淀区</span><br></pre></td></tr></table></figure>

<h3 id="垂直拆分【纵向拆分】"><a href="#垂直拆分【纵向拆分】" class="headerlink" title="垂直拆分【纵向拆分】"></a>垂直拆分【纵向拆分】</h3><p>表结构拆分，如上分为：</p>
<ul>
<li>示例<br>表1，user_base<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  </span><br><span class="line">1   张三1   15    男    </span><br><span class="line">2   李四2   17    男</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>表2，user_ext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  address</span><br><span class="line">1    北京市大兴区</span><br><span class="line">2    北京市海淀区</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>拆分后业务清晰，查分规则明确</li>
<li>系统之间整合扩展容易</li>
<li>按照成本、应用等级、应用类型等将表放置在不同的机器上，便于管理</li>
<li>便于实现动静分离、冷热分离的数据库表的设计模式</li>
<li>数据维护简单</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>部分业务表无法关联【join】、只能通过接口方式解决。提高了复杂度</li>
<li>存在单库、单表性能瓶颈。不易进行数据扩展和性能提升</li>
<li>事务处理复杂。</li>
</ol>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>数据拆分，如上表可分为：</p>
<ul>
<li><p>示例<br>表1，user1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  address</span><br><span class="line">1   张三1  15    男      北京市大兴区</span><br><span class="line">3   李四3  17    男      北京市海淀区</span><br></pre></td></tr></table></figure>
<p>表2，user2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name  age   gender  address</span><br><span class="line">2   张三2  15    男      北京市大兴区</span><br><span class="line">4   李四4  17    男      北京市海淀区</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>单库单表数量级一定，有助于性能的提升</li>
<li>应用改造少，只需增加路由规则</li>
<li>提高了系统稳定性和负载能力</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>数据分散，使用join较难，性能差</li>
<li>拆分规则难以抽象</li>
<li>分片事务的一致性难以解决</li>
<li>数据扩容的难度和维护量极大</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>共同问题：</p>
<ol>
<li>分布式事务问题</li>
<li>跨节点join问题</li>
<li>存在跨节点合并排序、分页问题</li>
<li>多数据源管理问题</li>
</ol>
<p>如上，垂直拆分，倾向于业务拆分，技术上比较关注水平拆分。。</p>
<h2 id="使用数据库的三个阶段"><a href="#使用数据库的三个阶段" class="headerlink" title="使用数据库的三个阶段"></a>使用数据库的三个阶段</h2><p>单库单表→单库多表→多库多表</p>
<h2 id="分库分表适用情况"><a href="#分库分表适用情况" class="headerlink" title="分库分表适用情况"></a>分库分表适用情况</h2><ol>
<li>数据表瓶颈【mysql 单表5000w数据达到极限】</li>
<li>数据库吞吐瓶颈</li>
<li>未来预留设计</li>
</ol>
<h1 id="解决实施方案"><a href="#解决实施方案" class="headerlink" title="解决实施方案"></a>解决实施方案</h1><p>主要有三类：客户端分片、代理分片、支持事务的分布式数据库</p>
<h2 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h2><p>应用端实现，每个应用层直接嵌入分片逻辑，一般一个jar。主要有三种方式:应用层直接实现、通过定制JDBC协议实现、通过定义ORM框架实现。</p>
<h3 id="应用层直接实现"><a href="#应用层直接实现" class="headerlink" title="应用层直接实现"></a>应用层直接实现</h3><p>直接在应用层，根据分片字段读取分片规则，然后解析分片规则。根据分片规则实现切分的路由逻辑，从应用层直接决定每次操作应该使用哪个数据库实例、数据库以及数据库表。通常实现方式是封装成一个jar。</p>
<ul>
<li>优点：简单、快速、方便定位问题</li>
<li>缺点：业务侵入、产生较多的数据库连接</li>
</ul>
<h3 id="通过定制JDBC协议实现"><a href="#通过定制JDBC协议实现" class="headerlink" title="通过定制JDBC协议实现"></a>通过定制JDBC协议实现</h3><p>在jdbc层进行处理，参看sharding jdbc</p>
<ul>
<li>优点：业务透明，不侵入</li>
<li>缺点：需要了解jdbc协议</li>
</ul>
<h3 id="通过定义ORM框架实现"><a href="#通过定义ORM框架实现" class="headerlink" title="通过定义ORM框架实现"></a>通过定义ORM框架实现</h3><p>把分片规则实现到orm框架或者通过ORM框架的扩展机制来完成分库分表逻辑。如mybatis，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.Map"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">select * from User_#&#123;index&#125;</span><br><span class="line">where userId=#&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="代理分片"><a href="#代理分片" class="headerlink" title="代理分片"></a>代理分片</h2><p>在应用层与数据库层中增加一个代理层，把分片的路由规则配置在代理层,代理层对外提供与JDBC兼容的接口给应用层，应用层开发不必关心分片规则。</p>
<ul>
<li>优点：应用开发专注业务逻辑</li>
<li>缺点：增加了代理层，而且数据库部署一般与应用分离。</li>
</ul>
<p>框架：Cobar和Mycat</p>
<h2 id="支持事务的分布式数据库"><a href="#支持事务的分布式数据库" class="headerlink" title="支持事务的分布式数据库"></a>支持事务的分布式数据库</h2><p>如：OceanBase、TiDB，对外提供JDBC接口。</p>
<h1 id="分库分表的架构设计"><a href="#分库分表的架构设计" class="headerlink" title="分库分表的架构设计"></a>分库分表的架构设计</h1><p>如上，垂直拆分，倾向于业务拆分，技术上比较关注水平拆分。故后续研究是水平拆分</p>
<h2 id="水平切分方式的路由过程和分片维度"><a href="#水平切分方式的路由过程和分片维度" class="headerlink" title="水平切分方式的路由过程和分片维度"></a>水平切分方式的路由过程和分片维度</h2><h3 id="路由过程"><a href="#路由过程" class="headerlink" title="路由过程"></a>路由过程</h3><p>在表设计时，需要确定对表按照什么样的规则进行分库分表。</p>
<p>针对输入的请求，通过分库分表规则查找到对应的表和库的过程叫做路由。</p>
<h3 id="水平切分的分片维度"><a href="#水平切分的分片维度" class="headerlink" title="水平切分的分片维度"></a>水平切分的分片维度</h3><h4 id="按照哈希切片"><a href="#按照哈希切片" class="headerlink" title="按照哈希切片"></a>按照哈希切片</h4><p>对数据分某个字段求哈希，在除以分片总数后取模，取模后相同的数据为一个分片，这种将数据分成多个分片的方法叫哈希分片。</p>
<p>设计系统时，要充分考虑如何设计数据库的分库分表的路由规则。</p>
<ul>
<li>优点：数据分散均匀，数据压力分散的效果比较好</li>
<li>缺点：查询需求需要聚合处理。</li>
</ul>
<h4 id="按照时间切片"><a href="#按照时间切片" class="headerlink" title="按照时间切片"></a>按照时间切片</h4><p>按照指定时间周期进行切片【如按年，按月】，主要取决于数据交易量。</p>
<p>针对具有明确时间特点的数据进行切分。</p>
<h2 id="分片后的事务处理机制"><a href="#分片后的事务处理机制" class="headerlink" title="分片后的事务处理机制"></a>分片后的事务处理机制</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>由于将单表的数据切片后存储在多个数据库甚至多个数据库实例中，所以依靠数据库本身的事务机制不能满足所有场景的需要。</p>
<p>主流分布式事务解决方案：两阶段提交协议、最大努力保证模式、事务补偿机制</p>
<h4 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h4><p>将分布式事务分为两个阶段，一个是准备阶段，一个是提交阶段，两个阶段都是由事务管理器发起。</p>
<p>基于两阶段提交协议，事务管理器能够最大限度地保证跨数据库操作的事务的原子性，是分布式系统环境下最严格的事务实现方法。</p>
<p>符合J2EE规范的AppServer（如：webSphere、Jboss等）对关系型数据库数据源和消息队列都实现了两阶段提交协议。。只需在使用时配置即可。</p>
<ul>
<li>缺点<br>两阶段提交协议，会有性能问题，难以进行水平伸缩，因为在提交事务的过程中，事务管理器需要和每个参与者进行准备和提交的操作的协调，在准备阶段锁定资源，在提交阶段消费资源，但是由于参与者较多，锁定资源和消费资源之间的时间差被拉长，导致响应速度较慢，在此期间产生死锁或者不确定结果的可能性比较大。因此在互联网行业里，为了追求性能的提升，很少时候两阶段提交协议。</li>
</ul>
<p>另外，由于两阶段提交协议是阻塞协议，在极端情况下不能快速响应请求方，因此目前有提出过三阶段提交协议，解决了两阶段提交协议的阻塞问题，但仍然需要事务管理器在参与者之间协调，才能完成一个分布式事务。</p>
<h4 id="最大努力保证模式"><a href="#最大努力保证模式" class="headerlink" title="最大努力保证模式"></a>最大努力保证模式</h4><p>一种常用的保证分布式一致性的模式，最大努力保证模式适用于对一致性要求并不十分严格但是对性能要求较高的场景。</p>
<p>具体实现，在更新多个资源时，将多个资源的提交尽量延后到最后一刻处理，这样的话，如果业务流程出现问题，则所有的资源更新都可以回滚，事务仍然保持一致性。<br>唯一可能出现问题，在提交多个资源时发生了系统异常，如网络问题，一旦出现这种情况，就需要进行实时补偿，将已提交的事务进行回滚，同TCC模式类似。</p>
<p>示例：如 涉及两个操作，一个是消息消费，一个是更新数据库，需要保证分布式的一致性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、开始消息事务</span><br><span class="line">2、开始数据库事务</span><br><span class="line">3、接收消息</span><br><span class="line">4、更新数据库</span><br><span class="line">5、提交数据库事务</span><br><span class="line">6、提交消息事务</span><br></pre></td></tr></table></figure>
<p>1-4不是很重要，5、6 发生异常都会回滚，5-6之间异常，导致消息被重发，消息重复消费，需要通过幂等进行处理。</p>
<p>对于提交顺序，需要充分考虑。如数据库事务中嵌套远程调用事务，且远程调用事务是耗时任务，导致数据库事务拉长，拖垮数据库。</p>
<h4 id="事务补偿机制"><a href="#事务补偿机制" class="headerlink" title="事务补偿机制"></a>事务补偿机制</h4><p>性能要求比较高场景中，两阶段提交协议不适用，最大努力保证模式会使多个分布式操作互相嵌套，也可能不适合。</p>
<p>事务补偿机制，提高性能，并且能够尽最大可能地保证事务的最终一致性。</p>
<p>在数据库分库分表后，如果涉及的多个更新操作在某一个数据库范围内完成，则可以使用数据库内的本地事务保证一致性；对于跨库的多个操作，可通过补偿和重试，使其在一定时间窗口内完成操作。</p>
<h3 id="事务路由"><a href="#事务路由" class="headerlink" title="事务路由"></a>事务路由</h3>]]></content>
      <categories>
        <category>framework-middleware</category>
      </categories>
  </entry>
  <entry>
    <title>001-分布式id生成</title>
    <url>/articles/20200227/9b0c33d0.html</url>
    <content><![CDATA[<p>摘要：github：<a href="https://github.com/bjlhx15/framework-middleware.git" target="_blank" rel="noopener">https://github.com/bjlhx15/framework-middleware.git</a></p>
<a id="more"></a>

<h2 id="自研发"><a href="#自研发" class="headerlink" title="自研发"></a>自研发</h2><p>可以看分类中，mysql 主键设计。</p>
<p>自开发版本github：<a href="https://github.com/bjlhx15/framework-middleware.git" target="_blank" rel="noopener">https://github.com/bjlhx15/framework-middleware.git</a> 下的：id-generator<br>支持DB，配置文件配置，配置文件配置IP等生成工作id</p>
<p>业界经典：雪花算法</p>
<h2 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h2><p>github地址：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">https://github.com/baidu/uid-generator</a></p>
<p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p>
<p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p>
<p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p>
<p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></p>
<h2 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h2><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">https://github.com/Meituan-Dianping/Leaf</a></p>
<p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p>
<p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p>
<p>上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>可以利用Redis中的incr命令来实现原子性的自增与返回</p>
]]></content>
      <categories>
        <category>framework-middleware</category>
      </categories>
  </entry>
  <entry>
    <title>003-dubbo的服务注册与发现</title>
    <url>/articles/20200226/8c67eec6.html</url>
    <content><![CDATA[<p>摘要：后续文章主要以2.7.5 版本说明，推荐使用zookeeper注册中心。</p>
<a id="more"></a>

<p>参看官方源码，支持一下方案：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-default<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-multicast<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-zookeeper<span class="tag">&lt;/<span class="name">module</span>&gt;</span>[推荐]</span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-redis<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-consul<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-etcd3<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-nacos<span class="tag">&lt;/<span class="name">module</span>&gt;</span>[推荐]</span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-multiple<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-sofa<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-registry-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Multicast-注册中心"><a href="#Multicast-注册中心" class="headerlink" title="Multicast 注册中心"></a>Multicast 注册中心</h1><h1 id="zookeeper-注册中心"><a href="#zookeeper-注册中心" class="headerlink" title="zookeeper 注册中心"></a>zookeeper 注册中心</h1><h2 id="需要安装zookeeper"><a href="#需要安装zookeeper" class="headerlink" title="需要安装zookeeper"></a>需要安装zookeeper</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:12181"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:2181"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181,10.20.153.12:2181"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="zk客户端"><a href="#zk客户端" class="headerlink" title="zk客户端"></a>zk客户端</h3><p>dubbo 2.6 以前的版本引入 zkclient 操作 zookeeper<br>dubbo 2.6 及以后的版本引入 curator 操作 zookeeper<br>2.7.5版本查看代码：curator</p>
<h1 id="Nacos-注册中心"><a href="#Nacos-注册中心" class="headerlink" title="Nacos 注册中心"></a>Nacos 注册中心</h1><p><a href="https://nacos.io/zh-cn/docs/quick-start-docker.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/quick-start-docker.html</a></p>
<p>参看git：<a href="https://github.com/bjlhx15/shell.git" target="_blank" rel="noopener">https://github.com/bjlhx15/shell.git</a><br>中:docker/nacos</p>
<h1 id="Redis-注册中心"><a href="#Redis-注册中心" class="headerlink" title="Redis 注册中心"></a>Redis 注册中心</h1>]]></content>
      <categories>
        <category>rpc-dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>002-dubbo的四种配置方式</title>
    <url>/articles/20200226/be7f604f.html</url>
    <content><![CDATA[<p>摘要：后续文章主要以2.7.5 版本说明</p>
<a id="more"></a>

<h1 id="xml配置【最为常用】"><a href="#xml配置【最为常用】" class="headerlink" title="xml配置【最为常用】"></a>xml配置【最为常用】</h1><p>代码级别：<a href="https://github.com/bjlhx15/rpc-dubbo.git" target="_blank" rel="noopener">https://github.com/bjlhx15/rpc-dubbo.git</a> 的 rpc-dubbo-001-sample<br>使用的既是 xml配置</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="provider-xml-示例"><a href="#provider-xml-示例" class="headerlink" title="provider.xml 示例"></a>provider.xml 示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20890"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.samples.basic.impl.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="consumer-xml-示例"><a href="#consumer-xml-示例" class="headerlink" title="consumer.xml 示例"></a>consumer.xml 示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">group</span>=<span class="string">"aaa"</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="标签支持自定义参数"><a href="#标签支持自定义参数" class="headerlink" title="标签支持自定义参数"></a>标签支持自定义参数</h3><p>所有标签都支持自定义参数，用于不同扩展点实现的特殊配置，如：<br>如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"jms"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"queue"</span> <span class="attr">value</span>=<span class="string">"your_queue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"jms"</span> <span class="attr">p:queue</span>=<span class="string">"your_queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签	用途	解释</span><br><span class="line">&lt;dubbo:service&#x2F;&gt;	服务配置	用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</span><br><span class="line">&lt;dubbo:reference&#x2F;&gt;	引用配置	用于创建一个远程服务代理，一个引用可以指向多个注册中心</span><br><span class="line">&lt;dubbo:protocol&#x2F;&gt;	协议配置	用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</span><br><span class="line">&lt;dubbo:application&#x2F;&gt;	应用配置	用于配置当前应用信息，不管该应用是提供者还是消费者</span><br><span class="line">&lt;dubbo:module&#x2F;&gt;	模块配置	用于配置当前模块信息，可选</span><br><span class="line">&lt;dubbo:registry&#x2F;&gt;	注册中心配置	用于配置连接注册中心相关信息</span><br><span class="line">&lt;dubbo:monitor&#x2F;&gt;	监控中心配置	用于配置连接监控中心相关信息，可选</span><br><span class="line">&lt;dubbo:provider&#x2F;&gt;	提供方配置	当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</span><br><span class="line">&lt;dubbo:consumer&#x2F;&gt;	消费方配置	当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</span><br><span class="line">&lt;dubbo:method&#x2F;&gt;	方法配置	用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</span><br><span class="line">&lt;dubbo:argument&#x2F;&gt;	参数配置	用于指定方法参数配置</span><br></pre></td></tr></table></figure>

<h2 id="不同粒度配置的覆盖关系"><a href="#不同粒度配置的覆盖关系" class="headerlink" title="不同粒度配置的覆盖关系"></a>不同粒度配置的覆盖关系</h2><p>以 timeout 为例，下图显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：</p>
<ul>
<li>方法级优先，接口级次之，全局配置再次之。</li>
<li>如果级别一样，则消费方优先，提供方次之。</li>
</ul>
<p>其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。</p>
<p>（建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置）。</p>
<p>理论上 ReferenceConfig 中除了interface这一项，其他所有配置项都可以缺省不配置，框架会自动使用ConsumerConfig，ServiceConfig, ProviderConfig等提供的缺省配置。</p>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><p>属性配置、API配置、注解配置<br>参看：<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/properties.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/configuration/properties.html</a></p>
]]></content>
      <categories>
        <category>rpc-dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>001-dubbo简介与准备</title>
    <url>/articles/20200226/47f3ff77.html</url>
    <content><![CDATA[<p>摘要：阿里出品，开源。目前持续支持。</p>
<a id="more"></a>

<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>dubbo个人示例代码：<a href="https://github.com/bjlhx15/rpc-dubbo.git" target="_blank" rel="noopener">https://github.com/bjlhx15/rpc-dubbo.git</a></p>
<p>docker安装：<a href="https://github.com/bjlhx15/shell.git" target="_blank" rel="noopener">https://github.com/bjlhx15/shell.git</a></p>
<p>dubbo代码：<a href="https://github.com/apache/dubbo.git" target="_blank" rel="noopener">https://github.com/apache/dubbo.git</a></p>
<p>dubbo参看文档：<a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p>
<p>nacos文档：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>远程接口调用、负载均衡和容错、自动服务注册和发现。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>需要安装注册中心、开发提供者、消费者</p>
<h2 id="注册中心安装-mac机器docker安装zk"><a href="#注册中心安装-mac机器docker安装zk" class="headerlink" title="注册中心安装-mac机器docker安装zk"></a>注册中心安装-mac机器docker安装zk</h2><p>参看git：<a href="https://github.com/bjlhx15/shell.git" target="_blank" rel="noopener">https://github.com/bjlhx15/shell.git</a><br>中docker/zookeeper/mac</p>
<h2 id="安装dubbo-admin对服务监控功能"><a href="#安装dubbo-admin对服务监控功能" class="headerlink" title="安装dubbo-admin对服务监控功能"></a>安装dubbo-admin对服务监控功能</h2><p>看：<a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin</a></p>
<p>生产环境配置 步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载代码: git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;dubbo-admin.git</span><br><span class="line"></span><br><span class="line">在 dubbo-admin-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties中指定注册中心地址</span><br><span class="line"></span><br><span class="line">构建</span><br><span class="line"></span><br><span class="line">mvn clean package -Dmaven.test.skip&#x3D;true</span><br><span class="line">启动</span><br><span class="line"></span><br><span class="line">mvn --projects dubbo-admin-server spring-boot:run</span><br><span class="line">或者</span><br><span class="line">cd dubbo-admin-distribution&#x2F;target; java -jar dubbo-admin-0.1.jar</span><br><span class="line">访问 http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>

<h2 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h2><p>代码级别：<a href="https://github.com/bjlhx15/rpc-dubbo.git" target="_blank" rel="noopener">https://github.com/bjlhx15/rpc-dubbo.git</a> 的 rpc-dubbo-001-sample</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id-generator-sample-dubbo-consumer</span><br><span class="line">id-generator-sample-dubbo-intf</span><br><span class="line">id-generator-sample-dubbo-provider</span><br></pre></td></tr></table></figure>
<ol>
<li>修改配置<br>在 provider、consumer 项目配置中：dubbo-XX.xml 修改配置中心地址</li>
<li>分别启动对应的main方法</li>
<li>测试<br>服务端服务：<a href="http://localhost:8082/get" target="_blank" rel="noopener">http://localhost:8082/get</a></li>
</ol>
<p>消费者服务：<a href="http://localhost:8083/get" target="_blank" rel="noopener">http://localhost:8083/get</a></p>
<p>参看项目：<a href="https://github.com/apache/dubbo/tree/master/dubbo-demo/dubbo-demo-xml" target="_blank" rel="noopener">https://github.com/apache/dubbo/tree/master/dubbo-demo/dubbo-demo-xml</a></p>
]]></content>
      <categories>
        <category>rpc-dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>001-rpc简介以及原理</title>
    <url>/articles/20200226/f4b7122c.html</url>
    <content><![CDATA[<p>摘要：什么是rpc,原理</p>
<a id="more"></a>

<h1 id="什么是rpc"><a href="#什么是rpc" class="headerlink" title="什么是rpc"></a>什么是rpc</h1><p>  RPC 【Remote Procedure Call，远程过程调用】：A调用B，A挂起，B执行，执行完毕后，继续执行A，这种机制称为RPC。<br>  是一种通过网络从远程计算机程序上请求服务来得到计算服务或者数据服务，且不需要了解底层网络技术的协议和框架。</p>
<h1 id="RPC服务原理"><a href="#RPC服务原理" class="headerlink" title="RPC服务原理"></a>RPC服务原理</h1><h2 id="socket-套接字"><a href="#socket-套接字" class="headerlink" title="socket 套接字"></a>socket 套接字</h2><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为socket。</p>
<p>socket用于描述IP地址和端口，是一个通信连接的句柄，可以用来实现不同的计算机之间的通信，是网络编程接口的具体实现。</p>
<h2 id="rpc调用过程"><a href="#rpc调用过程" class="headerlink" title="rpc调用过程"></a>rpc调用过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------客户端---------+        +---------服务端---------+ </span><br><span class="line">|                       |        |                       |</span><br><span class="line">|     |客户端函数|        |        |      |服务端函数|      |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|       1     10        |        |        5     6        |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|     |客户端存根|        |        |      |服务端存根|      |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|       2     9         |        |        4     7        |</span><br><span class="line">|       ↓     ↑         |        |        ↑     ↓        |</span><br><span class="line">|     |客户端套接字|------|---3----|-----→|服务端套接字|     |</span><br><span class="line">|                 ←-----|---8----|------                 |</span><br><span class="line">|_______________________|        |_______________________|</span><br></pre></td></tr></table></figure>

<ul>
<li>第1步，客户端调用本地存根方法，对于客户端程序来说，就是本地普通方法，但是，他的执行与本地代码不同，因为真正执行的是发生在远程服务器上。<br>客户端存根方法会将参数打包并封装成一个或多个网络消息体并发送到服务端。参数封装到网络消息中的过程称为编码（encode），他会将所有数据序列化为字节数组格式</li>
<li>第2步，客户端存根通过系统调用，使用操作系统内核提供的socket套接字接口来向远程服务发送我们编码的的网络消息</li>
<li>第3步，网络消息由内核通过某种协议（UDP，TCP）传输到远端服务器。</li>
<li>第4步，服务端存根接收到客户端消息，并对参数消息进行解码（decode），通常会将参数从标准的网络格式转换成特定的语言格式。</li>
<li>第5步，服务端存根调用服务端方法，并将从客户端接收的参数传递给该方法，他来运行具体的功能并返回，这部分代码的执行对客户端来说就是远程调用过程</li>
<li>第6步，服务端方法执行完毕后，会把结果返回到服务端存根代码中。</li>
<li>第7步，服务端存根在将该返回值进行编码并序列化后，通过一个或多个套接字网络消息发送给客户端</li>
<li>第8步，消息通过网络发送给客户端存根中。</li>
<li>第9步，客户端存根从本地socket接口中读取结果消息。</li>
<li>第10步，客户端存根将结果传给客户端函数，并且将消息从网络二进制转化为本地语言格式。</li>
</ul>
<p>以上为整个rpc调用过程。</p>
<h1 id="在程序中使用RPC"><a href="#在程序中使用RPC" class="headerlink" title="在程序中使用RPC"></a>在程序中使用RPC</h1><p>目前大部分语言【C、C++、java等】，都没有设计用于远程调用的内置语法，因此不能编译生成必要的存根方法。</p>
<p>IDL 接口定义语言。</p>
<p>RPC是构建在语言级别之上的，是跨语言的，他在OSI七层网络模型中介于会话层和表示层之间。</p>
]]></content>
      <categories>
        <category>rpc</category>
      </categories>
  </entry>
  <entry>
    <title>数据存储分布方案</title>
    <url>/articles/20200225/e0a8e4c6.html</url>
    <content><![CDATA[<p>1、数据结构<br>2、数据量：第一次 7条<br>    后续：每个合同 5条</p>
<p>3、分布式主键 生成</p>
<p>4、数据库mysql 分库分表</p>
]]></content>
  </entry>
  <entry>
    <title>003-tools-markdown-流程图</title>
    <url>/articles/20200225/b7758272.html</url>
    <content><![CDATA[<p>概述:003-tools-markdown-流程图</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><p>Markdown Preview Enhanced<br>默认支持，直接使用，预览功能 最流程图支持不够。</p>
<p>推荐使用插件：Markdown Preview Enhanced</p>
<p>Markdown Preview Enhanced 内部支持 mermaid, PlantUML, WaveDrom,GraphViz，Vega &amp; Vega-lite，Ditaa 图像渲染。<br>你也可以通过使用 Code Chunk 来渲染 TikZ, Python Matplotlib, Plotly 等图像。</p>
<h2 id="流图-mermaid"><a href="#流图-mermaid" class="headerlink" title="流图-mermaid"></a>流图-mermaid</h2><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。</p>
<p>Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码，因此安全许多。</p>
<p>官网：<a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">https://mermaidjs.github.io/</a><br>Github 项目地址：<a href="https://github.com/knsv/mermaid" target="_blank" rel="noopener">https://github.com/knsv/mermaid</a></p>
<h3 id="流程图-graph"><a href="#流程图-graph" class="headerlink" title="流程图-graph"></a>流程图-graph</h3><p>语法，左侧 // 不需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;        &#96;&#96;&#96;mermaid</span><br><span class="line">&#x2F;&#x2F;        graph 方向</span><br><span class="line">&#x2F;&#x2F;          A --&gt; B</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说明 </span><br><span class="line">1. 三个“&#96;”后的mermaid表示使用这个语言化图</span><br><span class="line">2. graph：流程图</span><br><span class="line">3. graph 后字符：方向描述</span><br><span class="line">4. 实际业务</span><br><span class="line"></span><br><span class="line">#### 方向描述</span><br></pre></td></tr></table></figure>
<pre><code>用词    含义
TB    从上到下
BT    从下到上
RL    从右到左
LR    从左到右</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 节点定义</span><br><span class="line">即流程图中每个文本块，包括开始、结束、处理、判断等。Mermaid 中每个节点都有一个 id，以及节点的文字。</span><br></pre></td></tr></table></figure>
<p>表述    说明<br>id[文字]    矩形节点<br>id(文字)    圆角矩形节点<br>id((文字))    圆形节点<br>id&gt;文字]    右向旗帜状节点<br>id{文字}    菱形节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">graph LR</span><br><span class="line">  id1[矩形节点]--&gt;id2(圆角矩形节点)</span><br><span class="line">  --&gt;id3((圆形节点))</span><br><span class="line">  id4&gt;右向旗帜状节点]--&gt;id5&#123;菱形节点&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果节点的文字中包含标点符号，需要时用双引号包裹起来。<br>另外如果希望在文字中使用换行，请使用 替换换行</p>
<h4 id="节点间的连线"><a href="#节点间的连线" class="headerlink" title="节点间的连线"></a>节点间的连线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表述	说明</span><br><span class="line">&gt;	添加尾部箭头</span><br><span class="line">-	不添加尾部箭头</span><br><span class="line">--	单线</span><br><span class="line">--text--	单线上加文字</span><br><span class="line">&#x3D;&#x3D;	粗线</span><br><span class="line">&#x3D;&#x3D;text&#x3D;&#x3D;	粗线加文字</span><br><span class="line">-.-	虚线</span><br><span class="line">-.text.-	虚线加文字</span><br></pre></td></tr></table></figure>

<p>线条 箭头 可以组合使用</p>
<h4 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h4><p>使用以下语法添加子图表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subgraph 子图表名称</span><br><span class="line">    子图表中的描述语句...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><ul>
<li>linkStyle 后面的数字表示第几根线，从 0 开始。可以指定颜色和粗细。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">    linkStyle 0 stroke:#0ff,stroke-width:2px;</span><br><span class="line">    linkStyle 3 stroke:#ff3,stroke-width:4px;</span><br></pre></td></tr></table></figure></li>
<li>可以设置节点背景，边框颜色，粗细，实线还是虚线<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1(Start)--&gt;id2(Stop)</span><br><span class="line">    style id1 fill:#f9f,stroke:#333,stroke-width:4px</span><br><span class="line">    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5</span><br></pre></td></tr></table></figure></li>
<li>样式类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt;B</span><br><span class="line"></span><br><span class="line">    %% 定义样式类</span><br><span class="line">    classDef className fill:#f9f,stroke:#333,stroke-width:4px;</span><br><span class="line"></span><br><span class="line">    %% 应用样式类，markdown里没效果</span><br><span class="line">    class A className</span><br></pre></td></tr></table></figure>
定义一个名为 default 的类，节点没有指定特定样式类时，将都会应用这个样式类。</li>
</ul>
<h4 id="图标-对-fontawesome-的支持"><a href="#图标-对-fontawesome-的支持" class="headerlink" title="图标-对 fontawesome 的支持"></a>图标-对 fontawesome 的支持</h4><p>使用 fa: #图表名称# 的语法添加 <a href="https://fontawesome.com/" target="_blank" rel="noopener">fontawesome</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">   B[&quot;fa:fa-twitter for peace&quot;]</span><br><span class="line">   B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">   B--&gt;D(fa:fa-spinner);</span><br><span class="line">   B--&gt;E(A fa:fa-camera-retro perhaps?);</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    id1(圆角矩形)--普通线--&gt;id2[矩形]</span><br><span class="line">    subgraph 子图表</span><br><span class="line">        id2&#x3D;&#x3D;粗线&#x3D;&#x3D;&gt;id3&#123;菱形&#125;</span><br><span class="line">        id3-.虚线.-&gt;id4&gt;右向旗帜]</span><br><span class="line">        id3--无箭头---id5((圆形))</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三-&gt;&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure>

<h3 id="序列图、时序图-sequenceDiagram"><a href="#序列图、时序图-sequenceDiagram" class="headerlink" title="序列图、时序图-sequenceDiagram"></a>序列图、时序图-sequenceDiagram</h3><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#96;&#96;&#96;mermaid</span><br><span class="line">&#x2F;&#x2F;sequenceDiagram</span><br><span class="line">&#x2F;&#x2F;  [参与者1][消息线][参与者2]:消息体</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<p>  或<br>  //<code>mermaid
  //sequenceDiagram
  //  participant 参与者 1
  //  participant 参与者 2
  //  ...
  //  participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3
  //</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">    张三-&gt;&gt;李四: 吃了吗？</span><br><span class="line">    李四-&gt;&gt;张三: 吃了</span><br></pre></td></tr></table></figure>

<h4 id="消息线"><a href="#消息线" class="headerlink" title="消息线"></a>消息线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|类型|描述|</span><br><span class="line">|-&gt;|无箭头的实线|</span><br><span class="line">|--&gt;|无箭头的虚线|</span><br><span class="line">|-&gt;&gt;|有箭头的实线|</span><br><span class="line">|--&gt;&gt;|有箭头的虚线|</span><br><span class="line">|-x|末端为叉的实线（表示异步）|</span><br><span class="line">|--x|末端为叉的虚线（表示异步）|</span><br></pre></td></tr></table></figure>

<h4 id="处理中"><a href="#处理中" class="headerlink" title="处理中"></a>处理中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在消息线末尾增加 + ，则消息接收者进入当前消息的“处理中”状态；</span><br><span class="line">在消息线末尾增加 - ，则消息接收者离开当前消息的“处理中”状态。</span><br></pre></td></tr></table></figure>
<p>或者使用以下语法直接说明某个参与者进入“处理中”状态:activate 参与者</p>
<h4 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h4><p>语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note 位置表述 参与者: 标注文字</span><br></pre></td></tr></table></figure>
<p>其中位置表述可以为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表述	含义</span><br><span class="line">right of	右侧</span><br><span class="line">left of	左侧</span><br><span class="line">over	在当中，可以横跨多个参与者</span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop 循环的条件</span><br><span class="line">    循环体描述语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alt 条件 1 描述</span><br><span class="line">    分支 1 描述语句</span><br><span class="line">else 条件 2 描述 # else 分支可选</span><br><span class="line">    分支 2 描述语句</span><br><span class="line">else ...</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>如果遇到可选的情况，即没有 else 分支的情况，使用如下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opt 条件描述</span><br><span class="line">    分支描述语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="mermaid">sequenceDiagram
    participant z as 张三
    participant l as 李四
    loop 日复一日
        z-&gt;&gt;l: 吃了吗您呐？
        l--&gt;&gt;z: 吃了，您呢？
        activate z
        Note left of z: 想了一下
        alt 还没吃
            z-xl: 还没呢，正准备回去吃
        else 已经吃了
            z-xl: 我也吃过了，哈哈
        end
        opt 大过年的
            l--&gt;z: 祝您新年好啊
        end
    end</code></pre>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>009-cmd-清空文件</title>
    <url>/articles/20200224/f0d92348.html</url>
    <content><![CDATA[<p>摘要：009-cmd-清空文件</p>
<a id="more"></a>

<ol>
<li>使用重定向的方法</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">&gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用true命令重定向清空文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line"><span class="literal">true</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用cat/cp/dd命令及/dev/null设备来清空文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">cat /dev/null &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br><span class="line"><span class="comment">###################################################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">cp /dev/null test.txt </span><br><span class="line">cp：是否覆盖<span class="string">"test.txt"</span>？ y</span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/null of=test.txt </span><br><span class="line"><span class="comment"># 记录了0+0 的读入</span></span><br><span class="line"><span class="comment"># 记录了0+0 的写出</span></span><br><span class="line"><span class="comment"># 0字节(0 B)已复制，0.000266781 秒，0.0 kB/秒</span></span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用echo命令清空文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; test.txt </span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">""</span> &gt; test.txt    ==&gt;要加上<span class="string">"-n"</span>参数，默认情况下会<span class="string">"\n"</span>，也就是回车符</span><br><span class="line">du -h test.txt  </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure></li>
<li>使用truncate命令清空文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 4.0K    test.txt</span></span><br><span class="line">truncate -s 0 test.txt   -s参数用来设定文件的大小，清空文件，就设定为0；</span><br><span class="line">du -h test.txt </span><br><span class="line"><span class="comment"># 0    test.txt</span></span><br></pre></td></tr></table></figure>






</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>008-cmd-文件cat、touch、echo</title>
    <url>/articles/20200224/341c10ca.html</url>
    <content><![CDATA[<p>摘要：008-cmd-文件cat、touch、echo</p>
<a id="more"></a>

<h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容</p>
<ul>
<li>cat主要有三大功能：</li>
</ul>
<ol>
<li>一次显示整个文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure></li>
<li>从键盘创建一个文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat  &gt;  filename</span><br></pre></td></tr></table></figure>
只能创建新文件,不能编辑已有文件.</li>
<li>将几个文件合并为一个文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat   file1   file2  &gt; file</span><br></pre></td></tr></table></figure>
两种均可，后者，支持嵌套</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>cat具体命令格式为 : cat [-AbeEnstTuv] [–help] [–version] fileName</p>
<p>说明：把档案串连接后传到基本输出(屏幕或加 &gt; fileName 到另一个档案)</p>
<p>参数：</p>
<blockquote>
<p>-n 或 –number 由 1 开始对所有输出的行数编号<br>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号<br>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-v 或 –show-nonprinting</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li>把 linuxfile1 的档案内容加上行号后输入 linuxfile2 这个档案里<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat -n linuxfile1 &gt; linuxfile2</span><br></pre></td></tr></table></figure></li>
<li>把 linuxfile1 和 linuxfile2 的档案内容加上行号(空白行不加)之后将内容附加到 linuxfile3 里。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat -b linuxfile1 linuxfile2 &gt;&gt; linuxfile3</span><br><span class="line">cat /dev/null &gt; /etc/test.txt 此为清空/etc/test.txt档案内容</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h1><p>一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；</p>
<p>二是用来创建新的空文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a或--time&#x3D;atime或--time&#x3D;access或--time&#x3D;use  只更改存取时间。</span><br><span class="line">-c或--no-create  不建立任何文件。</span><br><span class="line">-d&lt;时间日期&gt;  使用指定的日期时间，而非现在的时间。</span><br><span class="line">-f  此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</span><br><span class="line">-m或--time&#x3D;mtime或--time&#x3D;modify  只更改变动时间。</span><br><span class="line">-r&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同。</span><br><span class="line">-t&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间。</span><br><span class="line">--help  在线帮助。</span><br><span class="line">--version  显示版本信息。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><ol>
<li>创建file1—file10共10个文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch file&#123;1..10&#125;</span><br></pre></td></tr></table></figure></li>
<li>设定文件的时间戳<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch -t 201810121230 hh.sh 【-t用十进制数】</span><br></pre></td></tr></table></figure></li>
<li>更新log.log的时间和log2012.log时间戳相同<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch -r hh hh.sh    【touch -r目标文件  源文件】</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>003-ocr-baidu</title>
    <url>/articles/20200220/ce469e7.html</url>
    <content><![CDATA[<p>摘要：003-ocr-baidu</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从一张图片中识别出中文，通过python来实现</p>
<h2 id="百度注册"><a href="#百度注册" class="headerlink" title="百度注册"></a>百度注册</h2><p>百度云注册账号 <a href="https://cloud.baidu.com/?from=console" target="_blank" rel="noopener">https://cloud.baidu.com/?from=console</a><br>管理应用 <a href="https://console.bce.baidu.com/ai/#/ai/ocr/overview/index" target="_blank" rel="noopener">https://console.bce.baidu.com/ai/#/ai/ocr/overview/index</a> 创建一个</p>
<p>进入链接之后创建应用，由于是从文字识别点进去的，所以默认选中的就是ocr相关内容，填好表格确认。</p>
<p>使用：AppID 、API Key、Secret Key</p>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>官方指南：<a href="https://ai.baidu.com/docs#/OCR-Python-SDK/top" target="_blank" rel="noopener">https://ai.baidu.com/docs#/OCR-Python-SDK/top</a><br>安装使用Python SDK： pip install baidu-aip<br>cv2 需要安装：pip install opencv_python<br>如果只需要预测文字以及框出文字区域，执行以下代码即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line"><span class="string">""" 你的 APPID AK SK  图2的内容"""</span></span><br><span class="line">APP_ID = <span class="string">'14318340'</span></span><br><span class="line">API_KEY = <span class="string">'DUvK5jEkNmCIEz4cXH8VvIVC'</span></span><br><span class="line">SECRET_KEY = <span class="string">'*******'</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line">fname = <span class="string">'picture/test4.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="string">""" 读取图片 """</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filePath, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line">image = get_file_content(fname)</span><br><span class="line"></span><br><span class="line"><span class="string">""" 调用通用文字识别, 图片参数为本地图片 """</span></span><br><span class="line">results = client.general(image)[<span class="string">"words_result"</span>]  <span class="comment"># 还可以使用身份证驾驶证模板，直接得到字典对应所需字段</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(fname)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    text = result[<span class="string">"words"</span>]</span><br><span class="line">    location = result[<span class="string">"location"</span>]</span><br><span class="line"></span><br><span class="line">    print(text)</span><br><span class="line">    <span class="comment"># 画矩形框</span></span><br><span class="line">    cv2.rectangle(img, (location[<span class="string">"left"</span>],location[<span class="string">"top"</span>]), (location[<span class="string">"left"</span>]+location[<span class="string">"width"</span>],location[<span class="string">"top"</span>]+location[<span class="string">"height"</span>]), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(fname[:<span class="number">-4</span>]+<span class="string">"_result.jpg"</span>, img)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>002-ocr-tesseract-ocr</title>
    <url>/articles/20200220/ff5ff1f0.html</url>
    <content><![CDATA[<p>摘要：002-ocr-tesseract-ocr</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从一张图片中识别出中文，通过python来实现</p>
<p>Tesseract的OCR引擎目前已作为开源项目发布在Google Project，其项目主页在这里查看<a href="https://github.com/tesseract-ocr，" target="_blank" rel="noopener">https://github.com/tesseract-ocr，</a></p>
<p>它支持中文OCR，并提供了一个命令行工具。python中对应的包是pytesseract. 通过这个工具我们可以识别图片上的文字。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="开发环境如下："><a href="#开发环境如下：" class="headerlink" title="开发环境如下："></a>开发环境如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macosx</span><br><span class="line">python 3.7</span><br><span class="line">brew</span><br></pre></td></tr></table></figure>

<h3 id="安装tesseract-和-pytesseract"><a href="#安装tesseract-和-pytesseract" class="headerlink" title="安装tesseract 和 pytesseract"></a>安装tesseract 和 pytesseract</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装tesseract</span></span><br><span class="line">brew install tesseract</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装python对应的包：pytesseract</span></span><br><span class="line">pip install pytesseract</span><br></pre></td></tr></table></figure>

<h3 id="中文字体下载安装"><a href="#中文字体下载安装" class="headerlink" title="中文字体下载安装"></a>中文字体下载安装</h3><h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><p>要识别中文需要下载对应的训练集：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></p>
<p>下载”chi_sim.traineddata”，然后copy到训练数据集的存放路径，如：</p>
<p>/usr/local/Cellar/tesseract/4.1.1/share/tessdata</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">'/Users/lihongxu6/IdeaProjectsGit/python-algorithm/tests/ocr/timg.jpeg'</span>)</span><br><span class="line">code = pytesseract.image_to_string(image, lang=<span class="string">'chi_sim'</span>)</span><br><span class="line">print(code)</span><br><span class="line"><span class="comment"># 你 一 定 要 过 的 好</span></span><br><span class="line"><span class="comment"># 不 然 对 不 起 我 的 不 打 扰</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>001-感知哈希算法</title>
    <url>/articles/20200220/121774e7.html</url>
    <content><![CDATA[<p>摘要：001-感知哈希算法</p>
<a id="more"></a>

<h1 id="两个图片是否是同一个图片内容"><a href="#两个图片是否是同一个图片内容" class="headerlink" title="两个图片是否是同一个图片内容"></a>两个图片是否是同一个图片内容</h1><h2 id="绝对一样【数据存储结构一样】"><a href="#绝对一样【数据存储结构一样】" class="headerlink" title="绝对一样【数据存储结构一样】"></a>绝对一样【数据存储结构一样】</h2><p>如果就是复制出来的，其实比较两个图片的 普通 sha 或者md5即可，</p>
<p>此处比对的是文件的数据结构。</p>
<h2 id="相似图片"><a href="#相似图片" class="headerlink" title="相似图片"></a>相似图片</h2><p>如果两个图片内容一样，但是有的经过压缩处理了，大小不一样，即存储结果不一样</p>
<h1 id="感知哈希"><a href="#感知哈希" class="headerlink" title="感知哈希"></a>感知哈希</h1><p>感知哈希算法（Perceptual hash algorithm），是一类哈希算法的总称，它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，比较不同图像的指纹信息来判断图像的相似性。结果越接近图像越相似。</p>
<p>感知哈希算法包括均值哈希（aHash）、感知哈希（pHash）和dHash（差异值哈希）。</p>
<p>aHash速度较快，但精确度较低；pHash则反其道而行之，精确度较高但速度较慢；dHash兼顾二者，精确度较高且速度较快。</p>
<p>在得到64位hash值后，使用汉明距离量化两张图像的相似性。汉明距离越大，图像的相似度越小，汉明距离越小，图像的相似度越大。</p>
<h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p>汉明距离是使用在数据传输差错控制编码里面的，汉明距离是一个概念，它表示两个（相同长度）字对应位不同的数量，我们以d（x,y）表示两个字x,y之间的汉明距离。对两个字符串进行异或运算，并统计结果为1的个数，那么这个数就是汉明距离。例如：<br>1011101与1001001之间的汉明距离是2。<br>2143896与2233796之间的汉明距离是3。<br>“toned”与”roses”之间的汉明距离是3。</p>
<h2 id="均值哈希（aHash）"><a href="#均值哈希（aHash）" class="headerlink" title="均值哈希（aHash）"></a>均值哈希（aHash）</h2><ul>
<li>a) 缩放图片：为了保留图像的结构，降低图像的信息量，需要去掉细节、大小和横纵比的差异，建议把图片统一缩放到8*8，共64个像素的图片；</li>
<li>b) 转化为灰度图：把缩放后的图片转化为256阶的灰度图；</li>
</ul>
<blockquote>
<p>灰度图相关算法（R = red， G = green， B = blue）<br>对于彩色转灰度，其基础的心理学公式为： Gray = R0.299 + G0.587 + B0.114，部分变种也很流行：<br>i. 浮点算法：Gray=R0.3+G0.59+B0.11<br>ii. 整数方法：Gray=(R30+G59+B11)/100<br>iii. 移位方法：Gray =(R76+G151+B28)&gt;&gt;8;<br>iv. 平均值法：Gray=（R+G+B）/3;<br>v. 仅取绿色：Gray=G；</p>
</blockquote>
<ul>
<li>c) 计算平均值： 计算进行灰度处理后图片的所有像素点的平均值；</li>
<li>d) 比较像素灰度值：遍历灰度图片每一个像素，如果大于平均值记录为1，否则为0；</li>
<li>e) 构造hash值：组合64个bit位生成hash值，顺序随意但前后保持一致性即可；</li>
<li>f) 对比指纹：计算两幅图片的指纹，计算汉明距离。</li>
</ul>
<h2 id="感知哈希（pHash）"><a href="#感知哈希（pHash）" class="headerlink" title="感知哈希（pHash）"></a>感知哈希（pHash）</h2><p>感知哈希算法可以获得更精确的结果，它采用的是DCT（离散余弦变换）来降低频率。</p>
<ul>
<li>a) 缩小尺寸<br>为了简化了DCT的计算，pHash以小图片开始（建议图片大于8x8，32x32）。</li>
<li>b) 简化色彩<br>与aHash相同，需要将图片转化成灰度图像，进一步简化计算量（具体算法见aHash算法步骤）。</li>
<li>c) 计算DCT<br>DCT是把图片分解频率聚集和梯状形。这里以32x32的图片为例。</li>
</ul>
<blockquote>
<p>DCT变换的全称是离散余弦变换(Discrete Cosine Transform)，主要用于将数据或图像的压缩，能够将空域的信号转换到频域上，具有良好的去相关性的性能。DCT变换本身是无损的，但是在图像编码等领域给接下来的量化、哈弗曼编码等创造了很好的条件，同时，由于DCT变换时对称的，所以，我们可以在量化编码后利用DCT反变换，在接收端恢复原始的图像信息。对原始图像进行离散余弦变换，变换后DCT系数能量主要集中在左上角，其余大部分系数接近于零，DCT具有适用于图像压缩的特性。将变换后的DCT系数进行门限操作，将小于一定值得系数归零，这就是图像压缩中的量化过程，然后进行逆DCT运算，可以得到压缩后的图像。</p>
</blockquote>
<blockquote>
<p>离散余弦变换的原理：<br>一维DCT变换：<br><img src="/images/post/python-algorithm/1dct.jpg" alt=""><br>其中，f(i)为原始的信号，F(u)是DCT变换后的系数，N为原始信号的点数，c(u)可以认为是一个补偿系数，可以使DCT变换矩阵为正交矩阵。<br>二维离散余弦变换的正变换公式为：<br><img src="/images/post/python-algorithm/1dct.jpg" alt=""></p>
</blockquote>
<ul>
<li>d) 缩小DCT<br>DCT的结果为32x32大小的矩阵，但只需保留左上角的8x8的矩阵，这部分呈现了图片中的最低频率。</li>
<li>e) 计算平均值<br>如同均值哈希一样，计算DCT的均值</li>
<li>f) 进一步减小DCT<br>根据8x8的DCT矩阵进行比较，大于等于DCT均值的设为”1”，小于DCT均值的设为“0”。图片的整体结构保持不变的情况下，hash结果值不变。</li>
<li>g) 构造hash值<br>组合64个bit位生成hash值，顺序随意但前后保持一致性即可。</li>
<li>h）对比指纹：计算两幅图片的指纹，计算汉明距离。</li>
</ul>
<h2 id="差异值哈希（dHash）"><a href="#差异值哈希（dHash）" class="headerlink" title="差异值哈希（dHash）"></a>差异值哈希（dHash）</h2><p>相比pHash，dHash的速度更快，相比aHash，dHash在效率几乎相同的情况下的效果要更好，它是基于渐变实现的。</p>
<ul>
<li>a) 缩小图片：收缩至9*8的大小，它有72的像素点；</li>
<li>b) 转化为灰度图：把缩放后的图片转化为256阶的灰度图。（具体算法见aHash算法步骤）；</li>
<li>c) 计算差异值：计算相邻像素间的差异值，这样每行9个像素之间产生了8个不同的差异，一共8行，则产生了64个差异值；</li>
<li>d) 比较差异值：如果前一个像素的颜色强度大于第二个像素，那么差异值就设置为“1”，如果不大于第二个像素，就设置“0”。</li>
<li>e) 构造hash值：组合64个bit位生成hash值，顺序随意但前后保持一致性即可。</li>
<li>f) 对比指纹：计算两幅图片的指纹，计算汉明距离。</li>
</ul>
<h2 id="小波哈希（wavelet-hashing）"><a href="#小波哈希（wavelet-hashing）" class="headerlink" title="小波哈希（wavelet hashing）"></a>小波哈希（wavelet hashing）</h2><p>离散小波变换（DWT）是频表示的另一种形式。流行的DCT和傅立叶变换使用余弦函数作为sin\cos的基础：sin(x)，sin(2x)，sin(3x)等等。与此相反，DWT使用一个单一的功能作为基础，但在不同的形式：缩放和移动。基础功能是可以改变的，这就是为什么我们可以有Haar小波，Daubechie-4小波等，这尺度效应给我们很大“时频表示”的时候，低频部分类似于原始信号。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>aHash：平均值哈希。速度比较快，但是常常不太精确<br>pHash：感知哈希。精确度比较高，但是速度方面较差一些<br>dHash：差异值哈希。精确度较高，且速度也非常快。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h3><p>github<a href="https://github.com/JohannesBuchner/imagehash" target="_blank" rel="noopener">https://github.com/JohannesBuchner/imagehash</a></p>
<h3 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install imagehash</span><br></pre></td></tr></table></figure>
<p>安装后在：/Users/lihongxu6/opt/anaconda3/lib/python3.7/site-packages</p>
<p>代码使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; import imagehash</span><br><span class="line">&gt;&gt;&gt; hash &#x3D; imagehash.average_hash(Image.open(&#39;test.png&#39;))</span><br><span class="line">&gt;&gt;&gt; print(hash)</span><br><span class="line">d879f8f89b1bbf</span><br><span class="line">&gt;&gt;&gt; otherhash &#x3D; imagehash.average_hash(Image.open(&#39;other.bmp&#39;))</span><br><span class="line">&gt;&gt;&gt; print(otherhash)</span><br><span class="line">ffff3720200ffff</span><br><span class="line">&gt;&gt;&gt; print(hash &#x3D;&#x3D; otherhash)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(hash - otherhash)</span><br><span class="line">36</span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="average-hashing"><a href="#average-hashing" class="headerlink" title="average hashing"></a>average hashing</h4><p>平均散列，对于每个像素输出1，如果该像素是大于或等于平均值，否则为0。</p>
<p>主函数：<br>  average_hash(image, hash_size=8)</p>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash_size = <span class="number">6</span></span><br><span class="line">hash1 = imagehash.average_hash(Image.open(<span class="string">'1_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.average_hash(Image.open(<span class="string">'5_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">hash1 - hash2</span><br></pre></td></tr></table></figure>

<h4 id="perception-hashing"><a href="#perception-hashing" class="headerlink" title="perception hashing"></a>perception hashing</h4><p>感知哈希，不同于aHash，但首先它确实是离散余弦变换和频域。</p>
<p>主函数：<br>def phash(image, hash_size=8, highfreq_factor=4):</p>
<p>两个参数，一起决定了图片resize的大小，最适合的才最好，按照公式：</p>
<ul>
<li>img_size = hash_size * highfreq_factor</li>
<li>hash_size代表最终返回hash数值长度</li>
<li>highfreq_factor，代表resize的尺度<br>案例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">highfreq_factor = <span class="number">1</span></span><br><span class="line">hash_size = <span class="number">8</span></span><br><span class="line">img_size = hash_size * highfreq_factor</span><br><span class="line"></span><br><span class="line">hash1 = imagehash.phash(Image.open(<span class="string">'1_1.jpg'</span>),hash_size=hash_size,highfreq_factor=highfreq_factor)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.phash(Image.open(<span class="string">'5_1.jpg'</span>),hash_size=hash_size,highfreq_factor=highfreq_factor)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="difference-hashing"><a href="#difference-hashing" class="headerlink" title="difference hashing"></a>difference hashing</h4><p>梯度散列，计算每个像素的差值，并与平均差异的差异进行比较。</p>
<p>主函数：def dhash(image, hash_size=8)</p>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash_size = <span class="number">10</span></span><br><span class="line">hash1 = imagehash.dhash(Image.open(<span class="string">'5_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.dhash(Image.open(<span class="string">'1_1.jpg'</span>),hash_size=hash_size)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br></pre></td></tr></table></figure>

<h5 id="wavelet-hashing"><a href="#wavelet-hashing" class="headerlink" title="wavelet hashing"></a>wavelet hashing</h5><p>离散小波变换（DWT）是频表示的另一种形式。流行的DCT和傅立叶变换使用余弦函数作为sin\cos的基础：sin(x)，sin(2x)，sin(3x)等等。与此相反，DWT使用一个单一的功能作为基础，但在不同的形式：缩放和移动。基础功能是可以改变的，这就是为什么我们可以有Haar小波，Daubechie-4小波等，这尺度效应给我们很大“时频表示”的时候，低频部分类似于原始信号。</p>
<p>它的工作原理在频域中作为pHash但它使用DWT代替DCT变换。<br>主函数：def whash(image, hash_size = 8, image_scale = None, mode = ‘haar’, remove_max_haar_ll = True)</p>
<p>参数：</p>
<ul>
<li>mode:<br>‘haar’ - Haar wavelets, by default<br>‘db4’ - Daubechies wavelets</li>
<li>remove_max_haar_ll:是否去掉低频段位，low level (LL) frequency</li>
<li>image_scale:图像重新resize成多大，一定是2的倍数</li>
</ul>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash_size = <span class="number">8</span></span><br><span class="line">mode = <span class="string">'db4'</span></span><br><span class="line">image_scale = <span class="number">64</span></span><br><span class="line">hash1 = imagehash.whash(Image.open(<span class="string">'1_1.jpg'</span>),image_scale=image_scale,hash_size=hash_size,mode = mode)</span><br><span class="line">print(hash1)</span><br><span class="line"><span class="comment"># &gt; 354adab5054af0b7</span></span><br><span class="line"></span><br><span class="line">hash2 = imagehash.whash(Image.open(<span class="string">'5_1.jpg'</span>),image_scale=image_scale,hash_size=hash_size,mode = mode)</span><br><span class="line">print(hash2)</span><br><span class="line"><span class="comment"># &gt; 5b7724c8bb364551</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - (hash1 - hash2)/len(hash1.hash)**<span class="number">2</span> <span class="comment"># 相似性</span></span><br></pre></td></tr></table></figure>
<p>更多代码：<a href="https://github.com/bjlhx15/python-algorithm.git" target="_blank" rel="noopener">https://github.com/bjlhx15/python-algorithm.git</a></p>
]]></content>
      <categories>
        <category>python-algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>007-binlog</title>
    <url>/articles/20200220/feb3a22e.html</url>
    <content><![CDATA[<p>摘要：007-binlog</p>
<a id="more"></a>

<h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><h2 id="日志的三种模式"><a href="#日志的三种模式" class="headerlink" title="日志的三种模式"></a>日志的三种模式</h2><p>系统变量binlog_format 指定二进制日志的类型。分别有STATEMENT、ROW、MIXED三种值。MySQL 5.7.6之前默认为STATEMENT模式。MySQL 5.7.7之后默认为ROW模式。这个参数主要影响主从复制。</p>
<p>开启和停用Binlog：log-bin=mysql-bin</p>
<p>查看binlog的格式：show variables like ‘binlog_format’</p>
<p>基于SQL语句的复制（statement-based replication, SBR）<br>基于行的复制（row-based replication, RBR）<br>混合模式复制（mixed-based replication, MBR）</p>
<h3 id="statement-level模式"><a href="#statement-level模式" class="headerlink" title="statement level模式"></a>statement level模式</h3><p>每一条会修改数据的sql都会记录到master的bin-log中。slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql来再次执行。</p>
<ul>
<li>适用场景：对主从数据一致性要求不太高，并且很少用到函数、存储过程、触发器等场景</li>
<li>优点：statement level下的优点，首先就是解决了row level下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约io，提高性能。因为他只需要记录在master上所执行的语句的细节，以及执行语句时候的上下文的信息。</li>
<li>缺点：由于它是记录的执行语句，所以为了让这些语句在slave端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果。另外就是,由于mysql现在发展比较快，很多的新功能加入，使mysql的复制遇到了不小的挑战,自然复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement level下，目前已经发现的就有不少情况会造成mysql的复制问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如sleep()在有些版本就不能正确复制。<br>部分新功能（函数、存储过程、触发器）同步会有障碍，比如now()</li>
</ul>
<h3 id="rowlevel模式"><a href="#rowlevel模式" class="headerlink" title="rowlevel模式"></a>rowlevel模式</h3><p>5.1.5版本的MySQL才开始支持row level的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>
<p>日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改</p>
<ul>
<li>适用场景：对主从数据一致性要求比较高的场景。</li>
<li>优点：bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以row level的日志的内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function,以及trigger的调用和触发无法被正确复制的问题。</li>
<li>缺点：row level下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改记录，这样可能会产生大量的日志内容，比如有这样一条update语句：update product set owner_member_id=‘d’ where owner_member_id=‘a’,执行之后，日志中记录的不是这条update语句所对应的事件(mysql是以事件的形式来记录bin-log日志)，而是这条语句所更新的每一条记录的变化情况，这样就记录成很多条记录被更新的很多事件。自然，bin-log日志的量会很大。</li>
</ul>
<h3 id="mixed模式"><a href="#mixed模式" class="headerlink" title="mixed模式"></a>mixed模式</h3><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合</p>
<p>实际上就是前两种模式的结合，在mixed模式下，mysql会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在statement和row之间选一种。新版本中的statement level还是和以前一样，仅仅记录执行的语句。而新版本的mysql中对row level模式被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete 等修改数据的语句，那么还是会记录所有行的变更。</p>
<p>MySQL默认采用statement格式进行二进制日志文件的记录，但是在一些情况下会使用row格式，可能的情况有：</p>
<blockquote>
<p>  1）、表的存储引擎为NDB，此时对表的DML操作都会以ROW格式记录<br>  2）、使用了UUID(),USER(),CURRENT_USER(),FOUND_ROWS(),ROW_count()等不确定函数时<br>  3）、使用了insert delay语句<br>  4）、使用了用户定义函数（UDF）<br>  5）、使用了临时表</p>
</blockquote>
<ul>
<li>适用场景：对主从数据一致性要求不太高，可能会用到函数、存储过程、触发器等场景</li>
<li>优缺点介于statement和row模式之间</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="MySQL主从复制的原理"><a href="#MySQL主从复制的原理" class="headerlink" title="MySQL主从复制的原理"></a>MySQL主从复制的原理</h2><p>（1）、主库必须开启二进制日志<br>（2）、当有增删改的语句时，会记录到主库的binlog中<br>（3）、主库通过IO线程把binlog里面的内容传给从库的relay binlog（中继日志）（这是msyql复制是异步复制的原因）<br>（4）、从库的sql线程负责读取它的relay log里的信息并应用到数据库中</p>
<h2 id="Seconds-Behind-Master的原理。"><a href="#Seconds-Behind-Master的原理。" class="headerlink" title="Seconds_Behind_Master的原理。"></a>Seconds_Behind_Master的原理。</h2><p>表示sql线程和io线程之间的时间差<br>具体的计算：从库服务器当前的时间戳与二进制日志中的事件的时间戳相对比得到的，所以只有在执行事件时才能报告延迟。<br>不足：<br>一些错误（例如主备的max_allowed_packet不匹配，或者网络不稳定）可能中断复制，由于主从复制是异步操作，Seconds_Behind_Master可能显示为0</p>
<h2 id="主从延迟的主要原因有哪些？"><a href="#主从延迟的主要原因有哪些？" class="headerlink" title="主从延迟的主要原因有哪些？"></a>主从延迟的主要原因有哪些？</h2><p>（1）、慢SQL语句过多<br>（2）、从库的硬件比主库差<br>（3）、同一个主库下有过多的从库<br>（4）、网络延迟<br>（5）、表分区过多</p>
<h1 id="CentOs7-6基于docker搭建主从集群"><a href="#CentOs7-6基于docker搭建主从集群" class="headerlink" title="CentOs7.6基于docker搭建主从集群"></a>CentOs7.6基于docker搭建主从集群</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mysql主从又叫Replication、AB复制。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步<br>mysql主从是基于binlog，主上需开启binlog才能进行主从</p>
<h3 id="主从过程大概有3个步骤"><a href="#主从过程大概有3个步骤" class="headerlink" title="主从过程大概有3个步骤"></a>主从过程大概有3个步骤</h3><ol>
<li>主将更改操作记录到binlog里</li>
<li>从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里</li>
<li>从根据relaylog里面的sql语句按顺序执行</li>
</ol>
<h3 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h3><ol>
<li>实时灾备，用于故障切换</li>
<li>读写分离，提供查询服务</li>
<li>备份，避免影响业务</li>
</ol>
<h3 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h3><ul>
<li>一主一从</li>
<li>主主复制</li>
<li>一主多从—扩展系统读取的性能，因为读是在从库读取的</li>
<li>多主一从—5.7版本开始支持</li>
<li>联级复制</li>
</ul>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p><img src="/images/post/db-mysql/mysqlrepl.webp" alt=""></p>
<ol>
<li>主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程</li>
<li>从库生成两个线程，一个是I/O线程，另一个是SQL线程</li>
<li>I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中</li>
<li>SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的</li>
</ol>
<h3 id="主从复制配置步骤："><a href="#主从复制配置步骤：" class="headerlink" title="主从复制配置步骤："></a>主从复制配置步骤：</h3><ol>
<li>确保从数据库与主数据库里的数据一致</li>
<li>在主数据库里创建一个同步账户授权给从数据库使用</li>
<li>配合主数据库（修改配置文件）</li>
<li>配置从数据库（修改配置文件）</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作</p>
<h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库角色	IP	应用与系统	有无数据</span><br><span class="line">主数据库	192.168.55.130	centos7 mysql-5.7	有</span><br><span class="line">从数据库	192.168.55.129	centos7 mysql-5.7	无</span><br></pre></td></tr></table></figure>

<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br><span class="line">docker version</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker <span class="comment">#开机启动docker</span></span><br><span class="line">docker version</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>详细参看：<a href="https://github.com/bjlhx15/shell" target="_blank" rel="noopener">https://github.com/bjlhx15/shell</a> 的 cmd/centos/docker</p>
<h3 id="docker安装mysql"><a href="#docker安装mysql" class="headerlink" title="docker安装mysql"></a>docker安装mysql</h3><h4 id="docker安装mysql以及配置文件"><a href="#docker安装mysql以及配置文件" class="headerlink" title="docker安装mysql以及配置文件"></a>docker安装mysql以及配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<h5 id="查看配置文件以及共享配置【过程说明】"><a href="#查看配置文件以及共享配置【过程说明】" class="headerlink" title="查看配置文件以及共享配置【过程说明】"></a>查看配置文件以及共享配置【过程说明】</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 53306:3306 --name mymysql57 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">docker <span class="built_in">exec</span> -it mymysql57 /bin/bash</span><br><span class="line">cat /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p>在宿主机上创建文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">export</span>/Data/docker/mymysql57/conf</span><br><span class="line">vim /<span class="built_in">export</span>/Data/docker/mymysql57/conf/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p>输入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file	&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket		&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">datadir		&#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">#log-error	&#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line"># By default we only accept connections from localhost</span><br><span class="line">#bind-address	&#x3D; 127.0.0.1</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br></pre></td></tr></table></figure>
<p>启动并添加目录映射</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 53306:3306 --name mymysql57 \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mymysql57/conf:/etc/mysql/mysql.conf.d \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mymysql57/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br></pre></td></tr></table></figure>

<p>详细参看：<a href="https://github.com/bjlhx15/shell" target="_blank" rel="noopener">https://github.com/bjlhx15/shell</a> 的 cmd/centos/docker</p>
<h4 id="Docker搭建主从服务器"><a href="#Docker搭建主从服务器" class="headerlink" title="Docker搭建主从服务器"></a>Docker搭建主从服务器</h4><ul>
<li>Master(主)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">export</span>/Data/docker/mysql_master/conf</span><br><span class="line">vim /<span class="built_in">export</span>/Data/docker/mysql_master/conf/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p>输入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file	&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket		&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">datadir		&#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">#log-error	&#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line"># By default we only accept connections from localhost</span><br><span class="line">#bind-address	&#x3D; 127.0.0.1</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line"></span><br><span class="line">## 开启 主从配置</span><br><span class="line">## 同一局域网内注意要唯一</span><br><span class="line">server-id&#x3D;100  </span><br><span class="line">## 开启二进制日志功能，可以随便取（关键）</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line">#binlog-do-db&#x3D;zn                   #可以被从服务器复制的库, 二进制需要同步的数据库名</span><br><span class="line">#binlog-ignore-db&#x3D;mysql            #不可以被从服务器复制的库</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 53306:3306 --name mysql_master \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_master/conf:/etc/mysql/mysql.conf.d \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_master/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br></pre></td></tr></table></figure>

<ul>
<li>Slave(从)：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">export</span>/Data/docker/mysql_slave/conf</span><br><span class="line">vim /<span class="built_in">export</span>/Data/docker/mysql_slave/conf/mysqld.cnf</span><br></pre></td></tr></table></figure>
输入如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"> </span><br><span class="line">[mysql]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">pid-file	&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket		&#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">datadir		&#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">#log-error	&#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line"># By default we only accept connections from localhost</span><br><span class="line">#bind-address	&#x3D; 127.0.0.1</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line">character-set-server &#x3D; utf8</span><br><span class="line"></span><br><span class="line">## 设置server_id,注意要唯一</span><br><span class="line">server-id&#x3D;101  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin&#x3D;mysql-slave-bin   </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log&#x3D;edu-mysql-relay-bin</span><br><span class="line">log_slave_updates&#x3D;1</span><br><span class="line">replicate-do-db&#x3D;contract</span><br><span class="line">sql_mode&#x3D;NO_AUTO_VALUE_ON_ZERO,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 53307:3306 --name mysql_slave \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_slave/conf:/etc/mysql/mysql.conf.d \</span><br><span class="line"> -v /<span class="built_in">export</span>/Data/docker/mysql_slave/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Master对外映射的端口是53306，Slave对外映射的端口是53307。因为docker容器是相互独立的，每个容器有其独立的ip，所以不同容器使用相同的端口并不会冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>可以使用Navicat等工具测试连接mysql</p>
<h3 id="账户配置及说明"><a href="#账户配置及说明" class="headerlink" title="账户配置及说明"></a>账户配置及说明</h3><p>进入主数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_master /bin/bash</span><br></pre></td></tr></table></figure>
<p>在Master数据库创建数据同步用户，授予用户 slave的 REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于在主从库之间同步数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'slave'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'slave'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>
<p>这里表示创建一个slaver同步账号slave，允许访问的IP地址为%，%表示通配符</p>
<h3 id="链接Master-主-和Slave-从"><a href="#链接Master-主-和Slave-从" class="headerlink" title="链接Master(主)和Slave(从)"></a>链接Master(主)和Slave(从)</h3><h4 id="进入主数据库"><a href="#进入主数据库" class="headerlink" title="进入主数据库"></a>进入主数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_master /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="comment"># 增加读锁，放置建立期间有人写入数据，查看完毕不要关闭窗口，unlock tables; 释放锁</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment">-- +------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="comment">-- | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span></span><br><span class="line"><span class="comment">-- +------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="comment">-- | mysql-bin.000001 |      617 |              |                  |                   |</span></span><br><span class="line"><span class="comment">-- +------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="comment">-- 1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>
<p>File和Position字段的值后面将会用到，在后面的操作完成之前，需要保证Master库不能做任何操作，否则将会引起状态变化，File和Position字段的值变化。<br>mysqlbinlog mysql-bin.000001</p>
<h5 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h5><p>mysqldump -h127.0.0.1 -uroot -p123456 –default-character-set=utf8 contract&gt;contract.sql</p>
<p>注意查看字符集<br>系统参数 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'char%'</span></span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br><span class="line">| Variable_name            | <span class="keyword">Value</span>                      |</span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br><span class="line">| character_set_client     | latin1                     |</span><br><span class="line">| character_set_connection | latin1                     |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | <span class="built_in">binary</span>                     |</span><br><span class="line">| character_set_results    | latin1                     |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/<span class="keyword">share</span>/mysql/charsets/ |</span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>上述导出：一般character_set_database 相一致：–default-character-set=utf8</p>
<h4 id="进入从数据库"><a href="#进入从数据库" class="headerlink" title="进入从数据库"></a>进入从数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_slave /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="comment">-- 创建从库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> contract2 <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="comment">-- 导入已有数据</span></span><br><span class="line"><span class="comment">-- 本机上传文件：scp /Users/lihongxu/work/contract.sql root@10.0.01:/export/Data/contract.sql</span></span><br><span class="line"><span class="comment">-- 容器拷贝：docker cp /home/trace/contract_dll_dml_0326.sql mysql_hr_prod_slave:/</span></span><br><span class="line"><span class="comment">-- 重置binlog,导入数据</span></span><br><span class="line">mysql -uroot -p   -e '<span class="keyword">reset</span> <span class="keyword">master</span><span class="string">'</span></span><br><span class="line"><span class="string">mysql -uroot -p   contract &lt; contract_dll_dml_0326.sql</span></span><br><span class="line"><span class="string">-- 从库配置链接主库</span></span><br><span class="line"><span class="string">change master to master_host='</span><span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span><span class="string">', master_user='</span><span class="keyword">slave</span><span class="string">', master_password='</span><span class="number">123456</span><span class="string">', master_port=3306, master_log_file='</span>mysql-<span class="keyword">bin</span><span class="number">.000001</span><span class="string">', master_log_pos= 617, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure>
<p>命令说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master_host ：Master的地址，指的是容器的独立ip,可以通过docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称|容器id  查询容器的ip</span><br><span class="line">master_port：Master的端口号，指的是容器的端口号</span><br><span class="line">master_user：用于数据同步的用户</span><br><span class="line">master_password：用于同步的用户的密码</span><br><span class="line">master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值</span><br><span class="line">master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值</span><br><span class="line">master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是60秒</span><br></pre></td></tr></table></figure>
<p>在Slave 中的mysql终端执行show slave status \G;用于查看主从同步状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;    <span class="comment">-- 开启从  stop slave 停止从</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span> \G;</span><br><span class="line"><span class="comment"># 主要关注参数 </span></span><br><span class="line"> <span class="comment">#  Slave_IO_Running: No</span></span><br><span class="line"> <span class="comment"># Slave_SQL_Running: No</span></span><br></pre></td></tr></table></figure>
<p>正常情况下，SlaveIORunning 和 SlaveSQLRunning 都是No，因为还没有开启主从复制过程。<br>使用start slave开启主从复制过程，然后再次查询主从同步状态show slave status \G;。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span> \G;</span><br></pre></td></tr></table></figure>
<p>使用start slave开启主从复制过程后，查看状态，如果SlaveIORunning一直是Connecting，则说明主从复制一直处于连接状态，这种情况一般是下面几种原因造成的，可以根据 Last_IO_Error提示予以排除。</p>
<p>网络不通:检查ip,端口<br>密码不对:检查是否创建用于同步的用户和用户密码是否正确<br>pos不对:检查Master的 Position</p>
<p>测试主从复制<br>在Master创建一个数据库，然后检查Slave是否存在此数据库。<br>Master:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_master /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>006-count优化</title>
    <url>/articles/20200220/1e6de73e.html</url>
    <content><![CDATA[<p>摘要：006-count优化</p>
<a id="more"></a>

<h1 id="增加占用空间小的非聚簇索引优化count"><a href="#增加占用空间小的非聚簇索引优化count" class="headerlink" title="增加占用空间小的非聚簇索引优化count"></a>增加占用空间小的非聚簇索引优化count</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`table500w`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5000001</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>
<p>然后，插入500w数据<br>参看<a href="https://www.cnblogs.com/bjlhx/p/11949479.html" target="_blank" rel="noopener">010-MySQL批量插入测试数据</a></p>
<ol>
<li>查看索引<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4967713				BTREE</span></span><br></pre></td></tr></table></figure>
只有主键id索引</li>
<li>count查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> table500w;</span><br></pre></td></tr></table></figure>
尝试多次后，耗时几乎一致，本机约6s<br>查看explain执行计划，<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="comment">-- Id  select_type table    type    possiable_key   key     key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1	  SIMPLE	  table500w	index		PRIMARY	        8		                4967713	Using index</span></span><br></pre></td></tr></table></figure>
三个均为一致，故网上说的count(id)、count(*)、count(1)快慢说法没有什么科学依据。用啥写法都是这么慢。</li>
<li>非聚簇索引优化<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">add</span> <span class="keyword">index</span> index_age(age);</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4967713				BTREE		</span></span><br><span class="line"><span class="comment">-- table500w	1	index_age	1	age	A	202			YES	BTREE</span></span><br></pre></td></tr></table></figure>
执行查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> table500w;</span><br></pre></td></tr></table></figure>
发现耗时，几乎约600ms，原因是mysql引擎做的优化，会使用占用空间较少的索引作为count（*）的命中统计<br>重复上述，查看执行计划，三个都一样<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> table500w; </span><br><span class="line"><span class="comment">-- 1	SIMPLE	table500w	index		index_age	5		4967713	Using index</span></span><br></pre></td></tr></table></figure>
上述可以通过force强制使用指定索引,来查看使用聚集索引以及非聚集索引 对count影响<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w <span class="keyword">FORCE</span> <span class="keyword">index</span>(<span class="string">`PRIMARY`</span>); </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table500w <span class="keyword">FORCE</span> <span class="keyword">index</span>(index_age);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>非聚集索引所占空间的大小往往，远小于聚集索引或堆表所占用的空间大小；<br>同样的，表中占用较少字节的字段的非聚集索引，对于速度的提升效果，也要远大于，占用较多字节的字段的非聚集索引，因为占用字节少，那么索引占用的空间也少，同样是扫描，只需要更少的时间，对硬盘的访问次数也更少，那么速度就会更快了。</p>
<ul>
<li>情况一、只有主键索引，</li>
</ul>
<ol>
<li>数据和主键索引存储在一个ibd中，总大小224mb，所加载文件也为全部</li>
</ol>
<ul>
<li>情况二、找一个短小的列age，为它建立辅助索引。<br>仅加载索引页统计，索引页为90mb，</li>
</ul>
<ol>
<li>二级索引的存储空间仅包含length字段值(4) 、数据主键(8)，假设二级索引辅助结构不占用空间（仅计算数据占用空间）</li>
<li>在默认情况下，MySQL的一个数据页大小为16K，一个页可存储的数据条数为 16*1024/(4+8) =1365 </li>
<li>按照单页存储空间占用为50%（页分裂现象导致页不满）计算，500万条数据的统计需要读取约:500 0000/(1365*0.5)=7331 个物理页</li>
<li>而页在连续的情况下，数据库一次可读取多个连续的页，数据读取总量为 16k*7331 约 114MB，使用附注方法查看约 90mb，以</li>
<li>因mysql空间分配为按区分配，每个区1M，一次分配1-5个连续区，当数据量较小，一次仅分配一个区，112M数据会分配在114个区中，</li>
<li>固态硬盘读取均速约 679m/s ，整个过程：io寻址时间(0ms)+读取时间（114m/679m=167ms）= 167 ms，</li>
<li>而数据解析统计约为 30-100ms，故总耗时会在300ms加。</li>
</ol>
<p>综上所述，纠结 count(id)、count(*) 、count(1)写法上性能没有任何意义，通过执行几化发现没有任何效率差异。关注语句真正命中的索引意义重大。</p>
<h1 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h1><h2 id="mac固态硬盘测试"><a href="#mac固态硬盘测试" class="headerlink" title="mac固态硬盘测试"></a>mac固态硬盘测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo time dd <span class="keyword">if</span>=/dev/zero bs=1024k of=tstfile count=1024</span><br><span class="line"><span class="comment"># 1024+0 records in</span></span><br><span class="line"><span class="comment"># 1024+0 records out</span></span><br><span class="line"><span class="comment"># 1073741824 bytes transferred in 1.506577 secs (712702911 bytes/sec)</span></span><br><span class="line"><span class="comment">#         1.51 real         0.00 user         0.49 sys</span></span><br></pre></td></tr></table></figure>

<p>速度：712702911/1024/1024=679m/s</p>
<h2 id="索引占用空间"><a href="#索引占用空间" class="headerlink" title="索引占用空间"></a>索引占用空间</h2><p>如上述，先删除age索引，则只剩下主键索引，主键索引和数据在一起，不被计算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">drop</span> <span class="keyword">index</span> index_age;</span><br><span class="line"><span class="comment">-- 查看表中存在的索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4988148				BTREE		</span></span><br><span class="line"><span class="comment">-- 优化 清理空间</span></span><br><span class="line"><span class="keyword">OPTIMIZE</span> <span class="keyword">table</span> table500w;</span><br><span class="line"><span class="comment">-- 查看 索引存储空间</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(INDEX_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> INDEX_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_FREE / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_FREE</span><br><span class="line"><span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'test_innodb'</span> <span class="keyword">and</span> table_name=<span class="string">'table500w'</span>;</span><br><span class="line"><span class="comment">-- DATA_SIZE  INDEX_SIZE  DATA_FREE</span></span><br><span class="line"><span class="comment">--  223.78MB	0.00MB	0.00MB</span></span><br><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">add</span> <span class="keyword">index</span> index_age(age);</span><br><span class="line"><span class="comment">-- 查看表中存在的索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table500w;</span><br><span class="line"><span class="comment">-- table500w	0	PRIMARY	1	id	A	4988148				BTREE		</span></span><br><span class="line"><span class="comment">-- table500w	1	index_age	1	age	A	202			YES	BTREE		</span></span><br><span class="line"><span class="comment">-- 查看 索引存储空间</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(INDEX_LENGTH / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> INDEX_SIZE, </span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">SUM</span>(DATA_FREE / <span class="number">1024</span> / <span class="number">1024</span>), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">AS</span> DATA_FREE</span><br><span class="line"><span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'test_innodb'</span> <span class="keyword">and</span> table_name=<span class="string">'table500w'</span>;</span><br><span class="line"><span class="comment">-- DATA_SIZE  INDEX_SIZE  DATA_FREE</span></span><br><span class="line"><span class="comment">--  223.78MB	89.66MB	0.00MB</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>004-mysql-语句执行顺序</title>
    <url>/articles/20200220/55a48c08.html</url>
    <content><![CDATA[<p>摘要：004-mysql-语句执行顺序</p>
<a id="more"></a>

<h1 id="mysql-语句语法结构"><a href="#mysql-语句语法结构" class="headerlink" title="mysql 语句语法结构"></a>mysql 语句语法结构</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<h1 id="mysql-语句执行顺序"><a href="#mysql-语句执行顺序" class="headerlink" title="mysql 语句执行顺序"></a>mysql 语句执行顺序</h1><p>MySQL的语句，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定对应的操作，那么将会跳过相应的步骤。</p>
<ol>
<li>from:需要从哪个数据表检索数据，对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li>on：在生成临时表时使用的条件，对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。</li>
<li>join：联合多表查询返回记录时，并生成一张临时表，如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li>where:过滤表中数据的条件，对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。</li>
<li>group by:如何将上面过滤出的数据分组，根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li>having:对上面已经分组的数据进行过滤的条件，对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。</li>
<li>select:查看结果集中的哪个列，或列的计算结果，执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li>DISTINCT: 对VT8中的记录进行去重。产生虚拟表VT9.</li>
<li>order by :按照什么样的顺序来查看返回的数据,将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10.</li>
<li>limit：限制查询结果返回的数量,取出指定行的记录，产生虚拟表VT11, 并将结果返回。</li>
</ol>
<h2 id="on与where的用法区别："><a href="#on与where的用法区别：" class="headerlink" title="on与where的用法区别："></a>on与where的用法区别：</h2><ol>
<li>on后面的筛选条件主要是针对的是关联表【而对于主表刷选条件不适用】。</li>
<li>如果是想再连接完毕后才筛选就应把条件放置于where后面。对于关联表我们要区分对待。如果是要条件查询后才连接应该把查询件放置于on后。</li>
<li>对于主表的筛选条件应放在where后面，不应该放在on后面</li>
</ol>
<h2 id="having和where的用法区别："><a href="#having和where的用法区别：" class="headerlink" title="having和where的用法区别："></a>having和where的用法区别：</h2><ol>
<li>having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。</li>
<li>where肯定在group by 之前，即也在having之前。</li>
<li>where后的条件表达式里不允许使用聚合函数，而having可以。</li>
</ol>
<h2 id="count用法"><a href="#count用法" class="headerlink" title="count用法"></a>count用法</h2><p>统计某个列值的数量，也可以统计行数<br>count(*) 和count(1) 都是统计行数，<br>count(col) 是统计col列非null的行数</p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>005-sql慢查询日志及优化建议</title>
    <url>/articles/20200219/cef9cfb1.html</url>
    <content><![CDATA[<p>摘要：优化</p>
<a id="more"></a>

<h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能</p>
<h2 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slow_query_log 慢查询开启状态</span><br><span class="line">slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</span><br><span class="line">long_query_time 查询超过多少秒才记录</span><br></pre></td></tr></table></figure>
<h2 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h2><ol>
<li>查看基础参数<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br><span class="line"><span class="comment">-- Variable_name  Value</span></span><br><span class="line"><span class="comment">-- slow_query_log	OFF</span></span><br><span class="line"><span class="comment">-- slow_query_log_file	/var/lib/mysql/2a623b03f48a-slow.log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br><span class="line"><span class="comment">-- Variable_name  Value</span></span><br><span class="line"><span class="comment">-- long_query_time	10.000000</span></span><br></pre></td></tr></table></figure></li>
<li>设置方法</li>
</ol>
<ul>
<li><p>方法一：全局变量设置【即时性的，重启mysql之后失效，常用的】<br>将 slow_query_log 全局变量设置为“ON”状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>; 或者 <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>
<p>设置慢查询日志存放的位置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file=<span class="string">'/var/log/mysql/slow.log'</span>;</span><br></pre></td></tr></table></figure>
<p>查询超过1秒就记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：配置文件设置【永久性的】<br>修改配置文件my.cnf，在[mysqld]下的下方加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;slow.log</span><br><span class="line">long_query_time &#x3D; 1</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>服务重启<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
可以使用步骤1中的查看</li>
</ol>
<h2 id="慢sql分析"><a href="#慢sql分析" class="headerlink" title="慢sql分析"></a>慢sql分析</h2><p>打开文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Time: 200219  9:09:58</span><br><span class="line"># User@Host: root[root] @  [172.17.0.1]  Id:     7</span><br><span class="line"># Query_time: 5.142734  Lock_time: 0.000080 Rows_sent: 5  Rows_examined: 5000000</span><br><span class="line">SET timestamp&#x3D;1582103398;</span><br><span class="line">select * from table500w where username&#x3D;&#39;name-23233&#39;;</span><br></pre></td></tr></table></figure>
<p>查询的时间，用户，花费的时间，使用的数据库，执行的sql语句等信息。在生产上我们就可以使用这种方式来查看 执行慢的sql</p>
<h2 id="查询慢查询的次数"><a href="#查询慢查询的次数" class="headerlink" title="查询慢查询的次数"></a>查询慢查询的次数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'slow_queries'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="优化及示例"><a href="#优化及示例" class="headerlink" title="优化及示例"></a>优化及示例</h1><ul>
<li><p>提前过滤<br>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</p>
</li>
<li><p>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
</li>
<li><p>避免在索引列上使用计算</p>
</li>
<li><p>避免在索引列上使用IS NULL和IS NOT NULL</p>
</li>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
</li>
</ul>
<h2 id="超大分页怎么处理"><a href="#超大分页怎么处理" class="headerlink" title="超大分页怎么处理?"></a>超大分页怎么处理?</h2><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><h4 id="基础分页-慢-大概5s"><a href="#基础分页-慢-大概5s" class="headerlink" title="基础分页-慢-大概5s"></a>基础分页-慢-大概5s</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>查看慢sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Time: 200219 23:47:01</span><br><span class="line"># User@Host: root[root] @  [172.17.0.1]  Id:    10</span><br><span class="line"># Query_time: 5.141059  Lock_time: 0.000086 Rows_sent: 5  Rows_examined: 4255328</span><br><span class="line">SET timestamp&#x3D;1582156021;</span><br><span class="line">select * from table500w where age&gt;5 limit 4000000,5;</span><br></pre></td></tr></table></figure>
<p>标准大分页 慢sql</p>
<h4 id="基础分页-优化-1s内"><a href="#基础分页-优化-1s内" class="headerlink" title="基础分页-优化-1s内"></a>基础分页-优化-1s内</h4><ol>
<li><p>查看执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment">-- Id  select_type table type  possiable_key key key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1 	SIMPLE	    table500w	  ALL					                  4967713	Using where</span></span><br></pre></td></tr></table></figure>
<p>参看:<a href="https://www.cnblogs.com/bjlhx/p/7567110.html" target="_blank" rel="noopener">004-mysql explain详解</a><br>发现：简单查询，使用all 全表扫描，涉及行数 4967713</p>
</li>
<li><p>优化-条件增加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table500w <span class="keyword">add</span> <span class="keyword">index</span> index_age(age);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment">-- Id  select_type table  type  possiable_key   key key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1	  SIMPLE	table500w	range	index_age	  index_age	5		      2483856	Using index condition; Using MRR</span></span><br></pre></td></tr></table></figure>
<p>发现：简单查询，使用range 索引范围扫描，涉及行数 2483856<br>执行查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>发现根本查询不出来了，或者查询巨慢<br>原因查看：<br>上述语句可以理解为</p>
<ol>
<li>命中非聚簇索引,通过age 查询 主索引 id</li>
<li>回读主索引，即聚簇索引查询主索引，然后获取叶子节点数据</li>
<li>根据limit 取结果</li>
</ol>
</li>
<li><p>利用关联子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">select</span> b.* <span class="keyword">from</span> table500w b, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>)<span class="keyword">as</span> a <span class="keyword">WHERE</span> b.id=a.id;</span><br><span class="line"><span class="comment">-- Id  select_type table    type    possiable_key   key     key_len ref rows  Extra</span></span><br><span class="line"><span class="comment">-- 1	PRIMARY	    &lt;derived2&gt;ALL					                                2483856	</span></span><br><span class="line"><span class="comment">-- 1	PRIMARY	    b	        eq_ref	PRIMARY	      PRIMARY	   8	    a.id	1	</span></span><br><span class="line"><span class="comment">-- 2	DERIVED	    table500w	range	  index_age    	index_age	 5		      2483856	Using where; Using index</span></span><br></pre></td></tr></table></figure>
<p>查询后速度：0.88s<br>from 取出 a结果 5行，b 表 按条件 筛选 5行。</p>
</li>
</ol>
<h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>原因：mysql 并不是跳过offset行，而是取 offset + N 行，然后返回，放弃offset行，返回N行，那当offset特别大的时候，效率非常低。<br>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面,快速定位需要获取的id段，然后在关联<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.* <span class="keyword">from</span> table500w b, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table500w <span class="keyword">where</span> age&gt;<span class="number">5</span> <span class="keyword">limit</span> <span class="number">4000000</span>,<span class="number">5</span>)<span class="keyword">as</span> a <span class="keyword">WHERE</span> b.id=a.id;</span><br></pre></td></tr></table></figure></li>
<li>需求界面上控制总页数<br>不允许直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>004-数据类型</title>
    <url>/articles/20200219/56a0d34f.html</url>
    <content><![CDATA[<p>摘要：事务</p>
<a id="more"></a>

<h1 id="整数类型-括号内数值含义"><a href="#整数类型-括号内数值含义" class="headerlink" title="整数类型-括号内数值含义"></a>整数类型-括号内数值含义</h1><p>包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p>
<h1 id="类型后的括号"><a href="#类型后的括号" class="headerlink" title="类型后的括号"></a>类型后的括号</h1><p>是展示长度含义：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</p>
<p>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
<h1 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h1><p>char是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符</p>
<p>varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.<br>在行数数据存储的时候，varchar 实际长度是需要记录到页结构中的 infimum和supermum record</p>
<p>在检索效率上来讲,char &gt; varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则按照设计应该使用varchar.</p>
<h1 id="varchar-10-和int-10-代表什么含义"><a href="#varchar-10-和int-10-代表什么含义" class="headerlink" title="varchar(10)和int(10)代表什么含义?"></a>varchar(10)和int(10)代表什么含义?</h1><ul>
<li>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度</li>
<li>int的10只是代表了展示的长度,不足10位以0填充.即,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</li>
</ul>
<h1 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h1><p>尽量使用timestamp，空间效率高于datetime,但是 注意存储范围</p>
<p>用整数保存时间戳通常不方便处理。如果需要存储微秒，可以使用bigint存储。</p>
<h1 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h1><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p>
<p>怎样才能找出最后一次插入时分配了哪个自动增量？</p>
<p>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</p>
<h1 id="段为什么要求定义为not-null"><a href="#段为什么要求定义为not-null" class="headerlink" title="段为什么要求定义为not null?"></a>段为什么要求定义为not null?</h1><p>MySQL官网这样介绍:</p>
<blockquote>
<p>NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
<p>null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.不利于索引</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>003-事务、锁总结</title>
    <url>/articles/20200219/6fd41f87.html</url>
    <content><![CDATA[<p>摘要：事务</p>
<a id="more"></a>

<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>事务是一系列的操作,他们要符合ACID特性.常见的理解就是:事务中的操作要么全部成功,要么全部失败.</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul>
<li><p>A=Atomicity 原子性<br>就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.</p>
</li>
<li><p>C=Consistency 一致性<br>系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.</p>
</li>
<li><p>I=Isolation 隔离性<br>通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.</p>
</li>
<li><p>D=Durability 持久性<br>一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.</p>
</li>
</ul>
<h1 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h1><p>5.5之前 是 myISAM<br>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。</p>
<p>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET<br>AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。<br>5.5之后是InnoDB,支持事务</p>
<h1 id="同时有多个事务在进行会怎么样呢"><a href="#同时有多个事务在进行会怎么样呢" class="headerlink" title="同时有多个事务在进行会怎么样呢?"></a>同时有多个事务在进行会怎么样呢?</h1><p>多事务的并发进行一般会造成以下几个问题:</p>
<ul>
<li>脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.</li>
<li>不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.</li>
<li>幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成”幻觉”.</li>
</ul>
<h1 id="MySQL的四种隔离级别"><a href="#MySQL的四种隔离级别" class="headerlink" title="MySQL的四种隔离级别"></a>MySQL的四种隔离级别</h1><ul>
<li>未提交读(READ UNCOMMITTED) 读到未提交数据<br>这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).</li>
</ul>
<p>这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.</p>
<ul>
<li>已提交读(READ COMMITTED) 脏读，不可重复读</li>
</ul>
<p>其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.</p>
<ul>
<li>REPEATABLE READ(可重复读)(InnoDB默认使用)</li>
</ul>
<p>可重复读隔离级别解决了上面不可重复读的问题,但是仍然有一个新问题,就是 幻读,当你读取id&gt; 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.</p>
<ul>
<li>SERIALIZABLE(可串行化事务)</li>
</ul>
<p>这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.</p>
<h1 id="mysql-锁"><a href="#mysql-锁" class="headerlink" title="mysql 锁"></a>mysql 锁</h1><p>当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.</p>
<p>例如，酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.</p>
<h1 id="MySQL都有哪些锁"><a href="#MySQL都有哪些锁" class="headerlink" title="MySQL都有哪些锁?"></a>MySQL都有哪些锁?</h1><p>从锁的类别上来讲,有共享锁和排他锁.</p>
<p>共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.</p>
<p>排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.</p>
<ul>
<li>表锁，系统开销最小，会锁定整张表，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。MyIsam使用表锁。</li>
<li>行锁，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。InnoDB使用行锁。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>他们的加锁开销从大到小,并发能力也是从大到小.</li>
</ul>
<h1 id="锁作用"><a href="#锁作用" class="headerlink" title="锁作用"></a>锁作用</h1><p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>002-索引总结</title>
    <url>/articles/20200219/24069596.html</url>
    <content><![CDATA[<p>摘要：存储引擎是数据库管理系统用来从数据库创建、读取和更新数据的软件模块。MySQL中有两种类型的存储引擎：事务性和非事务性。<br>对于MySQL 5.5及更高版本，默认的存储引擎是InnoDB。在5.5版本之前，MySQL的默认存储引擎是MyISAM。</p>
<a id="more"></a>

<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>索引是一种数据结构，可以快速的进行数据的查找.<br>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p>
<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM &lt;tablename&gt;;</span><br></pre></td></tr></table></figure>

<h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><p>任何标准表最多可以创建16个索引列。</p>
<h1 id="什么时候不需要回表查询数据"><a href="#什么时候不需要回表查询数据" class="headerlink" title="什么时候不需要回表查询数据"></a>什么时候不需要回表查询数据</h1><p>B+树在满足聚簇索引和覆盖索引的时候。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使不创建主键，系统也会帮你创建一个隐式的主键。<br>B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，称之为聚集索引。</p>
<p>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p>
<h2 id="非聚簇索引一定会回表查询吗-覆盖索引"><a href="#非聚簇索引一定会回表查询吗-覆盖索引" class="headerlink" title="非聚簇索引一定会回表查询吗-覆盖索引"></a>非聚簇索引一定会回表查询吗-覆盖索引</h2><p>不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.</p>
<p>例如，假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age &lt; 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.</p>
<h1 id="在建立索引的时候-都有哪些需要考虑的因素呢"><a href="#在建立索引的时候-都有哪些需要考虑的因素呢" class="headerlink" title="在建立索引的时候,都有哪些需要考虑的因素呢?"></a>在建立索引的时候,都有哪些需要考虑的因素呢?</h1><p>建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.</p>
<h2 id="联合索引是什么-为什么需要注意联合索引中的顺序"><a href="#联合索引是什么-为什么需要注意联合索引中的顺序" class="headerlink" title="联合索引是什么?为什么需要注意联合索引中的顺序?"></a>联合索引是什么?为什么需要注意联合索引中的顺序?</h2><p>MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.</p>
<p>具体原因为:</p>
<p>MySQL使用索引时需要索引有序,假设现在建立了”name,age,school”的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.</p>
<p>当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p>
<h1 id="语句是否使用了索引，分析语句？"><a href="#语句是否使用了索引，分析语句？" class="headerlink" title="语句是否使用了索引，分析语句？"></a>语句是否使用了索引，分析语句？</h1><p>MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.</p>
<p><a href="https://www.cnblogs.com/bjlhx/p/7567110.html" target="_blank" rel="noopener">更多,004-mysql explain详解</a></p>
<h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p>列设置了索引但是查询不生效</p>
<ul>
<li>使用不等于查询,</li>
<li>列参与了数学运算或者函数</li>
<li>在字符串like时左边是通配符.类似于’%aaa’.</li>
<li>当mysql分析全表扫描比使用索引快的时候不使用索引.</li>
<li>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.</li>
</ul>
<h1 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h1><p>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.</p>
<p>B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.</p>
<h2 id="不同"><a href="#不同" class="headerlink" title="不同:"></a>不同:</h2><p>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>
<p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</p>
<p>hash索引不支持使用索引进行排序,原理同上.</p>
<p>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性.</p>
<p>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</p>
<p>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</p>
<p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p>
<p><a href="https://www.cnblogs.com/bjlhx/p/11953939.html" target="_blank" rel="noopener">012-MySQL 索引添加以及优化说明</a></p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>001-存储引擎MyISAM和InnoDB</title>
    <url>/articles/20200219/b39e95d3.html</url>
    <content><![CDATA[<p>摘要：存储引擎是数据库管理系统用来从数据库创建、读取和更新数据的软件模块。MySQL中有两种类型的存储引擎：事务性和非事务性。<br>对于MySQL 5.5及更高版本，默认的存储引擎是InnoDB。在5.5版本之前，MySQL的默认存储引擎是MyISAM。</p>
<a id="more"></a>

<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="查看安装mysql版本的支持的"><a href="#查看安装mysql版本的支持的" class="headerlink" title="查看安装mysql版本的支持的"></a>查看安装mysql版本的支持的</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br><span class="line"><span class="comment">-- Enginne      Supports     Trabsactions    XA  Savepoints  Comment</span></span><br><span class="line"><span class="comment">-- FEDERATED	    NO				                                Federated MySQL storage engine</span></span><br><span class="line"><span class="comment">-- MRG_MYISAM	    YES	        NO	        NO	   NO	Collection of identical MyISAM tables</span></span><br><span class="line"><span class="comment">-- MyISAM	        YES	        NO	        NO	   NO	MyISAM storage engine</span></span><br><span class="line"><span class="comment">-- BLACKHOLE	    YES	        NO	        NO	   NO	/dev/null storage engine (anything you write to it disappears)</span></span><br><span class="line"><span class="comment">-- CSV	            YES	        NO	        NO	   NO	CSV storage engine</span></span><br><span class="line"><span class="comment">-- MEMORY	        YES	        NO	        NO	   NO	Hash based, stored in memory, useful for temporary tables</span></span><br><span class="line"><span class="comment">-- ARCHIVE	        YES	        NO	        NO	   NO	Archive storage engine</span></span><br><span class="line"><span class="comment">-- InnoDB	        DEFAULT	    YES	        YES	   YES	Supports transactions, row-level locking, and foreign keys</span></span><br><span class="line"><span class="comment">-- PERFORMANCE_SCHEMA	YES	    NO	        NO	   NO	Performance Schema</span></span><br></pre></td></tr></table></figure>
<p>说明<br>　　engine：引擎名称。<br>　　suppot：是否支持。<br>　　comment：说明。<br>　　transactions：是够支持事务。<br>　　xa：是否支持XA事务。<br>　　savepoints：是否支持保存savepoints之间的内容。</p>
<h1 id="常用引擎（常用的MyISAM和InnoDB）"><a href="#常用引擎（常用的MyISAM和InnoDB）" class="headerlink" title="常用引擎（常用的MyISAM和InnoDB）"></a>常用引擎（常用的MyISAM和InnoDB）</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>mysql5.5之前默认的存储引擎，由MYD和MYI组成。<br>查看数据库的data目录/数据库名称/，在查找相对应的表名。frm,myd,myi这三个结尾的文件。<br>　　.myd　　//数据库文件<br>　　.myi　　//索引文件  又叫非聚集索引</p>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul>
<li>并发性与锁级别-表解锁</li>
<li>支持全文索引</li>
<li>支持数据压缩   命令：进入到mysql的bin文件夹， .\myisampack.exe -b -f “需要压缩的test.MYI地址” （此命令实在Windows运行）。</li>
<li>运行完以后，会出现一个以OLD结尾的文件，删除OLD可能会出现问题。需要恢复 CHECK table 表名，REPAIR table 表名      </li>
</ul>
<h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><ul>
<li>非事务的类型</li>
<li>只读类应用，读取数据的速度快</li>
<li>空间类型（坐标，空间函数）</li>
</ul>
<h2 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h2><p>　　mysql5.5以后默认的存储引擎，innodb_file_per_table  on：表示独立表空间，OFF：表示系统表空间。5.6之前是系统表空间，之后为独立表空间。<br>　　独立表空间：.frm .ibd  存储数据+索引。 可以通过 optimize table 表名 .ibd收缩数据文件，同时可以向多个文件刷新数据。<br>　　系统表空间：.frm是放在数据库的文件下的。 .ibdata1是放在data文件夹下的，表公用的，会产生IO的瓶颈。 系统表空间无法简单的收缩文件大小<br>　　建议使用独立表空间。</p>
<h3 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h3><p>是一种事务性存储引擎。完全支持事务的ACID特性。执行行级锁，并发程度高。Redo Log和Undo Log。</p>
<h3 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h3><p>大多数的OLTP应用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对比项  MyISAM  InnoDB</span><br><span class="line">外键    不支持      支持</span><br><span class="line">事务    不支持      支持</span><br><span class="line">锁      表锁       行锁</span><br><span class="line">关注点  性能        事务</span><br><span class="line">表空间  小          大</span><br><span class="line">缓存    缓存索引    缓存索引和数据</span><br><span class="line">场景    不合适高并发 适合高并发</span><br></pre></td></tr></table></figure>

<h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><p>　　数据以文本方式存储，表的字段不能为空，不能有主键。<br>　　.frm , .csv数据的内容， .csm存储表的元数据 。<br>　　使用文本编辑器可以直接编辑.csv数据，然后保存，在数据库里面执行flush  tables;<br>　　注：要在最后一行数据回车一下，要不然最后一条数据不展示。<br>　　在excel里面操作提示兼容性问题，无法操作成功，编辑完以后修复一下，可能是excel版本的问题吧。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>以CSV格式进行数据存储，所有列的字段都不能为null，不支持索引，可以对数据文件在线编辑。</p>
<h2 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h2><p>　　以zlib对表数据进行压缩，磁盘I/O更少，数据存储在.ARZ。<br>　　.frm , .ARZ数据的内容。</p>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>　　　　只支持insert和select操作，只允许在自增ID列上加索引。</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>　　　　日志和数据采集应用</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>　　在data文件夹里面只有一个frm。<br>　　数据保存在内存中，支持hash索引和BTree索引，所有字段都是固定的长度varchar(10)=char(10),不支持Blog和Text等字段<br>　　使用表级索，最大有max_heap_table_size 决定。 重启会丢失数据。<br>　　在系统使用临时表的时候，超过限制会使用MyISAM，未超过的时候使用Memory<br>　　临时表：在同一个session（会话）里面，才能使用。重启服务会丢失数据。<br>　　应用场景：mysql后台服务使用Memory</p>
<h2 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h2><p>　　访问远程的数据库表，本地只保存数据库结构和连接信息，数据保存在远程的服务器中。在本地只保存.frm<br>　　默认不是开启的引擎，在my.ini  增加 federated=1，重启。<br>　　只能用命令创建。create table ‘aaa’(里面的字段，要和连接的服务器一样) engine=federated connection=’mysql://用户名:密码@地址:IP/数据库名/表名’</p>
]]></content>
      <categories>
        <category>db-mysql-qa</category>
      </categories>
  </entry>
  <entry>
    <title>001-mac安装、工具vscode配置、工程目录</title>
    <url>/articles/20200214/769cb3c4.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://www.cnblogs.com/bjlhx/p/11940108.html" target="_blank" rel="noopener">001-mac搭建Python开发环境、Anaconda、zsh兼容</a></p>
<h2 id="检测安装情况"><a href="#检测安装情况" class="headerlink" title="检测安装情况"></a>检测安装情况</h2><p>一般默认安装了 py2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># py 3 版本检测</span></span><br><span class="line">python3 -V</span><br><span class="line"><span class="comment"># py 2 版本检测</span></span><br><span class="line">python2 -V</span><br><span class="line"><span class="comment"># Anaconda 版本检测</span></span><br><span class="line">conda --version</span><br></pre></td></tr></table></figure>

<h2 id="vscodoe安装Python插件"><a href="#vscodoe安装Python插件" class="headerlink" title="vscodoe安装Python插件"></a>vscodoe安装Python插件</h2><p>搜索后安装“Python”即可,成功后重启</p>
<p>如果你同时安装了多个版本的Python（如Python2.7，Python3.x和Anaconda），你可以通过点击左下角的语言（这里的Python x.x.x）或在命令盘中选择select interpreter来切换Python解释器。VSCode默认用PEP8标准来格式化Python代码，但你也可以选用其他标准。</p>
<h1 id="python项目工程结构"><a href="#python项目工程结构" class="headerlink" title="python项目工程结构"></a>python项目工程结构</h1><p>参看几个比较流行的python开源项目<br><a href="https://github.com/pallets/flask" target="_blank" rel="noopener">flask</a><br><a href="https://github.com/psf/requests" target="_blank" rel="noopener">requests</a><br><a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">thefuck</a><br><a href="https://github.com/docker/compose" target="_blank" rel="noopener">compose</a><br><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">tensorflow</a><br><a href="https://github.com/django/django" target="_blank" rel="noopener">django</a></p>
<p>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project&#x2F;</span><br><span class="line">|-- bin&#x2F;    存放项目的一些可执行文件，或 script&#x2F;。</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- project&#x2F; 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录tests&#x2F;存放单元测试代码； (3) 程序的入口最好命名为main.py。</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py   </span><br><span class="line">|   |-- moduleA</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- packageA.py</span><br><span class="line">|   |-- moduleB</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- packageB.py</span><br><span class="line">|</span><br><span class="line">|-- tests&#x2F;</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- test_main.py</span><br><span class="line">|</span><br><span class="line">|-- docs&#x2F; 文档</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py  安装、部署、打包的脚本</span><br><span class="line">|-- requirements.txt 存放软件依赖的外部Python包列表</span><br><span class="line">|-- README  说明</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application" target="_blank" rel="noopener">查看</a></p>
]]></content>
      <categories>
        <category>python-syntax</category>
      </categories>
  </entry>
  <entry>
    <title>003-ab压力测试之post与get请求</title>
    <url>/articles/20200214/8dd4d804.html</url>
    <content><![CDATA[<p>摘要：使用ab检测指定地址 处理问题能力。</p>
<a id="more"></a>

<h1 id="模拟get请求"><a href="#模拟get请求" class="headerlink" title="模拟get请求"></a>模拟get请求</h1><p>直接在url后面带参数即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 10 -n 10 http://www.test.api.com/?gid=2</span><br></pre></td></tr></table></figure>
<p>n 总数，c 一次请求</p>
<h1 id="模拟post请求"><a href="#模拟post请求" class="headerlink" title="模拟post请求"></a>模拟post请求</h1><h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h2><p>在当前目录下创建一个文件post.txt,编辑文件post.txt写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cid&#x3D;4&amp;status&#x3D;1</span><br></pre></td></tr></table></figure>
<p>相当于post传递cid,status参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -n 100  -c 10 -p <span class="string">'post.txt'</span> -T <span class="string">'application/x-www-form-urlencoded'</span> <span class="string">'http://test.api.com/ttk/auth/info/'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test-ab</category>
      </categories>
  </entry>
  <entry>
    <title>007-高性能网站建设笔记-12移除重读脚本、13配置ETag、14使用ajax</title>
    <url>/articles/20200214/96280786.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="12移除重读脚本"><a href="#12移除重读脚本" class="headerlink" title="12移除重读脚本"></a>12移除重读脚本</h1><h1 id="13配置ETag"><a href="#13配置ETag" class="headerlink" title="13配置ETag"></a>13配置ETag</h1><p>[Pragma、Expires、Cache-Control、max-age、Last-Modified、用户刷新访问、避免过度304]（<a href="https://www.cnblogs.com/bjlhx/p/10338625.html）" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10338625.html）</a></p>
<h1 id="14使用ajax"><a href="#14使用ajax" class="headerlink" title="14使用ajax"></a>14使用ajax</h1>]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>006-高性能网站建设笔记-09减少DNS查找、10精简javscript、11避免重定向</title>
    <url>/articles/20200214/d6bed999.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="09减少DNS查找"><a href="#09减少DNS查找" class="headerlink" title="09减少DNS查找"></a>09减少DNS查找</h1><p>DNS 域名解析也会耗时。</p>
<h1 id="10精简javscript"><a href="#10精简javscript" class="headerlink" title="10精简javscript"></a>10精简javscript</h1><p>混淆：也能优化注释和空白，但是注意混淆可能会使代码出现错误</p>
<p>压缩和精简：推荐压缩，会使变量名，方法名变短，减少带宽，增加下载速度，解析速度。</p>
<h1 id="11避免重定向"><a href="#11避免重定向" class="headerlink" title="11避免重定向"></a>11避免重定向</h1><p>重定向会增加http请求次数</p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>004-高性能网站建设笔记-05样式表放在顶部、06脚本放在底部</title>
    <url>/articles/20200213/372b80cc.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="05样式表放在顶部【必须】"><a href="#05样式表放在顶部【必须】" class="headerlink" title="05样式表放在顶部【必须】"></a>05样式表放在顶部【必须】</h1><p>将样式表放在 head中，在html规范中，也明确规定Link需出现下head中，不限次数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//storage.jd.com/sy-static.jd.com/1564972561844_index.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>避免了白屏和无样式内容的闪烁问题</p>
<h1 id="06脚本放在底部"><a href="#06脚本放在底部" class="headerlink" title="06脚本放在底部"></a>06脚本放在底部</h1><p>DOM 加载是顺序加载<a href="http://blog.bjlhx.top/categories/html_jd_css">more</a></p>
<p>如果脚本在页面头部，可能会造成，页面阻塞。</p>
<h2 id="并行下载-无意义，会发生脚本阻塞下载"><a href="#并行下载-无意义，会发生脚本阻塞下载" class="headerlink" title="并行下载-无意义，会发生脚本阻塞下载"></a>并行下载-无意义，会发生脚本阻塞下载</h2><p>如果页面编写了 script 标签，那么每个脚本都会产生一个http请求，进而进行下载。</p>
<p>在http 1.1规范，建议浏览器从每个主机名并行下载两个组件。简单理解，默认同时下载两个文件。</p>
<p>增加并行下载数量：可以简单使用CNAME（DNS别名）来将组件分别放到多个主机域名中。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>增加了带宽以及cpu的使用</p>
<h2 id="脚本阻塞下载"><a href="#脚本阻塞下载" class="headerlink" title="脚本阻塞下载"></a>脚本阻塞下载</h2><p>并行下载组件的优点多多，但是，在下载脚本时并行下载实际上是被禁用的–即使用了不同的主机名，浏览器也不会启动其他的下载。<br>原因：<br>1、脚本可能使用了document.write来修改页面内容，因此浏览器会等待，以确保页面能够恰当的布局。<br>2、为了保证脚本能够按照正确的顺序执行。</p>
<p>如果并行下载多个脚本，就无法保证响应是按照特定顺序到达浏览器的。如后面的先下载，结果后面的执行了，但内部有依赖于上一个脚本的代码，或导致js错误</p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>005-高性能网站建设笔记-07避免CSS表达式、08使用外部的js和css</title>
    <url>/articles/20200213/ac31f31.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="07避免CSS表达式"><a href="#07避免CSS表达式" class="headerlink" title="07避免CSS表达式"></a>07避免CSS表达式</h1><p>浏览器兼容，大部分不支持css表达式</p>
<h1 id="08使用外部的js和css"><a href="#08使用外部的js和css" class="headerlink" title="08使用外部的js和css"></a>08使用外部的js和css</h1><h2 id="内联和外置"><a href="#内联和外置" class="headerlink" title="内联和外置"></a>内联和外置</h2><ul>
<li>内联：默认的script 引入</li>
<li>外置：动态加载 脚本<br>切割公共部分，适当选择使用外部js和css<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doOnload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="string">"downloadComponents()"</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload=doOnload;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doenloadComponents</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  downloadJS(<span class="string">"ss"</span>);</span><br><span class="line">  downloadCSS(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadJS</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  elem.src = url;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadCSS</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">  elem.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">  elem.type = <span class="string">"text/css"</span>;</span><br><span class="line">  elem.href = url;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>




</li>
</ul>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>003-高性能网站建设笔记-03添加Expires头、04压缩组件</title>
    <url>/articles/20200213/457472c2.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>

<h1 id="03添加Expires头-【推荐Cache-Control】"><a href="#03添加Expires头-【推荐Cache-Control】" class="headerlink" title="03添加Expires头-【推荐Cache-Control】"></a>03添加Expires头-【推荐Cache-Control】</h1><h2 id="添加Expires头和Cache-Control"><a href="#添加Expires头和Cache-Control" class="headerlink" title="添加Expires头和Cache-Control"></a>添加Expires头和Cache-Control</h2><p>关于gzip压缩、http缓存控制和缓存校验[Pragma、Expires、Cache-Control、max-age、Last-Modified、用户刷新访问、避免过度304]（<a href="https://www.cnblogs.com/bjlhx/p/10338625.html）" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10338625.html）</a></p>
<p>可以参看，大部分站点会将变更较少的图片、js、css等设置成缓存30天以上</p>
<h1 id="04压缩组件"><a href="#04压缩组件" class="headerlink" title="04压缩组件"></a>04压缩组件</h1><h2 id="压缩的是什么"><a href="#压缩的是什么" class="headerlink" title="压缩的是什么"></a>压缩的是什么</h2><p>主要压缩静态资源：html 文档、js、css、xml、json等</p>
<p>压缩成本：花费额外的CPU 周期完成压缩，配置文件大于一个常规值开始压缩，如：1M 或 2M</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx开启压缩：<a href="https://www.cnblogs.com/bjlhx/p/12034531.html" target="_blank" rel="noopener">006-nginx.conf详解-error_page 使用、压缩</a></p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>003-分析Chrome的瀑布流（Waterfall）</title>
    <url>/articles/20200213/961373d8.html</url>
    <content><![CDATA[<p>摘要：当需要调试网页或分析网站性能时，我们往往会F12打开浏览器控制台，查看网络请求，看网页加载了哪些资源，以及对应的请求方式（Method）、状态码（Status）、资源类型（Type）、大小（Size）、耗费的时间（Time）等。</p>
<p>如果某个资源耗费的时间比较长，需要深入分析时，则需要看：瀑布流（Waterfall），在Waterfall中可以看出时间具体花在了哪些部分。</p>
<!-- maore -->

<h1 id="解说"><a href="#解说" class="headerlink" title="解说"></a>解说</h1><p>打开用chrome console，可以看到如下</p>
<p><img src="/images/post/performance-web/chrome-console.jpg" alt=""></p>
<p>可以看到页面加载的时间窗口。此时可以将鼠标放置 右侧的waterfall上，可以查看具体耗时</p>
<p><img src="/images/post/performance-web/chrome-console2.jpg" alt=""></p>
<h2 id="瀑布流中各项指标含义如下："><a href="#瀑布流中各项指标含义如下：" class="headerlink" title="瀑布流中各项指标含义如下："></a>瀑布流中各项指标含义如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queueing：浏览器将资源放入队列时间，比如：遇到更高优先级的请求或请求并发超过6了。</span><br><span class="line">Stalled：因放入队列时间而发生的停滞时间。</span><br><span class="line">Proxy negotiation：与代理服务器协商时间。</span><br><span class="line">DNS Lookup：DNS解析时间，浏览器需要将域名转换成IP。</span><br><span class="line">Initial Connection：在浏览器发送请求前，需要建立HTTP连接的时间。</span><br><span class="line">SSL：如果网站使用了HTTPS，这个就是浏览器与服务器建立安全性连接的时间。</span><br><span class="line">Request sent：请求发送的时间。</span><br><span class="line">Waiting (TTFB)：等待服务端返回数据的时间，这个时间受制于服务端处理性能。</span><br><span class="line">Content Download：浏览器下载资源的时间，这个时间受制于文件大小和带宽。</span><br></pre></td></tr></table></figure>

<p>如何优化，请参看：<a href="http://blog.bjlhx.top/categories/performance-web">http://blog.bjlhx.top/categories/performance-web</a></p>
]]></content>
      <categories>
        <category>performance</category>
      </categories>
  </entry>
  <entry>
    <title>002-高性能网站建设笔记-01减少http请求、02使用内容发布网络CDN</title>
    <url>/articles/20200213/481fe23c.html</url>
    <content><![CDATA[<p>摘要：减少http请求：图片地图、css scripts、内联图片和脚本、样式表的合并</p>
<a id="more"></a>

<h1 id="减少http请求"><a href="#减少http请求" class="headerlink" title="减少http请求"></a>减少http请求</h1><h2 id="图片地图-【不常用】"><a href="#图片地图-【不常用】" class="headerlink" title="图片地图-【不常用】"></a>图片地图-【不常用】</h2><p>多个图片合成一个，根据区域不同触发不同操作。<br>或者一个图片有多个区域触发不同操作，不用将图片拆成多个<br>如，导航栏 有帮助、关于、设置等图标，变成一个图片，根据坐标触发不同操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"planets.gif"</span> <span class="attr">alt</span>=<span class="string">"Planets"</span> <span class="attr">usemap</span>=<span class="string">"#planetmap"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"sun.htm"</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,110,260"</span>&gt;</span>Sun<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"mercur.htm"</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"129,161,10"</span>&gt;</span>Mercury<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"venus.htm"</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"180,139,14"</span>&gt;</span>Venus<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="css-scripts-【即雪碧图，常用】"><a href="#css-scripts-【即雪碧图，常用】" class="headerlink" title="css scripts-【即雪碧图，常用】"></a>css scripts-【即雪碧图，常用】</h2><p>多个图片合成一个，根据区域不同触发不同操作。只不过是 使用css脚本控制，需要用到background-position属性</p>
<p>主要适用：页面背景、按钮、导航栏、链接图标等</p>
<p>图片截取都是从左上角的（0,0）坐标开始，所有需要把所需的图片移动想左、上移动，移动到所截取的图片的位置即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*空格  ：后代选择器（所有后代）*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-id">#container</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">            width: 25px;</span><br><span class="line">            height: 25px;</span><br><span class="line">            color: red;</span><br><span class="line">            background-image: url("../../img/icon.gif");</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#div2</span>&#123;<span class="attribute">background-position</span>:-<span class="number">42px</span> <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#div3</span>&#123;  <span class="attribute">background-position</span>: -<span class="number">165px</span> -<span class="number">25px</span>; &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>雪碧图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内联图片-【适当使用】"><a href="#内联图片-【适当使用】" class="headerlink" title="内联图片-【适当使用】"></a>内联图片-【适当使用】</h2><p>将图片编码，通html放置在一起，已达到降低请求次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;data:[mediatype][;base64],base64data&gt;  data - 取得数据的协定名称</span><br><span class="line"></span><br><span class="line">mediatype:image&#x2F;png - 数据类型名称</span><br><span class="line">base64 - 数据的编码方法</span><br><span class="line">base64data - 编码后的数据</span><br><span class="line">: , ; - data URI scheme 指定的分隔符号</span><br></pre></td></tr></table></figure>
<p>缺点</p>
<ol>
<li>浏览器不会缓存内联图片资源</li>
<li>存在大小限制</li>
<li>base64编码会使图片大小增大，导致网页整体下载速度减慢</li>
</ol>
<h2 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h2><p>样式表-每个页面统一成一个<br>脚本-适当合并，尽量减少脚本数量</p>
<h1 id="使用内容发布网络CDN"><a href="#使用内容发布网络CDN" class="headerlink" title="使用内容发布网络CDN"></a>使用内容发布网络CDN</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>归纳起来，CDN具有以下主要功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)节省骨干网带宽，减少带宽需求量；</span><br><span class="line">(2)提供服务器端加速，解决由于用户访问量大造成的服务器过载问题；</span><br><span class="line">(3)服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求；</span><br><span class="line">(4)能克服网站分布不均的问题，并且能降低网站自身建设和维护成本；</span><br><span class="line">(5)降低“通信风暴”的影响，提高网络访问的稳定性。</span><br></pre></td></tr></table></figure>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>002-使用、参数讲解</title>
    <url>/articles/20200213/629a2186.html</url>
    <content><![CDATA[<p>摘要：使用ab检测指定地址 处理问题能力。</p>
<a id="more"></a>

<h1 id="AB的简介"><a href="#AB的简介" class="headerlink" title="AB的简介"></a>AB的简介</h1><h2 id="命令常用参数"><a href="#命令常用参数" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># -n requests Number of requests to perform //本次测试发起的总请求数</span></span><br><span class="line"><span class="comment"># -c concurrency Number of multiple requests to make　　 //一次产生的请求数（或并发数）</span></span><br><span class="line"><span class="comment"># -t timelimit Seconds to max. wait for responses　　　　//测试所进行的最大秒数，默认没有时间限制。</span></span><br><span class="line"><span class="comment"># -r Don't exit on socket receive errors.    // 抛出异常继续执行测试任务</span></span><br><span class="line"><span class="comment"># -p postfile File containing data to POST　　//包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt</span></span><br><span class="line"><span class="comment"># -T content-type Content-type header for POSTing</span></span><br><span class="line"><span class="comment"># //POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）</span></span><br><span class="line"><span class="comment"># -v verbosity How much troubleshooting info to print</span></span><br><span class="line"><span class="comment"># //设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。</span></span><br><span class="line"><span class="comment"># -C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)</span></span><br><span class="line"><span class="comment"># //-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。</span></span><br><span class="line"><span class="comment"># 提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。</span></span><br><span class="line"><span class="comment"># -w Print out results in HTML tables　　//以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 500 -n 5000 http://jd.com/</span><br></pre></td></tr></table></figure>
<p>说明：发送 5000个请求，每次发送500 个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 500 -n 5000 http://jd.com/</span><br><span class="line"><span class="comment"># This is ApacheBench, Version 2.3 &lt;$Revision: 1826891 $&gt;</span></span><br><span class="line"><span class="comment"># Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span></span><br><span class="line"><span class="comment"># Licensed to The Apache Software Foundation, http://www.apache.org/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Benchmarking jd.com (be patient)</span></span><br><span class="line"><span class="comment"># Completed 500 requests</span></span><br><span class="line"><span class="comment"># Completed 1000 requests</span></span><br><span class="line"><span class="comment"># Completed 1500 requests</span></span><br><span class="line"><span class="comment"># Completed 2000 requests</span></span><br><span class="line"><span class="comment"># Completed 2500 requests</span></span><br><span class="line"><span class="comment"># Completed 3000 requests</span></span><br><span class="line"><span class="comment"># Completed 3500 requests</span></span><br><span class="line"><span class="comment"># Completed 4000 requests</span></span><br><span class="line"><span class="comment"># Completed 4500 requests</span></span><br><span class="line"><span class="comment"># Completed 5000 requests</span></span><br><span class="line"><span class="comment"># Finished 5000 requests</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Server Software:        jfe #测试服务器的名字</span></span><br><span class="line"><span class="comment"># Server Hostname:        jd.com  #请求的URL主机名</span></span><br><span class="line"><span class="comment"># Server Port:            80   #请求端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Document Path:          / #请求路径</span></span><br><span class="line"><span class="comment"># Document Length:        165 bytes #HTTP响应数据的正文长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Concurrency Level:      500   #并发用户数，这是我们设置的参数之一</span></span><br><span class="line"><span class="comment"># Time taken for tests:   14.630 seconds  #所有这些请求被处理完成所花费的总时间 单位秒</span></span><br><span class="line"><span class="comment"># Complete requests:      5000  #总请求数量，这是我们设置的参数之一</span></span><br><span class="line"><span class="comment"># Failed requests:        0     #表示失败的请求数量</span></span><br><span class="line"><span class="comment"># Non-2xx responses:      5000</span></span><br><span class="line"><span class="comment"># Total transferred:      1715000 bytes #所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度</span></span><br><span class="line"><span class="comment"># HTML transferred:       825000 bytes  #所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度</span></span><br><span class="line"><span class="comment"># Requests per second:    341.75 [#/sec] (mean) #吞吐量，计算公式：Complete requests/Time taken for tests  总请求数/处理完成这些请求数所花费的时间</span></span><br><span class="line"><span class="comment"># Time per request:       1463.049 [ms] (mean)   #用户平均请求等待时间，计算公式：Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）</span></span><br><span class="line"><span class="comment"># Time per request:       2.926 [ms] (mean, across all concurrent requests) #服务器平均请求等待时间，计算公式：Time taken for tests/Complete requests，正好是吞吐率的倒数。也可以这么统计：Time per request/Concurrency Level</span></span><br><span class="line"><span class="comment"># Transfer rate:          114.47 [Kbytes/sec] received  #表示这些请求在单位时间内从服务器获取的数据长度，计算公式：Total trnasferred/ Time taken for tests，这个统计很好的说明服务器的处理能力达到极限时，其出口宽带的需求量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connection Times (ms)   #网络消耗时间，</span></span><br><span class="line"><span class="comment">#               min  mean[+/-sd] median   max</span></span><br><span class="line"><span class="comment"># Connect:        9  242 414.5    138    3513</span></span><br><span class="line"><span class="comment"># Processing:    12  407 801.4    158   11468</span></span><br><span class="line"><span class="comment"># Waiting:       12  276 575.5    147    8130</span></span><br><span class="line"><span class="comment"># Total:         26  649 938.0    320   12727</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Percentage of the requests served within a certain time (ms)</span></span><br><span class="line"><span class="comment">#   50%    320    #50%用户请求在320ms内返回</span></span><br><span class="line"><span class="comment">#   66%    359    #60%用户请求在359ms内返回</span></span><br><span class="line"><span class="comment">#   75%    858</span></span><br><span class="line"><span class="comment">#   80%   1009</span></span><br><span class="line"><span class="comment">#   90%   1431    #这是一个衡量点，主要参看指标</span></span><br><span class="line"><span class="comment">#   95%   2478</span></span><br><span class="line"><span class="comment">#   98%   3963    #98%用户请求在3963ms内返回</span></span><br><span class="line"><span class="comment">#   99%   4664</span></span><br><span class="line"><span class="comment">#  100%  12727 (longest request)</span></span><br></pre></td></tr></table></figure>

<h2 id="关键指标说明"><a href="#关键指标说明" class="headerlink" title="关键指标说明"></a>关键指标说明</h2><p>主要看90% 的请求响应时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TPS吞吐量：请求数&#x2F;请求响应的时间(s) ，即每秒请求数，对应 Request per second一项，tps&#x3D;13.24 req&#x2F;s</span><br><span class="line">响应时间：请求发送到接受到请求的时间差，单位为ms，一般看90%的响应时间，此时RT&#x3D;862ms</span><br><span class="line">并发连接数：每秒服务器端能处理的连接数。并发连接数 &#x3D; 吞吐量*响应时间，并发连接数&#x3D;11.4 req</span><br><span class="line">PV:Page View网页的浏览次数,或者点击量</span><br><span class="line">UV:Unique Visitor,一台ip地址为一个访客。00:00-24:00内相同的客户端只被计算一次</span><br><span class="line">峰值QPS:每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间</span><br><span class="line">( 总PV数 * 80% ) &#x2F; ( 每天秒数 * 20% ) &#x3D; 峰值时间每秒请求数(QPS)</span><br><span class="line">峰值机器数：保证机器数量抗住峰值QPS，机器数 &#x3D; 峰值QPS&#x2F;单台机器QPS</span><br></pre></td></tr></table></figure>

<h2 id="防重放攻击处理"><a href="#防重放攻击处理" class="headerlink" title="防重放攻击处理"></a>防重放攻击处理</h2><p>上述请求没有增加防重放攻击处理，可以尝试请求测试下百度的，</p>
<p>可以看到 发送了100个，失败了99个，做了重放攻击的处理<br>如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ab -c 10 -n 100 http://www.baidu.com/</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1826891 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking www.baidu.com (be patient).....<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">Server Software:        BWS/1.1</span><br><span class="line">Server Hostname:        www.baidu.com</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        168409 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   4.660 seconds</span><br><span class="line">Complete requests:      100</span><br><span class="line">Failed requests:        99</span><br><span class="line">   (Connect: 0, Receive: 0, Length: 99, Exceptions: 0)</span><br><span class="line">Total transferred:      16300978 bytes</span><br><span class="line">HTML transferred:       16182926 bytes</span><br><span class="line">Requests per second:    21.46 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       466.012 [ms] (mean)</span><br><span class="line">Time per request:       46.601 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          3415.99 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        7   83  46.2     77     219</span><br><span class="line">Processing:   134  371  76.3    383     775</span><br><span class="line">Waiting:        7   91  40.2     87     205</span><br><span class="line">Total:        141  454  72.9    455     826</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    455</span><br><span class="line">  66%    477</span><br><span class="line">  75%    488</span><br><span class="line">  80%    496</span><br><span class="line">  90%    509</span><br><span class="line">  95%    585</span><br><span class="line">  98%    654</span><br><span class="line">  99%    826</span><br><span class="line"> 100%    826 (longest request)</span><br></pre></td></tr></table></figure>

<h2 id="导出报告"><a href="#导出报告" class="headerlink" title="导出报告"></a>导出报告</h2><p>ab -c10 -n100 <a href="http://www.baidu.com/&gt;report.html" target="_blank" rel="noopener">http://www.baidu.com/&gt;report.html</a>    </p>
]]></content>
      <categories>
        <category>test-ab</category>
      </categories>
  </entry>
  <entry>
    <title>001-安装简介</title>
    <url>/articles/20200213/ff1f09cb.html</url>
    <content><![CDATA[<h1 id="AB的简介"><a href="#AB的简介" class="headerlink" title="AB的简介"></a>AB的简介</h1><p>ab是apachebench命令的缩写。Apache Bench 是 Apache 服务器的一个web压力测试工具.</p>
<p>ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等</p>
<p>ab也是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一个URL地址进行访问，因此可以用来测试目标服务器的负载压力。缺点就是没有图形化结果，不能监控。</p>
<h1 id="ab的原理"><a href="#ab的原理" class="headerlink" title="ab的原理"></a>ab的原理</h1><p>　　ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。</p>
<p>　　ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机</p>
<h1 id="ab的安装"><a href="#ab的安装" class="headerlink" title="ab的安装"></a>ab的安装</h1><h2 id="linux-上，安装命令："><a href="#linux-上，安装命令：" class="headerlink" title="linux 上，安装命令："></a>linux 上，安装命令：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install httpd-tools</span><br></pre></td></tr></table></figure>
<p>查看参数说明：ab –help</p>
<h2 id="MAC中自带了Apache"><a href="#MAC中自带了Apache" class="headerlink" title="MAC中自带了Apache"></a>MAC中自带了Apache</h2><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在使用ab命令时，并发了过高会出现错误：Too many open files，由于系统打开文件数量限制了。</p>
<ol>
<li>查看系统打开文件数量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a </span><br><span class="line"><span class="comment"># -t: cpu time (seconds)              unlimited</span></span><br><span class="line"><span class="comment"># -f: file size (blocks)              unlimited</span></span><br><span class="line"><span class="comment"># -d: data seg size (kbytes)          unlimited</span></span><br><span class="line"><span class="comment"># -s: stack size (kbytes)             8192</span></span><br><span class="line"><span class="comment"># -c: core file size (blocks)         0</span></span><br><span class="line"><span class="comment"># -v: address space (kbytes)          unlimited</span></span><br><span class="line"><span class="comment"># -l: locked-in-memory size (kbytes)  unlimited</span></span><br><span class="line"><span class="comment"># -u: processes                       1418</span></span><br><span class="line"><span class="comment"># -n: file descriptors                8192</span></span><br></pre></td></tr></table></figure></li>
<li>修改打开文件数量，修改成1024，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 1024</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>test-ab</category>
      </categories>
  </entry>
  <entry>
    <title>001-网站的性能指标及指标测试方法</title>
    <url>/articles/20200213/ea81502f.html</url>
    <content><![CDATA[<p>摘要：并发数、响应时间(RT)、吞吐量(Throughput)、页面浏览量(PV)、网站独立访客(UV)、峰值QPS和机器计算公式</p>
<a id="more"></a>

<h1 id="常用网站性能参数"><a href="#常用网站性能参数" class="headerlink" title="常用网站性能参数"></a>常用网站性能参数</h1><h2 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h2><p>是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。</p>
<h2 id="响应时间-RT"><a href="#响应时间-RT" class="headerlink" title="响应时间(RT)"></a>响应时间(RT)</h2><p>响应时间是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。响应时间是指执行一个请求从开始到最后收到响应数据所花费的总体时间。</p>
<h2 id="吞吐量-Throughput-TPS"><a href="#吞吐量-Throughput-TPS" class="headerlink" title="吞吐量(Throughput)-TPS"></a>吞吐量(Throughput)-TPS</h2><p>吞吐量是指单位时间内系统能处理的请求数量，体现系统处理请求的能力，这是目前最常用的性能测试指标。</p>
<p>QPS（每秒查询数）、TPS（每秒事务数）是吞吐量的常用量化指标，另外还有HPS（每秒HTTP请求数）。</p>
<p>跟吞吐量有关的几个重要是：并发数、响应时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QPS（TPS）&#x3D; 并发数 &#x2F; 平均响应时间</span><br></pre></td></tr></table></figure>

<h3 id="QPS和TPS有什么区别？"><a href="#QPS和TPS有什么区别？" class="headerlink" title="QPS和TPS有什么区别？"></a>QPS和TPS有什么区别？</h3><p>TPS是每秒处理的请求数，是统计每秒用户的请求次数。QPS是每秒处理的查询次数，是统计每秒对于服务器查询的次数。用户一次请求，tps+1，而可能该请求中对应3次服务器查询次数，则qps+3。</p>
<p>例如输入一个url，返回html内容，对应查询服务器一次，而有可能在html中再次出现一个url，还需查询同样的服务器一次，则此时QPS&gt;TPS。</p>
<h2 id="页面浏览量-PV"><a href="#页面浏览量-PV" class="headerlink" title="页面浏览量(PV)"></a>页面浏览量(PV)</h2><p>PV即Page View的简写, 即页面浏览量或点击量，用户每次刷新即被计算一次。<br>单台服务器每天PV计算：<br>公式1：每天总PV = QPS * 3600 * 6<br>公式2：每天总PV = QPS * 3600 * 8</p>
<h2 id="网站独立访客-UV"><a href="#网站独立访客-UV" class="headerlink" title="网站独立访客(UV)"></a>网站独立访客(UV)</h2><p>UV即Unique Visitor的简写，访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次<br>服务器数量。<br>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器<br>机器：ceil( 每天总PV / 单台服务器每天总PV )</p>
<h2 id="峰值QPS和机器计算公式"><a href="#峰值QPS和机器计算公式" class="headerlink" title="峰值QPS和机器计算公式"></a>峰值QPS和机器计算公式</h2><p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间<br>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)<br>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器</p>
<p>例子：<br>每天300万PV的在单台机器上，这台机器需要多少QPS？<br>答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)<br>如果一台机器的QPS是58，需要几台机器来支持？<br>答：139 / 58 = 3</p>
<h1 id="如何评估网站性能参数"><a href="#如何评估网站性能参数" class="headerlink" title="如何评估网站性能参数"></a>如何评估网站性能参数</h1><h2 id="针对中小型站点"><a href="#针对中小型站点" class="headerlink" title="针对中小型站点"></a>针对中小型站点</h2><ul>
<li>方式一、使用：ab，可参看：<a href="http://blog.bjlhx.top/categories/test-ab">http://blog.bjlhx.top/categories/test-ab</a></li>
</ul>
<p>初步评估 站点TPS等性能参数</p>
<ul>
<li>方式二、jemter评估</li>
</ul>
<h2 id="大型-对应性能团队"><a href="#大型-对应性能团队" class="headerlink" title="大型-对应性能团队"></a>大型-对应性能团队</h2>]]></content>
      <categories>
        <category>performance</category>
      </categories>
  </entry>
  <entry>
    <title>002-性能测试方法及性能优化分类</title>
    <url>/articles/20200213/7add234f.html</url>
    <content><![CDATA[<p>摘要：并发数、响应时间(RT)、吞吐量(Throughput)、页面浏览量(PV)、网站独立访客(UV)、峰值QPS和机器计算公式</p>
<a id="more"></a>

<h1 id="性能测试方法"><a href="#性能测试方法" class="headerlink" title="性能测试方法"></a>性能测试方法</h1><p>性能测试是一个不断对系统添加访问压力，以获得系统性能指标、最大负载能力、最大压力承受能力的过程。</p>
<p>性能测试方法：</p>
<ul>
<li>性能测试：以系统设计初期规划的性能指标为预期目标，对系统不断施加压力。验证系统在资源可接受范围内，能否达到性能预期。</li>
<li>负载測试：对系统不断地添加并发请求以添加系统压力，知道系统的某项或多项性能指标达到安全临界值。如某种资源已经呈饱和状态，这是继续对系统施加压力，系统的处理能力不但不提高，反而会下降。</li>
<li>压力测试：超过安全负载的情况下。对系统继续施加压力，知道系统崩溃或不能再处理请求，一次获得系统最大压力承受能力。</li>
<li>稳定性测试：被測试系统在特定硬件、软件、网络环境条件下。给系统载入一定业务压力，使系统执行一段较长时间，以此检測系统是否稳定。在不同生成环境、不同一时候间点的请求压力是不均匀的，呈波浪特性。因此为了更好地模拟生产环境，稳定性測试也不应均与地对系统施加压力。</li>
</ul>
<h1 id="性能优化分类"><a href="#性能优化分类" class="headerlink" title="性能优化分类"></a>性能优化分类</h1><p>参看现在大多数站点分层架构设计,性能优化可分为：web前端性能优化、应用server性能优化、存储server性能优化。</p>
<h2 id="web前端性能优化"><a href="#web前端性能优化" class="headerlink" title="web前端性能优化"></a>web前端性能优化</h2><ul>
<li>浏览器访问优化：降低http请求;使用浏览器缓存;启用压缩;css放在页面最上面、javaScript放在页面最以下;降低Cookie传输</li>
<li>CDN加速</li>
<li>反向代理</li>
</ul>
<h2 id="应用server性能优化"><a href="#应用server性能优化" class="headerlink" title="应用server性能优化"></a>应用server性能优化</h2><ul>
<li>内存数据库的使用（Redis、等）</li>
<li>异步操作（消息队列）</li>
<li>使用集群（负载均衡）</li>
<li>代码优化</li>
</ul>
<h2 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h2><ul>
<li>机械硬盘→固态硬盘</li>
<li>B+树 vs LSM树</li>
<li>RAID vs HDFS</li>
<li>DB表结构设计，索引设计</li>
<li>elastsearch 合理使用</li>
</ul>
]]></content>
      <categories>
        <category>performance</category>
      </categories>
  </entry>
  <entry>
    <title>001-高性能网站建设笔记-整体规则</title>
    <url>/articles/20200213/90bc3718.html</url>
    <content><![CDATA[<p>摘要：web性能优化，指导规则；性能黄金法则：只有10%-20%的最终用户响应时间花在了下载HTML文档上；其余的80%-90%的时间花在了下载页面中的所有组件上。</p>
<a id="more"></a>

<h1 id="整体规则"><a href="#整体规则" class="headerlink" title="整体规则"></a>整体规则</h1><p>按照优先级排序，不是每个网站要求使用每个规则，但是值得参考。</p>
<ul>
<li>规则1——减少HTTP请求- </li>
<li>规则2——使用内容发布网络- </li>
<li>规则3——添加Expires头- </li>
<li>规则4——压缩组件- </li>
<li>规则5——将样式表放在顶部- </li>
<li>规则6——将脚本放在底部- </li>
<li>规则7——避免CSS表达式- </li>
<li>规则8——使用外部JavaScript和CSS- </li>
<li>规则9——减少DNS查找- </li>
<li>规则10——精简JavaScript- </li>
<li>规则11——避免重定向- </li>
<li>规则12——移除重复脚本- </li>
<li>规则13——配置ETag- </li>
<li>规则14——使AjaX可缓存</li>
</ul>
<h1 id="跟踪web页面性能方法"><a href="#跟踪web页面性能方法" class="headerlink" title="跟踪web页面性能方法"></a>跟踪web页面性能方法</h1><p>获取页面耗时，请参看：<a href="http://blog.bjlhx.top/categories/performance">http://blog.bjlhx.top/categories/performance</a> 关于使用Chrome 瀑布流<br>获取接口耗时，请参看：<a href="http://blog.bjlhx.top/categories/test-ab">http://blog.bjlhx.top/categories/test-ab</a> </p>
<h1 id="http协议概述"><a href="#http协议概述" class="headerlink" title="http协议概述"></a>http协议概述</h1><p>参看：<a href="https://www.cnblogs.com/bjlhx/p/10987051.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10987051.html</a></p>
<p>关于gzip压缩、http缓存控制和缓存校验【Pragma、Expires、Cache-Control、max-age、Last-Modified、用户刷新访问、避免过度304】<br>参看：<a href="https://www.cnblogs.com/bjlhx/p/10338625.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/10338625.html</a></p>
<p>nginx开启压缩：<a href="https://www.cnblogs.com/bjlhx/p/12034531.html" target="_blank" rel="noopener">006-nginx.conf详解-error_page 使用、压缩</a></p>
]]></content>
      <categories>
        <category>performance-web</category>
      </categories>
  </entry>
  <entry>
    <title>001-html，css，js加载顺序</title>
    <url>/articles/20200212/6bc16603.html</url>
    <content><![CDATA[<p>摘要：</p>
<a id="more"></a>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/*.css"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/*.js&gt;&lt;/script&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;/head&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="DOM加载"><a href="#DOM加载" class="headerlink" title="DOM加载"></a>DOM加载</h1><p>DOM文档的加载顺序是由上而下的顺序加载；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 浏览器一边下载HTML网页，一边开始解析</span><br><span class="line">2. 解析过程中，发现&lt;script&gt;标签</span><br><span class="line">3. 暂停解析，网页渲染的控制权转交给JavaScript引擎</span><br><span class="line">4. 如果&lt;script&gt;标签引用了外部脚本，就下载该脚本，否则就直接执行</span><br><span class="line">5. 执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页</span><br></pre></td></tr></table></figure>

<h2 id="DOM加载到link标签"><a href="#DOM加载到link标签" class="headerlink" title="DOM加载到link标签"></a>DOM加载到link标签</h2><p>css文件的加载是与DOM的加载并行的，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；</p>
<h2 id="DOM加载到script标签"><a href="#DOM加载到script标签" class="headerlink" title="DOM加载到script标签"></a>DOM加载到script标签</h2><p>由于js文件不会与DOM并行加载，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；</p>
<p>而这个特性也是为什么在js文件中开头需要$(document).ready(function(){})或者（function(){}）或者window.onload,即是让DOM文档加载完成之后才执行js文件，这样才不会出现查找不到DOM节点等问题；</p>
<p>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现；</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>html需要等head中所有的js和css加载完成后才会开始绘制，但是html不需要等待放在body最后的js下载执行就会开始绘制,因此将js放在body的最后面，可以避免资源阻塞，同时使静态的html页面迅速显示。将脚本文件都放在网页尾部加载，还有一个好处。在DOM结构生成之前就调用DOM，JavaScript会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时DOM肯定已经生成了。</p>
<p>前提，js是外部脚本；</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>外链的js如果含有defer=”true”属性，将会并行加载js，到页面全部加载完成后才会执行，会按顺序执行。</p>
<p>defer属性的作用是，告诉浏览器，等到DOM加载完成后，再执行指定脚本。</p>
<ol>
<li>浏览器开始解析HTML网页</li>
<li>解析过程中，发现带有defer属性的script标签</li>
<li>浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本</li>
<li>浏览器完成解析HTML网页，此时再执行下载的脚本<br>对于内置而不是连接外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。<br>在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；</li>
</ol>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；</p>
<p>async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>
<ol>
<li>浏览器开始解析HTML网页</li>
<li>解析过程中，发现带有async属性的script标签</li>
<li>浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本</li>
<li>脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本</li>
<li>脚本执行完毕，浏览器恢复解析HTML网页</li>
</ol>
<p>同时使用defer和async属性时，defer属性会失效；</p>
<p>可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。</p>
<p>但是</p>
]]></content>
      <categories>
        <category>html_js_css</category>
      </categories>
  </entry>
  <entry>
    <title>007-shell-编程注意事项、引号区别</title>
    <url>/articles/20200212/b4490d2f.html</url>
    <content><![CDATA[<p>摘要：shell开发时，注意事项</p>
<a id="more"></a>

<h1 id="单引号、双引号、反单引号的区别"><a href="#单引号、双引号、反单引号的区别" class="headerlink" title="单引号、双引号、反单引号的区别"></a>单引号、双引号、反单引号的区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单引号&#39; &#39;：包围变量的值时，原样输出。强引用。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</span><br><span class="line"></span><br><span class="line">双引号&quot; &quot;：包围变量的值时，解析里面的变量和命令。弱引。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</span><br><span class="line"></span><br><span class="line">反引号&#96; &#96;：一般用于命令，执行的时候命令会被执行，相当于$()，赋值和输出都要用反引号引起来。</span><br></pre></td></tr></table></figure>

<p>两种均可，后者，支持嵌套</p>
<h1 id="Shell编程注意事项"><a href="#Shell编程注意事项" class="headerlink" title="Shell编程注意事项"></a>Shell编程注意事项</h1><ol>
<li>变量赋值时‘=’两边不能有空格</li>
<li>使用[]命令测试表达式的时候，在操作数和操作符或者方括号的前后都要至少留一个空格</li>
<li>变量的引用： 使用$var 或者 ${var}</li>
<li>命令的引用：【执行命令返回值给变量】<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var2&#x3D;&#96;command&#96; 或者 var3&#x3D;$(command)</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>cmd-data</title>
    <url>/articles/20200211/f7a4df92.html</url>
    <content><![CDATA[<p>摘要：shell开发时，常用date控制展示时间</p>
<a id="more"></a>

<h1 id="date"><a href="#date" class="headerlink" title="date"></a>date</h1><p>date 可以用来显示或设定系统的日期与时间。</p>
<h2 id="查看帮助语法说明"><a href="#查看帮助语法说明" class="headerlink" title="查看帮助语法说明"></a>查看帮助语法说明</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：date [选项]... [+格式]</span><br><span class="line">　或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">可选参数：</span><br><span class="line">  -d, --date&#x3D;STRING         显示字符串所指的日期与时间。字符串前后必须加上引号； not &#39;now&#39;</span><br><span class="line">  -f, --file&#x3D;DATEFILE       like --date once for each line of DATEFILE</span><br><span class="line">  -I[TIMESPEC], --iso-8601[&#x3D;TIMESPEC]  output date&#x2F;time in ISO 8601 format.</span><br><span class="line">                            TIMESPEC&#x3D;&#39;date&#39; for date only (the default),</span><br><span class="line">                            &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, or &#39;ns&#39; for date</span><br><span class="line">                            and time to the indicated precision.</span><br><span class="line">  -r, --reference&#x3D;文件		显示文件指定文件的最后修改时间</span><br><span class="line">  -R, --rfc-2822		以RFC 2822格式输出日期和时间，例如：2006年8月7日，星期一 12:34:56 -0600</span><br><span class="line">      --rfc-3339&#x3D;TIMESPEC   output date and time in RFC 3339 format.</span><br><span class="line">                            TIMESPEC&#x3D;&#39;date&#39;, &#39;seconds&#39;, or &#39;ns&#39; for</span><br><span class="line">                            date and time to the indicated precision.</span><br><span class="line">                            Date and time components are separated by</span><br><span class="line">                            a single space: 2006-08-07 12:34:56-06:00</span><br><span class="line">  -s, --set&#x3D;STRING          根据字符串来设置日期与时间。字符串前后必须加上引号；</span><br><span class="line">  -u, --utc, --universal    print or set Coordinated Universal Time (UTC)</span><br><span class="line">      --help		显示此帮助信息并退出</span><br><span class="line">      --version		显示版本信息并退出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>日期格式字符串</span></figcaption><table><tr><td class="code"><pre><span class="line"># 如果需要以指定的格式显示日期，可以使用“+”开头的字符串指定其格式</span><br><span class="line">  %%	一个文字的 %</span><br><span class="line">  %a	当前locale 的星期名缩写(例如： 日，代表星期日)</span><br><span class="line">  %A	当前locale 的星期名全称 (如：星期日)</span><br><span class="line">  %b	当前locale 的月名缩写 (如：一，代表一月)</span><br><span class="line">  %B	当前locale 的月名全称 (如：一月)</span><br><span class="line">  %c	当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)</span><br><span class="line">  %C	世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)</span><br><span class="line">  %d	按月计的日期(例如：01)</span><br><span class="line">  %D	按月计的日期；等于%m&#x2F;%d&#x2F;%y</span><br><span class="line">  %e	按月计的日期，添加空格，等于%_d</span><br><span class="line">  %F	完整日期格式，等价于 %Y-%m-%d</span><br><span class="line">  %g	ISO-8601 格式年份的最后两位 (参见%G)</span><br><span class="line">  %G	ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用</span><br><span class="line">  %h	等于%b</span><br><span class="line">  %H	小时(00-23)</span><br><span class="line">  %I	小时(00-12)</span><br><span class="line">  %j	按年计的日期(001-366)</span><br><span class="line">  %k   hour, space padded ( 0..23); same as %_H</span><br><span class="line">  %l   hour, space padded ( 1..12); same as %_I</span><br><span class="line">  %m   month (01..12)</span><br><span class="line">  %M   minute (00..59)</span><br><span class="line">  %n	换行</span><br><span class="line">  %N	纳秒(000000000-999999999)</span><br><span class="line">  %p	当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空</span><br><span class="line">  %P	与%p 类似，但是输出小写字母</span><br><span class="line">  %r	当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)</span><br><span class="line">  %R	24 小时时间的时和分，等价于 %H:%M</span><br><span class="line">  %s	自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</span><br><span class="line">  %S	秒(00-60)</span><br><span class="line">  %t	输出制表符 Tab</span><br><span class="line">  %T	时间，等于%H:%M:%S</span><br><span class="line">  %u	星期，1 代表星期一</span><br><span class="line">  %U	一年中的第几周，以周日为每星期第一天(00-53)</span><br><span class="line">  %V	ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)</span><br><span class="line">  %w	一星期中的第几日(0-6)，0 代表周一</span><br><span class="line">  %W	一年中的第几周，以周一为每星期第一天(00-53)</span><br><span class="line">  %x	当前locale 下的日期描述 (如：12&#x2F;31&#x2F;99)</span><br><span class="line">  %X	当前locale 下的时间描述 (如：23:13:48)</span><br><span class="line">  %y	年份最后两位数位 (00-99)</span><br><span class="line">  %Y	年份</span><br><span class="line">  %z +hhmm		数字时区(例如，-0400)</span><br><span class="line">  %:z +hh:mm		数字时区(例如，-04:00)</span><br><span class="line">  %::z +hh:mm:ss	数字时区(例如，-04:00:00)</span><br><span class="line">  %:::z			数字时区带有必要的精度 (例如，-04，+05:30)</span><br><span class="line">  %Z			按字母表排序的时区缩写 (例如，EDT)</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式化输出：</span></span><br><span class="line">date +<span class="string">"%Y-%m-%d"</span> </span><br><span class="line">2020-02-11</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date +%Y%m%d               <span class="comment">#显示当前天年月日 </span></span><br><span class="line">date -d <span class="string">"-1 day"</span> +%Y%m%d   <span class="comment">#显示前一天的日期 或 date -d "1 day ago" +%Y%m%d </span></span><br><span class="line">date -d <span class="string">"+1 day"</span> +%Y%m%d   <span class="comment">#显示后一天的日期 或 date -d "1 day" +%Y%m%d</span></span><br><span class="line"><span class="comment"># 其中：day 天；month 月；year 年；second 秒；</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-java-保留两位小数以及浮点类型精度问题</title>
    <url>/articles/20200211/7aa0e1b.html</url>
    <content><![CDATA[<p>摘要：保存成两个小数</p>
<a id="more"></a>

<h1 id="几种方式"><a href="#几种方式" class="headerlink" title="几种方式"></a>几种方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> roundLong = <span class="number">8710</span>;</span><br><span class="line">System.out.println((roundLong * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((roundLong /<span class="number">100.0</span>));</span><br><span class="line"><span class="comment">// 方式一、DecimalFormat</span></span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">".00"</span>);</span><br><span class="line">System.out.println(df.format(roundLong * <span class="number">0.01</span>));</span><br><span class="line"><span class="comment">// 方式二、String.format</span></span><br><span class="line">System.out.println(String.format(<span class="string">"%.2f"</span>, (roundLong * <span class="number">0.01</span>)));</span><br><span class="line"><span class="comment">// 方式三、BigDecimal</span></span><br><span class="line">BigDecimal bg = <span class="keyword">new</span> BigDecimal(roundLong * <span class="number">0.01</span>);</span><br><span class="line"><span class="keyword">double</span> d3 = bg.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">System.out.println(d3);</span><br><span class="line"><span class="comment">// 方式四：通过NumberFormat类实现</span></span><br><span class="line">NumberFormat nf = NumberFormat.getNumberInstance();</span><br><span class="line">nf.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">System.out.println(nf.format(roundLong * <span class="number">0.01</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">87.10000000000001</span><br><span class="line">87.1</span><br><span class="line">87.10</span><br><span class="line">87.10</span><br><span class="line">87.1</span><br><span class="line">87.1</span><br></pre></td></tr></table></figure>

<h1 id="浮点类型精度问题"><a href="#浮点类型精度问题" class="headerlink" title="浮点类型精度问题"></a>浮点类型精度问题</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t2 = <span class="number">8710</span>;</span><br><span class="line">System.out.println((t2 * <span class="number">0.1</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.001</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line">t2 = <span class="number">870</span>;</span><br><span class="line">System.out.println((t2 * <span class="number">0.1</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.01</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.001</span>));</span><br><span class="line">System.out.println((t2 * <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> number1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> number2 = <span class="number">20.2</span>;</span><br><span class="line"><span class="keyword">double</span> number3 = <span class="number">300.03</span>;</span><br><span class="line"><span class="keyword">double</span> result = number1 + number2 + number3;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">871.0</span><br><span class="line">87.10000000000001</span><br><span class="line">8.71</span><br><span class="line">0.871</span><br><span class="line">87.0</span><br><span class="line">8.700000000000001</span><br><span class="line">0.87</span><br><span class="line">0.08700000000000001</span><br><span class="line">321.22999999999996</span><br></pre></td></tr></table></figure>
<p>此处涉及，计算机浮点设计问题，详细可查阅资料。<br>float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。<br>主要是说明应用系统设计、数据库设计，商业计算标准金额时，请尽量避开浮点直接运算，推荐 long、BigDecimal等其他方式进行</p>
]]></content>
      <categories>
        <category>java-base</category>
      </categories>
  </entry>
  <entry>
    <title>005-cmd-stat显示与touch修改文件的各种时间</title>
    <url>/articles/20200211/ced46313.html</url>
    <content><![CDATA[<p>摘要：stat查看具体，touch操作具体<br>主要是测试log4j2日志删除策略时候使用。</p>
<a id="more"></a>

<h1 id="stat显示指定文件的状态信息"><a href="#stat显示指定文件的状态信息" class="headerlink" title="stat显示指定文件的状态信息"></a>stat显示指定文件的状态信息</h1><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><ul>
<li>mac<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -?</span><br><span class="line"><span class="comment"># stat: illegal option -- ?</span></span><br><span class="line"><span class="comment"># usage: stat [-FlLnqrsx] [-f format] [-t timefmt] [file ...]</span></span><br></pre></td></tr></table></figure></li>
<li>centos<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 用法：stat [选项]... 文件...</span></span><br><span class="line"><span class="comment"># Display file or file system status.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   -L, --dereference     follow links</span></span><br><span class="line"><span class="comment">#   -Z, --context         print the SELinux security context </span></span><br><span class="line"><span class="comment">#   -f, --file-system     display file system status instead of file status</span></span><br><span class="line"><span class="comment">#   -c --format=格式	使用指定输出格式代替默认值，每用一次指定格式换一新行</span></span><br><span class="line"><span class="comment">#       --printf=格式	类似 --format，但是会解释反斜杠转义符，不使用换行作</span></span><br><span class="line"><span class="comment"># 				输出结尾。如果您仍希望使用换行，可以在格式中</span></span><br><span class="line"><span class="comment"># 				加入"\n"</span></span><br><span class="line"><span class="comment">#   -t, --terse		使用简洁格式输出</span></span><br><span class="line"><span class="comment">#       --help		显示此帮助信息并退出</span></span><br><span class="line"><span class="comment">#       --version		显示版本信息并退出</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="查看具体时间"><a href="#查看具体时间" class="headerlink" title="查看具体时间"></a>查看具体时间</h2><ul>
<li>mac<br>一次尝试一下其中含义，发现 -x 比较容易理解各种时间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -x text.txt</span><br><span class="line"><span class="comment">#   File: "text.txt"</span></span><br><span class="line"><span class="comment">#   Size: 6            FileType: Regular File</span></span><br><span class="line"><span class="comment">#   Mode: (0644/-rw-r--r--)         Uid: (545858136/lihongxu6)  Gid: (699739227/(699739227))</span></span><br><span class="line"><span class="comment"># Device: 1,4   Inode: 15213285    Links: 1</span></span><br><span class="line"><span class="comment"># Access: Tue Feb 11 08:53:33 2020</span></span><br><span class="line"><span class="comment"># Modify: Tue Feb 11 08:53:32 2020</span></span><br><span class="line"><span class="comment"># Change: Tue Feb 11 08:53:32 2020</span></span><br></pre></td></tr></table></figure>

<p>Access是文件访问时间，Modify是文件内容最后修改时间，Change是文件属性最后修改时间，分别对应时间戳atime/mtime/ctime。<br>Change时间比较特殊，当改变文件的名称，大小和权限的时候Change时间才会改变。</p>
<p>通过上述发现并没有包含文件的创建时间，即crtime。查看源码可知，这是因为inode结构体中并没有crtime。</p>
<ul>
<li>centos<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span>  test.txt </span><br><span class="line"><span class="comment">#   File: "test.txt"</span></span><br><span class="line"><span class="comment">#   Size: 0         	Blocks: 0          IO Block: 4096   普通空文件</span></span><br><span class="line"><span class="comment"># Device: fc01h/64513d	Inode: 1579964     Links: 1</span></span><br><span class="line"><span class="comment"># Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line"><span class="comment"># Access: 2020-02-11 10:07:53.343752608 +0800</span></span><br><span class="line"><span class="comment"># Modify: 2020-02-11 10:08:14.709608664 +0800</span></span><br><span class="line"><span class="comment"># Change: 2020-02-11 10:08:14.709608664 +080</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="查看文件的创建时间。"><a href="#查看文件的创建时间。" class="headerlink" title="查看文件的创建时间。"></a>查看文件的创建时间。</h3><ul>
<li><p>mac<br>Mac OS X上没有debugfs（8）。Debugfs（8）是用于调试Linux文件系统ext2 / ext3的Linux程序。<br>可以使用： HFS+ try fsck(8) or use Disk Utility. 或者自带命令： GetFileInfo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GetFileInfo text.txt </span><br><span class="line"><span class="comment"># file: "/Users/lihongxu6/IdeaProjectsGit/shell/test/fileop/text.txt"</span></span><br><span class="line"><span class="comment"># type: "\0\0\0\0"</span></span><br><span class="line"><span class="comment"># creator: "\0\0\0\0"</span></span><br><span class="line"><span class="comment"># attributes: avbstclinmedz</span></span><br><span class="line"><span class="comment"># created: 02/11/2020 08:53:27</span></span><br><span class="line"><span class="comment"># modified: 02/11/2020 08:53:32</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>centos</p>
</li>
</ul>
<ol>
<li><p>查看文件的inode号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> test.txt</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">stat</span> -x text.txt</span><br></pre></td></tr></table></figure>
<p>inode:15213285</p>
</li>
<li><p>输出分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df test.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df text.txt                         </span></span><br><span class="line"><span class="comment"># Filesystem   512-blocks      Used Available Capacity iused               ifree %iused  Mounted on</span></span><br><span class="line"><span class="comment"># /dev/disk1s1  489620264 215965128 243191936    48% 2289359 9223372036852486448    0%   /</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过debugfs就可以查询到文件的完整信息<br>linux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugfs -R <span class="string">'stat &lt;15213285&gt;'</span> /dev/disk1s1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="linux修改文件各种时间"><a href="#linux修改文件各种时间" class="headerlink" title="linux修改文件各种时间"></a>linux修改文件各种时间</h1><p>查看下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span>  test.txt </span><br><span class="line"><span class="comment">#   File: "test.txt"</span></span><br><span class="line"><span class="comment">#   Size: 0         	Blocks: 0          IO Block: 4096   普通空文件</span></span><br><span class="line"><span class="comment"># Device: fc01h/64513d	Inode: 1579964     Links: 1</span></span><br><span class="line"><span class="comment"># Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line"><span class="comment"># Access: 2020-02-11 10:07:53.343752608 +0800</span></span><br><span class="line"><span class="comment"># Modify: 2020-02-11 10:08:14.709608664 +0800</span></span><br><span class="line"><span class="comment"># Change: 2020-02-11 10:08:14.709608664 +080</span></span><br></pre></td></tr></table></figure>

<h2 id="修改修改时间"><a href="#修改修改时间" class="headerlink" title="修改修改时间"></a>修改修改时间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件修改时间设置为：2020年02月11日09:17:52</span></span><br><span class="line">touch -t 202002110917.52 test.txt</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">touch -d <span class="string">"2020-02-11 09:18:08"</span> test.txt</span><br><span class="line"><span class="comment"># 查看实际是否修改</span></span><br><span class="line"><span class="built_in">stat</span> test.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>004-shell-函数以及传递参数的几种方式</title>
    <url>/articles/20200210/7355fbf4.html</url>
    <content><![CDATA[<p>摘要：linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<a id="more"></a>

<h1 id="函数语法格式"><a href="#函数语法格式" class="headerlink" title="函数语法格式"></a>函数语法格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
<li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。执行成功 默认是 0 </li>
</ol>
<p>shell 语言中 0 代表 true，0 以外的值代表 false。</p>
<ol start="3">
<li>函数返回值在调用该函数后通过 $? 来获得。$? 仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。</li>
</ol>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<p>示例1、无返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"test"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"返回值：$?"</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">返回值：0</span><br></pre></td></tr></table></figure>

<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… </p>
<p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数处理	说明</span><br><span class="line">$#	传递到脚本或函数的参数个数</span><br><span class="line">$*	以一个单字符串显示所有向脚本传递的参数</span><br><span class="line">$	脚本运行的当前进程ID号</span><br><span class="line">$!	后台运行的最后一个进程的ID号</span><br><span class="line">$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">$-	显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"进程id:$"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数个数: <span class="variable">$&#123;#&#125;</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"所有参数: $*"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"所有参数: <span class="variable">$@</span>"</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"显示Shell使用的当前选项:$-"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span> aa xx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"返回值：$?"</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程id:11414</span><br><span class="line">参数个数: 2</span><br><span class="line">所有参数: aa xx</span><br><span class="line">所有参数: aa xx</span><br><span class="line">aa</span><br><span class="line">xx</span><br><span class="line">显示Shell使用的当前选项:hB</span><br><span class="line">返回值：0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-tomcat-日志分割三种方法</title>
    <url>/articles/20200210/6998e040.html</url>
    <content><![CDATA[<p>概述:tomcat-日志分割三种方法<br>三种方式均有优缺点，</p>
<ul>
<li>cronolog：需要在主机安装软件</li>
<li>log4j：方便使用，但是不能删除</li>
<li>crontab：需要有对应目录权限</li>
</ul>
<p>采取cronolog、log4j缺点：已经做好对应主机镜像，大范围使用，在应用系统级别修改，所有使用者会参与修改；<br>采用crontab，crontab不需要安装，检测linux默认自带安装。正好部署时使用shell脚本，此时只需在脚本中嵌入执行crontab脚本即可。</p>
<a id="more"></a>
<h1 id="方法一、用cronolog分割tomcat的catalina-out文件"><a href="#方法一、用cronolog分割tomcat的catalina-out文件" class="headerlink" title="方法一、用cronolog分割tomcat的catalina.out文件"></a>方法一、用cronolog分割tomcat的catalina.out文件</h1><p>Linux 日志切割工具cronolog详解：<a href="https://blog.csdn.net/chenkeqin_2012/article/details/52670887" target="_blank" rel="noopener">https://blog.csdn.net/chenkeqin_2012/article/details/52670887</a></p>
<ol>
<li>编译安装cronolog<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://cronolog.org/download/cronolog-1.6.2.tar.gz </span><br><span class="line">tar zxvf cronolog-1.6.2.tar.gz </span><br><span class="line"><span class="built_in">cd</span> cronolog-1.6.2</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li>查看cronolog安装后所在目录（验证安装是否成功）<br>which cronolog<br>一般情况下显示为：/usr/local/sbin/cronolog </li>
<li>编辑tomcat目录bin下的catalina.sh文件<br>找到下面这行，类似这样的行有2处：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \</span><br><span class="line">      &gt;&gt; &quot;$CATALINA_OUT&quot; 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>第一处：tomcat是带“-security”参数的启动，</li>
<li>第二处：默认tomcat启动方式，也就是else下面的那部分，我们只修改这里。</li>
<li>另外还要把touch “$CATALINA_OUT”这行注释掉。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  touch "$CATALINA_OUT"</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"-security"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$have_tty</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"Using Security Manager"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="string">"<span class="variable">$_RUNJAVA</span>"</span> <span class="string">"<span class="variable">$LOGGING_CONFIG</span>"</span> <span class="variable">$LOGGING_MANAGER</span> <span class="variable">$JAVA_OPTS</span> <span class="variable">$CATALINA_OPTS</span> \</span><br><span class="line">      -Djava.endorsed.dirs=<span class="string">"<span class="variable">$JAVA_ENDORSED_DIRS</span>"</span> -classpath <span class="string">"<span class="variable">$CLASSPATH</span>"</span> \</span><br><span class="line">      -Djava.security.manager \</span><br><span class="line">      -Djava.security.policy==<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span>/conf/catalina.policy \</span><br><span class="line">      -Dcatalina.base=<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span> \</span><br><span class="line">      -Dcatalina.home=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span> \</span><br><span class="line">      -Djava.io.tmpdir=<span class="string">"<span class="variable">$CATALINA_TMPDIR</span>"</span> \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap <span class="string">"<span class="variable">$@</span>"</span> start \</span><br><span class="line">      &gt;&gt; <span class="string">"<span class="variable">$CATALINA_OUT</span>"</span> 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="string">"<span class="variable">$_RUNJAVA</span>"</span> <span class="string">"<span class="variable">$LOGGING_CONFIG</span>"</span> <span class="variable">$LOGGING_MANAGER</span> <span class="variable">$JAVA_OPTS</span> <span class="variable">$CATALINA_OPTS</span> \</span><br><span class="line">      -Djava.endorsed.dirs=<span class="string">"<span class="variable">$JAVA_ENDORSED_DIRS</span>"</span> -classpath <span class="string">"<span class="variable">$CLASSPATH</span>"</span> \</span><br><span class="line">      -Dcatalina.base=<span class="string">"<span class="variable">$CATALINA_BASE</span>"</span> \</span><br><span class="line">      -Dcatalina.home=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span> \</span><br><span class="line">      -Djava.io.tmpdir=<span class="string">"<span class="variable">$CATALINA_TMPDIR</span>"</span> \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap <span class="string">"<span class="variable">$@</span>"</span> start 2&gt;&amp;1 | /usr/<span class="built_in">local</span>/sbin/cronolog /usr/<span class="built_in">local</span>/tomcat/logs/catalina.%Y%m%d.out &gt;&gt; /dev/null &amp;</span><br><span class="line"><span class="comment">#      &gt;&gt; "$CATALINA_OUT" 2&gt;&amp;1 &amp;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>重启tomcat<br>查看日志目录是否生成catalina.yymmdd.out的日志文件</li>
</ol>
<p>-rw-r–r– 1 root root 10537 Jul 30 10:50 catalina.20140730.out</p>
<p>配置cronolog完成了，观察每天是否有一个新的catalina.yymmdd.out的日志文件生成，定期删除日期较旧的日志文件。</p>
<h1 id="方法二、使用log4j成功使catalina-out文件实现分割"><a href="#方法二、使用log4j成功使catalina-out文件实现分割" class="headerlink" title="方法二、使用log4j成功使catalina.out文件实现分割"></a>方法二、使用log4j成功使catalina.out文件实现分割</h1><p>　　1、在tomcat根目录下建立common/classes/log4j.properties，内容如下<br>复制代码<br>log4j.rootLogger=INFO, R<br>log4j.appender.R=org.apache.log4j.RollingFileAppender<br>log4j.appender.R.File=${catalina.home}/logs/tomcat.newlog  #设定日志文件名<br>log4j.appender.R.MaxFileSize=100KB   #设定文件到100kb即分割<br>log4j.appender.R.MaxBackupIndex=10   #设定日志文件保留的序号数<br>log4j.appender.R.layout=org.apache.log4j.PatternLayout<br>log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n<br>复制代码<br>　　2、在tomcat根目录下的common/lib下加入log4j.jar和commons-logging.jar<br>　　3、重新启动tomcat即可。</p>
<h1 id="方法三、使用系统crontab"><a href="#方法三、使用系统crontab" class="headerlink" title="方法三、使用系统crontab"></a>方法三、使用系统crontab</h1><ol>
<li>编写一个crontab_log_work.sh文件,shell脚本如下:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>  `dirname <span class="variable">$0</span>`</span><br><span class="line">d=`date +%Y%m%d`</span><br><span class="line">d7=`date -d<span class="string">'7 day ago'</span> +%Y%m%d`</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>  ../logs/</span><br><span class="line"></span><br><span class="line">cp catalina.out catalina.out.<span class="variable">$&#123;d&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; catalina.out </span><br><span class="line">rm -rf catalina.out.<span class="variable">$&#123;d7&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>编写任务执行计划 crontab_log<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55 23 * * * crontab_log_work.sh</span><br></pre></td></tr></table></figure></li>
<li>使用crontab 启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab crontab_log</span><br></pre></td></tr></table></figure>






</li>
</ol>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>003-shell-crontab定时任务</title>
    <url>/articles/20200208/a16096f7.html</url>
    <content><![CDATA[<p>摘要：有时需要操作系统统，定时做一些任务，解决一些问题。<br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>说明：</p>
<ol>
<li>Linux和Mac下操作crontab都是一致的</li>
<li>配置文件都在/etc/crontab下，如果没有就创建。默认系统级别存在，不需要额外安装定时任务</li>
<li>测试直接使用crontab -e命令创建的定时任务是放在临时文件夹的，重启会删除，并且与/etc/crontab文件无关联。</li>
</ol>
<h2 id="crontab服务的重启关闭，开启"><a href="#crontab服务的重启关闭，开启" class="headerlink" title="crontab服务的重启关闭，开启"></a>crontab服务的重启关闭，开启</h2><p>系统级别，是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。所以下述命令不可用。</p>
<ul>
<li>Mac系统下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/cron start</span><br><span class="line">sudo /usr/sbin/cron restart</span><br><span class="line">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure></li>
<li>Ubuntu<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/cron start</span><br><span class="line">sudo /etc/init.d/cron stop</span><br><span class="line">sudo /etc/init.d/cron restart</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看定时任务：<code>crontab -l</code><br>列出用户test的所有调度任务:<code>crontab -l -u test</code><br>删除所有调度任务：<code>crontab -r</code></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li><p>方式一、系统级别-/etc/crontab 方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/crontab</span><br><span class="line">*/1 * * * * root /bin/date &gt;&gt; /tmp/time2.txt</span><br></pre></td></tr></table></figure>
<p>保存使用：<code>:wq!</code>；默认超管只读权限，需要强制保存退出</p>
</li>
<li><p>方式二、用户级别-crontab -e 自定义脚本启动</p>
</li>
</ul>
<ol>
<li>执行脚本编写<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每分钟执行一次date命令，输出时间到time.txt文本</span></span><br><span class="line">*/1 * * * * /bin/date &gt;&gt; /tmp/time.txt</span><br></pre></td></tr></table></figure></li>
<li>crontab命令调用crontab文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab testing_crontab</span><br></pre></td></tr></table></figure></li>
<li>查看 文件内容<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f  /tmp/time.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="etc-crontab文件和crontab-e命令区别"><a href="#etc-crontab文件和crontab-e命令区别" class="headerlink" title="/etc/crontab文件和crontab -e命令区别"></a>/etc/crontab文件和crontab -e命令区别</h2><ol>
<li>修改/etc/crontab这种方法只有root用户能用，这种方法更加方便与直接直接给其他用户设置计划任务，而且还可以指定执行shell等等，crontab -e这种所有用户都可以使用，普通用户也只能为自己设置计划任务。然后自动写入/var/spool/cron/usename</li>
<li>crontab -e是某个用户的周期计划任务；/etc/crontab是系统的周期任务</li>
<li>crontab -e与/etc/crontab修改语法格式不一样，后者多一个user指定</li>
<li>不管用crontab -e或者/etc/crontab都不需要重新启动crond服务</li>
<li>crontab  -e是针对用户的cron来设计的，如果是系统的例行性任务，需要编辑/etc/crontab文件。需要注意的是：crontab -e的作用其实是/usr/bin/crontab这个执行文件，但是/etc/crontab是个纯文本文件，可以root的身份编辑这个文件。</li>
<li>cron服务的最低检测时间单位是分钟，所以cron会每分钟读取一次/etc/crontab与/var/spool/cron中的数据内容，因此，只要您编辑完/etc/crontab文件并且保存之后，crontab时设定就会自动执行。</li>
</ol>
<p>注意：在Linux下的crontab会自动帮我们每分钟重新读取一次/etc/crontab的例行工作事项，但是某些原因或在其他的unix系统中，由于crontab是读到内存中，所以在您修改完/etc/crontab之后可能并不会马上执行，这时请重新启动crond服务。</p>
<p>/et</p>
<h1 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file [-u user] [ -e | -l | -r ]</span><br><span class="line">*   -u user：用来设定某个用户的crontab服务；</span><br><span class="line">*   file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">*   -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">*   -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">*   -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">*   -i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<h1 id="cron语法"><a href="#cron语法" class="headerlink" title="cron语法"></a>cron语法</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>分钟 小时 日期 月份 周 命令<br>如：数字范围 0-59 0-23 1-31 1-12 0-7 echo “hello” &gt;&gt; abc.log  </p>
<figure class="highlight plain"><figcaption><span>特殊字符的含义</span></figcaption><table><tr><td class="code"><pre><span class="line">*(星号) 代表任何时刻都接受。</span><br><span class="line">,(逗号) 代表分隔时段的意思。</span><br><span class="line">-(减号) 代表一段时间范围内。</span><br><span class="line">&#x2F;n(斜线) 那个 n 代表数字，每隔 n 单位间隔。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>每年的五月一日 10:5 执行一次：<code>5 10 1 5 * command（要是执行网址（curl &quot;http://网址&quot;），或者执行其它的直接写路径）</code></li>
<li>每天的三点，六点各执行一次：<code>00 3,6 * * * command</code></li>
<li>每天的8:20, 9:20,10:20,11:20各执行一次：<code>20 8-11 * * * command</code></li>
<li>每五分钟执行一次：<code>*/5 * * * * command</code></li>
<li>每周一十点执行一次：<code>00 10 * * 1 command</code></li>
<li>每天 02:00 执行任务：<code>0 2 * * * /bin/sh backup.sh</code></li>
<li>每天 5:00和17:00执行任务：<code>0 5,17 * * * /scripts/script.sh</code></li>
<li>每分钟执行一次任务：<code>* * * * * /scripts/script.sh</code></li>
<li>每周日 17:00 执行任务：<code>0 17 * * sun /scripts/script.sh</code></li>
<li>每 10min 执行一次任务：<code>*/10 * * * * /scripts/monitor.sh</code></li>
<li>在特定的某几个月执行任务：<code>* * * jan,may,aug * /script/script.sh</code></li>
<li>在特定的某几天执行任务：<code>0 17 * * sun,fri /script/scripy.sh（在每周五、周日的17点执行任务）</code></li>
<li>在某个月的第一个周日执行任务：<code>0 2 * * sun [ $(date +%d) -le 07 ] &amp;&amp; /script/script.sh</code></li>
<li>每四个小时执行一个任务：<code>0 */4 * * * /scripts/script.sh</code></li>
<li>每周一、周日执行任务：<code>0 4,17 * * sun,mon /scripts/script.sh</code></li>
<li>每个30秒执行一次任务：我们没有办法直接通过上诉类似的例子去执行，因为最小的是1min。但是我们可以通过如下的方法。<br><code>* * * * * /scripts/script.sh</code><br><code>* * * * * sleep 30; /scripts/script.sh</code></li>
<li>多个任务在一条命令中配置<br><code>* * * * * /scripts/script.sh; /scripts/scrit2.sh</code></li>
<li>每年执行一次任务<br><code>@yearly /scripts/script.sh</code><br>@yearly 类似于“0 0 1 1 *”。它会在每年的第一分钟内执行，通常我们可以用这个发送新年的问候。</li>
<li>系统重启时执行：<code>@reboot /scripts/script.sh</code></li>
</ul>
<h1 id="清除日志命令"><a href="#清除日志命令" class="headerlink" title="清除日志命令"></a>清除日志命令</h1><p>主要目标：每日凌晨前10分钟，将catalina.out日志，copy重命名 catalina.out-2020-02-08.log，清空服务器上的catalina.out日志，</p>
<p>编译一个shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>002-tools-mac-vscode</title>
    <url>/articles/20200208/6d6ffdd4.html</url>
    <content><![CDATA[<p>概述:mac下基础操作</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><p>支持：JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity).</p>
<h2 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载 安装"></a>下载 安装</h2><ol>
<li>下载地址<br><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></li>
</ol>
<p>下载后直接运行</p>
<h2 id="界面操作说明"><a href="#界面操作说明" class="headerlink" title="界面操作说明"></a>界面操作说明</h2><h3 id="界面展示语言设置"><a href="#界面展示语言设置" class="headerlink" title="界面展示语言设置"></a>界面展示语言设置</h3><p>command + shift + p，配置语言 或者 Configure Language，选择后会打开 locale.json 文件,【版本不一样其他类似】</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"locale"</span>:<span class="string">"zh-CN"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>界面说明<br>顶部：工具栏<br>最左侧：快捷工具栏【资源管理器、搜索、git、调试、扩展工具】</li>
<li>关闭更新<br>并将联机社会组中部分关闭</li>
</ol>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ &#96; ：调取和关闭终端</span><br><span class="line">⌘ + 、 ⌘ + ：很容易的实现整个页面所有字体大小</span><br><span class="line">⌥ ⇧ F：格式化文件快捷键</span><br></pre></td></tr></table></figure>

<h2 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h2><p>点击 左侧 打开git 操作窗，列表中即文件变化,输入框可以输入 commit message，上面 对号 是提交 </p>
<ol>
<li>界面说明<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左下角，分支选择</span><br><span class="line">顶部 操作</span><br><span class="line">省略号  是 git更多操作</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="markdown-支持"><a href="#markdown-支持" class="headerlink" title="markdown 支持"></a>markdown 支持</h2><p>  vscode 在没有安装任何插件的情况下是可以直接编写markdown文档的，以及 可以预览</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>001-tools-mac-sublime text3</title>
    <url>/articles/20200208/6c7c66a.html</url>
    <content><![CDATA[<p>概述:mac下基础操作</p>
<a id="more"></a>
<h1 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h1><h2 id="停止更新提示："><a href="#停止更新提示：" class="headerlink" title="停止更新提示："></a>停止更新提示：</h2><ol>
<li>preferences→setting→增加如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;font_size&quot;: 17,</span><br><span class="line">    &quot;update_check&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意：一定要在每一行结束加逗号</li>
</ol>
<h2 id="插件安装包"><a href="#插件安装包" class="headerlink" title="插件安装包"></a>插件安装包</h2><h3 id="安装-Package-Control"><a href="#安装-Package-Control" class="headerlink" title="安装 Package Control"></a>安装 Package Control</h3><ol>
<li>安装</li>
</ol>
<ul>
<li>方式一、在线安装<br>Mac: cmd+shift+p<br>输入;Install Package Control, 按 enter</li>
<li>方式二、离线安装<br>下载：<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a> 下载 ： Package Control.sublime-package 即可</li>
</ul>
<p>Mac位置:/Users/用户名/Library/Application Support/Sublime Text 3/Installed Packages</p>
<ol start="2">
<li>使用<br>重启Sublime3,如果菜单-&gt;Preferences有Package Setting和Package Control就说明安装成功。</li>
</ol>
<p>Ctrl+Shift+p输入install选中Install Package回车就可以安装插件。</p>
<p>一般有些慢，可以在 菜单-&gt;Preferences有Package Setting 的setting user增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;debug&quot;: true,</span><br><span class="line">&quot;downloader_precedence&quot;:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;linux&quot;:[&quot;curl&quot;,&quot;urllib&quot;,&quot;wget&quot;],</span><br><span class="line">	&quot;osx&quot;:[&quot;curl&quot;,&quot;urllib&quot;],</span><br><span class="line">	&quot;windows&quot;:[&quot;wininet&quot;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="安装markdown-相关"><a href="#安装markdown-相关" class="headerlink" title="安装markdown 相关"></a>安装markdown 相关</h3><ol>
<li>安装预览：cmd+ shift + p,输入 install package，注意看左下角在加载，完毕后 出现输出框，输入 markdown preview 查找合适即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>

<p>markdown edit,preview</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>003-mysql-基础操作-常用数据类型</title>
    <url>/articles/20200205/93944b35.html</url>
    <content><![CDATA[<p>摘要：mysql 常用数据类型:数值类型、字符串类型、日期类型</p>
<a id="more"></a>

<p>更多：<a href="https://www.cnblogs.com/bjlhx/category/998292.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/998292.html</a></p>
<h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><p>MySQL中支持5种整数类型，其实很大程度上相同的，只是存储值的大小范围不同而已。其次是浮点类型float和double类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tinyint：占用1个字节，相对于java中的byte</span><br><span class="line">smallint：占用2个字节，相对于java中的short</span><br><span class="line">int：占用4个字节，相对于java中的int【推荐直接使用这个，已于扩展，降低转换】</span><br><span class="line">bigint：占用8个字节，相对于java中的long【自增主键推荐使用】</span><br><span class="line">float：4字节单精度浮点类型，相对于java中的float</span><br><span class="line">double：8字节双精度浮点类型，相对于java中的double</span><br></pre></td></tr></table></figure>
<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char()------定长字符串，最长255个字符。定长会浪费空间</span><br><span class="line">varchar()----变长(不定长)字符串，最长不超过 65535个字节,一般超过255个字节，会使用text类型. 不定长节省空间,剩余空间会留给别的数据使用</span><br><span class="line">text--------长文本类型,最长65535个字节</span><br></pre></td></tr></table></figure>

<h2 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h2><ul>
<li>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</li>
<li>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</li>
<li>VARCHAR存储的内容超出设置的长度时，内容会被截断。</li>
</ul>
<h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><ul>
<li>CHAR是定长的，根据定义的字符串长度分配足够的空间。</li>
<li>CHAR会根据需要使用空格进行填充方便比较。</li>
<li>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</li>
<li>CHAR存储的内容超出设置的长度时，内容同样会被截断。</li>
</ul>
<h2 id="使用策略："><a href="#使用策略：" class="headerlink" title="使用策略："></a>使用策略：</h2><ul>
<li>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。</li>
<li>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</li>
<li>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</li>
<li>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</li>
</ul>
<h2 id="总结：-char、varchar、text都可以表示字符串类型，其区别在于："><a href="#总结：-char、varchar、text都可以表示字符串类型，其区别在于：" class="headerlink" title="总结： char、varchar、text都可以表示字符串类型，其区别在于："></a>总结： char、varchar、text都可以表示字符串类型，其区别在于：</h2><ol>
<li>char在保存数据时, 如果存入的字符串长度小于指定的长度n,后面会用空格补全。</li>
<li>varchar和text保存数据时, 按数据的真实长度存储, 剩余的空间可以留给别的数据用.</li>
<li>char会造成空间浪费(不足指定长度的会用空格补全), 但是由于不需要计算数据的长度, 因此速度更快。（即浪费空间、节约时间）</li>
<li>varchar和text但是节省了空间, 但是存储的速度不如char快(因为要计算数据的实际长度)</li>
</ol>
<h1 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date：年月日</span><br><span class="line">time：时分秒</span><br><span class="line">datetime：年月日 时分秒</span><br><span class="line">	5.6后：使用：DEFAULT NOW()、DEFAULT CURRENT_TIMESTAMP设置</span><br><span class="line">timestamp：时间戳，与datetime存储相同的数据。</span><br><span class="line">	1、插入记录时，时间戳字段包含DEFAULT CURRENT_TIMESTAMP，如插入记录时未指定具体时间数据则将该时间戳字段值设置为当前时间</span><br><span class="line">  	2、更新记录时，时间戳字段包含ON UPDATE CURRENT_TIMESTAMP，如更新记录时未指定具体时间数据则将该时间戳字段值设置为当前时间</span><br><span class="line">	CURRENT_TIMESTAMP表示使用CURRENT_TIMESTAMP()函数来获取当前时间，类似于NOW()函数</span><br></pre></td></tr></table></figure>
<h2 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日期类型         存储空间       日期格式                                      日期范围</span><br><span class="line">datetime		8 bytes   YYYY-MM-DD HH:MM:SS   1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</span><br><span class="line">timestamp		4 bytes   YYYY-MM-DD HH:MM:SS   1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</span><br><span class="line">date			3 bytes   YYYY-MM-DD            1000-01-01 ~ 9999-12-31</span><br></pre></td></tr></table></figure>

<h3 id="datetime和timestamp的区别用法："><a href="#datetime和timestamp的区别用法：" class="headerlink" title="datetime和timestamp的区别用法："></a>datetime和timestamp的区别用法：</h3><p>1.datetime 的日期范围比较大；如果有1970年以前的数据还是要用datetime.但是timestamp 所占存储空间比较小。(节省空间)<br>2.timestamp 类型的列还有个特性：默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新。(可设置)<br>3.timestamp比较受时区timezone的影响以及MYSQL版本和服务器的SQL MODE的影响.</p>
<p>使用一个常用的格式集的任何一个，你可以指定DATETIME、DATE和TIMESTAMP值：<br>‘YYYY-MM-DD HH:MM:SS’或’YY-MM-DD HH:MM:SS’格式的一个字符串,允许一种”宽松”的语法:任何标点可用作在日期部分和时间部分之间的分隔符。例如，’98-12-31 11:30:45’、’98.12.31 11+30+45’、’98/12/31 11<em>30</em>45’和‘98@12@31 11^30^45’是等价的。</p>
<ul>
<li>timestamp最大表示2038年，而datetime范围是1000~9999</li>
<li>timestamp在插入数、修改数据时，可以自动更新成系统当前时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  在创建新记录和修改现有记录的时候都对这个数据列刷新。</span><br><span class="line">TIMESTAMP DEFAULT CURRENT_TIMESTAMP  在创建新记录的时候把这个字段设置为当前时间，但以后修改时，不再刷新它。</span><br><span class="line">TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  在创建新记录的时候把这个字段设置为0，以后修改时刷新它。</span><br><span class="line">TIMESTAMP DEFAULT ‘yyyy-mm-dd hh:mm:ss’ ON UPDATE CURRENT_TIMESTAMP  在创建新记录的时候把这个字段设置为给定值，以后修改时刷新它</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>002-mysql-基础操作-连接、库表操作、字段</title>
    <url>/articles/20200205/8d83348a.html</url>
    <content><![CDATA[<p>摘要：mysql 库表操作</p>
<a id="more"></a>

<p>其他：<a href="https://www.cnblogs.com/bjlhx/category/998292.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/998292.html</a></p>
<h1 id="连接登录"><a href="#连接登录" class="headerlink" title="连接登录"></a>连接登录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 帮助</span></span><br><span class="line">mysql -?</span><br><span class="line"><span class="comment"># 常用参数</span></span><br><span class="line"><span class="comment"># -h 表示服务器名字。localhost表示本地 可以省略</span></span><br><span class="line"><span class="comment"># -P 端口</span></span><br><span class="line"><span class="comment"># -u 表示用户名</span></span><br><span class="line"><span class="comment"># -p 表示密码。直接在-p后面输入密码即可，中间不能有空格。 新版本不能指定，需要手工输入</span></span><br><span class="line"><span class="comment"># -D 指定数据库，权限不够时。</span></span><br></pre></td></tr></table></figure>
<p>连接 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p123456</span><br></pre></td></tr></table></figure>
<p>进入后，语句以 ; 结尾</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul>
<li>查看所有数据库: <code>show databases;</code></li>
<li>进入数据库: <code>use 库名;</code></li>
<li>查看数据库使用端口:<code>show variables like &#39;port&#39;;</code></li>
<li>数据库编码:<code>show variables like &#39;character%&#39;;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">character_set_client      为客户端编码方式；</span><br><span class="line">character_set_connection  为建立连接使用的编码；</span><br><span class="line">character_set_database    为数据库的编码；</span><br><span class="line">character_set_results     为结果集的编码；</span><br><span class="line">character_set_server      为数据库服务器的编码；</span><br></pre></td></tr></table></figure></li>
<li>查看数据库最大连接数:<code>show variables like &#39;%max_connections%&#39;;</code></li>
<li>查看数据库当前连接数，并发数:<code>show status like &#39;Threads%&#39;;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Threads_cached : 代表当前此时此刻线程缓存中有多少空闲线程。</span><br><span class="line">Threads_connected :代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。</span><br><span class="line">Threads_created :代表从最近一次服务启动，已创建线程的数量。</span><br><span class="line">Threads_running :代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态，这里相对应的线程也是sleep状态。</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><ul>
<li>查看正在使用的数据库：<code>select database();</code></li>
<li>查看库中所有的表: <code>show tables;</code></li>
<li>查看表结构: <code>desc/describe 表名</code>;或：<code>show columns from table_name [from database_name];</code></li>
<li>查看表-列结构: <code>desc/describe 表名 列名;</code></li>
<li>查看表生成的DDL sql语句:<code>show create table tname;</code></li>
<li>查看库表信息：<code>SHOW TABLE STATUS [{FROM | IN} db_name] [LIKE &#39;pattern&#39; | WHERE expr]</code><figure class="highlight plain"><figcaption><span>字段含义</span></figcaption><table><tr><td class="code"><pre><span class="line">返回列	说明</span><br><span class="line">Name	表名称</span><br><span class="line">Engine	表的存储引擎</span><br><span class="line">Version	版本</span><br><span class="line">Row_format	行格式</span><br><span class="line">Rows	表中的行数。对于非事务性表，这个值是精确的，对于事务性引擎，这个值通常是估算的。</span><br><span class="line">Avg_row_length	平均每行的大下（字节）</span><br><span class="line">Data_length	表的数据量(单位：字节)</span><br><span class="line">Max_data_length	表可以容纳的最大数据量</span><br><span class="line">Index_length	索引占用磁盘的空间大小</span><br><span class="line">Data_free	标识已分配，但现在未使用的空间，并且包含了已被删除行的空间。</span><br><span class="line">Auto_increment	下一个Auto_increment的值</span><br><span class="line">Create_time	表的创建时间</span><br><span class="line">Update_time	表的最近更新时间</span><br><span class="line">Check_time	最近一次使用 check table 或myisamchk工具检查表的时间</span><br><span class="line">Collation	表的字符集和字符排序规则</span><br><span class="line">Checksum	如果启用，则对整个表的内容计算时的校验和</span><br><span class="line">Create_options	表创建时的其它</span><br><span class="line">Comment	表在创建是添加的注释说明</span><br></pre></td></tr></table></figure>
或者 <code>select * from information_schema.tables where TABLE_SCHEMA=&#39;库名&#39;</code></li>
</ul>
<h2 id="库、表"><a href="#库、表" class="headerlink" title="库、表"></a>库、表</h2><ul>
<li>显示数据库状态：<code>status;</code></li>
<li>退出/断开连接:<code>exit;或quit;或 \q;或ctrl+c;</code></li>
</ul>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p>字符集： 1.若没有显式设置，则自动使用服务器级的配置 ； 2.显式设置：在创建库时指定 ，如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span>  <span class="keyword">exists</span>  库名 <span class="keyword">default</span> <span class="keyword">charset</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
<p>查看 库信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.schemata <span class="keyword">where</span> schema_name = <span class="string">'test_sql'</span>; </span><br><span class="line"><span class="comment">-- def	test_sql	utf8	utf8_general_ci</span></span><br></pre></td></tr></table></figure>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><p>创建表时, 除了要给每个列指定对应的数据类型, 有时也需要给列添加约束。常见的约束有：主键约束、唯一约束、非空约束、外键约束。</p>
<h4 id="主键-primary-key-【主键索引，聚集索引】"><a href="#主键-primary-key-【主键索引，聚集索引】" class="headerlink" title="主键(primary key)【主键索引，聚集索引】"></a>主键(primary key)【主键索引，聚集索引】</h4><p>主键是数据表中，一行记录的唯一标识。比如学生的编号，人的身份证号;<br>当主键为数值时，为了方便维护，可以设置主键为自增（auto_increment）</p>
<h4 id="唯一-unique"><a href="#唯一-unique" class="headerlink" title="唯一(unique)"></a>唯一(unique)</h4><p>保证所约束的列必须是唯一的，即不能重复出现，例如：用户注册时，保存的用户名不可以重复。</p>
<blockquote>
<ul>
<li>约束 全称完整性约束，它是关系数据库中的对象，用来存放插入到一个表中一列数据的规则，用来确保数据的准确性和一致性。</li>
<li>索引 数据库中用的最频繁的操作是数据查询，索引就是为了加速表中数据行的检索而创建的一种分散的数据结构。可以把索引类比成书的目录，有目录的肯定比没有目录的书，更方便查找。</li>
<li>唯一约束 保证在一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一约束允许为 NULL，只是只能有一行。</li>
<li>唯一索引 不允许具有索引值相同的行，从而禁止重复的索引或键值。</li>
</ul>
</blockquote>
<p>在mysql 中唯一约束 与 唯一索引 一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 唯一约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> AUTO_INCREMENT  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> <span class="keyword">comment</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> AUTO_INCREMENT  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">TABLE</span>  <span class="string">`t2`</span>  <span class="keyword">ADD</span>  <span class="keyword">UNIQUE</span> (<span class="string">`username`</span> ) ;</span><br></pre></td></tr></table></figure>
<p>查看 ddl t1,t2均为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'非空约束'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'默认为空'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`username`</span> (<span class="string">`username`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</span><br></pre></td></tr></table></figure>

<h4 id="非空-not-null"><a href="#非空-not-null" class="headerlink" title="非空(not null)"></a>非空(not null)</h4><p>保证所约束的列必须是不为空的，即在插入记录时，该列必须要赋值，例如：用户注册时，保存的密码不能为空。<br>创建user表, 指定密码不能为空</p>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>外键是用于表和表之间关系的列</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increament  <span class="keyword">COMMENT</span> <span class="string">'主键约束'</span>,</span><br><span class="line">	username <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span> <span class="keyword">comment</span> <span class="string">'唯一约束'</span>,</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'非空约束'</span>,</span><br><span class="line">	address <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'默认为空'</span>,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 库名;</span><br></pre></td></tr></table></figure>

<h2 id="表、字段操作"><a href="#表、字段操作" class="headerlink" title="表、字段操作"></a>表、字段操作</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><ol>
<li>是否需要删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li>创建【推荐】<br>create table 表名 (字段设定列表) default charset=utf8 default collate=utf8_bin; <ul>
<li>字符集：1.若没有显式设置，则自动使用数据库级的配置 ；2.显式设置：在创建表时指定 </li>
<li>字段列表类型：查看下文</li>
<li>成功后，可以使用<code>desc 表名</code>或<code>show create table 表名</code>查看</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>(</span><br><span class="line">   <span class="string">`user_id`</span> <span class="built_in">INT</span>(<span class="number">20</span>) AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`user_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`user_age`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`regist_date`</span> <span class="built_in">DATE</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`user_id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span>=utf8_unicode_ci  <span class="keyword">COMMENT</span> <span class="string">'用户信息表'</span>;</span><br></pre></td></tr></table></figure>


<h3 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure>

<h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> [<span class="keyword">TO</span>|<span class="keyword">AS</span>] 新表名;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure>

<h3 id="表字段操作"><a href="#表字段操作" class="headerlink" title="表字段操作"></a>表字段操作</h3><h4 id="改表-加字段"><a href="#改表-加字段" class="headerlink" title="改表-加字段"></a>改表-加字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">COLUMN</span> new_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="改表-删段名"><a href="#改表-删段名" class="headerlink" title="改表-删段名"></a>改表-删段名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">drop</span> <span class="keyword">column</span> old_name;</span><br></pre></td></tr></table></figure>

<h4 id="改表-改字段名"><a href="#改表-改字段名" class="headerlink" title="改表-改字段名"></a>改表-改字段名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">change</span> <span class="keyword">column</span> old_name new_name <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">comment</span> <span class="string">'注释'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="改表-改字段类型或大小"><a href="#改表-改字段类型或大小" class="headerlink" title="改表-改字段类型或大小"></a>改表-改字段类型或大小</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">modify</span> <span class="keyword">column</span> column1  <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'注释'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>参看：<a href="https://www.cnblogs.com/bjlhx/p/11953939.html" target="_blank" rel="noopener">012-MySQL 索引添加以及优化说明</a></p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>001-mysql-主键设计</title>
    <url>/articles/20200205/dd81f687.html</url>
    <content><![CDATA[<p>摘要：MySQL InnoDB数据存储是以B+树索引方式存储<br>存储单元、mysql InnoDB-B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>

<h1 id="mysql知识储备"><a href="#mysql知识储备" class="headerlink" title="mysql知识储备"></a>mysql知识储备</h1><p>参看：<a href="http://blog.bjlhx.top/categories/db-mysql-core/">http://blog.bjlhx.top/categories/db-mysql-core/</a></p>
<ol>
<li>InnoDB为聚集主键类型的引擎，数据会按照主键进行排序</li>
<li>mysql 的索引是B+tree，聚集索引使用主键，没有主键默认生成一个隐式主键rowId，辅助索引保存的是主键</li>
<li>innodb 存储单元是页，每页 16k，数据类型过大，会跨页，溢出等</li>
<li>每张表都会有主键，如没有显式设置主键，则<br>（1）、表中的非空唯一索引作为主键<br>（2）、自动创建一个6字节大小的指针</li>
</ol>
<h1 id="主键定义"><a href="#主键定义" class="headerlink" title="主键定义"></a>主键定义</h1><p>表中经常有一个列或多列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。</p>
<h1 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h1><p>总原则：根据数据库表的具体使用范围来决定采用不同的表主键定义。</p>
<p>数据库设计的三大范式</p>
<ul>
<li><p>第一范式（1NF）：指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。<br>即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。</p>
</li>
<li><p>第二范式（2NF）：首先要满足它是1NF，另外还需要包含两部分内容：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。简而言之，第二范式就是非主属性非部分依赖于主关键字</p>
</li>
<li><p>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p>
</li>
</ul>
<p>反范式主键的设计原则</p>
<ul>
<li>主键应当是对用户没有意义的。业务上的‘主键’可以通过唯一键（Unique Key）或唯一索引（Unique Index）和其它约束条件实现</li>
<li>主键应该是单列的，以便提高连接和筛选操作的效率</li>
<li>不要更新主键。实际上，因为主键除了惟一地标识一行之外再没有其他的用途了，所以也就没有理由去对它更新。另外，主键的值通常不重用，意味着记录被删除后，该主键值不再使用</li>
<li>主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等</li>
<li>主键应当由计算机自动生成。</li>
</ul>
<p>反范式跟范式所要求的正好相反，在反范式的设计模式，可以允许适当的数据的冗余，用这个冗余去取操作数据时间的缩短。<br>本质上就是用空间来换取时间，把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联（手册中也有禁止三表以上 JOIN 的条款）。</p>
<p>但需要注意的是，采用代理主键是为了避免业务逻辑变化导致主键变更，以及提高 JOIN 效率等。但在实际查询中，数据查询还是需要通过业务上的唯一键进行匹配的，<br>而不应该将代理主键作为查询条件，尤其不能将代理主键作为查询条件输入项提供给用户。</p>
<p>总体来说，实际应用中应当具体问题具体分析，结合范式和反范式两种设计思想。<br>对数据一致性和完整性较高、而对查询效率要求并不严格的地方，应当更倾向于遵从范式；而类似分布式、高并发集群的场景，则应当更考虑反范式的设计方案。</p>
<h2 id="确保主键的无意义性"><a href="#确保主键的无意义性" class="headerlink" title="确保主键的无意义性"></a>确保主键的无意义性</h2><p>在开发过程中，有意义的字段例如“用户登录信息表”将“登录名”（英文名）作为主键，“订单表”中将“订单编号”作为主键，如此设计主键一般都是没什么问题，因为将这些主键基本不具有“意义更改”的可能性。</p>
<p>但是，也有一些例外的情况，例如“订单表”需要支持需求“订单可以作废，并重新生成订单，而且订单号要保持原订单号一致”，那将“订单编号”作为主键就满足不了要求了。</p>
<p>因此在使用具有实际意义的字段作为主键时，需要考虑是否存在这种可能性。</p>
<p>要用代理主键，不要使用业务主键。任何一张表，强烈建议不要使用有业务含义的字段充当主键。我们通常都是在表中单独添加一个整型的编号充当主键字段。</p>
<h2 id="采用整型主键"><a href="#采用整型主键" class="headerlink" title="采用整型主键"></a>采用整型主键</h2><p>主键通常都是整数，不建议使用字符串当主键。（如果主键是用于集群式服务，可以采用字符串类型）</p>
<h2 id="减少主键的变动"><a href="#减少主键的变动" class="headerlink" title="减少主键的变动"></a>减少主键的变动</h2><p>主键的值通常都不允许修改，除非本记录被删除。</p>
<h2 id="避免重复使用主键"><a href="#避免重复使用主键" class="headerlink" title="避免重复使用主键"></a>避免重复使用主键</h2><p>主键的值通常不重用，意味着记录被删除后，该主键值不再使用。</p>
<h2 id="主键字段定义区分"><a href="#主键字段定义区分" class="headerlink" title="主键字段定义区分"></a>主键字段定义区分</h2><p>主键不要直接定义成【id】，而要加上前缀，定义成【表名id】或者【表名_id】</p>
<h1 id="主键设计的常用方案"><a href="#主键设计的常用方案" class="headerlink" title="主键设计的常用方案"></a>主键设计的常用方案</h1><h2 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h2><ul>
<li><p>方案：数据库设置：AUTO_INCREMENT</p>
</li>
<li><p>使用场景：不拆分库的情况下，推荐使用</p>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利。</li>
<li>数字型，占用空间小，易排序，在程序中传递方便。<br>同样数据量的情况下，自增id主键的数据量是字符串主键的1/2，对于考虑成本的公司来说无疑是一件好事，并且数据量小对备份还原数据都有大大的好处。</li>
<li>Mysql会按照键值的大小进行顺序存放，如果设置自增id为主键，这个时候主键是按照一种紧凑的接近顺序写入的方式进行存储数据。<br>如果用其他字段作为主键的话，此时Mysql不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，<br>此时又要从磁盘上读回来，这增加了很多额外的开销，同时频繁的移动、分页操作造成了大量的碎片。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>不支持水平分片架构，水平分片的设计当中，这种方法显然不能保证全局唯一。</li>
<li>表锁<br>在MySQL5.1.22之前，InnoDB自增值是通过其本身的自增长计数器来获取值，该实现方式是通过表锁机制来完成的（AUTO-INC LOCKING）。<br>锁不是在每次事务完成后释放，而是在完成对自增长值插入的SQL语句后释放，要等待其释放才能进行后续操作。<br>比如说当表里有一个auto_increment字段的时候，innoDB会在内存里保存一个计数器用来记录auto_increment的值，当插入一个新行数据时，<br>就会用一个表锁来锁住这个计数器，直到插入结束。如果大量的并发插入，表锁会引起SQL堵塞。<br>在5.1.22之后，InnoDB为了解决自增主键锁表的问题，引入了参数innodb_autoinc_lock_mode：<br>0：通过表锁的方式进行，也就是所有类型的insert都用AUTO-inc locking（表锁机制）。<br>1：默认值，对于simple insert 自增长值的产生使用互斥量对内存中的计数器进行累加操作，对于bulk insert 则还是使用表锁的方式进行。<br>2：对所有的insert-like 自增长值的产生使用互斥量机制完成，性能最高，并发插入可能导致自增值不连续，可能会导致Statement 的 Replication 出现不一致，使用该模式，需要用 Row Replication的模式。</li>
<li>可能不连续</li>
<li>当系统与其他系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突。</li>
<li>如果其他系统主键不是数字型，会导致修改主键数据类型，导致其他相关表的修改。</li>
</ol>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。在UUID的算法中，可能会用到诸如网卡MAC地址，IP，主机名，进程ID等信息以保证其独立性。</p>
<ul>
<li><p>方案：mysql uuid()函数，应用程序UUID函数</p>
</li>
<li><p>使用场景：不推荐使用，针对mysql缺点过于严重</p>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li>全局唯一性、安全性、可移植性。</li>
<li>能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响。</li>
<li>保证生成的ID不仅是表独立的，而且是库独立的，在你切分数据库的时候尤为重要</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>针对InnoDB引擎会徒增IO压力，InnoDB为聚集主键类型的引擎，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力。InnoDB主键索引和数据存储位置相关（簇类索引），uuid 主键可能会引起数据位置频繁变动，严重影响性能。</li>
<li>UUID长度过长，一个UUID占用128个比特（16个字节）。主键索引KeyLength长度过大，而影响能够基于内存的索引记录数量，进而影响基于内存的索引命中率，而基于硬盘进行索引查询性能很差。严重影响数据库服务器整体的性能表现。</li>
</ol>
<h2 id="自建的id生成器"><a href="#自建的id生成器" class="headerlink" title="自建的id生成器"></a>自建的id生成器</h2><p>当数据量比较大，又是分布式架构的时候，可能需要考虑各种分库分表方案了。<br>自建id生成器，可以保证全局唯一，可以参考snowflake的算法（18位）方案，具体实施也可以根据自身业务进行调整算法。其次需要考虑的就是服务的高可用。</p>
<h2 id="业务编号做主键"><a href="#业务编号做主键" class="headerlink" title="业务编号做主键"></a>业务编号做主键</h2><ul>
<li><p>优点<br>此方法就是采用实际业务中的唯一字段的“编号”作为主键设计，这在小型的项目中是推荐这样做的，因为这可以使项目比较简单化，</p>
</li>
<li><p>缺点：<br>但在使用中却可能带来一些麻烦，比如要进行编号修改”时，可能要涉及到很多相关联的其他表，后果很严重”;或“业务要求允许编号重复时”</p>
</li>
</ul>
<h2 id="max加1"><a href="#max加1" class="headerlink" title="max加1"></a>max加1</h2><ul>
<li><p>优点：<br>由于自动编号存在那些问题，采用自己生成，同样是数字型的，只是把自动增长去掉了，采用在Insert时，读取Max值后加一，这种方法可 以避免自动编号的问题，</p>
</li>
<li><p>缺点：<br>但也存在一个效率问题，如果记录非常大的话，那么Max()也会影响效率的;更严重的是并发性问题，如果同时有两人读到相同的Max后，加一后插入的ID值会重复。</p>
</li>
</ul>
<h2 id="自制加一"><a href="#自制加一" class="headerlink" title="自制加一"></a>自制加一</h2><ul>
<li><p>优点：<br>考虑Max加一的效率后，采用自制加一，也就是建一个特别的表，字段为：表名，当前序列值。这样在往表中插入值时，先从此表中找到相应表的最大值后加 一，进行插入，<br>也可能会存在并发处理，这个并发处理，我们可以采用lock线程的方式来避免，在生成此值的时，先Lock，取到值以后，再unLock出来，这样不会有两人同时生成了。<br>这比Max加一的速度要快多了。</p>
</li>
<li><p>缺点：<br>但同样存在一个问题：在与其他系统集成时，脱离了系统中的生成方法后，很麻 烦保证自制表中的最大值与导入后的保持一致，而且数字型都存在老数据的导入问题。<br>因此在“自制加一”中可以把主键设为字符型的。字符型的 自制加一我倒是蛮推荐的，应该字符型主键可以应付很多我们意想不到的情况。</p>
</li>
</ul>
<h1 id="主键的选取建议"><a href="#主键的选取建议" class="headerlink" title="主键的选取建议"></a>主键的选取建议</h1><p>此处的分布式主要指 分库分表。非应用分布式</p>
<ol>
<li><p>非分布式架构直接套用自增id做主键</p>
</li>
<li><p>小规模分布式架构用uuid或者自增id+步长做主键</p>
</li>
<li><p>大规模分布式架构用自建的id生成器做主键，参考twitter的[snowflake算法][2]</p>
</li>
</ol>
<p>（1）单实例或者单节点组：<br>经过500W、1000W的单机表测试，自增ID相对UUID来说，自增ID主键性能高于UUID，磁盘存储费用比UUID节省一半的钱。所以在单实例上或者单节点组上，使用自增ID作为首选主键。</p>
<p>（2）分布式架构场景：<br>20个节点组下的小型规模的分布式场景，为了快速实现部署，可以采用多花存储费用、牺牲部分性能而使用UUID主键快速部署；</p>
<p>20到200个节点组的中等规模的分布式场景，可以采用自增ID+步长的较快速方案。</p>
<p>200以上节点组的大数据下的分布式场景，可以借鉴类似twitter雪花算法构造的全局自增ID作为主键。</p>
]]></content>
      <categories>
        <category>db-mysql</category>
      </categories>
  </entry>
  <entry>
    <title>11-InnoDB-事务隔离级别、ACID模型</title>
    <url>/articles/20200205/3890ccea.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。<br>理解为：事务对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。</p>
<p>同一行数据会有多个版本，某事务对该数据的修改并不会直接覆盖老版本，而是产生一个新版本和老版共存。<br>然后在该行追加两个虚拟的列，列就是进行数据操作的事务的ID（created_by_txn_id），是一个单调递增的ID；还有一个deleted_by_txn_id，将来用来做删除的。</p>
<p>那么在另一个事务在读取该行数据时，由具体的隔离级别来控制到底读取该行的哪个版本。同时，在读取过程中完全不加锁，除非用select * xxx for update强行加锁。</p>
<p>譬如read committed级别，每次读取，总是取事务ID最大的那个就好了。</p>
<p>对于Repeatable read，每次读取时，总是取事务ID小于等于当前事务的ID的那些数据记录。在这个范围内，如果某一数据有多个版本，则取最新的。</p>
<p>MVCC在mysql中的实现依赖的是undo log与read view</p>
<p>undo log记录某行数据的多个版本的数据；read view用来判断当前版本数据的可见性。</p>
<p>mysql就是用MVCC来实现读写分离不加锁的。</p>
<p>那么MVCC里多出来的那些版本的数据最终是要删除的，支持MVCC的数据库套路一般差不多，都会有一个后台线程来定时清理那些肯定没用的数据。只要一个数据的deleted_by_txn_id不为空，并且比当前还没结束的事务ID最小的一个还小，该数据就可以被清理掉了。在PostgreSQL中，该清理任务叫“vacuum”，在Innodb中，叫做“purge”。</p>
<h1 id="InnoDB-事务隔离级别"><a href="#InnoDB-事务隔离级别" class="headerlink" title="InnoDB 事务隔离级别"></a>InnoDB 事务隔离级别</h1><p>InnoDB的多版本并发控制是基于事务隔离级别实现的，而事务隔离级别则是依托前面提到的 Undo Log 实现的。<br>当读取一个数据记录时，每个事务会使用一个读视图(Read View)，读视图用于控制事务能读取到的记录的版本。</p>
<p>InnoDB的事务隔离级别分为：Read UnCommitted，Read Committed，Repeatable Read以及Serializable。<br>其中Serializable是基于锁实现的串行化方式，严格来说不是事务可见性范畴。</p>
<ul>
<li>Read Uncommitted：未提交读也称为脏读，它读取的是当前最新修改的记录，即便这个修改最后并未生效。</li>
<li>Read Committed：提交读。它基于的是当前事务内的语句开始执行时的最大的事务ID。如果其他事务修改同一个记录，在没有提交前，则该语句读取的记录还是不会变。<br>但是这种情况会产生不可重复读，即一个事务内多次读取同一条记录可能得到不同的结果(该记录被其他事务修改并提交了)。</li>
<li>Repeatable Read：可重复读。它基于的是事务开始时的读视图，直到事务结束。不读取其他新的事务对该记录的修改，保证同一个事务内的可重复读取。<br>InnoDB提供了 next-key lock来解决幻读问题，不过在一些特殊场景下，可重复读还是可能出现幻读的情况。在实际开发中影响不大。</li>
</ul>
<h1 id="ACID-模型"><a href="#ACID-模型" class="headerlink" title="ACID 模型"></a>ACID 模型</h1><p>事务有 ACID 四个属性， InnoDB 是支持事务的，它实现 ACID 的机制如下：</p>
<h2 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h2><p>innodb的原子性主要是通过提供的事务机制实现，与原子性相关的特性有：</p>
<ul>
<li>Autocommit 设置。</li>
<li>COMMIT 和 ROLLBACK 语句(通过 Undo Log实现)。</li>
</ul>
<h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>innodb的一致性主要是指保护数据不受系统崩溃影响，相关特性包括：</p>
<ul>
<li>InnoDB 的双写缓冲区(doublewrite buffer)。</li>
<li>InnoDB 的故障恢复机制(crash recovery)。</li>
</ul>
<h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>innodb的隔离性也是主要通过事务机制实现，特别是为事务提供的多种隔离级别，相关特性包括：</p>
<ul>
<li>Autocommit设置。</li>
<li>SET ISOLATION LEVEL 语句。</li>
<li>InnoDB 锁机制。</li>
</ul>
<h2 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h2><p>innodb的持久性相关特性：</p>
<ul>
<li>Redo log。</li>
<li>双写缓冲功能。可以通过配置项 innodb_doublewrite 开启或者关闭。</li>
<li>配置 innodb_flush_log_at_trx_commit。用于配置innodb如何写入和刷新 redo 日志缓存到磁盘。默认为1，表示每次事务提交都会将日志缓存写入并刷到磁盘。innodb_flush_log_at_timeout 可以配置刷新日志缓存到磁盘的频率，默认是1秒。</li>
<li>配置 sync_binlog。用于设置同步 binlog 到磁盘的频率，为0表示禁止MySQL同步binlog到磁盘，binlog刷到磁盘的频率由操作系统决定，性能最好但是最不安全。为1表示每次事务提交前同步到磁盘，性能最差但是最安全。MySQL文档推荐是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置为 1。</li>
<li>操作系统的 fsync 系统调用。</li>
<li>UPS设备和备份策略等。</li>
</ul>
<p>参考资料<br><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html</a><br><a href="http://ourmysql.com/archives/1228" target="_blank" rel="noopener">http://ourmysql.com/archives/1228</a><br><a href="https://www.jianshu.com/p/d4cc0ea9d097" target="_blank" rel="noopener">https://www.jianshu.com/p/d4cc0ea9d097</a><br><a href="https://zhuanlan.zhihu.com/p/103487968?utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103487968?utm_source=wechat_session</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>10-存储引擎层-innodb框架-内存架构</title>
    <url>/articles/20200205/ddb6eda9.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>


<h1 id="InnoDB-内存中的结构"><a href="#InnoDB-内存中的结构" class="headerlink" title="InnoDB 内存中的结构"></a>InnoDB 内存中的结构</h1><p>参看原理图 03-存储引擎层、InnoDB 架构</p>
<p><img src="/images/post/db-mysql/innodb-struct.webp" alt=""></p>
<p>内存中的结构主要包括 Buffer Pool，Change Buffer、Adaptive Hash Index以及 Log Buffer 四部分。</p>
<p>如果从内存上来看，Change Buffer 和 Adaptive Hash Index 占用的内存都属于 Buffer Pool，Log Buffer占用的内存与 Buffer Pool独立。</p>
<p>缓冲池缓存的数据包括Page Cache、Change Buffer、Data Dictionary Cache等，通常 MySQL 服务器的 80% 的物理内存会分配给 Buffer Pool。</p>
<p>基于效率考虑，InnoDB中数据管理的最小单位为页，默认每页大小为16KB，每页包含若干行数据。为了提高缓存管理效率，InnoDB的缓存池通过一个页链表实现，很少访问的页会通过缓存池的 LRU 算法淘汰出去。</p>
<p>InnoDB 的缓冲池页链表分为两部分：New sublist(默认占5/8缓存池) 和 Old sublist(默认占3/8缓存池，可以通过 innodb_old_blocks_pct修改，默认值为 37)，</p>
<p>其中新读取的页会加入到 Old sublist的头部，而 Old sublist中的页如果被访问，则会移到 New sublist的头部。</p>
<p>缓冲池的使用情况可以通过 <code>show engine innodb status</code> 命令查看。其中一些主要信息如下：</p>
<p>由于MySQL不同版本采用InnoDB引擎版本不同，5.6后对show engine innodb status信息进行了优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL版本	InnoDB引擎版本</span><br><span class="line">5.1.x	1.0.x版本（官方称为InnoDB Plugin）</span><br><span class="line">5.5.x	5.5（1.1.x版本），InnoDB被Oracle收购后</span><br><span class="line">5.6.x	5.6（1.2.x版本）</span><br><span class="line">5.7.x	5.7</span><br><span class="line">8.0.x	8.0</span><br></pre></td></tr></table></figure>
<p>show engine innodb status显示的不是当前状态，而是过去某个时间范围内InnoDB存储引擎的状态。</p>
<p>向右拉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Per second averages calculated from the last 59 seconds</span><br></pre></td></tr></table></figure>
<p>在显示前端可看到以上信息，代表查询的信息为过去59秒内每2秒的平均值。</p>
<p>show engine innodb status主要包括以下几个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BACKGROUND THREAD	后台Master线程</span><br><span class="line">SEMAPHORES	信号量信息</span><br><span class="line">LATEST DETECTED DEADLOCK	最近一次死锁信息，只有产生过死锁才会有</span><br><span class="line">TRANSACTIONS	事物信息</span><br><span class="line">FILE I&#x2F;O	IO Thread信息</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX	INSERT BUFFER和自适应HASH索引</span><br><span class="line">LOG	日志</span><br><span class="line">BUFFER POOL AND MEMORY	BUFFER POOL和内存</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO	如果设置了多个BUFFER POOL实例，这里显示每个BUFFER POOL信息。可通过innodb_buffer_pool_instances参数设置</span><br><span class="line">ROW OPERATIONS	行操作统计信息</span><br><span class="line">END OF INNODB MONITOR OUTPU	输出结束语</span><br></pre></td></tr></table></figure>

<h2 id="Buffer-pool"><a href="#Buffer-pool" class="headerlink" title="Buffer pool"></a>Buffer pool</h2><p>查看：BUFFER POOL AND MEMORY</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992 # 分配给InnoDB缓存池的内存(字节)</span><br><span class="line">Dictionary memory allocated 102398  # 分配给InnoDB数据字典的内存(字节)</span><br><span class="line">Buffer pool size   8191 # 缓存池的页数目</span><br><span class="line">Free buffers       7893 # 缓存池空闲链表的页数目</span><br><span class="line">Database pages     298  # 缓存池LRU链表的页数目</span><br><span class="line">Modified db pages  0    # 修改过的页数目</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>Innodb的这个缓存区就是Innodb_buffer_pool，当读取数据时，就会先从缓存中查看是否数据的页（page）存在，不存在的话才去磁盘上检索，查到后缓存到这个pool里。<br>同理，插入、修改、删除也是先操作缓存里数据，之后再以一定频率更新到磁盘上。控制刷盘的机制，叫做Checkpoint。</p>
<p><img src="/images/post/db-mysql/innodb_buffer_pool.png" alt=""></p>
<p>注意，左边那两个不在Innodb_buffer_pool里，是另外一块内存。只不过大部分的内存都属于Innodb_buffer_pool的。</p>
<p>mysql安装后，默认pool的大小是128M，可以通过show variables like ‘innodb_buffer_pool%’;命令查看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer_pool%'</span>;</span><br><span class="line"><span class="comment"># innodb_buffer_pool_dump_at_shutdown	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_dump_now	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_filename	ib_buffer_pool</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_instances	8</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_abort	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_at_startup	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_load_now	OFF</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_size	134217728</span></span><br></pre></td></tr></table></figure>
<p>可以通过show global status like ‘%innodb_buffer_pool_pages%’;  查看已经被占用的和空闲的。共计8000多个page。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%innodb_buffer_pool_pages%'</span>;</span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_data	7167</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_dirty	0</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_flushed	120861</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_free	1024</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_misc	1</span></span><br><span class="line"><span class="comment"># Innodb_buffer_pool_pages_total	8192</span></span><br></pre></td></tr></table></figure>

<p>所以如果数据很多，而pool很小，那么性能就好不了。</p>
<p>理论上来说，如果你给pool的内存足够大，够装下所有数据，要访问的所有数据都在pool里，那么你的所有请求都是走内存，性能将是最好的，和redis类似。</p>
<p>官方建议pool的空间设置为物理内存的50%-75%。</p>
<p>在mysql5.7.5之后，可以在mysql不重启的情况下动态修改pool的size，如果你设置的pool的size超过了1G的话，应该再修改一下Innodb_buffer_pool_instances=N，将pool分成N个pool实例，将来操作的数据会按照page的hash来映射到不同的pool实例。</p>
<p>这样可以大幅优化多线程情况下，并发读取同一个pool造成的锁的竞争。</p>
<h3 id="缓冲区LRU淘汰算法"><a href="#缓冲区LRU淘汰算法" class="headerlink" title="缓冲区LRU淘汰算法"></a>缓冲区LRU淘汰算法</h3><p>当pool的大小不够用了，满了，就会根据LRU算法（最近最少使用）来淘汰老的页面。最频繁使用的页在LRU列表的前端，最少使用的页在LRU列表的尾端。淘汰的话，就首先释放尾端的页。</p>
<p>InnoDB的LRU和普通的不太一样，Innodb的加入了midpoint位置的概念。最新读取到的页，并不是直接放到LRU列表的头部的，而是放到midpoint位置。<br>这个位置大概是LRU列表的5/8处，该参数由innodb_old_blocks_pct控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_old_blocks_pct%&#39;;</span><br><span class="line">innodb_old_blocks_pct	37</span><br></pre></td></tr></table></figure>
<p>如37是默认值，表示新读取的页插入到LRU尾端37%的位置。在midpoint之后的列表都是old列表，之前的是new列表，可以简单理解为new列表的页都是最活跃的数据。</p>
<p>为什么不直接放头部？因为某些数据扫描操作需要访问的页很多，有时候这些页仅仅在本次查询有效，以后就不怎么用了，并不算是活跃的热点数据。那么真正活跃的还是希望放到头部去，这些新的暂不确定是否真正未来要活跃。所以，这可以理解为预热。还引入了一个参数innodb_old_blocks_time用来表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p>
<p>重要的查询命令可以看到这些信息，show engine innodb status;<br>Database pages表示LRU列表中页的数量，pages made young显示了LRU列表中页移动到前端的次数，Buffer pool hit rate表示缓冲池的命中率，100%表示良好，该值小于95%时，需要考虑是否因为全表扫描引起了LRU列表被污染。里面还有其他的参数，可以自行查阅一下代表什么意思。</p>
<h3 id="Pool的主要空间"><a href="#Pool的主要空间" class="headerlink" title="Pool的主要空间"></a>Pool的主要空间</h3><p>其实更多的、对性能影响更大的是读缓存。毕竟多数数据库是读多写少。</p>
<p>读缓存主要数据是索引页和数据页，如果要读取的数据在pool里没有，那就去磁盘读，读到后的新页放到pool的3/8位置，后续根据情况再决定是否放到LRU列表的头部。</p>
<p>注意，最小单位是页，哪怕只读一条数据，也会加载整个页进去。如果是顺序读的话，刚好又在同一个页里，譬如读了id=1的，那么再读id=2的时，大概率直接从缓存里读。 </p>
<h2 id="BACKGROUND-THREAD"><a href="#BACKGROUND-THREAD" class="headerlink" title="BACKGROUND THREAD"></a>BACKGROUND THREAD</h2><p>InnoDB存储引擎的核心操作大部分都集中在Mater Thread后台线程中。</p>
<p>MySQL5.5版本之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 846676 1_second, 846675 sleeps, 84665 10_second, 17 background, 17 flush</span><br><span class="line">srv_master_thread log flush and writes: 854189</span><br></pre></td></tr></table></figure>
<p>MySQL 5.6之后对Master Thread进行了优化，去除了sleeps的信息，srv_active为之前的每秒的循环，srv_idle为每10秒的的循环，srv_shutdown为停止的循环，通常为0，只在MySQL关闭时才会增加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 3911776 srv_active, 0 srv_shutdown, 309625 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 4221384</span><br></pre></td></tr></table></figure>
<p>上面可以看出主循环每10秒进行了309625次，每秒进行了3911776次，每10秒的操作符合1：10。</p>
<p>负载低的情况下日志缓冲刷盘次数，4221384 ≈ 3911776+309625。</p>
<p>根据循环次数可大概判断当前数据库负载情况。如果每秒循环次数少，每10秒次数多，证明当前负载很低；如果每秒循环次数多，每10秒次数少，远大于10：1，证明当前负载很高。</p>
<h2 id="SEMAPHORES"><a href="#SEMAPHORES" class="headerlink" title="SEMAPHORES"></a>SEMAPHORES</h2><p>当前等待线程的列表及事件计数器，可以评估当前负载情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 58961200</span><br><span class="line">OS WAIT ARRAY INFO: signal count 125268732</span><br><span class="line">Mutex spin waits 770371493, rounds 6482840874, OS waits 20699077</span><br><span class="line">RW-shared spins 0, rounds 115276716, OS waits 14655922</span><br><span class="line">RW-excl spins 0, rounds 987115172, OS waits 12384598</span><br><span class="line">RW-sx spins 40484350, rounds 419545112, OS waits 4476477</span><br><span class="line">Spin rounds per wait: 115276716.00 RW-shared, 987115172.00 RW-excl, 10.36 RW-sx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OS WAIT ARRAY INFO	reservation count：表示InnoDB产生了多少次OS WAIT；</span><br><span class="line">                    signal count：表示进入OS WAIT的线程被唤醒次数</span><br><span class="line">Mutex(5.7后去除)	spins：空转次数，通过innodb_sync_spin_loops控制，超过则转到OS waits；</span><br><span class="line">                spin waits：spin线程无法获取锁而进入Spin wait；</span><br><span class="line">                rounds：spin wait进行轮询检查mutexes的次数；</span><br><span class="line">                OS waits：线程放弃spin wait进入挂起状态。</span><br><span class="line">RW-shared	RW-shared 共享锁</span><br><span class="line">RW-excl	RW-excl 排他锁</span><br><span class="line">RW-sx	5.7后新增；RW-sx 共享排他锁</span><br><span class="line">Spin rounds per wait	rounds &#x2F; spins &#x3D; 值</span><br></pre></td></tr></table></figure>

<p>要明白InnoDB如何处理互斥量(Mutexes)，以及什么是两步获得锁(two-step approach)。</p>
<ol>
<li>首先进程试图获得一个锁，如果此锁被它人占用。它就会执行所谓的spin wait，即所谓循环的查询“锁被释放了吗？”。</li>
<li>如果在循环过程中，一直未得到锁释放的信息，则其转入OS WAIT，即所谓线程进入挂起(suspended)状态。</li>
<li>直到锁被释放后，通过信号(singal)唤醒线程。</li>
</ol>
<p>Spin wait的消耗远小于OSwaits。Spin wait利用cpu的空闲时间，检查锁的状态，OS Wait会有所谓content switch，从CPU内核中换出当前执行线程以供其它线程使用。</p>
<p>所以应尽量减少OS waits，可以通过innodb_sync_spin_loops参数来平衡spin wait和os wait。Mutex信息可通过show engine innodb mutex查看。</p>
<h2 id="LATEST-DETECTED-DEADLOCK"><a href="#LATEST-DETECTED-DEADLOCK" class="headerlink" title="LATEST DETECTED DEADLOCK"></a>LATEST DETECTED DEADLOCK</h2><p>记录最近一次死锁信息，只有产生过死锁才会有记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">190425 18:00:13</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 231E7C5DF, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1248, 3 row lock(s)</span><br><span class="line">MySQL thread id 1346996, OS thread handle 0x7fd968454700, query id 760545285 10.10.x.x app_user updating</span><br><span class="line">DELETE </span><br><span class="line">    FROM db_0.table_0</span><br><span class="line">    WHERE ORDER_ID IN (  456787464 , 456787465 )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DF lock_mode X waiting</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 231E7C5DD, ACTIVE 0 sec starting index read, thread declared inside InnoDB 1</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">5 lock struct(s), heap size 1248, 4 row lock(s)</span><br><span class="line">MySQL thread id 1348165, OS thread handle 0x7fd96669f700, query id 760545283 10.10.x.x app_user updating</span><br><span class="line">DELETE </span><br><span class="line">    FROM db_0.table_0</span><br><span class="line">    WHERE ORDER_ID IN (  456787464 , 456787465 )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DD lock_mode X locks rec but not gap</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;;</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 5 page no 6064 n bits 824 index &#96;orderId_index&#96; of table &#96;db_0&#96;.&#96;table_0&#96; trx id 231E7C5DD lock_mode X waiting</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Record lock, heap no 180 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 8; hex 80000015eb6a1041; asc      j A;;</span><br><span class="line"> 1: len 8; hex 800000002018fce2; asc         ;;</span><br><span class="line">*** WE ROLL BACK TRANSACTION （1）</span><br></pre></td></tr></table></figure>

<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。正常死锁会自动释放，innodb有一个内在的死锁检测工具，</p>
<p>当死锁超过一定时间后，会回滚其中一个事务，innodb_lock_wait_timeout可配置死锁等待超时时间。</p>
<ul>
<li><p>死锁在两情况下最容易产生：</p>
</li>
<li><p>高并发同时操作同一条数据</p>
</li>
</ul>
<p>存在主键和辅助索引，加锁顺序相反</p>
<p>避免死锁方法即降低并发，操作数据时使加锁顺序相同。  </p>
<h2 id="TRANSACTIONS"><a href="#TRANSACTIONS" class="headerlink" title="TRANSACTIONS"></a>TRANSACTIONS</h2><p>包含了InnoDB事务(transaction)的统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 2409176</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 2409171 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 31</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421224214038352, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421224214044736, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421224214039264, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 2409171, ACTIVE 1549 sec fetching rows, thread declared inside InnoDB 3871</span><br><span class="line">mysql tables in use 1, locked 0</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">MySQL thread id 653597, OS thread handle 140289889908480, query id 2528936 127.0.0.1 root Sending data</span><br><span class="line">SELECT &#x2F;*!40001 SQL_NO_CACHE *&#x2F; * FROM &#96;table&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trx id counter	当前事物ID</span><br><span class="line">Purge done for trx&#39;s	正在清理掉的transaction ID</span><br><span class="line">History list length	记录了undo spaces内未清掉的事务个数，Purge的原则是记录没有被其它事务继续使用。</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION	每个session的事物状态</span><br></pre></td></tr></table></figure>
<p>当前活跃的事物状态为ACTIVE，事物的详细信息，包括线程ID、执行时间、用户、SQL等。正在使用1个表，涉及锁的表0个。</p>
<h2 id="FILE-I-O"><a href="#FILE-I-O" class="headerlink" title="FILE I/O"></a>FILE I/O</h2><p>在InnoDB中大量使用了AIO（Async IO）来处理IO 请求，IO Thread主要是负责这些IO请求的回调处理，通过调用fsync()函数协调内存与磁盘之间的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for completed aio requests (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for completed aio requests (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for completed aio requests (read thread)</span><br><span class="line">I&#x2F;O thread 10 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 11 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 12 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 13 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 14 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 15 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 16 state: waiting for completed aio requests (write thread)</span><br><span class="line">I&#x2F;O thread 17 state: waiting for completed aio requests (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0, 0, 0, 0, 0] , aio writes: [0, 0, 0, 0, 0, 0, 0, 0] ,</span><br><span class="line">ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">15234061 OS file reads, 304461183 OS file writes, 73899457 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.24 writes&#x2F;s, 0.17 fsyncs&#x2F;s</span><br></pre></td></tr></table></figure>
<p>InnoDB1.0版本之前有4个IO线程，1.1后做了优化，Purge Thread从Master Thread独立出来，Purge Cleaner Thread从InnoDB1.2版本引入，都是为了减轻Master Thread的工作，提高CPU利用率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert buffer thread	合并插入缓冲，insert buffer维护非唯一辅助索引</span><br><span class="line">log thread	负责异步刷新事物日志</span><br><span class="line">read thread	预读，innodb_read_io_threads 默认4</span><br><span class="line">write thread	刷新脏页缓冲，innodb_write_io_threads 默认4</span><br><span class="line">purge thread	回收已经使用并分配的undo页，可设置多个</span><br><span class="line">purge cleaner Thread	刷新脏页</span><br></pre></td></tr></table></figure>
<p>显示各个I/O thread的pending operations,pending的log和buffer pool thread的fsync()调用；</p>
<ul>
<li>aio：代表的是异步IO(asynchronous I/O)；</li>
<li>OS file：显示了reads writes fsync() 调用次数。</li>
</ul>
<h2 id="Change-Buffer-INSERT-BUFFER-AND-ADAPTIVE-HASH-INDEX"><a href="#Change-Buffer-INSERT-BUFFER-AND-ADAPTIVE-HASH-INDEX" class="headerlink" title="(Change Buffer)INSERT BUFFER AND ADAPTIVE HASH INDEX"></a>(Change Buffer)INSERT BUFFER AND ADAPTIVE HASH INDEX</h2><h3 id="插入缓冲insert-buffer"><a href="#插入缓冲insert-buffer" class="headerlink" title="插入缓冲insert buffer"></a>插入缓冲insert buffer</h3><p>它是buffer_pool的一部分，用来做insert操作时的缓存的。</p>
<p>如b+tree，以及数据的存放格式，那么当新插入数据时，倘若直接就插入到b+ tree里，那么可能会比较缓慢，需要读取、找到要插入的地方，还要做树的扩容、校验、寻址、落盘等等一大堆操作。</p>
<p>在Innodb中，主键是行唯一标识，如果你的插入顺序是按照主键递增进行插入的，那么还好，它不需要磁盘的随机读取，找到了页，就能插，这样速度还是可以的。</p>
<p>然而，如果你的表上有多个别的索引（二级索引），那么当插入时，对于那个二级索引树，就不是顺序的了，它需要根据自己的索引列进行排序，这就需要随机读取了。<br>二级索引越多，那么插入就会越慢，因为要寻找的树更多了。还有，如果你频繁地更新同一条数据，倘若也频繁地读写磁盘，那就不合适了，最好是将多个对同一page的操作，合并起来，统一操作。</p>
<p>所以，Innodb设计了Insert Buffer，对于非聚簇索引的插入、更新操作，不是每次都插入到索引页中，而是先判断该二级索引页是否在缓冲池中，<br>若在，就直接插入，若不在，则先插入一个insert buffer里，再以一定的频率进行真正的插入到二级索引的操作，这时就可以聚合多个操作，一起去插入，就能提高性能。</p>
<p>然而，insert buffer需要同时满足两个条件时，才会被使用：</p>
<ul>
<li>索引是二级索引</li>
<li>索引不是unique</li>
</ul>
<p>注意，索引不能是unique，因为在插入缓冲时，数据库并不去查询索引页来判断插入的记录的唯一性，如果查找了，就又会产生随机读取。</p>
<p>insert buffer的问题是，在写密集的情况下，内存会占有很大，默认最大可以占用1/2的Innodb_buffer_pool的空间。<br>很明显，如果占用过大，就会对其他的操作有影响，譬如能缓存的查询页就变少了。可以通过IBUF_POOL_SIZE_PER_MAX_SIZE来进行控制。</p>
<h3 id="变更缓冲change-buffer"><a href="#变更缓冲change-buffer" class="headerlink" title="变更缓冲change buffer"></a>变更缓冲change buffer</h3><p>INSERT BUFFER即合并插入缓存，从innodb 1.0.x(MySQL5.5 之前)版本开始引入Change Buffer，是INSERT BUFFER升级版，即MySQL 5.1.x以上版本都支持，<br>不仅包括INSERT BUFFER，还包括UPDATE BUFFER、DELETE BUFFER、PURGE BUFFER。</p>
<p>也就是所有DML操作，都会先进缓冲区，进行逻辑操作，后面才会真正落地。</p>
<p>通过参数Innodb_change_buffering开始查看修改各种buffer的选项。可选值有inserts\deletes\purges\changes\all\none。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'Innodb_change_buffering%'</span>;</span><br><span class="line"><span class="comment">-- innodb_change_buffering	all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'Innodb_change_buffer_max_size'</span>;</span><br><span class="line"><span class="comment">-- innodb_change_buffer_max_size	25</span></span><br></pre></td></tr></table></figure>
<p>默认是所有操作都入buffer，参数是控制内存大小的，25代表最多使用1/4的缓冲池空间。</p>
<p>通常来说，InnoDB辅助索引不同于聚集索引的顺序插入，如果每次修改二级索引都直接写入磁盘，则会有大量频繁的随机IO。<br>Change buffer 的主要目的是将对 非唯一 辅助索引页的操作缓存下来，以此减少辅助索引的随机IO，并达到操作合并的效果。它会占用部分Buffer Pool 的内存空间。<br>在 MySQL5.5 之前 Change Buffer其实叫 Insert Buffer，最初只支持 insert 操作的缓存，随着支持操作类型的增加，改名为 Change Buffer。<br>如果辅助索引页已经在缓冲区了，则直接修改即可；如果不在，则先将修改保存到 Change Buffer。<br>Change Buffer的数据在对应辅助索引页读取到缓冲区时合并到真正的辅助索引页中。Change Buffer 内部实现也是使用的 B+ 树。</p>
<p>查看Change Buffer信息也可以通过 show engine innodb status 命令。更多信息见 <a href="https://mysqlserverteam.com/the-innodb-change-buffer/" target="_blank" rel="noopener">mysqlserverteam: the-innodb-change-buffer</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1356, free list len 149402, seg size 149404, 2004231 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1373793, delete mark 316276978, delete 5341003</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 2 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 298897, node heap has 1 buffer(s)</span><br><span class="line">193.03 hash searches&#x2F;s, 713.40 non-hash searches&#x2F;s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ibuf：size	已经合并页的数量</span><br><span class="line">free list len	空闲列表长度</span><br><span class="line">seg size	Insert Buffer大小</span><br><span class="line">merges	合并次数</span><br><span class="line">merged operations 	</span><br><span class="line">                    Change Buffer中每个操作次数；</span><br><span class="line">                    insert代表Insert Buffer;</span><br><span class="line">                    delete mark代表Delete Buffer；</span><br><span class="line">                    delete代表Purge Buffer;</span><br><span class="line">discarded operations	Change Buffer中无需合并的次数</span><br><span class="line">hash searches&#x2F;s	通过hash索引查询</span><br><span class="line">non-hash searches&#x2F;s	不能通过hash索引查询</span><br></pre></td></tr></table></figure>

<p>可以通过 innodb_change_buffering 配置是否缓存辅助索引页的修改，默认为 all，即缓存 insert/delete-mark/purge 操作<br>(注：MySQL 删除数据通常分为两步，第一步是delete-mark，即只标记，而purge才是真正的删除数据)。</p>
<p><img src="/images/post/db-mysql/changebuffer.webp" alt=""></p>
<h3 id="ADAPTIVE-HASH-INDEX"><a href="#ADAPTIVE-HASH-INDEX" class="headerlink" title="ADAPTIVE HASH INDEX"></a>ADAPTIVE HASH INDEX</h3><p>自适应哈希索引(AHI)查询非常快，一般时间复杂度为 O(1)，相比 B+ 树通常要查询 3~4次，效率会有很大提升。</p>
<p>innodb 通过观察索引页上的查询次数，如果发现建立哈希索引可以提升查询效率，则会自动建立哈希索引，称之为自适应哈希索引，不需要人工干预，可以通过 innodb_adaptive_hash_index 开启，MySQL5.7 默认开启。</p>
<p>考虑到不同系统的差异，有些系统开启自适应哈希索引可能会导致性能提升不明显，而且为监控索引页查询次数增加了多余的性能损耗，</p>
<p> MySQL5.7 更改了 AHI 实现机制，每个 AHI 都分配了专门分区，通过 innodb_adaptive_hash_index_parts配置分区数目，默认是8个，如前一节命令列出所示。</p>
<p>通过(Change Buffer)INSERT BUFFER 可以看到自适应哈希索引大小、使用情况、每秒使用自适应哈希索引搜索情况。<br>自适应HASH索引，由INNODB存储引擎控制，只适合等值查询，不适合范围查询。</p>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><p>事物日志的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 33859450169594</span><br><span class="line">Log flushed up to   33859450169564</span><br><span class="line">Pages flushed up to 33859450169210</span><br><span class="line">Last checkpoint at  33859450169201</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">15044267 log i&#x2F;o&#39;s done, 0.10 log i&#x2F;o&#39;s&#x2F;second</span><br></pre></td></tr></table></figure>
<p>InnoDB事物采用Write-Ahead log策略，即事物在提交时，先写重做日志，在修改页。</p>
<p>Write-Ahead Log：如果一个页在写入磁盘时，必须先将内存中小于该页LSN的日志先写入到磁盘中。</p>
<p>重做日志有LSN、每个页有LSN、Checkpoint也有LSN。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Log sequence number	最新产生的日志序列号</span><br><span class="line">Log flushed up to	已刷到磁盘的重做日志的日志号</span><br><span class="line">Pages flushed up to	已刷到磁盘的页的日志号</span><br><span class="line">Last checkpoint at	最后一次检查点位置，数据和日志一致的状态</span><br><span class="line">pending	当前挂起的日志读写操作</span><br></pre></td></tr></table></figure>
<p>LSN记录的是重做日志的总量，单位是字节。以下三种情况会将重做日志缓存刷到重做日志文件：</p>
<ul>
<li><p>Master Thread 每秒刷重做日志缓存到重做日志文件</p>
</li>
<li><p>innodb_flush_log_at_trx_commit=1时，控制Log Buffer如何写入和刷到磁盘，每次事务提交刷重做日志缓存到重做日志文件</p>
</li>
<li><p>重做日志缓冲池剩余空间小于1/2时，刷重做日志缓存到重做日志文件</p>
</li>
</ul>
<p>innodb_flush_log_at_trx_commit 说明：</p>
<ul>
<li>默认为1，表示每次事务提交都会将 Log Buffer 写入操作系统缓存，并调用配置的 “flush” 方法将数据写到磁盘。设置为 1 因为频繁刷磁盘效率会偏低，但是安全性高，最多丢失 1个 事务数据。而设置为 0 和 2 则可能丢失 1秒以上 的事务数据。</li>
<li>为 0 则表示每秒才将 Log Buffer 写入内核缓冲区并调用 “flush” 方法将数据写到磁盘。</li>
<li>为 2 则是每次事务提交都将 Log Buffer写入内核缓冲区，但是每秒才调用 “flush” 将内核缓冲区的数据刷到磁盘。</li>
</ul>
<p>注意，除了 MySQL 的缓冲区，操作系统本身也有内核缓冲区。</p>
<p>Log Buffer是 重做日志在内存中的缓冲区，大小由 innodb_log_buffer_size 定义，默认是 16M。</p>
<p>一个大的 Log Buffer可以让大事务在提交前不必将日志中途刷到磁盘，可以提高效率。如果你的系统有很多修改很多行记录的大事务，可以增大该值。</p>
<p><img src="/images/post/db-mysql/innodb_flush_log_at_trx_commit.png" alt=""></p>
<p>innodb_flush_log_at_timeout 可以配置刷新日志缓存到磁盘的频率，默认是1秒。注意刷磁盘的频率并不保证就正好是这个时间，可能因为MySQL的一些操作导致推迟或提前。<br>而这个 “flush” 方法并不是C标准库的 fflush 方法(fflush是将C标准库的缓冲写到内核缓冲区，并不保证刷到磁盘)，它通过 innodb_flush_method 配置的，默认是 fsync，即日志和数据都通过 fsync 系统调用刷到磁盘。</p>
<p>可以发现，InnoDB 基本每秒都会将 Log buffer落盘。而InnoDB中使用的 redo log 和 undo log，它们是分开存储的。<br>redo log在内存中有log buffer，在磁盘对应ib_logfile文件。而undo log是记录在表空间ibd文件中的，InnoDB为undo log会生成undo页，对undo log本身的操作（比如向undo log插入一条记录），也会记录redo log，因此undo log并不需要马上落盘。<br>而 redo log则通常会分配一块连续的磁盘空间，然后先写到log buffer，并每秒刷一次磁盘。redo log必须在数据落盘前先落盘(Write Ahead Log)，从而保证数据持久性和一致性。而数据本身的修改可以先驻留在内存缓冲池中，再根据特定的策略定期刷到磁盘。</p>
<h2 id="BUFFER-POOL-AND-MEMORY"><a href="#BUFFER-POOL-AND-MEMORY" class="headerlink" title="BUFFER POOL AND MEMORY"></a>BUFFER POOL AND MEMORY</h2><p>innodb_buffer_pool包含数据页、索引页、undo页、insert buffer、数据字典、自适应哈希索引、锁信息等。数据库缓冲池是通过LRU列表管理的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 19789774848</span><br><span class="line">Dictionary memory allocated 3944999</span><br><span class="line">Buffer pool size   1179504</span><br><span class="line">Free buffers       8192</span><br><span class="line">Database pages     1116347</span><br><span class="line">Old database pages 411925</span><br><span class="line">Modified db pages  3</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 74514305, not young 649973267</span><br><span class="line">0.21 youngs&#x2F;s, 0.17 non-youngs&#x2F;s</span><br><span class="line">Pages read 15233915, created 7356668, written 264739684</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.10 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 1116347, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[48]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total large memory allocated	为innodb 分配的总内存数(byte)</span><br><span class="line">Dictionary memory allocated	为innodb数据字典分配的内存数(byte)</span><br><span class="line">Buffer pool size	innodb_buffer_pool的页数量</span><br><span class="line">Free buffers	lru列表中的空闲页数量</span><br><span class="line">Database pages	lru列表中的非空闲页数量</span><br><span class="line">Old database pages	old子列表的页数量</span><br><span class="line">Modified db pages	脏页的数量</span><br><span class="line">Pending reads	挂起读的数量</span><br></pre></td></tr></table></figure>
<p>可以看到当前Buffer Pool Size共有1179504页，即1179504*16K。新读取到的页默认插入LRU列表的5/8的位置。</p>
<p>此值由innodb_old_blocks_pct控制，即前5/8称为new list，后面3/8的称为old list。</p>
<p>Pages made young 显示LRU列表中old list移到new list的次数，not young显示仍在old list的次数。</p>
<p>这两个值受innodb_old_blocks_time影响，此值为微秒。如果old list中超过30微秒不再读取，则记录not young，反之记录为Pages made young。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show global variables like &#39;%blocks%&#39;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| innodb_old_blocks_pct  | 37    |</span><br><span class="line">| innodb_old_blocks_time | 30    |</span><br><span class="line">+------------------------+-------+</span><br></pre></td></tr></table></figure>
<p>youngs/s,non-youngs/s，表示每秒这两类操作的次数。</p>
<p>Pages read,created,written，表示innodb被读取，创建，写入了多少页及每秒的次数。</p>
<p>Buffer pool hit rate，表示缓冲池命中率，如果低于95%需要具体排查。</p>
<p>Pages read ahead，表示页面预读，随机预读的每秒页数。</p>
<p>LRU中包含unzip_LRU，unzip_LRU是管理非16KB的压缩表。</p>
<h2 id="INDIVIDUAL-BUFFER-POOL-INFO"><a href="#INDIVIDUAL-BUFFER-POOL-INFO" class="headerlink" title="INDIVIDUAL BUFFER POOL INFO"></a>INDIVIDUAL BUFFER POOL INFO</h2><p>可通过innodb_buffer_pool_instances 来配置多个缓冲池实例，默认为1。可减少数据库内部资源竞争，增加并发处理能力。如果分配多个缓冲池实例，每个缓冲池大小为 innodb_buffer_pool_size / innodb_buffer_pool_instances 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   147438</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     139530</span><br><span class="line">Old database pages 51486</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 8790743, not young 77467460</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 1856892, created 916430, written 30727167</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 139530, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[6]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">---BUFFER POOL 3</span><br></pre></td></tr></table></figure>
<p>可以通过information_schema.INNODB_BUFFER_POOL_STATS视图查看每个buffer_pool实例的信息，MySQL默认一个page大小为16K，</p>
<p>可以得出POOL_SIZE * innodb_buffer_pool_instances * 16K = innodb_buffer_pool_size。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(root@localhost) [information_schema] &gt;select POOL_ID,POOL_SIZE,FREE_BUFFERS,DATABASE_PAGES,OLD_DATABASE_PAGES,MODIFIED_DATABASE_PAGES,PAGES_MADE_YOUNG,PAGES_NOT_MADE_YOUNG from information_schema.INNODB_BUFFER_POOL_STATS;</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br><span class="line">| POOL_ID | POOL_SIZE | FREE_BUFFERS | DATABASE_PAGES | OLD_DATABASE_PAGES | MODIFIED_DATABASE_PAGES | PAGES_MADE_YOUNG | PAGES_NOT_MADE_YOUNG |</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br><span class="line">|       0 |     90112 |            0 |          90109 |              33279 |                       0 |            18064 |            132278807 |</span><br><span class="line">|       1 |     90112 |            0 |          90109 |              33282 |                       0 |            18342 |            132086061 |</span><br><span class="line">|       2 |     90112 |            0 |          90110 |              33282 |                       0 |            17631 |            132149779 |</span><br><span class="line">+---------+-----------+--------------+----------------+--------------------+-------------------------+------------------+----------------------+</span><br></pre></td></tr></table></figure>
<p>详细说明同上。</p>
<h2 id="ROW-OPERATIONS"><a href="#ROW-OPERATIONS" class="headerlink" title="ROW OPERATIONS"></a>ROW OPERATIONS</h2><p>显示了row 操作及其他一些统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;444943, Main thread ID&#x3D;139899621590784, state: sleeping</span><br><span class="line">Number of rows inserted 172887566, updated 227534242, deleted 56676133, read 709667077</span><br><span class="line">8.77 inserts&#x2F;s, 8.04 updates&#x2F;s, 0.00 deletes&#x2F;s, 10.92 reads&#x2F;s</span><br></pre></td></tr></table></figure>
<p>queries，表示innodb内核中有多少个线程，队列中有多少个线程。</p>
<p>read views open inside InnoDB，表示有多少个read view 被打开，一个read view 包含事物开始点数据库内容的MVCC快照。</p>
<p>Process ID=444943，表示内核的主线程状态。</p>
<p>Number of rows inserted、updated、deleted、read，表示多少行被插入，更新和删除，读取及每秒信息，可用于监控。</p>
<p>可通过以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(root@localhost) [(none)] &gt;show global status like &#39;Innodb_rows_%&#39;;</span><br><span class="line">+----------------------+-----------+</span><br><span class="line">| Variable_name        | Value     |</span><br><span class="line">+----------------------+-----------+</span><br><span class="line">| Innodb_rows_deleted  | 56676133  |</span><br><span class="line">| Innodb_rows_inserted | 172887566 |</span><br><span class="line">| Innodb_rows_read     | 709667077 |</span><br><span class="line">| Innodb_rows_updated  | 227534242 |</span><br><span class="line">+----------------------+-----------+</span><br><span class="line"></span><br><span class="line">(root@localhost) [(none)] &gt;show global status like &#39;Uptime&#39;;</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Variable_name | Value   |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Uptime        | 1757270 |</span><br><span class="line">+---------------+---------+</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB信息结束语。"><a href="#InnoDB信息结束语。" class="headerlink" title="InnoDB信息结束语。"></a>InnoDB信息结束语。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">如果看不到这行输出，可能是有大量事务或者有一个大的死锁截断了输出信息。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>09-存储引擎层-innodb框架-索引-使用B+树组织数据、实例查看数据</title>
    <url>/articles/20200205/190e6be3.html</url>
    <content><![CDATA[<p>摘要：mysql InnoDB 使用 B+树组织数据、查询数据、mysql InnoDB-B+树存储数据量、实际操作查看</p>
<a id="more"></a>


<h2 id="mysql-InnoDB-B-树组织数据、查询数据"><a href="#mysql-InnoDB-B-树组织数据、查询数据" class="headerlink" title="mysql InnoDB-B+树组织数据、查询数据"></a>mysql InnoDB-B+树组织数据、查询数据</h2><p>在MySQL中，InnoDB页的大小默认是16k，当然也可以通过参数设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_page_size&#39;;</span><br><span class="line">-- innodb_page_size	16384</span><br></pre></td></tr></table></figure>
<h3 id="方式一、直接按页存储【假想】"><a href="#方式一、直接按页存储【假想】" class="headerlink" title="方式一、直接按页存储【假想】"></a>方式一、直接按页存储【假想】</h3><p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是 1K，那么一个页可以存放 16 行这样的数据。</p>
<p>如果数据库按这样的方式存储，那么查找数据就成为一个问题。不知道要查找的数据存在哪个页中，每次查询都需要把所有的页遍历一遍，时间复杂度为 n。</p>
<h3 id="方式二、用-B-树的方式组织数据【实际】"><a href="#方式二、用-B-树的方式组织数据【实际】" class="headerlink" title="方式二、用 B+ 树的方式组织数据【实际】"></a>方式二、用 B+ 树的方式组织数据【实际】</h3><p>示例一、2层b+ tree</p>
<p><img src="source/images/post/db-mysql/ecengbtree.png" alt=""></p>
<p>这个树只有2层，首先每个page都有自己的唯一编号，将来就要通过编号来找对应的page。根页做为一个第一层的索引页，里面是不存在叶子数据（行数据）的，只存放Key，同时还包含了pageNo信息，用来将来去找对应的页。</p>
<p>所有的记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接（双向指针）。所以查询时，无论正序倒序，其实是一样的扫描速度。</p>
<p>每一层的最左边节点页面的最左边位置，会有一个Min记录，该记录由2部分组成，第一部分就是一个Min标记，代表这就是 最小值；第二部分是一个pageNo指针，指向下一层中最左边的记录。注意看根页的Min记录，就是这样的。而33号page的Min记录由于没有下一层了，所以没有pageNo指针。</p>
<p>可以看到，上一层的Key，在下一层对应的page中，也会重复存在，譬如Key=10的记录。但是，每个page，只有第一条数据会和上层有重复，其他的不会有重复。</p>
<p>每一个page还会有一个最大记录和最小记录，用来标记该page的边界，便于查询。</p>
<p>由此结构可以看到，做一次查询的耗时，每一层只需要一次内存级的二分查找，定位后就进入下一层，再一次二分查找。</p>
<p>譬如查询Key=11，那么可以定位到56号page，因为11小于78号page的最小值，之后找到56号page，在做一次二分查询。就能找到11。2层只需要2次IO，就能找到一条数据。3层3次，之前已经说过，3层和4层分别能存多少数据，这个查询效率其实是非常高的。</p>
<p>通过这样的方式，我们就知道了一颗树是怎么构成的了。</p>
<p>示例解说：</p>
<ol>
<li>B+树-组织数据<br><img src="/images/post/db-mysql/001/index-01.jpg" alt=""></li>
</ol>
<p>先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解这里一个页中只存放 3 条记录，实际情况可以存放很多）。</p>
<p>除了存放数据的页以外，还有存放键值+指针的页，如图中 page number=3 的页，该页存放键值和指向数据页的指针，这样的页由 N 个键值+指针组成。</p>
<p>当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。  </p>
<ol start="2">
<li>B+树-查询数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
id 是主键，我们通过这棵 B+ 树来查找，首先找到根页，怎么知道 user 表的根页在哪呢？</li>
</ol>
<p>其实每张表的根页位置在表空间文件中是固定的，即 page number=3 的页（后续说明）。</p>
<p>找到根页后通过二分查找法，定位到 id=5 的数据应该在指针 P5 指向的页中，那么进一步去 page number=5 的页中查找，同样通过二分查询法即可找到 id=5 的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5    zhao2   27</span><br></pre></td></tr></table></figure>
<p>小结：  InnoDB 中主键索引 B+ 树是如何组织数据、查询数据</p>
<p>InnoDB 存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在 B+ 树中叶子节点存放数据，非叶子节点存放键值+指针。</p>
<p>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。</p>
<h3 id="Page内详细结构"><a href="#Page内详细结构" class="headerlink" title="Page内详细结构"></a>Page内详细结构</h3><p><img src="/images/post/db-mysql/page.png" alt=""></p>
<p>page内的存储，共16K的空间,分为几个部分，文件管理头信息、页面头信息、页面尾信息、最小记录最大记录、用户记录、可重用空间、未使用空间、页面槽信息。</p>
<p>用户记录就是行数据，可重用就是曾经被分配过数据后来被删了，未使用就是没分配过的空间。</p>
<h4 id="文件管理头信息"><a href="#文件管理头信息" class="headerlink" title="文件管理头信息"></a>文件管理头信息</h4><p>它占用38个字节，里面存储的东西主要有:</p>
<ul>
<li>该页面的checkSum信息，校验文件是否被损坏的；</li>
<li>该页面在当前表空间的页面号（pageNo）；</li>
<li>当前页面的上一个页面的pageNo；</li>
<li>下一个页面的pageNo；</li>
<li>当前页面最后一次被修改时，对应日志的LSN值，与后面的日志系统有关；</li>
<li>当前页面的类型；</li>
<li>只有第0号页面会存一个LSN值，用来存储当前Innodb引擎最大的被flush的LSN值，将来做checkPoint时用；</li>
<li>标记属于哪个表空间的（避免多个表空间，有相同的pageNo的页）</li>
</ul>
<h4 id="页面头信息"><a href="#页面头信息" class="headerlink" title="页面头信息"></a>页面头信息</h4><ul>
<li>槽的个数；</li>
<li>未使用空间的指针；</li>
<li>存储的记录数，包括最大最小记录的管理；</li>
<li>已被删除的记录的链表的首指针；</li>
<li>已被标记删除的记录数；</li>
<li>最后被插入的记录的位置；</li>
<li>当前节点在b+ tree处于第几层，叶子就是0，往上就加1；</li>
</ul>
<h4 id="页面尾部："><a href="#页面尾部：" class="headerlink" title="页面尾部："></a>页面尾部：</h4><ul>
<li>这8个字节还是用来做完整性校验的。</li>
</ul>
<h4 id="页面重组"><a href="#页面重组" class="headerlink" title="页面重组"></a>页面重组</h4><p>一个页面会频繁的插入删除，在插入过程中，都会去已经删除的可重用链表去找合适的空间，如果放得下，就会放进去，放不下，另寻空间。<br>时间一长，就会有空间碎片产出，譬如累计的空闲空间还有很多呢，但就是找不到能放下一条新数据的合适空间。</p>
<p>那么带来的问题很明显，page增加，每个page存储数据量下降，磁盘占用很大，但存的数据并不多，IO数增加，性能下降。</p>
<p>如果是一张表的话，如果大量数据被删，就需要及时处理回收空间，可以通过一个空的alter命令，如alter table tablename engine innodb，就可以将表的空间给回收重组了。</p>
<p>对于页面也一样，在数据库向某一个页面插入时，如果找不到大小合适的空间，就会做一次页面重组操作。</p>
<p>重组的方式是，新建一个buffer pool页面，然后将老页面的数据一条一条插入到新页面，插入完成后，将老页面空间释放掉，再修改指针位置，指向新页面。</p>
<h2 id="mysql-InnoDB-B-树存储数据量"><a href="#mysql-InnoDB-B-树存储数据量" class="headerlink" title="mysql InnoDB-B+树存储数据量"></a>mysql InnoDB-B+树存储数据量</h2><h3 id="数据量估算"><a href="#数据量估算" class="headerlink" title="数据量估算"></a>数据量估算</h3><p><strong>以B+ 树高为 2为例计算</strong></p>
<p>假设 B+ 树高为 2，即存在一个根节点和若干个叶子节点，那么这棵 B+ 树的存放总记录数为：根节点指针数*单个叶子节点记录行数。</p>
<p>上文已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为 1K，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。</p>
<p>那么现在需要计算出非叶子节点能存放多少指针？假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。</p>
<p>一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。</p>
<p>可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。</p>
<p>根据同样的原理可以算出一个高度为 3 的 B+ 树可以存放：1170<em>1170</em>16=21902400 条这样的记录。</p>
<p>所以在 InnoDB 中 B+ 树高度一般为 1-3 层，它就能满足千万级的数据存储。</p>
<p>在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。</p>
<h3 id="InnoDB-主键索引-B-树的高度"><a href="#InnoDB-主键索引-B-树的高度" class="headerlink" title="InnoDB 主键索引 B+ 树的高度"></a>InnoDB 主键索引 B+ 树的高度</h3><p>上面通过推断得出 B+ 树的高度通常是 1-3，下面我们从另外一个侧面证明这个结论。</p>
<p>在 InnoDB 的表空间文件中，约定 page number 为 3 的代表主键索引的根页，而在根页偏移量为 64 的地方存放了该 B+ 树的 page level。</p>
<p>如果 page level 为 1，树高为 2，page level 为 2，则树高为 3。即 B+ 树的高度=page level+1；</p>
<p>查询系统表：page level。</p>
<p>在实际操作之前，可以通过 InnoDB 元数据表确认主键索引根页的 page number 为 3，也可以从《InnoDB 存储引擎》这本书中得到确认：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO</span><br><span class="line">FROM</span><br><span class="line">    information_schema.INNODB_SYS_INDEXES a,</span><br><span class="line">    information_schema.INNODB_SYS_TABLES b</span><br><span class="line">WHERE a.table_id &#x3D; b.table_id AND a.space &lt;&gt; 0;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blockchain_manager&#x2F;member	    PRIMARY	    22	3	6	3</span><br><span class="line">blockchain_manager&#x2F;member_group	PRIMARY	    23	3	7	3</span><br><span class="line">blockchain_manager&#x2F;permission	PRIMARY	    24	3	8	3</span><br><span class="line">blockchain_manager&#x2F;permission	idx_group	56	0	8	4</span><br></pre></td></tr></table></figure>
<p>可以看出数据库 blockchain_manager 下的 member 表、member 表、permission表主键索引根页的 page number 均为 3，而其他的二级索引 page number 为 4。</p>
<p>关于二级索引与主键索引的区别请参考 MySQL 相关书籍，</p>
<h2 id="实际操作查看"><a href="#实际操作查看" class="headerlink" title="实际操作查看"></a>实际操作查看</h2><h3 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h3><h4 id="测试表"><a href="#测试表" class="headerlink" title="测试表"></a>测试表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;table5hang&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<p>修改表名，依次创建 table15w、table500w、table1000w</p>
<h4 id="测试数据-添加"><a href="#测试数据-添加" class="headerlink" title="测试数据 添加"></a>测试数据 添加</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter //  <span class="comment">#定义标识符为双斜杠</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_procedure ; <span class="comment">#如果存在 my_procedure 存储过程则删除</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_procedure () <span class="comment">#创建无参存储过程</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> n <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> ; <span class="comment"># 申明变量</span></span><br><span class="line">    <span class="keyword">set</span> @execSql=<span class="string">'insert into table5hang(username,age)  values '</span>;</span><br><span class="line">    <span class="keyword">set</span> @execdata = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    WHILE n &lt; 6 DO</span><br><span class="line">        <span class="keyword">set</span> @execdata=<span class="keyword">concat</span>(@execdata,<span class="string">"("</span>,<span class="string">"'name-"</span>,n,<span class="string">"',"</span>,n%<span class="number">100</span>,<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">        if n%5=0</span><br><span class="line">        then</span><br><span class="line">            <span class="keyword">set</span> @execSql = <span class="keyword">concat</span>(@execSql,@execdata,<span class="string">";"</span>);</span><br><span class="line">            <span class="comment">#select @execSql;</span></span><br><span class="line">            <span class="keyword">prepare</span> stmt <span class="keyword">from</span> @execSql;</span><br><span class="line">            <span class="keyword">execute</span> stmt;</span><br><span class="line">            <span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br><span class="line">            <span class="keyword">commit</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">set</span> @execSql=<span class="string">'insert into table5hang (username,age)  values '</span>;</span><br><span class="line">            <span class="keyword">set</span> @execdata = <span class="string">''</span>;</span><br><span class="line">        ELSE</span><br><span class="line">            <span class="keyword">set</span> @execdata = <span class="keyword">concat</span>(@execdata,<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">SET</span> n = n + <span class="number">1</span> ; <span class="comment">#循环一次,i加一</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span> ; <span class="comment">#结束while循环</span></span><br><span class="line">    <span class="comment">#select count(*) from test_table;</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> my_procedure(); <span class="comment">#调用存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_procedure ; <span class="comment">#如果存在 my_procedure 存储过程则删除</span></span><br></pre></td></tr></table></figure>
<p>插入数据，依次修改表名：table15w、table500w、table1000w 以及插入条数</p>
<p>根据性能 500w、1000w 数据量的需要分批插入。</p>
<p>查看文件结构，mysql每次建库，会在data下创建以库名为名的文件夹，内部文件是表名，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-rw----  1    54B  1 31 11:36 db.opt</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table1000w.frm</span><br><span class="line">-rw-rw----  1   460M  1 31 12:41 table1000w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table15w.frm</span><br><span class="line">-rw-rw----  1    15M  1 31 11:54 table15w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:39 table500w.frm</span><br><span class="line">-rw-rw----  1   236M  1 31 12:19 table500w.ibd</span><br><span class="line">-rw-rw----  1   8.4K  1 31 11:40 table5hang.frm</span><br><span class="line">-rw-rw----  1    96K  1 31 11:51 table5hang.ibd</span><br></pre></td></tr></table></figure>

<p>因为主键索引 B+ 树的根页在整个表空间文件中的第 3 个页开始，所以可以算出它在文件中的偏移量：16384*3=49152（16384 为页大小）。</p>
<p>另外根据《InnoDB 存储引擎》中描述在根页的 64 偏移量位置前 2 个字节，保存了 page level 的值。</p>
<p>因此想要的 page level 的值在整个文件中的偏移量为：16384*3+64=49152+64=49216，前 2 个字节中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -s 49216 -n 10 table5hang.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 00 00 00 00 00 00 00 00 3c                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table15w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 01 00 00 00 00 00 00 00 3b                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table500w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 02 00 00 00 00 00 00 00 3a                  </span><br><span class="line">000c04a</span><br><span class="line"></span><br><span class="line">hexdump -s 49216 -n 10 table1000w.ibd</span><br><span class="line"></span><br><span class="line">000c040 00 02 00 00 00 00 00 00 00 39                  </span><br><span class="line">000c04a</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>table5hang 表数据行数为 5 条，B+ 树高度为 1，<br>table15w   表数据行数为 15 万，B+ 树高度为 2，<br>table500w  表数据行数为 500 万，B+ 树高度为 3，<br>table1000w 表数据行数为 1000 万，B+ 树高度为 3。</p>
<p>500w、1000w 两个表树的高度都是 3。换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做 3 次 IO。<br>那么如果有一张表行数是一千万，那么他的 B+ 树高度依旧是 3，查询效率仍然不会相差太大。region 表只有 5 行数据，当然他的 B+ 树高度为 1。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table500w <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">4230000</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1000w <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">4230000</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>08-存储引擎层-innodb框架-索引-树到B+树演变、聚集索引与非聚集索引</title>
    <url>/articles/20200205/4e769343.html</url>
    <content><![CDATA[<p>摘要：从树到B+树解释索引演变过程，聚集索引与非聚集索引</p>
<p>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。</p>
<p>索引在 MySQL 数据库中分三类：</p>
<ul>
<li>B+ 树索引</li>
<li>Hash 索引</li>
<li>全文索引</li>
</ul>
<p>B+ 树索引，由二叉查找树，平衡二叉树和 B 树这三种数据结构 演化来的。</p>
<a id="more"></a>

<h1 id="用树的概念理解mysql数据库"><a href="#用树的概念理解mysql数据库" class="headerlink" title="用树的概念理解mysql数据库"></a>用树的概念理解mysql数据库</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>树的基础：<a href="https://www.cnblogs.com/bjlhx/p/10870875.html" target="_blank" rel="noopener">006-数据结构-树形结构-二叉树、二叉查找树、平衡二叉查找树-AVL树</a></p>
<p>数据库表 对应 二叉查找树</p>
<p><img src="/images/post/db-mysql/002/erchachazhao.jpg" alt=""></p>
<p>从图中可以看到，为 user 表（用户信息表）建立了一个二叉查找树的索引。</p>
<p>图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。</p>
<p>二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。</p>
<p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p>
<ol>
<li>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来把当前节点&gt;的右子节点作为当前节点。</li>
<li>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</li>
<li>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</li>
</ol>
<p>利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，需要 6 次才能找到。</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>上面利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造【以5为根节点】：</p>
<p><img src="/images/post/db-mysql/002/pinghengerchashu.jpg" alt=""></p>
<p>可以看到二叉查找树变成了一个链表。如果需要查找 id=17 的用户信息，需要查找 7 次，也就相当于全表扫描了。</p>
<p>导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。</p>
<p>为了解决这个问题，需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树。</p>
<p>平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。</p>
<p>下面是平衡二叉树和非平衡二叉树的对比：</p>
<p><img src="/images/post/db-mysql/002/pinghengerchashu-2.jpg" alt=""></p>
<p>由平衡二叉树的构造可以发现第一张图中的二叉树其实就是一棵平衡二叉树。</p>
<p>平衡二叉树保证了树的构造是平衡的，当插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式,参看。</p>
<p>平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>因为内存的易失性。一般情况下，都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。</p>
<p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，应当尽量减少从磁盘中读取数据的次数。</p>
<p>另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。</p>
<p>如果能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那查找数据的时间也会大幅度降低。</p>
<p>如果用树这种数据结构作为索引的数据结构，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块。</p>
<p>平衡二叉树是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果要存储海量的数据呢</p>
<p>可以想象到二叉树的节点将会非常多，高度也会极其高，查找数据时也会进行很多次磁盘 IO，查找数据的效率将会极低！</p>
<p><img src="/images/post/db-mysql/002/btree-1.jpg" alt=""></p>
<p>为了解决平衡二叉树的这个弊端，应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。</p>
<p>B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树：</p>
<p>B树，<a href="https://www.cnblogs.com/bjlhx/p/10898059.html" target="_blank" rel="noopener">参看</a></p>
<p><img src="/images/post/db-mysql/002/btree-2.jpg" alt=""></p>
<p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有。</p>
<p>图中的每个节点称为页，页就是上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以这里叫做页更符合 MySQL 中索引的底层数据结构。</p>
<p>从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。</p>
<p>基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p>
<p>假如要查找 id=28 的用户信息，那么在上图 B 树中查找的流程如下：</p>
<ul>
<li>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么根据页 1 中的指针 p2 找到页 3。</li>
<li>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，根据页 3 中的指针 p2 找到页 8。</li>
<li>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><a href="https://www.cnblogs.com/bjlhx/p/10898373.html" target="_blank" rel="noopener">参看</a></p>
<p>B+ 树是对 B 树的进一步优化。看下 B+ 树的结构图：</p>
<p><img src="/images/post/db-mysql/002/btree-3.jpg" alt=""></p>
<p>根据上图看下 B+ 树和 B 树有什么不同：</p>
<p>①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p>
<p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。</p>
<p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p>
<p>另外，B+ 树的阶数是等于键值的数量的，如果 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。</p>
<p>一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p>
<p>②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。</p>
<p>那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p>
<p>上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p>
<p>其实上面的 B 树也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。</p>
<p>也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引。</p>
<p>通过上图可以看到，在 InnoDB 中，通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p>
<p>MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>
<h1 id="mysql聚集索引-VS-非聚集索引"><a href="#mysql聚集索引-VS-非聚集索引" class="headerlink" title="mysql聚集索引 VS 非聚集索引"></a>mysql聚集索引 VS 非聚集索引</h1><p>InnoDB数据文件本身就是索引文件，其索引分聚集索引和辅助索引，聚集索引的叶节点包含了完整的数据记录，辅助索引叶节点数据部分是主键的值，</p>
<p>除了空间索引外，InnoDB的索引实现基本都是 B+ 树，如图所示。</p>
<p>其中非叶子结点存储的是子页的最小的键值和子页的页号，叶子结点存储的是数据，数据按照索引键排序。</p>
<p>同一层的页之间用双向链表连接(前面提到的FIL Header中PREV PAGE 和 NEXT PAGE)，同一页内的记录用单向链表连接(Record Header中记录了下一条记录的偏移)。</p>
<p>每一页设置了两个虚拟记录Infimum和Supremum用于标识页的开始和结束。</p>
<p><img src="/images/post/db-mysql/bptreestruct.webp" alt=""></p>
<p>在InnoDB中根据辅助索引查询，如果除了主键外还有其他字段，则需要查询两遍，先根据辅助索引查询主键的值，然后再到主索引中查询得到记录。</p>
<p>此外，因为辅助索引的数据部分是主键值，主键不能过大，否则会导致辅助索引占用空间变大，用自增ID做主键是个不错的选择。</p>
<h2 id="聚集索引-VS-非聚集索引-概念"><a href="#聚集索引-VS-非聚集索引-概念" class="headerlink" title="聚集索引 VS 非聚集索引 概念"></a>聚集索引 VS 非聚集索引 概念</h2><p>在上面介绍 B+ 树索引的时候，提到了图中的索引其实是聚集索引的实现方式。</p>
<p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p>
<p>主要说明下 InnoDB 中的聚集索引和非聚集索引：</p>
<p>①聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使不创建主键，系统也会帮你创建一个隐式的主键。</p>
<p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p>
<p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，称之为聚集索引。</p>
<p>②非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p>
<p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，称为回表。</p>
<h2 id="利用聚集索引-和-非聚集索引-查找数据"><a href="#利用聚集索引-和-非聚集索引-查找数据" class="headerlink" title="利用聚集索引 和 非聚集索引 查找数据"></a>利用聚集索引 和 非聚集索引 查找数据</h2><p>聚簇索引和二级索引（非聚簇索引）</p>
<p>二级索引就是手工创建的非聚集索引，可以建多个，建在一个列或者多个列上。这些索引也会构成B+tree，和聚簇索引的区别就是它不需要存每行的详细数据，它的叶子节点只需要存primary key或（rowId）（当然还有主键索引所在磁盘的位置PageNo）。</p>
<p>将来能通过这个索引找到数据行的ID。要查数据时，就根据ID去聚簇索引那棵B+tree去查，这就是回表。</p>
<p>最后，索引是方便查询的，索引列的数据不适合放大的，它占用的空间一多，那么B+tree一层中能放的个数就越少。</p>
<p>索引列一多，插入就越慢，如果没有索引，插入一行时只需要对主键进行排序即可。如果有很多列都有索引，那么插入时，就要做很多次排序,以及多个B+tree的结构变化。</p>
<h3 id="利用聚集索引查找数据"><a href="#利用聚集索引查找数据" class="headerlink" title="利用聚集索引查找数据"></a>利用聚集索引查找数据</h3><p><img src="/images/post/db-mysql/002/btree-3.jpg" alt=""></p>
<p>聚集索引，表中的数据存储在其中。</p>
<p>现在假设要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">18</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt;<span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>其中 id 为主键，具体的查找过程如下：</p>
<p>①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。</p>
<p>从内存中读取到页 1，要查找这个 id&gt;=18 and id&lt;40 或者范围值，我们首先需要找到 id=18 的键值。</p>
<p>从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。</p>
<p>②要从页 3 中查找数据，需要拿着 p2 指针去磁盘中进行读取页 3。</p>
<p>从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。</p>
<p>③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。</p>
<p>将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。</p>
<p>此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。</p>
<p>因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。</p>
<p>可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。</p>
<p>④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</p>
<p>最终我们找到满足条件的所有数据，总共 12 条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)。</span><br></pre></td></tr></table></figure>
<p>具体的查找流程图：</p>
<p><img src="/images/post/db-mysql/002/jucu-chazhao.jpeg" alt=""></p>
<h3 id="利用非聚集索引查找数据"><a href="#利用非聚集索引查找数据" class="headerlink" title="利用非聚集索引查找数据"></a>利用非聚集索引查找数据</h3><p>上述表结构 只有主键 和 名称，扩展下表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id  name    luckyNum</span><br><span class="line">1   zs      23</span><br><span class="line">2   ls      7</span><br></pre></td></tr></table></figure>
<p>使用 luckyNum 建立非聚集索引</p>
<p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。</p>
<p><img src="/images/post/db-mysql/002/feijuji-1.jpeg" alt=""></p>
<p>如果要找到幸运数字为 33 的用户信息，对应的 sql 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> luckNum=<span class="number">33</span></span><br></pre></td></tr></table></figure>
<p>查找的流程跟聚集索引一样，最终会找到主键值 47，找到主键后,需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。</p>
<p><img src="/images/post/db-mysql/002/feijuji-chazhao.jpeg" alt=""></p>
<p>在 MyISAM 中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。</p>
<p>因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出）。<br>指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</p>
<p>参看地址：<a href="https://blog.51cto.com/14480698/2451603" target="_blank" rel="noopener">https://blog.51cto.com/14480698/2451603</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>07-存储引擎层-innodb框架-表空间-系统表空间</title>
    <url>/articles/20200205/da9f4def.html</url>
    <content><![CDATA[<p>摘要：系统表空间包含内容有：数据字典，双写缓冲，修改缓冲，undo日志，以及在系统表空间创建的表的数据和索引。</p>
<a id="more"></a>

<h1 id="表空间物理结构-页、区、段"><a href="#表空间物理结构-页、区、段" class="headerlink" title="表空间物理结构-页、区、段"></a>表空间物理结构-页、区、段</h1><p>可以看到，除了分配未使用的页外， UNDO_LOG，SYS, INDEX 页占据了不少的空间。</p>
<p>UNDO_LOG 页存储的是Undo log，SYS 页存储的是数据字典、回滚段、修改缓存等信息，INDEX 是索引页，TRX_SYS 页用于InnoDB的事务系统。</p>
<p>数据字典就是数据表的元信息，修改缓冲前面提到是为了提高IO性能也不再赘述，这里主要分析下 Undo 日志和双写缓冲。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 space-page-type-summary</span><br><span class="line"><span class="built_in">type</span>                count       percent     description         </span><br><span class="line">ALLOCATED           4392        90.30       Freshly allocated   </span><br><span class="line">UNDO_LOG            210         4.32        Undo <span class="built_in">log</span>            </span><br><span class="line">SYS                 141         2.90        System internal     </span><br><span class="line">INDEX               110         2.26        B+Tree index        </span><br><span class="line">INODE               7           0.14        File segment inode  </span><br><span class="line">FSP_HDR             2           0.04        File space header   </span><br><span class="line">TRX_SYS             1           0.02        Transaction system header</span><br><span class="line">IBUF_BITMAP         1           0.02        Insert buffer bitmap</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MySQL的MVCC(多版本并发控制)依赖Undo Log实现</p>
<p>MySQL的表空间文件 *.ibd 存储的是记录最新值，每个记录都有一个回滚指针(见前面图中的Roll Ptr)，指向该记录的最近一条Undo记录，</p>
<p>而每条Undo记录都会指向它的前一条Undo记录，如下图所示。默认情况下 undo log存储在系统表空间 ibdata1 中。</p>
<p>示例<br>这是最初的 插入后的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 -R 127 record-history</span><br><span class="line"><span class="comment"># Transaction   Type                Undo record</span></span><br><span class="line"><span class="comment"># (n/a)         insert              (id=1) → ()</span></span><br><span class="line"><span class="comment"># (base)</span></span><br></pre></td></tr></table></figure>
<p>执行一个更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table5hang <span class="keyword">set</span> age=<span class="number">12</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> table5hang <span class="keyword">set</span> age=<span class="number">13</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>再次查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 -R 127 record-history</span><br><span class="line"><span class="comment"># Transaction   Type                Undo record</span></span><br><span class="line"><span class="comment"># 29910         update_existing     (id=1) → (age=12)</span></span><br><span class="line"><span class="comment"># 29904         update_existing     (id=1) → (age=1)</span></span><br><span class="line"><span class="comment"># (n/a)         insert              (id=1) → ()</span></span><br><span class="line"><span class="comment"># (base)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，Undo Log 在事务执行过程中就会产生，事务提交后才会持久化，如果事务回滚了则Undo Log也会删除。</p>
<p>另外，删除记录并不会立即在表空间中删除该记录，而只是做个标记(delete-mark)，真正的删除则是等由后台运行的 purge 进程处理。</p>
<p>除了每条记录有Undo Log的列表外，整个数据库也会有一个历史列表，purge 进程会根据该历史列表真正删除已经没有再被其他事务使用的 delete-mark 的记录。</p>
<p>purge 进程会删除该记录以及该记录的 Undo Log。</p>
<h2 id="双写缓冲"><a href="#双写缓冲" class="headerlink" title="双写缓冲"></a>双写缓冲</h2><p>InnoDB的记录更新流程：先在Buffer Pool中更新，并将更新记录到 Redo Log 文件中，Buffer Pool中的记录会标记为脏数据并定期刷到磁盘。</p>
<p>由于InnoDB默认Page大小是16KB，而磁盘通常以扇区为单位写入，每次默认只能写入512个字节，无法保证16K数据可以原子的写入。</p>
<p>如果写入过程发生故障(比如机器掉电或者操作系统崩溃)，会出现页的部分写入(partial page writes)，导致难以恢复。</p>
<p>因为 MySQL 的重做日志采用的是物理逻辑日志，即页间是物理信息，而页内是逻辑信息，在发生页部分写入时，无法确认数据页的具体修改而导致难以恢复。</p>
<p>MySQL 的数据页在真正写入到表空间文件前，会先写到系统表空间文件的一段连续区域双写缓冲(Double-Write Buffer，默认大小为 2MB，128个页)并 fsync 落盘，</p>
<p>等双写缓冲写入成功后才会将数据页写到实际表空间的位置。</p>
<p>因为双写缓冲和数据页的写入时机不一致，如果在写入双写缓冲出错，可以直接丢弃该缓冲页，而如果是写入数据页时出错，则可以根据双写缓冲区数据恢复表空间文件。</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>002-cmd-hexdump进制文件查看工具</title>
    <url>/articles/20200203/653046b.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。</p>
<p>指令所在路径：/usr/bin/hexdump</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump: [-bcCdovx] [-e fmt] [-f fmt_file] [-n length] [-s skip] [file ...]</span><br></pre></td></tr></table></figure>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>此命令参数是Red Hat Enterprise Linux Server release 5.7下hexdump命令参数，不同版本Linux的hexdump命令参数有可能不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b              one-byte octal display           8进制显示</span><br><span class="line">-c              one-byte character display       ASCII显示</span><br><span class="line">-C              canonical hex+ASCII display       十六进制+ASCII显示</span><br><span class="line">-d              two-byte decimal display        两字节计算，显示为10进制方式</span><br><span class="line">-o              two-byte octal display         两字节计算，显示为8进制方式</span><br><span class="line">-x              two-byte hexadecimal display    两字节计算，显示为16进制方式</span><br><span class="line">-e format       format string to be used for displaying data   格式化输出</span><br><span class="line">-f format_file  file that contains format strings</span><br><span class="line">-n length       interpret only length bytes of input    输出多少个bytes的字符长度的内容</span><br><span class="line">-s offset       skip offset bytes from the beginning    输出文件的开始偏移量  【注意：偏移量从0开始的！】</span><br><span class="line">-v              display without squeezing similar lines    </span><br><span class="line">-V              output version information and exit</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li>帮助<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li>
<li>案例<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;test.txt</span><br><span class="line">ABCDEF    </span><br><span class="line">GHIJKM</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C test.txt</span><br><span class="line">00000000  41 42 43 44 45 46 0a 47  48 49 4a 4b 4d 0a 31 32  |ABCDEF.GHIJKM.12|</span><br><span class="line">00000010  33 34 35 36 0a                                    |3456.|</span><br><span class="line">00000015</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>跳过 7 个取6个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C -s 7 -n 6 test.txt</span><br><span class="line">00000007  47 48 49 4a 4b 4d                                 |GHIJKM|</span><br><span class="line">0000000d</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>001-shell-概述与命令行区别</title>
    <url>/articles/20200203/d189e05e.html</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>shell翻译成壳的意思，它是包裹在linux内核外层的，一个可通过一系列的linux命令对操作系统发出相关指令的人机界面。</p>
<p>shell可以通过其条件语句和循环语句等，把一系列linux命令结合在一起，形成一个相当于面向过程的程序，shell script，来实现一些较为复杂的功能。</p>
<p>总括，shell是linux命令集的概称，是属于命令行的人机界面。Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。<br>Shell既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。<br>Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。Shell 和Shell Script不是一回事，通常我们说的都是Shell Script。</p>
<p>由定义可知， shell相当于经过装饰的命令行，和命令行一样，都能操作linux。但是shell是面向过程的，相当于有了一定的逻辑和过程，而命令行只是单一的操作。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol>
<li>直接在命令行执行 就是在当前的shell环境下执行 比如涉及到一些环境变量的时候 必须在当前shell环境里执行</li>
</ol>
<p>在脚本里执行的话 脚本执行的时候 会fork一个子进程 所有操作都在子进程进行 如果涉及到一些在脚本里设置环境变量的东西 脚本结束了 环境变量也就消失了。 </p>
<p>这个修改环境变量的话，需要特别注意下。</p>
<ol start="2">
<li>shell可以重复执行一些命令。也可以把自己要重复执行的命令写到脚本里面执行。而命令行的话就需要一个一个的输入命令，相对而言麻烦一些。</li>
</ol>
]]></content>
      <categories>
        <category>linux-shell</category>
      </categories>
  </entry>
  <entry>
    <title>06-存储引擎层-innodb框架-表空间-段、区、页与组织结构</title>
    <url>/articles/20200202/12fe7f8a.html</url>
    <content><![CDATA[<p>摘要：InnoDB表空间文件.ibd文件内部存储单元是页，初始大小为 96K，而InnoDB默认页大小为 16K。当然页大小也可以通过 innodb_page_size 配置为 4K, 8K…64K 等。</p>
<p>如果用二进制打开，以16K划分一页。在ibd文件中，0-16KB偏移量即为0号数据页，16KB-32KB的为1号数据页，以此类推。</p>
<a id="more"></a>

<h1 id="表空间物理结构-页、区、段"><a href="#表空间物理结构-页、区、段" class="headerlink" title="表空间物理结构-页、区、段"></a>表空间物理结构-页、区、段</h1><p>磁盘最小单位是512字节，操作系统是4KB，mysql里最小的是page（页面）有16K。</p>
<p>ibd就是放索引树的，但总不能一个树就摊在一个txt文档里，所以必须还要有一种文件组织结构。所有的数据都放在page里，用一种规则来把N个page连一起，让它们形成一些关联，才能便于查询，要先找到page，再找到page内的数据。</p>
<p>B+树是离不开页面page</p>
<p><img src="/images/post/db-mysql/006/tablespace.webp" alt=""></p>
<h2 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h2><p>段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。</p>
<p>表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。</p>
<p>InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。</p>
<p>创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据（分裂、增长、删除等），叶子段用来管理（存储）B+树叶子节点的数据，负责行数据的相关动作；</p>
<p>也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。一个段包含256个区(256M大小)。</p>
<h2 id="区-簇（extents）"><a href="#区-簇（extents）" class="headerlink" title="区/簇（extents）"></a>区/簇（extents）</h2><p>段是个逻辑概念，innodb引入了簇的概念，在代码中被称为extent；</p>
<p>簇是由64个连续的页组成的，每个页大小为16KB，即每个簇的大小为1MB硬盘空间。即默认大小为 1MB (64*16K)。</p>
<p>簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。</p>
<p>如果存储数据时，即往段里写入数据，就是往簇里写数据，簇是硬盘空间，当一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据，等于又多了一块64*16K的连续硬盘空间。</p>
<p>一个段所管理的空间大小是无限的，可一直扩展下去，但是扩展的最小单位就是簇。注意，每个簇是一块连续的硬盘空间，但多个簇之间可不是连续的。</p>
<p>同样，两个段之间，在硬盘上也没有什么关系。</p>
<h2 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h2><h3 id="页存储单元"><a href="#页存储单元" class="headerlink" title="页存储单元"></a>页存储单元</h3><p>磁盘扇区、文件系统、InnoDB 存储引擎都有各自的最小存储单元。存储数据的最小单位。</p>
<p><img src="/images/post/db-mysql/001/mysql-disk.jpg" alt=""></p>
<ul>
<li><p>磁盘扇区存储单元-扇区-512字节<br>在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是 512 字节</p>
</li>
<li><p>文件系统存储单元-块-4k<br>文件系统(例如 XFS/EXT4)他的最小单元是块，一个块的大小是 4K。<br>文件系统中一个文件大小只有 1 个字节，但不得不占磁盘上 4KB 的空间。[0k不占空间]<br><img src="/images/post/db-mysql/001/file-0k.jpg" alt="">  <img src="/images/post/db-mysql/001/file-1k.jpg" alt=""></p>
</li>
<li><p>InnoDB存储单元-页-16k<br>InnoDB 存储引擎也有自己的最小储存单元——页(Page)，一个页的大小是 16K。<br>InnoDB 的所有数据文件(后缀为 ibd 的文件)，他的大小始终都是 16384(16K)的整数倍。  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ll |grep ibd </span><br><span class="line">-rw…………    96K 10 31 11:22 innodb_index_stats.ibd</span><br><span class="line">-rw…………    96K 10 31 11:22 innodb_table_stats.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_master_info.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_relay_log_info.ibd</span><br><span class="line">-rw…………    96K 10  2  2018 slave_worker_info.ibd</span><br></pre></td></tr></table></figure>

<p>InnoDB有页（page）的概念，可以理解为簇的细化。页是InnoDB磁盘管理的最小单位。</p>
<h3 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h3><p>所有页的结构都是一样的，分为文件头(前38字节)，页数据和文件尾(后8字节)。页数据根据页的类型不同而不一样。</p>
<p>页的头尾除了一些元信息外，还有Checksum校验值，这些校验值在写入磁盘前计算得到，当从磁盘中读取时，重新计算校验值并与数据页中存储的对比，如果发现不同，则会导致 MySQL 崩溃。</p>
<p><img src="/images/post/db-mysql/page-struct.jpg" alt=""></p>
<h4 id="File-Header-记录页的一些头信息，共占用38字节，组成部分如"><a href="#File-Header-记录页的一些头信息，共占用38字节，组成部分如" class="headerlink" title="File Header 记录页的一些头信息，共占用38字节，组成部分如:"></a>File Header 记录页的一些头信息，共占用38字节，组成部分如:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_SPACE_OR_CHKSUM	4	当mysql4.0.14之前，值是0，之后该值代表页的checksum值</span><br><span class="line">FIL_PAGE_OFFSET	        4	表空间中页的偏移量。。如某独立表空间a.ibd的大小为1GB，如果页的大小为16KB，那么总共有65536个页。</span><br><span class="line">                            FILE_PAGE_OFFSET表示该页在所有页中的位置。若此表空间的ID为10，那么搜索页（10，1）就表示查找表a中的第二页</span><br><span class="line">FIL_PAGE_PREV	        4	该页的上一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_NEXT	        4	该页的下一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_LSN	        8	该页最后被修改的LSN日志序列位置（Log Sequence Number）</span><br><span class="line">FIL_PAGE_TYPE	        2	该页的类型，0x45BF为数据页,实际行记录的存储空间</span><br><span class="line">FIL_PAGE_FILE_FLUSH_LSN	8	独立表空间中为0，如在系统表空间表示一个页的定义，代表文件至少被更新到了该LSN值</span><br><span class="line">FIL_PAGE_ARCH_LOG_NO	4	从4.1开始，该页属于哪一个表空间</span><br></pre></td></tr></table></figure>

<h5 id="页类型【innodb存储引擎中】"><a href="#页类型【innodb存储引擎中】" class="headerlink" title="页类型【innodb存储引擎中】"></a>页类型【innodb存储引擎中】</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_INDEX          0x45BF  数据页，B+树叶节点，索引页的叶子结点的data就是数据，如聚集索引存储的行数据，辅助索引存储的主键值。</span><br><span class="line">FIL_PAGE_UNDO_LOG	    0x0002  Undo页（Undo Log Page）</span><br><span class="line">FIL_PAGE_INODE	        0x0003  索引节点</span><br><span class="line">FIL_PAGE_IBUF_FREE_LIST 0x0004  插入缓冲空闲列表页（Insert Buffer Free List）</span><br><span class="line">FIL_PAGE_TYPE_ALLOCATED 0x0000  最新分配</span><br><span class="line">FIL_PAGE_IBUF_BITMAP	0x0005  插入缓冲位图页（Insert Buffer Bitmap）。用于记录 change buffer的使用情况。</span><br><span class="line">FIL_PAGE_TYPE_SYS       0x0006  系统页（System Page）</span><br><span class="line">FIL_PAGE_TYPE_TRX_SYS   0x0007  事务数据页（Transaction system Page）</span><br><span class="line">FIL_PAGE_TYPE_FSP_HDR   0x0008  File Space Header，主要用于跟踪表空间，空闲链表、碎片页以及区等信息。</span><br><span class="line">FIL_PAGE_TYPE_XDES      0x0009  扩展描述也</span><br><span class="line">FIL_PAGE_TYPE_BLOB      0x000A  BLOB Page</span><br></pre></td></tr></table></figure>
<ul>
<li><p>FIL_PAGE_INODE：用于记录文件段(FSEG)的信息，每页有85个INODE entry，每个INODE entry占用192字节，用于描述一个文件段。每个INODE entry包括文件段ID、属于该段的区的信息以及碎片页数组。区信息包括 FREE(完全空闲的区), NOT_FULL(至少使用了一个页的区), FULL(没空闲页的区)三种类型的区的List Base Node(包含链表长度和头尾页号和偏移的结构体)。碎片页数组则是不同于分配整个区的单独分配的32个页。</p>
</li>
<li><p>FIL_PAGE_TYPE_FSP_HDR 页：用于存储区的元信息。<br>ibd文件的第一页 FSP_HDR 页通常就用于存储区的元信息，里面的256个 XDES(extent descriptors) 项存储了256个区的元信息，包括区的使用情况和区里面页的使用情况。</p>
<p>更多 参看 附表 </p>
</li>
</ul>
<h4 id="Page-Header：记录数据页的状态信息，共占56个字节，组成部分如图："><a href="#Page-Header：记录数据页的状态信息，共占56个字节，组成部分如图：" class="headerlink" title="Page Header：记录数据页的状态信息，共占56个字节，组成部分如图："></a>Page Header：记录数据页的状态信息，共占56个字节，组成部分如图：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">PAGE_N_DIR_SLOTS	2	在Page Directory中Slot的数量，初始值为2</span><br><span class="line">PAGE_HEAP_TOP	    2	堆中第一个记录的指针,记录在页中是根据堆的形式存放</span><br><span class="line">PAGE_N_HEAP	        2	堆中的记录数，初始值为2，但是第15位表示行记录格式</span><br><span class="line">PAGE_FREE	        2	指向可重用空间的首指针</span><br><span class="line">PAGE_GARBAGE	    2	已标记为删除（deleted_flag）的记录的字节数</span><br><span class="line">PAGE_LAST_INSERT	2	最后插入记录的位置</span><br><span class="line">PAGE_DIRECTION	    2	最后插入的方向，PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0X03),PAGE_SAME_PAGE(0X04),PAGE_NO_DIRECTION(0x05)</span><br><span class="line">PAGE_N_DIRECTION	2	一个方向上连续插入记录的数量</span><br><span class="line">PAGE_N_RECS	        2	该页中记录（User Record）的数量</span><br><span class="line">PAGE_MAX_TRX_ID	    8	修改该页的最大事务ID（仅在辅助索引中定义）</span><br><span class="line">PAGE_LEVEL	        2	该页在索引树中位置，0000代表叶子节点</span><br><span class="line">PAGE_INDEX_ID	    8	索引ID，表示该页属于哪个索引</span><br><span class="line">PAGE_BTR_SEG_LEAF	10	B+Tree叶子节点所在Leaf Node Segment的Segment Header（无关紧要）</span><br><span class="line">PAGE_BTR_SEG_TOP	10	B+Tree非叶子节点所在Non-Leaf Node Segment的Segment Header（无关紧要）</span><br></pre></td></tr></table></figure>

<h4 id="infimum和supermum-record"><a href="#infimum和supermum-record" class="headerlink" title="infimum和supermum record"></a>infimum和supermum record</h4><ul>
<li>每个数据页中都有两个虚拟的行记录，用来限定记录（User Record）的边界（Infimum为下界，Supremum为上界）</li>
<li>Infimum和Supremum在页被创建是自动创建，不会被删除</li>
<li>在Compact和Redundant行记录格式下，Infimum和Supremum占用的字节数是不一样的<br><img src="/images/post/db-mysql/insupermum.jpg" alt=""></li>
<li>5.1后有Compact（默认）和Redundant两种格式<ul>
<li>Compact行记录格式<br>设计目标为高效存放数据，行数据越多，性能越高。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变长字段长度列表    |   NULL标志位     |   记录头信息   |   列1数据    |   列2数据    |   ……  |</span><br></pre></td></tr></table></figure>
<ul>
<li>变长字段长度列表，按照列的顺序逆序放置。列长度小于255字节，用1字节表示，大于255字节，则用2个字节表示</li>
<li>NULL标志位，一个字节，表示对应列为NULL</li>
<li>记录头信息，5个字节，含义见下表</li>
<li>下面即为数据列，NULL不占用存储空间</li>
<li>每行除了用户定义的列，还有两个隐藏列，事务ID列（6字节）和回滚指针列（7字节），若没有定义主键，每行还会有一个6字节的RowID列<figure class="highlight plain"><figcaption><span>Compact行记录格式</span></figcaption><table><tr><td class="code"><pre><span class="line">名称          大小（bit） 描述</span><br><span class="line">（）          1           未知</span><br><span class="line">（）          1           未知</span><br><span class="line">deleted_flag  1         该行是否被删除</span><br><span class="line">min_rec_flag  1         为1，如果该记录是预先被定义为最小的记录</span><br><span class="line">n_owned       4         该记录拥有的记录数</span><br><span class="line">heap_no       13        索引堆中该条记录的排序记录</span><br><span class="line">record_type   3         记录类型 000&#x3D;普通 001&#x3D;B+树节点指针 010-Infimum 011&#x3D;Supremum 1xx&#x3D;保留</span><br><span class="line">next_recorder 16        页中下一条记录的相对位置</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Redundant行记录格式</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字段长度偏移列表    |   记录头信息   |   列1数据    |   列2数据    |   ……  |</span><br></pre></td></tr></table></figure>
<ul>
<li>字段长度偏移列表，按照列的顺序逆序放置。列长度小于255字节，用1字节表示，大于255字节，则用2个字节表示</li>
<li>记录头信息，固定占用6个字节，含义见下表。n_fields、1byte_offs_flag两个值值得注意</li>
<li>数据列，varchar的NULL值不占用存储空间，但是char值需要占用空间</li>
</ul>
<figure class="highlight plain"><figcaption><span>Compact行记录格式</span></figcaption><table><tr><td class="code"><pre><span class="line">名称          大小（bit） 描述</span><br><span class="line">（）          1           未知</span><br><span class="line">（）          1           未知</span><br><span class="line">deleted_flag  1         该行是否被删除</span><br><span class="line">min_rec_flag  1         为1，如果该记录是预先被定义为最小的记录</span><br><span class="line">n_owned       4         该记录拥有的记录数</span><br><span class="line">heap_no       13        索引堆中该条记录的排序记录</span><br><span class="line">lbyte_offs_flag 1       偏移列表为1字节还是2字节</span><br><span class="line">next_recorder 16        页中下一条记录的相对位置</span><br></pre></td></tr></table></figure>

<h4 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h4><ul>
<li>存储实际插入的行记录</li>
<li>在Page Header中PAGE_HEAP_TOP、PAGE_N_HEAP的HEAP，实际上指的是Unordered User Record List<ul>
<li>InnoDB不想每次都依据B+Tree键的顺序来插入新行，因为这可能需要移动大量的数据</li>
<li>因此InnoDB插入新行时，通常是插入到当前行的后面（Free Space的顶部）或者是已删除行留下来的空间</li>
</ul>
</li>
<li>为了保证访问B+Tree记录的顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表</li>
</ul>
<h4 id="Free-Space"><a href="#Free-Space" class="headerlink" title="Free Space"></a>Free Space</h4><ul>
<li>空闲空间，数据结构是链表，在一个记录被删除后，该空间会被加入到空闲链表中</li>
</ul>
<h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><ul>
<li>存放着行记录（User Record）的相对位置（不是偏移量）</li>
<li>这里的行记录指针称为Slot或Directory Slot，每个Slot占用2Byte</li>
<li>并不是每一个行记录都有一个Slot，一个Slot中可能包含多条行记录，通过行记录中n_owned字段标识</li>
<li>Infimum的n_owned总是1，Supremum的n_owned为[1,8]，User Record的n_owned为[4,8]</li>
<li>Slot是按照索引键值的顺序进行逆序存放（Infimum是下界，Supremum是上界），可以利用二分查找快速地定位一个粗略的结果，然后再通过next_record进行精确查找</li>
<li>B+Tree索引本身并不能直接找到具体的一行记录，只能找到该行记录所在的页<ul>
<li>数据库把页载入到内存中，然后通过Page Directory再进行二分查找</li>
<li>二分查找时间复杂度很低，又在内存中进行查找，这部分的时间基本开销可以忽略</li>
</ul>
</li>
</ul>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><ul>
<li>总共8 Bytes，为了检测页是否已经完整地写入磁盘</li>
<li>变量innodb_checksums，InnoDB从磁盘读取一个页时是否会检测页的完整性</li>
<li>变量innodb_checksum_algorithm，检验和算法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_END_LSN	8	前4Bytes与File Header中的FIL_PAGE_SPACE一致，后4Bytes与File Header中的FIL_PAGE_LSN的后4Bytes一致</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE 'innodb_checksums';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| innodb_checksums | ON    |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'innodb_checksum_algorithm'</span>;</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| innodb_checksum_algorithm | crc32 |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/images/post/db-mysql/index-page-extents1.jpg" alt=""></p>
<ol>
<li><p>每个簇里有64个页面，都会进行编号，页面就是最小的存储单元了。在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。</p>
</li>
<li><p>在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；</p>
<ul>
<li>一个页面16K，放主键如int型能放几千，放一行数据，如1K一行，能放十几行。</li>
<li>这里需要注意，一行数据尽量不要过大，一旦跨page，就会对性能产生影响。本来一个page就能查出来，结果每次要查2个page，那性能就丢了一倍。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><figcaption><span>官网</span></figcaption><table><tr><td class="code"><pre><span class="line">Pages, Extents, Segments, and Tablespaces</span><br><span class="line"></span><br><span class="line">Each tablespace consists of database pages. Every tablespace in a MySQL instance has the same page size. By default, all tablespaces have a page size of 16KB; you can reduce the page size to 8KB or 4KB by specifying the innodb_page_size option when you create the MySQL instance. You can also increase the page size to 32KB or 64KB. For more information, refer to the innodb_page_sizedocumentation.</span><br><span class="line"></span><br><span class="line">The pages are grouped into extents of size 1MB for pages up to 16KB in size (64 consecutive 16KB pages, or 128 8KB pages, or 256 4KB pages). For a page size of 32KB, extent size is 2MB. For page size of 64KB, extent size is 4MB. The “files” inside a tablespace are called segments in InnoDB. (These segments are different from the rollback segment, which actually contains many tablespace segments.)</span><br><span class="line"></span><br><span class="line">When a segment grows inside the tablespace, InnoDB allocates the first 32 pages to it one at a time. After that, InnoDB starts to allocate whole extents to the segment. InnoDB can add up to 4 extents at a time to a large segment to ensure good sequentiality of data.</span><br><span class="line"></span><br><span class="line">Two segments are allocated for each index in InnoDB. One is for nonleaf nodes of the B-tree, the other is for the leaf nodes. Keeping the leaf nodes contiguous on disk enables better sequential I&#x2F;O operations, because these leaf nodes contain the actual table data.</span><br><span class="line"></span><br><span class="line">Some pages in the tablespace contain bitmaps of other pages, and therefore a few extents in an InnoDB tablespace cannot be allocated to segments as a whole, but only as individual pages.</span><br></pre></td></tr></table></figure>

<h1 id="表空间ibd与页关系"><a href="#表空间ibd与页关系" class="headerlink" title="表空间ibd与页关系"></a>表空间ibd与页关系</h1><p>一个表，占用一个表空间，创建一个表空间时，至少有一个文件（0号文件），这个文件的第一个页面page，page_no=0，这个page中存储了这个表空间中，所有段、簇、页管理的入口。</p>
<p>InnoDB表空间文件.ibd文件内部存储单元是页，初始大小为 96K，而InnoDB默认页大小为 16K。当然页大小也可以通过 innodb_page_size 配置为 4K, 8K…64K 等。</p>
<p>如果用二进制打开，以16K划分一页。在ibd文件中，0-16KB偏移量即为0号数据页，16KB-32KB的为1号数据页，以此类推。</p>
<h2 id="ibd文件存储结构【页】"><a href="#ibd文件存储结构【页】" class="headerlink" title="ibd文件存储结构【页】"></a>ibd文件存储结构【页】</h2><ol>
<li>图形<br><img src="/images/post/db-mysql/ibdfile.webp" alt=""><br>更为抽象一点的<br><img src="/images/post/db-mysql/index-page-extents2.png" alt=""></li>
<li>sql查询<br>可以在 innodb_sys_tables 表中查到表t的表空间ID为 36，然后可以在 innodb_buffer_page查到所有页信息，一共4个页。<br>分别是 FSP_HDR, IBUF_BITMAP, INODE, INDEX。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table15w'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_buffer_page <span class="keyword">where</span> <span class="keyword">SPACE</span>=<span class="number">36</span>;</span><br></pre></td></tr></table></figure></li>
<li>实际文件结构：</li>
</ol>
<ul>
<li>第0页是 FSP_HDR 页，主要用于跟踪表空间，空闲链表、碎片页以及区等信息。</li>
<li>第1页是 IBUF_BITMAP 页，保存Change Buffer的位图。</li>
<li>第2页是 INODE 页，用于存储区和单独分配的碎片页信息，包括FULL、FREE、NOT_FULL 等页列表的基础结点信息(基础结点信息记录了列表的起始和结束页号和偏移等)，这些结点指向的是 FSP_HDR 页中的项，用于记录页的使用情况，它们之间关系如下图所示。</li>
<li>第3页开始是索引页 INDEX(B-tree node)，从 0xc000(每页16K) 开始，后面还有些分配的未使用的页。</li>
</ul>
<h1 id="表空间文件ibd-页类型-实操说明"><a href="#表空间文件ibd-页类型-实操说明" class="headerlink" title="表空间文件ibd-页类型-实操说明"></a>表空间文件ibd-页类型-实操说明</h1><h2 id="FSP-HDR-PAGE【File-Space-Header-Page】"><a href="#FSP-HDR-PAGE【File-Space-Header-Page】" class="headerlink" title="FSP_HDR PAGE【File Space Header Page】"></a>FSP_HDR PAGE【File Space Header Page】</h2><p>数据文件.ibd的第一个Page类型为FIL_PAGE_TYPE_FSP_HDR，在创建一个新的表空间时进行初始化(fsp_header_init)，</p>
<p>该page同时用于跟踪随后的256个Extent(约256MB文件大小)的空间管理，所以每隔256MB就要创建一个类似的数据页，类型为FIL_PAGE_TYPE_XDES ，XDES Page除了文件头部外，</p>
<p>其他都和FSP_HDR页具有相同的数据结构，可以称之为Extent描述页，每个Extent占用40个字节，一个XDES Page最多描述256个Extent。</p>
<p>FSP_HDR页的头部使用FSP_HEADER_SIZE个字节来记录文件的相关信息，具体的包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">FSP_SPACE_ID	4	该文件对应的space id</span><br><span class="line">FSP_NOT_USED	4	如其名，保留字节，当前未使用</span><br><span class="line">FSP_SIZE	4	当前表空间总的PAGE个数，扩展文件时需要更新该值（fsp_try_extend_data_file_with_pages）</span><br><span class="line">FSP_FREE_LIMIT	4	当前尚未初始化的最小Page No。从该Page往后的都尚未加入到表空间的FREE LIST上。</span><br><span class="line">FSP_SPACE_FLAGS	4	当前表空间的FLAG信息，见下文</span><br><span class="line">FSP_FRAG_N_USED	4	FSP_FREE_FRAG链表上已被使用的Page数，用于快速计算该链表上可用空闲Page数</span><br><span class="line">FSP_FREE	16	当一个Extent中所有page都未被使用时，放到该链表上，可以用于随后的分配</span><br><span class="line">FSP_FREE_FRAG	16	FREE_FRAG链表的Base Node，通常这样的Extent中的Page可能归属于不同的segment，用于segment frag array page的分配（见下文）</span><br><span class="line">FSP_FULL_FRAG	16	Extent中所有的page都被使用掉时，会放到该链表上，当有Page从该Extent释放时，则移回FREE_FRAG链表</span><br><span class="line">FSP_SEG_ID	8	当前文件中最大Segment ID + 1，用于段分配时的seg id计数器</span><br><span class="line">FSP_SEG_INODES_FULL	16	已被完全用满的Inode Page链表</span><br><span class="line">FSP_SEG_INODES_FREE	16	至少存在一个空闲Inode Entry的Inode Page被放到该链表上</span><br></pre></td></tr></table></figure>
<p>第一页的 前38字节</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C  -n 38 table5hang.ibd</span><br><span class="line">00000000  ff 64 a5 b7 00 00 00 00  00 00 00 00 00 00 00 00  |.d..............|</span><br><span class="line">00000010  00 00 00 00 80 eb 9d 23  00 08 00 00 00 00 00 00  |.......<span class="comment">#........|</span></span><br><span class="line">00000020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00000026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<p>通过 ：File Header 记录页的一些头信息 参看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">FIL_PAGE_SPACE_OR_CHKSUM	4	ff 64 a5 b7：checksum值</span><br><span class="line">FIL_PAGE_OFFSET	        4	00 00 00 00：表空间中页的偏移量</span><br><span class="line">FIL_PAGE_PREV	        4	00 00 00 00：该页的上一个页</span><br><span class="line">FIL_PAGE_NEXT	        4	00 00 00 00：该页的下一个页，B+tree特性决定了叶子节点必须是双向列表</span><br><span class="line">FIL_PAGE_LSN	        8	00 00 00 00 80 eb 9d 23：该页最后被修改的LSN日志序列位置（Log Sequence Number）</span><br><span class="line">FIL_PAGE_TYPE	        2	00 08：&#x3D; FSP_HDR 该页的类型，</span><br><span class="line">FIL_PAGE_FILE_FLUSH_LSN	8	00 00 00 00 00 00 00 00 ：独立表空间中为0</span><br><span class="line">FIL_PAGE_ARCH_LOG_NO	4	00 00 00 2c：&#x3D;2*16+12&#x3D;44 该页属于哪一个表空间，与上文sql 查询一致</span><br></pre></td></tr></table></figure>

<h2 id="IBUF-BITMAP-Page"><a href="#IBUF-BITMAP-Page" class="headerlink" title="IBUF_BITMAP Page"></a>IBUF_BITMAP Page</h2><p>第2个page类型为FIL_PAGE_IBUF_BITMAP，主要用于跟踪随后的每个page的change buffer信息，使用4个bit来描述每个page的change buffer信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">IBUF_BITMAP_FREE	2	使用2个bit来描述page的空闲空间范围：0（0 bytes）、1（512 bytes）、2（1024 bytes）、3（2048 bytes）</span><br><span class="line">IBUF_BITMAP_BUFFERED	1	是否有ibuf操作缓存</span><br><span class="line">IBUF_BITMAP_IBUF	1	该Page本身是否是Ibuf Btree的节点</span><br></pre></td></tr></table></figure>
<p>由于bitmap page的空间有限，同样每隔256个Extent Page之后，也会在XDES PAGE之后创建一个ibuf bitmap page。</p>
<p>offsets:16<em>1024</em>1=16384</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 16384 -n 38 table5hang.ibd</span><br><span class="line">00004000  a0 58 07 7e 00 00 00 01  00 00 00 00 00 00 00 00  |.X.~............|</span><br><span class="line">00004010  00 00 00 00 80 eb 93 80  00 05 00 00 00 00 00 00  |................|</span><br><span class="line">00004020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00004026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前 38也是  File Header<br>00 05 : FIL_PAGE_IBUF_BITMAP    0x0005  插入缓冲位图页（Insert Buffer Bitmap）。用于记录 change buffer的使用情况。 </p>
<h2 id="FIL-PAGE-INODE"><a href="#FIL-PAGE-INODE" class="headerlink" title="FIL_PAGE_INODE"></a>FIL_PAGE_INODE</h2><p>数据文件的第3个page的类型为FIL_PAGE_INODE，用于管理数据文件中的segement，每个索引占用2个segment，分别用于管理叶子节点和非叶子节点。</p>
<p>每个inode页可以存储FSP_SEG_INODES_PER_PAGE（默认为85）个记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_INODE_PAGE_NODE	12	INODE页的链表节点，记录前后Inode Page的位置，BaseNode记录在头Page的FSP_SEG_INODES_FULL或者FSP_SEG_INODES_FREE字段。</span><br><span class="line">Inode Entry 0	192	Inode记录</span><br><span class="line">Inode Entry 1	 	 </span><br><span class="line">……	 	 </span><br><span class="line">Inode Entry 84</span><br></pre></td></tr></table></figure>
<p>每个Inode Entry的结构如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_ID	8	该Inode归属的Segment ID，若值为0表示该slot未被使用</span><br><span class="line">FSEG_NOT_FULL_N_USED	8	FSEG_NOT_FULL链表上被使用的Page数量</span><br><span class="line">FSEG_FREE	16	完全没有被使用并分配给该Segment的Extent链表</span><br><span class="line">FSEG_NOT_FULL	16	至少有一个page分配给当前Segment的Extent链表，全部用完时，转移到FSEG_FULL上，全部释放时，则归还给当前表空间FSP_FREE链表</span><br><span class="line">FSEG_FULL	16	分配给当前segment且Page完全使用完的Extent链表</span><br><span class="line">FSEG_MAGIC_N	4	Magic Number</span><br><span class="line">FSEG_FRAG_ARR 0	4	属于该Segment的独立Page。总是先从全局分配独立的Page，当填满32个数组项时，就在每次分配时都分配一个完整的Extent，并在XDES PAGE中将其Segment ID设置为当前值</span><br><span class="line">……	……	 </span><br><span class="line">FSEG_FRAG_ARR 31	4	总共存储32个记录项</span><br></pre></td></tr></table></figure>

<p>offsets:16<em>1024</em>2=32768</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 32768 -n 38 table5hang.ibd</span><br><span class="line">00008000  86 d5 41 60 00 00 00 02  00 00 00 00 00 00 00 00  |..A ............|</span><br><span class="line">00008010  00 00 00 00 80 eb 9d 23  00 03 00 00 00 00 00 00  |.......<span class="comment">#........|</span></span><br><span class="line">00008020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">00008026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前 38也是  File Header<br>00 03 : 索引节点 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_INODE_PAGE_NODE	12	INODE页的链表节点，记录前后Inode Page的位置，BaseNode记录在头Page的FSP_SEG_INODES_FULL或者FSP_SEG_INODES_FREE字段。</span><br><span class="line">Inode Entry 0	192	Inode记录</span><br><span class="line">Inode Entry 1	 	 </span><br><span class="line">……	 	 </span><br><span class="line">Inode Entry 84</span><br></pre></td></tr></table></figure>
<p>每个Inode Entry的结构如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bits	Desc</span><br><span class="line">FSEG_ID	8	该Inode归属的Segment ID，若值为0表示该slot未被使用</span><br><span class="line">FSEG_NOT_FULL_N_USED	8	FSEG_NOT_FULL链表上被使用的Page数量</span><br><span class="line">FSEG_FREE	16	完全没有被使用并分配给该Segment的Extent链表</span><br><span class="line">FSEG_NOT_FULL	16	至少有一个page分配给当前Segment的Extent链表，全部用完时，转移到FSEG_FULL上，全部释放时，则归还给当前表空间FSP_FREE链表</span><br><span class="line">FSEG_FULL	16	分配给当前segment且Page完全使用完的Extent链表</span><br><span class="line">FSEG_MAGIC_N	4	Magic Number</span><br><span class="line">FSEG_FRAG_ARR 0	4	属于该Segment的独立Page。总是先从全局分配独立的Page，当填满32个数组项时，就在每次分配时都分配一个完整的Extent，并在XDES PAGE中将其Segment ID设置为当前值</span><br><span class="line">……	……	 </span><br><span class="line">FSEG_FRAG_ARR 31	4	总共存储32个记录项</span><br></pre></td></tr></table></figure>


<h2 id="Index-索引页"><a href="#Index-索引页" class="headerlink" title="Index 索引页"></a>Index 索引页</h2><p>需要跳过3页面，即 49152，索引页 结构也符合基础页结构。</p>
<p><img src="/images/post/db-mysql/index-struct.webp" alt=""></p>
<p>同上述步骤类似</p>
<h3 id="FIL-Header（38字节-记录文件头信息。"><a href="#FIL-Header（38字节-记录文件头信息。" class="headerlink" title="FIL Header（38字节): 记录文件头信息。"></a>FIL Header（38字节): 记录文件头信息。</h3><p>offsets:16<em>1024</em>3=49152</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49152 -n 38 table5hang.ibd</span><br><span class="line">0000c000  3b 03 ff eb 00 00 00 03  ff ff ff ff ff ff ff ff  |;...............|</span><br><span class="line">0000c010  00 00 00 00 80 eb af c9  45 bf 00 00 00 00 00 00  |........E.......|</span><br><span class="line">0000c020  00 00 00 00 00 2c                                 |.....,|</span><br><span class="line">0000c026</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>前4字节 3b 03 ff eb 是 checksum，接着4个 00 00 00 03 是页偏移值 3，即这是第2+1页。【数组下标方式，这是真实的第四页】</p>
<p>接着 4 字节是上一页偏移值，ff ff ff ff 第一个数据页 无上一页，接着 4 字节是下一页偏移值 ff ff ff ff 无下一页。</p>
<p>然后 8 字节 00 00 00 00 80 eb af c9 是日志序列号 LSN。</p>
<p>随后的 2 字节 45 bf 是页类型，代表是 INDEX 页。</p>
<p>接着 8 字节 00 00 00 00 00 00 00 00 表示被更新到的LSN，在 File-Per-Table 表空间中都是0。</p>
<p>然后 4 字节 00 00 00 2c 表示该数据页属于的表t的表空间ID是 0x2c(44)。 与上文sql 查询一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table5hang'</span></span><br></pre></td></tr></table></figure>

<h3 id="PageHeader-INDEX-Header（56字节-记录的是-INDEX-页的状态信息"><a href="#PageHeader-INDEX-Header（56字节-记录的是-INDEX-页的状态信息" class="headerlink" title="PageHeader-INDEX Header（56字节): 记录的是 INDEX 页的状态信息"></a>PageHeader-INDEX Header（56字节): 记录的是 INDEX 页的状态信息</h3><p>offsets:16<em>1024</em>3+38=49190</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49190 -n 56 table5hang.ibd</span><br><span class="line">0000c026  00 02 01 36 80 07 00 00  00 00 01 17 00 02 00 04  |...6............|</span><br><span class="line">0000c036  00 05 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">0000c046  00 00 00 3c 00 00 00 2c  00 00 00 02 00 f2 00 00  |...&lt;...,........|</span><br><span class="line">0000c056  00 2c 00 00 00 02 00 32                           |.,.....2|</span><br><span class="line">0000c05e</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名称	大小（Bytes）	描述</span><br><span class="line">PAGE_N_DIR_SLOTS	2	00 02：在Page Directory中Slot的数量，初始值为2</span><br><span class="line">PAGE_HEAP_TOP	    2	01 36：堆中第一个记录的指针,记录在页中是根据堆的形式存放</span><br><span class="line">PAGE_N_HEAP	        2	80 07：堆中的记录数，初始值为2，但是第15位表示行记录格式</span><br><span class="line">PAGE_FREE	        2	00 00：指向可重用空间的首指针</span><br><span class="line">PAGE_GARBAGE	    2	00 00：已标记为删除（deleted_flag）的记录的字节数</span><br><span class="line">PAGE_LAST_INSERT	2	01 17：最后插入记录的位置</span><br><span class="line">PAGE_DIRECTION	    2	00 02：最后插入的方向，PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0X03),PAGE_SAME_PAGE(0X04),PAGE_NO_DIRECTION(0x05)</span><br><span class="line">PAGE_N_DIRECTION	2	00 04：一个方向上连续插入记录的数量</span><br><span class="line">PAGE_N_RECS	        2	00 05：该页中记录（User Record）的数量</span><br><span class="line">PAGE_MAX_TRX_ID	    8	00 00 00 00 00 00  00 00：修改该页的最大事务ID（仅在辅助索引中定义）</span><br><span class="line">PAGE_LEVEL	        2	00 00：该页在索引树中位置，0000代表叶子节点</span><br><span class="line">PAGE_INDEX_ID	    8	00 00 00 00 00 00 00 3c：索引ID，表示该页属于哪个索引</span><br><span class="line">PAGE_BTR_SEG_LEAF	10	00 00 00 2c 00 00 00 02 00 f2：B+Tree叶子节点所在Leaf Node Segment的Segment Header（无关紧要）</span><br><span class="line">PAGE_BTR_SEG_TOP	10	00 00 00 2c 00 00 00 02 00 32：B+Tree非叶子节点所在Non-Leaf Node Segment的Segment Header（无关紧要）</span><br></pre></td></tr></table></figure>
<p>PAGE_INDEX_ID = 3c =3*16+12=60  索引ID可以在information_schema.INNODB_SYS_INDEXES 中查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.INNODB_SYS_INDEXES </span><br><span class="line"><span class="keyword">where</span> TABLE_ID <span class="keyword">in</span> (<span class="keyword">SELECT</span> TABLE_ID <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table5hang'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index_id    name    table_id    type    n_fields    page_no space</span><br><span class="line">60          PRIMARY 58          3       1           3       44</span><br></pre></td></tr></table></figure>

<p>PAGE_BTR_SEG_LEAF和PAGE_BTR_SEG_TOP INDEX页中的根结点才有的，非根结点的为0。<br>前10字节 00 00 00 2c 00 00 00 02 00 f2 是叶子结点所在段的segment header，分别记录了叶子结点的表空间ID 0x24，INODE页的页号 2 和 INODE项偏移 0xf2。<br>后10字节 00 00 00 2c 00 00 00 02 00 32 是非叶子结点所在段的segment header，偏移分别是0xf2 和 0x32，即INODE页的前2个Entry，文件段ID分别是1和2。<br>FSEG Header中存储了该 INDEX 页的INODE项，INODE项里面则记录了该页存储所在的文件段以及文件段页的使用情况。对于 File-Per-Table情况下，每个单独的表空间文件的 FSP_HDR 页负责管理页使用情况。</p>
<p><img src="/images/post/db-mysql/fseg.webp" alt=""></p>
<h3 id="System-Records-26字节-infimum和supermum-record"><a href="#System-Records-26字节-infimum和supermum-record" class="headerlink" title="System Records(26字节)-infimum和supermum record"></a>System Records(26字节)-infimum和supermum record</h3><p>offset:16<em>1024</em>3+38+56 = 49246</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49246 -n 60 table5hang.ibd</span><br><span class="line">0000c05e  01 00 02 00 1c 69 6e 66  69 6d 75 6d 00 06 00 0b  |.....infimum....|</span><br><span class="line">0000c06e  00 00 73 75 70 72 65 6d  75 6d 06 00 00 00 10 00  |..supremum......|</span><br><span class="line">0000c07e  26 80 00 00 00 00 00 00  01 00 00 00 00 74 d0 9e  |&amp;............t..|</span><br><span class="line">0000c08e  00 00 01 57 01 10 6e 61  6d 65 2d 31              |...W..name-1|</span><br><span class="line">0000c09a</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 00 02 00 1c 69 6e 66 69 6d 75 6d 00 |.....infimum....|</span><br><span class="line">06 00 0b 00 00 73 75 70 72 65 6d 75 6d |..supremum......|</span><br></pre></td></tr></table></figure>
<p>每个 INDEX 页都有两条虚拟记录 infimum 和 supremum，用于限定记录的边界，各占 13 个字节。<br>其中记录头的5个字节分别标识了拥有记录的数目和类型(拥有记录数目是即后面页目录部分的owned值，当前页目录只有两个槽，infimum拥有记录数只有它自己为1，<br>而supremum拥有我们插入的5条记录和它自己，故为6)、下一条记录的偏移 0x1c=28 向后【当前位置】偏移 28个，即位置是 0xC062+0x1c=0xc07e 的后一个 0xco7f，这就是我们实际数据记录开始位置。<br>后面8个字节为 infimum + 空值，supremum类似，只是它下一条记录偏移为0。</p>
<h3 id="User-Records-1"><a href="#User-Records-1" class="headerlink" title="User Records"></a>User Records</h3><p>offset:16<em>1024</em>3+38+56 +26 = 49272</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 49272 -n 1000 table5hang.ibd</span><br><span class="line">0000c078  06 00 00 00 10 00 26 80  00 00 00 00 00 00 01 00  |......&amp;.........|</span><br><span class="line">0000c088  00 00 00 74 d0 9e 00 00  01 57 01 10 6e 61 6d 65  |...t.....W..name|</span><br><span class="line">0000c098  2d 31 80 00 00 01 06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line">0000c0a8  00 00 00 00 02 00 00 00  00 74 d0 9e 00 00 01 57  |.........t.....W|</span><br><span class="line">0000c0b8  01 20 6e 61 6d 65 2d 32  80 00 00 02 06 00 00 00  |. name-2........|</span><br><span class="line">0000c0c8  20 00 26 80 00 00 00 00  00 00 03 00 00 00 00 74  | .&amp;............t|</span><br><span class="line">0000c0d8  d0 9e 00 00 01 57 01 30  6e 61 6d 65 2d 33 80 00  |.....W.0name-3..|</span><br><span class="line">0000c0e8  00 03 06 00 00 00 28 00  26 80 00 00 00 00 00 00  |......(.&amp;.......|</span><br><span class="line">0000c0f8  04 00 00 00 00 74 d0 9e  00 00 01 57 01 40 6e 61  |.....t.....W.@na|</span><br><span class="line">0000c108  6d 65 2d 34 80 00 00 04  06 00 00 00 30 ff 59 80  |me-4........0.Y.|</span><br><span class="line">0000c118  00 00 00 00 00 00 05 00  00 00 00 74 d0 9e 00 00  |...........t....|</span><br><span class="line">0000c128  01 57 01 50 6e 61 6d 65  2d 35 80 00 00 05 00 00  |.W.Pname-5......|</span><br><span class="line">0000c138  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">0000c458  00 00 00 00 00 00 00 00                           |........|</span><br><span class="line">0000c460</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>查看 行记录格式 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">from</span> test_innodb <span class="keyword">like</span> <span class="string">'table5hang'</span></span><br><span class="line"><span class="comment">--- Compact</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接下来是插入的记录。Compact 【变长字段长度列表 小于255 1字节，大于 255 2】</span><br><span class="line">06  1字节记录的是可变变量的长度06，因为我们记录中c的值是 name-5。</span><br><span class="line">00  1字节记录的是可为NULL的变量是否是NULL，这里不为 NULL，故为0。</span><br><span class="line">记录头：00 00 10 00 26</span><br><span class="line">    Compact行记录格式 头格式</span><br><span class="line">    00  </span><br><span class="line">    00 10 &#x3D; 10110</span><br><span class="line">    00 26 &#x3D; 下一记录相对位置</span><br><span class="line">    后面就是记录内容。第2条记录同理。这里的事务ID可以通过 select * from information_schema.innodb_trx 进行验证。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line">0000c078  06 00 00 00 10 00 26 80  00 00 00 00 00 00 01 00  |......&amp;.........|</span><br><span class="line">0000c088  00 00 00 74 d0 9e 00 00  01 57 01 10 6e 61 6d 65  |...t.....W..name|</span><br><span class="line">0000c098  2d 31 80 00 00 01 06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line"></span><br><span class="line"> 06 00 00 00 10 00 26 # 列长+null标记+记录头</span><br><span class="line"> 80 00 00 00 00 00 00 01   # 主键值1  bigint</span><br><span class="line"> 00 00 00 00 74 d0    # 事务ID</span><br><span class="line"> 9e 00 00 01 57 01 10 # 回滚指针</span><br><span class="line"> 6e 61 6d 65 2d 31    # username的值 name-1  6个字节</span><br><span class="line"> 80 00 00 01          # 列 age &#x3D;1  int 4字节</span><br><span class="line"> </span><br><span class="line">第二行</span><br><span class="line">                            06 00  00 00 18 00 26 80 00 00  |-1..........&amp;...|</span><br><span class="line">0000c0a8  00 00 00 00 02 00 00 00  00 74 d0 9e 00 00 01 57  |.........t.....W|</span><br><span class="line">0000c0b8  01 20 6e 61 6d 65 2d 32  80 00 00 02 06 00 00 00  |. name-2........|</span><br><span class="line"></span><br><span class="line"> 06 00 00 00 18 00 26 # 第2条记录头</span><br><span class="line"> 80 00 00 00 00 00 00 02   # 主键值1  bigint</span><br><span class="line"> 00 00 00 00 74 d0    # 事务ID</span><br><span class="line"> 9e 00 00 01 57 01 20 # 回滚指针</span><br><span class="line"> 6e 61 6d 65 2d 32    # username的值 name-1  6个字节</span><br><span class="line"> 80 00 00 01          # 列 age &#x3D;1  int 4字节</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">![](&#x2F;images&#x2F;post&#x2F;db-mysql&#x2F;bptree.webp)</span><br><span class="line"></span><br><span class="line">### Page Directory(4字节)</span><br><span class="line"></span><br><span class="line">因为页目录的slot只有2个，每个slot占2字节，故页目录为 00 70 00 63 这4字节，存储的是相对于最初行的位置。</span><br><span class="line"></span><br><span class="line">其中 0xc063 正好是 infimum 记录的开始位置，而 0xc070 正好是 supremum 记录的开始位置。使用页目录进行二分查找，可以加速查询，详细见后面分析。</span><br><span class="line"></span><br><span class="line">offset:16*1024*4 - 4 - 8 &#x3D; 65524</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">hexdump -C -s 65524 -n 4 table5hang.ibd</span><br><span class="line">0000fff4  00 70 00 63                                       |.p.c|</span><br><span class="line">0000fff8</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<h3 id="FIL-Tail-8字节"><a href="#FIL-Tail-8字节" class="headerlink" title="FIL Tail (8字节)"></a>FIL Tail (8字节)</h3><p>offset:16<em>1024</em>4 - 8 = 65528</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C -s 65528 -n 8 table5hang.ibd</span><br><span class="line">0000fff8  bd 11 4b e6 80 eb af c9                           |..K.....|</span><br><span class="line">00010000</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>其中 bd 11 4b e6 为 checknum，跟 FIL Header的checksum一样。【没有匹配上，需要继续查看资料】</p>
<p>后4字节80 eb af c9 与 FIL Header的LSN的后4个字节一致。</p>
<h2 id="通过-innodb-ruby-工具来分析表空间文件"><a href="#通过-innodb-ruby-工具来分析表空间文件" class="headerlink" title="通过 innodb_ruby 工具来分析表空间文件"></a>通过 innodb_ruby 工具来分析表空间文件</h2><p>mac安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ruby</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rubygems/rubygems.git</span><br><span class="line"><span class="built_in">cd</span> rubygems/bin/</span><br><span class="line">./gem install innodb_ruby</span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang space-page-type-regions</span><br><span class="line">start       end         count       <span class="built_in">type</span>                </span><br><span class="line">0           0           1           FSP_HDR             </span><br><span class="line">1           1           1           IBUF_BITMAP         </span><br><span class="line">2           2           1           INODE               </span><br><span class="line">3           3           1           INDEX               </span><br><span class="line">4           5           2           FREE (ALLOCATED)    </span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>
<p>查看具体数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innodb_space -s /Users/lihongxu6/docker/mymysql56/data/ibdata1 -T test_innodb/table5hang -p 3 page-records</span><br><span class="line"><span class="comment"># Record 127: (id=1) → (username="name-1", age=1)</span></span><br><span class="line"><span class="comment"># Record 165: (id=2) → (username="name-2", age=2)</span></span><br><span class="line"><span class="comment"># Record 203: (id=3) → (username="name-3", age=3)</span></span><br><span class="line"><span class="comment"># Record 241: (id=4) → (username="name-4", age=4)</span></span><br><span class="line"><span class="comment"># Record 279: (id=5) → (username="name-5", age=5)</span></span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<h2 id="其他-XDES页"><a href="#其他-XDES页" class="headerlink" title="其他-XDES页"></a>其他-XDES页</h2><p>簇或者分区（extent）是段的组成元素，在文件头使用FLAG描述了创建表信息，除此之外其他部分的数据结构和XDES PAGE都是相同的，<br>使用连续数组的方式，每个XDES PAGE最多存储256个XDES Entry，每个Entry占用40个字节，描述64个Page（即一个Extent）。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">XDES_ID	8	如果该Extent归属某个segment的话，则记录其ID</span><br><span class="line">XDES_FLST_NODE	12(FLST_NODE_SIZE)	维持Extent链表的双向指针节点</span><br><span class="line">XDES_STATE	4	该Extent的状态信息，包括：XDES_FREE，XDES_FREE_FRAG，XDES_FULL_FRAG，XDES_FSEG，详解见下文</span><br><span class="line">XDES_BITMAP	16	总共16*8&#x3D; 128个bit，用2个bit表示Extent中的一个page，一个bit表示该page是否是空闲的(XDES_FREE_BIT)，另一个保留位，尚未使用（XDES_CLEAN_BIT）</span><br></pre></td></tr></table></figure>
<p>XDES_STATE表示该Extent的四种不同状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	Desc</span><br><span class="line">XDES_FREE(1)	存在于FREE链表上</span><br><span class="line">XDES_FREE_FRAG(2)	存在于FREE_FRAG链表上</span><br><span class="line">XDES_FULL_FRAG(3)	存在于FULL_FRAG链表上</span><br><span class="line">XDES_FSEG(4)	该Extent归属于ID为XDES_ID记录的值的SEGMENT。</span><br></pre></td></tr></table></figure>
<p>通过XDES_STATE信息，我们只需要一个FLIST_NODE节点就可以维护每个Extent的信息，是处于全局表空间的链表上，还是某个btree segment的链表上。</p>
<h2 id="文件维护"><a href="#文件维护" class="headerlink" title="文件维护"></a>文件维护</h2><p>从上文我们可以看到，InnoDB通过Inode Entry来管理每个Segment占用的数据页，每个segment可以看做一个文件页维护单元。Inode Entry所在的inode page有可能存放满，因此又通过头Page维护了Inode Page链表。</p>
<p>在ibd的第一个Page中还维护了表空间内Extent的FREE、FREE_FRAG、FULL_FRAG三个Extent链表；而每个Inode Entry也维护了对应的FREE、NOT_FULL、FULL三个Extent链表。这些链表之间存在着转换关系，以高效的利用数据文件空间。</p>
<p>注意区别：表空间中的链表管理的是整个表空间中所有的簇，包括满簇、半满簇及空闲簇，而段的iNode信息中管理的是属于自己段中的满簇、半满簇及空闲簇。</p>
<p>当创建一个新的索引时，实际上构建一个新的btree(btr_create)，先为非叶子节点Segment分配一个inode entry，再创建root page，并将该segment的位置记录到root page中，然后再分配leaf segment的Inode entry，并记录到root page中。当删除某个索引后，该索引占用的空间需要能被重新利用起来。</p>
<p>创建一个segment：</p>
<p>函数入口：fseg_create_general。</p>
<ol>
<li><p>根据空间id得到表空间头信息。</p>
</li>
<li><p>从得到的表空间头信息分配Inode:具体实现为读取文件头Page并加锁（fsp_get_space_header），然后开始为其分配Inode Entry(fsp_alloc_seg_inode)。</p>
<p> 为了管理Inode Page，在文件头存储了两个Inode Page链表，一个链接已经用满的inode page，一个链接尚未用满的inode page。如果当前Inode Page的空间使用完了，<br> 就需要再分配一个inode page，并加入到FSP_SEG_INODES_FREE链表上(fsp_alloc_seg_inode_page)。对于独立表空间，通常一个inode page就足够了。</p>
</li>
</ol>
<p>具体查找inode Page过程：首先判断FSP_SEG_INODES_FREE链表是否还有空闲页面，如果有，则从页面的数据存储位置开始扫描，没找一个Inode，先判断是否空闲（空闲表示其不归属任何segment，即FSEG_ID置为0）。<br>找到则返回。找到这个且这个Inode为这个页最后一个Inode.则该inode page中的记录用满了，就从FSP_SEG_INODES_FREE链表上转移到FSP_SEG_INODES_FULL链表。<br>如果FSP_SEG_INODES_FREE没有空闲的Inode页面，则重新分配一个inode页面，分配后把所有描述符里面的FSEG_ID置为0，重复上面过程。</p>
<ol start="3">
<li><p>给新分配的Inode设置SEG_ID. 这个ID号要从表空间头信息的FSP_SEG_ID作为当前segment的seg id写入到inode entry中。同时更新FSP_SEG_ID的值为ID+1，作为下一个段的ID号。</p>
</li>
<li><p>在完成inode entry的提取后，初始化这个Inode信息。把FSEG_NOT_FULL_N_USED置为0，初始化FSEG_FREE、FSEG_NOT_FULL，FSEG_FULL。</p>
</li>
<li><p>从这个段分配出一个页面。（这块逻辑不太懂）</p>
</li>
<li><p>分配好页面后，通过缓存找到段的首页面（页面号为page+index）。就将该inode entry所在inode page的位置及页内偏移量存储到段首页，10个字节的inode信息包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macro	bytes	Desc</span><br><span class="line">FSEG_HDR_SPACE	4	描述该segment的inode page所在的space id （目前的实现来看，感觉有点多余…）</span><br><span class="line">FSEG_HDR_PAGE_NO	4	描述该segment的inode page的page no</span><br><span class="line">FSEG_HDR_OFFSET	2	inode page内的页内偏移量</span><br></pre></td></tr></table></figure>
<p>至此段就分配完成了，以后如果需要在这个段中分配空间，只需要找到其首页，然后根据对应的Inode分配空间。</p>
</li>
</ol>
<p>分配数据页函数 fsp_alloc_free_page</p>
<p>表空间Extent的分配函数fsp_alloc_free_extent。</p>
<p>对应的还有释放Segment 当我们删除索引或者表时，需要删除btree（btr_free_if_exists），先删除除了root节点外的其他部分(btr_free_but_not_root)，再删除root节点(btr_free_root)</p>
<p>由于数据操作都需要记录redo，为了避免产生非常大的redo log，leaf segment通过反复调用函数fseg_free_step来释放其占用的数据页。</p>
<h2 id="创建B-索引"><a href="#创建B-索引" class="headerlink" title="创建B+索引"></a>创建B+索引</h2><p>innodb的文件管理方式，核心目的是为了管理好B+索引。</p>
<p>ibd文件中真正构建起用户数据的结构是BTREE，在你创建一个表时，已经基于显式或隐式定义的主键构建了一个btree，其叶子节点上记录了行的全部列数据（加上事务id列及回滚段指针列）；</p>
<p>如果你在表上创建了二级索引，其叶子节点存储了键值加上聚集索引键值。所以书上贴一段创建B+索引的代码。网上找了5.6.15版本的。</p>
<p>这个函数就是创建一个B+树，只是概念上的，还没有真正的数据写入。</p>
<h1 id="页内-页目录"><a href="#页内-页目录" class="headerlink" title="页内-页目录"></a>页内-页目录</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(<span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>, ch <span class="built_in">varchar</span>(<span class="number">10</span>), <span class="keyword">key</span>(ch));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(ch) <span class="keyword">values</span>(<span class="string">'ab'</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个新的测试表 t2，有主索引 id 和 辅助索引 ch，分析 t2.ibd 文件可验证：</p>
<ul>
<li>对比没有辅助索引的表，表t2多一个INDEX页，用于存储辅助索引的根结点。</li>
<li>辅助索引的INDEX页也有两个系统记录 infimum 和 supremum。而用户记录内容格式跟前面分析基本一致，内容为辅助索引 ch 列的值 ab 和 主键值1。</li>
</ul>
<p>INDEX页内的记录是通过单向链表连接在一起的，遍历列表性能会比较差，而INDEX页的页目录就是为了加速记录搜索。</p>
<p>表 t2 中的页目录只有两项，分别是 0x63 和 0x70，即 99 和 112。</p>
<p>下面的ownedkey为这个页目录槽拥有的小于等于它的记录数目，显然 infimum 的ownedkey为 1，即只有它自己，没有key会比infimum小。</p>
<p>而 supremum 的owned是3，分别是我们插入的两条记录和它自己。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slot    offset  type          owned  key</span><br><span class="line">0       99      infimum       1       </span><br><span class="line">1       112     supremum      3</span><br></pre></td></tr></table></figure>
<p>每个页目录槽最少要包含4个记录，最多包含8个记录(包括它自己)。如果我们在表 t2 中另外插入 7 条记录，则会增加一个新的slot，即 id 为 4 的记录，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slot    offset  type          owned   key</span><br><span class="line">0       99      infimum       1       </span><br><span class="line">1       207     conventional  4       (i&#x3D;4)</span><br><span class="line">2       112     supremum      5</span><br></pre></td></tr></table></figure>
<p>下图是页目录结构图，可以通过页目录的二分查找提高页内数据的查询性能。</p>
<p><img src="/images/post/db-mysql/bptreepagestruct.webp" alt=""></p>
<p>参考：</p>
<p><a href="http://mysql.taobao.org/monthly/2016/02/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/02/01/</a></p>
<p>《MYSQL运维内参》<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html</a></p>
<p>链接：<a href="https://blog.csdn.net/bohu83/article/details/81086474" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/article/details/81086474</a><br><a href="http://mysql.taobao.org/monthly/2016/02/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/02/01/</a></p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>05-存储引擎层-innodb框架-表空间-ibd</title>
    <url>/articles/20200202/20b74871.html</url>
    <content><![CDATA[<p>摘要：<br>innodb文件系统是由一些log和每个表的ibd（16K的整数倍）等文件组成的。内部结构如下。</p>
<a id="more"></a>

<h1 id="表空间-idb简述"><a href="#表空间-idb简述" class="headerlink" title="表空间-idb简述"></a>表空间-idb简述</h1><p>ibd是存表数据的，那么在计算机里，所有的存储都是有最小存储单元的。</p>
<p>在磁盘上，最小的单元是扇区，一个扇区是512字节，操作系统中最小单元是块（block），最小单位是4K。而innodb也有自己的最小存储单元——页（page），一页是16K。</p>
<p>这意味着一个文件放到电脑上，哪怕它是空的，也要占用4K，它占用的空间永远是4K的整数倍。</p>
<p>可以去查看每个ibd文件的大小，它永远是16384（16k）的整数倍。</p>
<p>后续说明索引加载表数据的前提，mysql的数据最小是16K，也就是哪怕你只取一条，可能还不到1K，那么mysql也会取出16K的数据。</p>
<p>因为“页”是最小单位。“页”还决定了b+ tree在某个高度下，能存放的数据量，为什么一个表存2万数据，和存1500万数据，查询速度一样。</p>
<h2 id="单个文件表空间-frm、ibd"><a href="#单个文件表空间-frm、ibd" class="headerlink" title="单个文件表空间-frm、ibd"></a>单个文件表空间-frm、ibd</h2><p>如果想让两个表共用一个数据文件的话,共用一个ibdata，可以通过<strong>innodb_file_per_table</strong>控制。默认每个表一个。</p>
<p>创建了一个数据库test_innodb，并且创建了几个表，可以在数据目录看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.opt</span><br><span class="line">table5hang.frm</span><br><span class="line">table5hang.ibd</span><br><span class="line">table15w.frm</span><br><span class="line">table15w.ibd</span><br><span class="line">table500w.frm</span><br><span class="line">table500w.ibd</span><br><span class="line">table1000w.frm</span><br><span class="line">table1000w.ibd</span><br></pre></td></tr></table></figure>
<p>当新建一个库时，首先文件系统上会多一个以库名命名的文件夹。里面有ibd、frm文件，每个表对应一个ibd文件。</p>
<ul>
<li><p>db.opt 保存了数据库test的默认字符集 utf8mb4 和校验方法utf8mb4_general_ci；<br>存储的是mysql的一些配置信息，如编码、排序的信息，如果在创建数据库时指定了一些非默认参数的话，也会存到该文件。</p>
</li>
<li><p>每个表会对应一个frm文件，一个ibd文件。</p>
<ul>
<li><p>frm文件是表结构，无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。<br>数据字典信息(InnoDB数据字典信息主要是存储在系统表空间ibdata1文件中，由于历史原因才在 t.frm 多保留了一份)</p>
</li>
<li><p>ibd是表的数据和索引，是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p>
</li>
</ul>
</li>
</ul>
<p>独立的表空间文件之存储对应表的B+树数据、索引和插入缓冲等信息，其余信息还是存储在默认表空间中。</p>
<p>这个文件所存储的内容主要就是B+树（索引），一个表可以有多个索引，也就是在一个文件中，可以存储多个索引，而如果一个表没有索引的话，用来存储数据的被称为聚簇索引，也就是说这也是一个索引。</p>
<h3 id="采用-File-Per-Table-的优缺点"><a href="#采用-File-Per-Table-的优缺点" class="headerlink" title="采用 File-Per-Table 的优缺点"></a>采用 File-Per-Table 的优缺点</h3><ul>
<li>优点：可以方便回收删除表所占的磁盘空间。如果使用系统表空间的话，删除表后空闲空间只能被 InnoDB 数据使用。TRUNCATE TABLE 操作会更快。<br>可以单独拷贝表空间数据到其他数据库(使用 transportable tablespace 特性)，可以更方便的观测每个表空间数据的大小。</li>
<li>缺点：fsync 操作需要作用的多个表空间文件，比只对系统表空间这一个文件进行fsync操作会多一些 IO 操作。此外，mysqld需要维护更多的文件描述符。</li>
</ul>
<h2 id="当新建库时，innodb内部操作"><a href="#当新建库时，innodb内部操作" class="headerlink" title="当新建库时，innodb内部操作"></a>当新建库时，innodb内部操作</h2><p>innodb存储引擎在存储设计上模仿了Oracle的存储结构，其数据是按照表空间进行管理的。</p>
<p>新建一个数据库时，innodb存储引擎会初始化一个名为ibdata1 的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表sys_tables、sys_columns、sys_indexes 、sys_fields等。</p>
<p>此外，还会存储用来保证数据完整性的回滚段数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了；</p>
<p>注：不同的表既可以共用一个ibd文件，也可以每个表自己一个ibd文件，默认是一个表一个。</p>
<p>虽然是一个表一个ibd，但这个ibd里只存储了该表的B+树数据、索引、插入缓存等信息，其余的信息如列、属性等信息还是存储在默认的ibdata1里面的。</p>
<figure class="highlight plain"><figcaption><span>官网介绍</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A data file that can hold data for one or more InnoDB tables and associated indexes.</span><br><span class="line"> </span><br><span class="line">The system tablespace contains the InnoDB data dictionary, and prior to MySQL 5.6 holds all other InnoDB tables by default.</span><br><span class="line"> </span><br><span class="line">The innodb_file_per_table option, enabled by default in MySQL 5.6 and higher, allows tables to be created in their own tablespaces.</span><br><span class="line"> </span><br><span class="line">File-per-table tablespaces support features such as efficient storage of off-page columns, table compression, and transportable tablespaces.</span><br><span class="line">See Section 14.7.4, “InnoDB File-Per-Table Tablespaces” for details.</span><br></pre></td></tr></table></figure>

<h2 id="ibd存储的数据"><a href="#ibd存储的数据" class="headerlink" title="ibd存储的数据"></a>ibd存储的数据</h2><p>该表的所有索引数据【聚集索引】。</p>
<p>这里使用了B+tree,B+ tree的叶子节点，就会存放所有的数据。整个表，其实就是一棵B+ tree，一个ibd就是1-N个b+ tree。N等于你的索引数量</p>
<p>当新建一个表时，会给表创建一个主键primary Key，然后这个key就带着整行数据占据着一块空间，作为B+ tree的一个叶子节点里元素。</p>
<p>可以理解为一个key-value键值对，key就是主键，value就是整行数据。如果你根本就没创建主键（不推荐），那innodb也会给你分配一个RowId来作为将来找它的主键，只是看不到。</p>
<p>这棵拥有全量数据的b+ tree，就是将来提供数据的树，一般来说，这棵树最大一般4层，3层就能存2千万数据了，4层能达到n个亿，将来通过主键查询时，通过2-4次IO就能找到数据行。这个索引树，即——聚簇索引。</p>
<h1 id="表空间-ibd内文件结构"><a href="#表空间-ibd内文件结构" class="headerlink" title="表空间-ibd内文件结构"></a>表空间-ibd内文件结构</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>04-存储引擎层-innodb框架-磁盘上的结构-表空间</title>
    <url>/articles/20200202/e9a15921.html</url>
    <content><![CDATA[<p>摘要：<br>物理存储， InnoDB 里的所有表数据，都以索引（聚簇索引+二级索引）的形式存储起来，索引包含了表数据。</p>
<a id="more"></a>

<h1 id="磁盘上的结构"><a href="#磁盘上的结构" class="headerlink" title="磁盘上的结构"></a>磁盘上的结构</h1><p>磁盘中的结构分为两大类：表空间和重做日志。</p>
<ul>
<li>表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。<br>系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等。</li>
<li>Redo日志：存储的就是 Log Buffer 刷到磁盘的数据。</li>
</ul>
<h2 id="innodb整体文件结构"><a href="#innodb整体文件结构" class="headerlink" title="innodb整体文件结构"></a>innodb整体文件结构</h2><p>物理存储文件结构中黑框里的就是innodb。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ibdata1</span><br><span class="line">ib_logfile0</span><br><span class="line">ib_logfile1</span><br></pre></td></tr></table></figure>
<p>有两个默认的日志文件，logfile0和logfile1，大小可以手工设定。</p>
<p>InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。另一部分是idb。</p>
<h3 id="InnoDB-表结构"><a href="#InnoDB-表结构" class="headerlink" title="InnoDB 表结构"></a>InnoDB 表结构</h3><p>InnoDB 与 MyISAM 不同，它在系统表空间存储数据字典信息，因此它的表不能像 MyISAM 那样直接拷贝数据表文件移动。</p>
<p>MySQL5.7 采用的文件格式是 Barracuda，它支持 COMPACT 和 DYNAMIC 这两种新的行记录格式。</p>
<p>创建表时可以通过 ROW_FORMAT 指定行记录格式，默认是 DYNAMIC。查看表信息，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'test_innodb/table15w'</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">from</span> test_innodb <span class="keyword">like</span> <span class="string">'table15w'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: table15w</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 149641</span><br><span class="line"> Avg_row_length: 52</span><br><span class="line">    Data_length: 7880704</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 4194304</span><br><span class="line"> Auto_increment: 150001</span><br><span class="line">    Create_time: 2020-01-31 03:40:25</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment:</span><br></pre></td></tr></table></figure>
<p>InnoDB表使用上有一些限制，如一个表最多只能有64个辅助索引，一行大小不能超过65535等，组合索引不能超过16个字段等，一般应该不会突破限制，详细见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-restrictions.html" target="_blank" rel="noopener">innodb-restrictions</a>。</p>
<h3 id="InnoDB-表空间"><a href="#InnoDB-表空间" class="headerlink" title="InnoDB 表空间"></a>InnoDB 表空间</h3><p>表空间根据类型可以分为：系统表空间，File-Per-Table 表空间{即ibd}，常规表空间，Undo表空间，临时表空间等。</p>
<ul>
<li><p>系统表空间：包含内容有数据字典，双写缓冲，修改缓冲以及undo日志，以及在系统表空间创建的表的数据和索引。</p>
</li>
<li><p>常规表空间：类似系统表空间，也是一种共享的表空间，可以通过 CREATE TABLESPACE 创建常规表空间，多个表可共享一个常规表空间，也可以修改表的表空间。<br>注意：必须删除常规表空间中的表后才能删除常规表空间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">`ts1`</span> <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">'ts1.ibd'</span> <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c2 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t2 <span class="keyword">TABLESPACE</span>=innodb_file_per_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLESPACE</span> ts1;</span><br></pre></td></tr></table></figure></li>
<li><p>File-Per-Table表空间：MySQL InnoDB新版本提供了 innodb_file_per_table 选项，每个表可以有单独的表空间数据文件(.ibd)，而不是全部放到系统表空间数据文件 ibdata1 中。在 MySQL5.7 中该选项默认开启。</p>
</li>
<li><p>其他表空间：其他表空间中Undo表空间存储的是Undo日志。除了存储在系统表空间外，Undo日志也可以存储在单独的Undo表空间中。<br>临时表空间则是非压缩的临时表的存储空间，默认是数据目录的 ibtmp1 文件，所有临时表共享，压缩的临时表用的是 File-Per-Table 表空间。</p>
</li>
</ul>
<h1 id="innodb承上启下的结构"><a href="#innodb承上启下的结构" class="headerlink" title="innodb承上启下的结构"></a>innodb承上启下的结构</h1><p><img src="/images/post/db-mysql/005/innodb-jiegou.png" alt=""></p>
<p>Handler API是供mysql server层调用的，server层定义了一些接口，譬如insert、delete，具体怎么实现，是由每个存储引擎自己实现的。</p>
<p>以上图中间虚线为分界，上面的是逻辑层，每个访问都会产生事务，事务处理会产生锁（表锁、行锁），操作对象是表、索引、b+ tree。对数据页面的访问需要物理事务，为了读写一致性，需要读写锁（物理锁）。为了高效定位和管理“页”，需要用到文件管理系统。</p>
<p>这些都是基于逻辑的处理，再往下就是物理层。</p>
<p>在逻辑处理和磁盘文件之间，都是有一层缓存的，这里主要是日志缓冲区和innodb_buffer_pool。和其他常用的kafka、elasticsearch、rocksDB等等一样，要保持性能，必然都遵循相同或类似的规则，那就是写pageCache、顺序写磁盘，这是决定任何一个带存储功能的性能的关键点。</p>
<p>innodb_buffer_pool，未来能对性能起决定性作用的一个重要因子。决定读写速度的都是内存，只要要读的数据在内存里，它就比在磁盘上快。redis就是靠内存，mysql的数据缓存，就取决于innodb_buffer_pool。</p>
<p>缓冲层提供了高效的读写性能，再下面就是物理文件层了，是落到磁盘上的。</p>
<p>磁盘上重要的地方有REDO日志，和表数据（页）</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>03-存储引擎层、InnoDB 架构</title>
    <url>/articles/20200201/4ced7854.html</url>
    <content><![CDATA[<p>摘要：物理存储文件结构</p>
<a id="more"></a>

<h1 id="物理存储文件结构"><a href="#物理存储文件结构" class="headerlink" title="物理存储文件结构"></a>物理存储文件结构</h1><p><img src="/images/post/db-mysql/005/jiegou.png" alt=""></p>
<p>my.cnf，配置文件。</p>
<p>slow.log，记录慢查询日志，当语句执行时间超过参数long_query_time的值时，会被记录到该log，需要开启配置后才有。</p>
<p>error.log，记录错误和警告信息。</p>
<p>general.log，记录所有在数据库上执行的语句，可以用来追踪问题，文件增长很快，也很大，一般不会打开，需要要调试时可以打开。</p>
<p>系统默认库有4个，存储系统信息的，表名、列名、列属性等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">information_scherma</span><br><span class="line">mysql</span><br><span class="line">performance_scherma</span><br><span class="line">sys</span><br></pre></td></tr></table></figure>

<h1 id="InnoDB-架构"><a href="#InnoDB-架构" class="headerlink" title="InnoDB 架构"></a>InnoDB 架构</h1><p><img src="/images/post/db-mysql/innodb-struct.webp" alt=""></p>
<p>从上面第二张图可以看到，InnoDB 主要分为两大块：</p>
<ul>
<li>InnoDB In-Memory Structures【内存中的结构】</li>
<li>InnoDB On-Disk Structures【磁盘上的结构】</li>
</ul>
<p>InnoDB 使用日志先行策略，将数据修改先在内存中完成，并且将事务记录成重做日志(Redo Log)，转换为顺序IO高效的提交事务。</p>
<p>这里日志先行，说的是日志记录到数据库以后，对应的事务就可以返回给用户，表示事务完成。</p>
<p>但是实际上，这个数据可能还只在内存中修改完，并没有刷到磁盘上去。内存是易失的，如果在数据落地前，机器挂了，那么这部分数据就丢失了。</p>
<p>InnoDB 通过 redo 日志来保证数据的一致性。如果保存所有的重做日志，显然可以在系统崩溃时根据日志重建数据。</p>
<p>当然记录所有的重做日志不太现实，所以 InnoDB 引入了检查点机制。即定期检查，保证检查点之前的日志都已经写到磁盘，则下次恢复只需要从检查点开始。</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>02-Server服务层</title>
    <url>/articles/20200201/73b4253b.html</url>
    <content><![CDATA[<p>摘要：Server服务层聚集了mysql的最多的逻辑，包括了请求解析、查询缓存、语义分析、查询优化、各种计算函数、扫描记录、binlog、缓存、锁、内存管理等等。</p>
<a id="more"></a>

<h1 id="表对象缓存"><a href="#表对象缓存" class="headerlink" title="表对象缓存"></a>表对象缓存</h1><p><img src="/images/post/db-mysql/store.jpg" alt=""><br><img src="/images/post/db-mysql/004/zhixing.png" alt=""></p>
<p>创建一个表，设置列、列属性，索引等，并且指定好了存储引擎（默认innodb）。</p>
<h2 id="表结构缓存、表对象缓存"><a href="#表结构缓存、表对象缓存" class="headerlink" title="表结构缓存、表对象缓存"></a>表结构缓存、表对象缓存</h2><p>客户端发过来一个sql，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tableA <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>此时mysql获取到此请求，会先到查询缓存中查看，是不是执行过这个语句。缓存里key就是这个查询语句，如果查询缓存有，那么就直接返回value给客户端。这个查询缓存比较没有意义，新版8.0已经把它删掉了。</p>
<p>mysql收到请求后，会进行sql语句解析，会分析出，你是查询（插入、删除），哪个表（tableA、tableB），条件。然后先判断sql语句是否合法，假如你写了个selector * 那么就会报错。</p>
<p>解析出了表之后，要得到这个表的各种信息。</p>
<h3 id="一级表结构缓存"><a href="#一级表结构缓存" class="headerlink" title="一级表结构缓存"></a>一级表结构缓存</h3><p>要操作这个表，首先要找到这个表。先从缓存中（源码里的table_def_cache，是一个Hash结构）找，根据表名做为Key去找，由于是第一次访问这个表，缓存里没有。</p>
<p>那么会从System表里去找，mysql元数据里有每个表的定义，列信息等。找到这个表，就会构建出这个表的结构体TABLE_SHARE。</p>
<p>这个TABLE_SHARE是一个静态的、不允许修改的（在内存中）结构体TABLE_SHARE，并将其放入缓存中（一个Hash结构里，key就是表名+模式名）。</p>
<p>可以理解为一个java里的类，每个字段已经被赋了初始值。这个缓存是属于mysql server层的，与后面的存储引擎无关。里面保存了表名、库名、所有列信息、列默认值、表的字符集、对应的frm文件路径、对应的存储引擎、主键等。</p>
<p>注意，这个结构体就是一级缓存，它被所有用户共享，并且不可修改，从系统表被读入直到该表被修改或删除，这个缓存都会一直存在。</p>
<h3 id="二级表对象缓存"><a href="#二级表对象缓存" class="headerlink" title="二级表对象缓存"></a>二级表对象缓存</h3><p>表已经找到了，结构也已经被缓存了，此时还不能操作这个表。因为缺少一个表对象。</p>
<p>上面的TABLE_SHARE可以理解为一个模板类，包含了表的基本信息，能被所有用户共享。</p>
<p>但是里面还缺少一些信息，譬如不同用户对该表的权限、譬如存储引擎信息。那么要想操作这个表，就需要创建一个表对象来供当前用户（线程）使用。</p>
<p>创建表对象就是实例化的过程，每个用户独享一个实例，我们称之为table实例，不会影响其他用户。</p>
<p>创建的这个实例，里面有一个指向TABLE_SHARE的引用，用以获取基本信息，还有一些其他属性，譬如存储引擎层的信息也会被初始化（引擎的handler）。</p>
<p>表对象创建完毕后，就具备了和存储引擎交互的能力（通过handler）。创建后，也会放入缓存，供下次使用时避免反复创建实例。</p>
<p>mysql层与存储引擎层，就是从这里开始区分，table对象就是沟通的桥梁。对于各个存储引擎，需要提供公共的接口来供上层（mysql server）层来调用，并由各自的table实例来完成各自的操作。<br>譬如插入一条记录，就可以调用table实例中被初始化过的存储引擎的句柄接口函数ha_write_row，进行写入。</p>
<p>这个table实例在一次操作完成之后就不需要了，系统此时并没有将其释放掉，而是保存下来，用一个状态标志位标记一下，并且会调用handler.reset()来重置引擎表状态，目的是handler会被复用，如果不reset，可能导致信息错误。缓存后，当下次用户再访问时，就不需要重新实例化了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到，当你想操作一个表时，系统对于这个表，会有两层缓存。第一层是SHARE缓存，第二层就是实例化后的对象缓存Table。</p>
<ul>
<li>缓存淘汰策略，<ul>
<li>SHARE缓存只有在表结构定义改变时，才会被删除，但是倘若表巨多，SHARE缓存超出限制，也会淘汰那些不经常使用的SHARE。</li>
<li>第二层的实例缓存，也是有最大值的，超出后则开始淘汰。</li>
</ul>
</li>
</ul>
<p>涉及的参数变量有两个，table_open_cache和table_definition_cache，一些淘汰策略数值就是靠这两个参数来计算得到的。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>不同于某些数据库，一启动就加载了所有表信息。mysql是按需加载，由于mysql的插件式存储引擎，mysql做了两层的缓存模型，第二层才加载引擎的handler。</p>
<ul>
<li>优点：<br>按需加载，提高内存利用率，避免启动时加载所有表信息带来的内存占用。</li>
</ul>
<ul>
<li>缺点：<br>两层缓存带来了效率的损失，每个用户（线程）都要实例化table对象。<br>在并发情况下，有可能会实例化多个table对象，导致table_open_cache增长过快，导致淘汰掉其他的table对象。同时倘若table比较大，譬如有N多的列，那么会占用非常多的内存。</li>
</ul>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>01-网络连接层</title>
    <url>/articles/20200201/3a03a839.html</url>
    <content><![CDATA[<p>摘要：数据库三层架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网络层</span><br><span class="line">  ↓</span><br><span class="line">server层</span><br><span class="line">  ↓</span><br><span class="line">存储层</span><br></pre></td></tr></table></figure>
<p>存储层：mysql作为一个插件式的数据库，在存储层支持多种引擎，譬如默认的innodb，和之前版本默认的MyIsam。由不同的引擎提供相同的接口给server层调用，来完成数据的增删改查。</p>
<p>server层：是mysql比较复杂的地方，里面包含了大量的逻辑，譬如语义分析、查询优化、日志、缓存等等。</p>
<p>网络层：主要是提供socket连接。</p>
<a id="more"></a>

<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在mysql的网络层，主要关注3点</p>
<ol>
<li>Poll、Select模型</li>
<li>Max-connections</li>
<li>connection复用</li>
</ol>
<p>mysql在启动后，创建了socket server，绑定了3306端口，并对其进行监听。和java里的写法类似，用一个while循环来监听新来的connection，如果有了新连接，就创建一个新的连接线程去处理（不能超过max-connections）。</p>
<p>这种就是典型的BIO的模式，为每一个连接创建一个线程。并且，mysql在这里采用了IO多路复用，会有一个if语句来判断当前系统是否支持Poll模式，否则就走Select模型（各个系统默认都有实现）。</p>
<p>Poll模型和Select非常类似，只是少了1024个fd的限制，都是采用遍历数组轮询有没有新IO事件的方式，在连接数较少的情况下，性能优异，要好于epoll。</p>
<p>mysql基于BIO，本质上是不接受大量的socket连接的，所以设置了max-connections这个限制，超过设置的max，那么新来的连接会被拒绝。</p>
<p>那么，第一个问题，为什么是BIO，而不是可以承受更大连接数的NIO和AIO呢？是否用NIO就会更好呢？</p>
<h3 id="mysql的BIO"><a href="#mysql的BIO" class="headerlink" title="mysql的BIO"></a>mysql的BIO</h3><h4 id="bio和nio的区别"><a href="#bio和nio的区别" class="headerlink" title="bio和nio的区别"></a>bio和nio的区别</h4><p>在BIO模式下，调用read，如果发现没数据，就会Block住。</p>
<p>在NIO模式下，调用read，如果发现没数据，就会立刻返回-1, 并且errno被设为EAGAIN。</p>
<h5 id="基于NIO-IO多路复用的模式"><a href="#基于NIO-IO多路复用的模式" class="headerlink" title="基于NIO+IO多路复用的模式"></a>基于NIO+IO多路复用的模式</h5><p>server开发使用的web容器：tomcat、netty等，都是基于NIO+IO多路复用的模式，来大幅提升性能，承载高并发访问的。但是到了DB层，则使用hakiri、druid之类的线程池，开启10个线程去连接mysql，反复复用这个线程池。</p>
<p>NIO+IO多路复用，并不是指多个用户socket共享一个IO，从而使得服务端的socket数量大减。而是把多个socket连接，归并到一个进程进行管理，如用一个大数组来聚合起来，然后循环遍历这个数组，来一次性把多个连接的事件通知业务代码进行处理。<br>这样就大幅减少了server的压力，高效利用资源。</p>
<p>对mysql来说，一般都会有多个连接，毕竟并发肯定是要有的。不可能做个查询，也要大家一起排队等上一个人查询完。所以线程池和并发是一定的。</p>
<h5 id="mysql和web-Server区别"><a href="#mysql和web-Server区别" class="headerlink" title="mysql和web Server区别"></a>mysql和web Server区别</h5><p>Web请求，往往是无状态的，一问一答的时候居多，请求也往往比较短促，对于顺序性也不是十分严格，哪怕是后请求的响应比先请求的提前到，也是有可能的。</p>
<p>DB请求，DB采用session作为一个连接会话，这一个session里，SQL的执行必须是串行、同步、有序的，而不能是异步乱序的。原因是，一个session内可能有多个操作，增删改查、事务隔离，必须保证顺序不能乱。<br>DB维护这样一个session，是要花费远大于web Server处理一个请求的资源才能完成的。</p>
<p>对于DB来说，连接是非常耗资源的事情，限制连接数是非常有必要的。</p>
<p>注意，当连接mysql出问题时，随便加大应用服务的连接池和增大mysql的max-connection。不能改善mysql的性能。当进行非常密集的数据库操作时，连接池的数量对性能产生的巨大影响。</p>
<h4 id="为什么用BIO，而不是NIO。"><a href="#为什么用BIO，而不是NIO。" class="headerlink" title="为什么用BIO，而不是NIO。"></a>为什么用BIO，而不是NIO。</h4><p>原因是JDBC不支持，JDBC出现了20年，它是一个标准，在它被提出时，只有BIO模型，导致数据库驱动对JDBC的实现都是BIO的形式，mysql驱动connector早早地实现了JDBC标准，就是采用阻塞的方式。</p>
<p>当进行一个select查询，在查询没有完成之前，整个调用线程会被卡住，等到天荒地老也要等下去，绝不是一请求立马收到返回，然后等mysql回调你结果。</p>
<p>其实，也有人修改了mysql的协议，增加了NIO+多路复用的功能，最后失败，主要原因是mysql和web server功能意义都不一样，确切地说，90%的场景下，不需要一个NIO的数据库。</p>
<p>BIO+连接池，已经发展了很多年，大部分问题都已经解决，在目前的java环境中，是非常靠谱的方案。已经出现了很多优秀的连接池框架，你只需要配置好账号密码和连接池数量，就能很开心的使用mysql了。</p>
<p>从mysql的角度来说，客户端多是一些IO密集型的应用，应该在一个线程里频繁做大量IO操作，而不是说有大量的客户端来反复连接我。毕竟，mysql的用户是你写的几个程序应用，而web server的用户是海量的。</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>mysql能支撑的连接数是有限的，那么就需要应用程序来利用好连接池。对于连接池来说，就是做好这10个连接的管理就好。</p>
<p>对于mysql来说，管理好自己的所有连接也是很重要，哪些空闲的该休息就休息，让出资源，该复用就复用，避免创建太多线程。</p>
<h4 id="IO密集的时候，要减少连接数。"><a href="#IO密集的时候，要减少连接数。" class="headerlink" title="IO密集的时候，要减少连接数。"></a>IO密集的时候，要减少连接数。</h4><p>譬如要读写几千万数据，非常密集的IO操作，那么你可以尝试一下开启少量的mysql连接（和cpu的核数相同）和开启大量的连接（成百上千），来做同样的事。你会发现，更少的连接数，会给你带来几百倍的性能提升。</p>
<p>譬如，你有4辆车（4核），要从仓库里拉一大堆货物到另一个地方。如果只有4条路，简单操作，一个车走一路，反复折返跑。现在有了100条路，还是4个车，车要频繁的在100条路上来回切换，每条路都必须要走到。</p>
<p>线程间的轮转会耗费大量的资源，尤其在密集操作时。但是当不密集时，情况就变了，大量的线程处于休息状态，那么你即便多开了几个连接，CPU还是能很快的照顾到你，并没有什么大的影响。</p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>作为RPC的连接，内部rpc数据协议</p>
]]></content>
      <categories>
        <category>db-mysql-core</category>
      </categories>
  </entry>
  <entry>
    <title>008-模板-NexT-版权、打赏</title>
    <url>/articles/20200130/7021388e.html</url>
    <content><![CDATA[<p>摘要：文章底部版权、文章底部打赏</p>
<a id="more"></a>

<h1 id="文章底部版权"><a href="#文章底部版权" class="headerlink" title="文章底部版权"></a>文章底部版权</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Next7.2.0官方对版权声明的设置做出了大改动，在主题配置文件_config.yml中已经找不到设置版权声明的post_copyright选项</p>
<p>旧版本：Next下，设置post_copyright为true，或是修改themes/next/layout/_macro/post-copyright.swig文件，自定义版权声明样式</p>
<p>新版本：Next下，网上一片教程，没有post_copyright选项了，各种改代码。</p>
<h2 id="探究新版版权"><a href="#探究新版版权" class="headerlink" title="探究新版版权"></a>探究新版版权</h2><p>发现：themes/next/layout/_partials/post/post-copyright.swig 还是有版权定义。</p>
<p>查看版权配置文件：themes/next/layout/_macro/post.swig</p>
<p>打开，直接搜搜：post-copyright.swig，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.creative_commons.license and theme.creative_commons.post %&#125;</span><br><span class="line">  &#123;&#123; partial(&#39;_partials&#x2F;post&#x2F;post-copyright.swig&#39;) &#125;&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>查看样式什么时候导入：themes/next/source/css/_common/components/post/post.styl<br><code>@import &#39;post-copyright&#39; if (hexo-config(&#39;creative_commons.post&#39;));</code><br>即配置文件中 有creative_commons</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<h1 id="文章底部打赏"><a href="#文章底部打赏" class="headerlink" title="文章底部打赏"></a>文章底部打赏</h1><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><p>查看 源码 发现 reward，配置：reward_settings</p>
<ol>
<li><p>打赏图片增加<br>支付宝，微信获取付款图片<br>source/images/reward/bjlhx-wx.bmp<br>source/images/reward/bjlhx-wx.bmp</p>
</li>
<li><p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">一分也是爱，两分情更浓【还没有人赞赏，支持一下呗】</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/reward/bjlhx-wx.bmp</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/reward/bjlhx-zfb.bmp</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>002-github pages建站，绑定主题</title>
    <url>/articles/20200130/e012e91a.html</url>
    <content><![CDATA[<p>搭建属于自己的博客网站，这里使用 github pages建站，绑定主题</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>基于github建站，使用仓库存放静态代码</p>
<h2 id="基础储备"><a href="#基础储备" class="headerlink" title="基础储备"></a>基础储备</h2><p>github账号注册</p>
<p>git使用：<a href="https://www.cnblogs.com/bjlhx/category/993475.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/category/993475.html</a>　　</p>
<p><strong>基础步骤</strong></p>
<ul>
<li>Github Pages</li>
<li>Hexo 博客框架</li>
<li>部署</li>
<li>Next 主题</li>
</ul>
<p><strong>涉及三个仓库</strong></p>
<ul>
<li>静态代码部署仓库：username.github.io 作用：username 需要设置成每个人仓库自己的，主要是基于Github Pages 的 部署代码。</li>
<li>静态代码开发仓库：hexo-src.bjlhx15.github.io 作用：开发代码的仓库。</li>
<li>基于github评论仓库：ment.bjlhx15.github.io 作用：使用基于github issues机制的评论仓库</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Github-Pages使用"><a href="#Github-Pages使用" class="headerlink" title="Github Pages使用"></a>Github Pages使用</h2><p>Github Pages 其实本身就是 Github 提供的博客服务。 我们在 Github 中创建一个特定格式的 Repository，Github Pages 就会将里面的信息生成一个网页，展示出来。</p>
<p>创建仓库：username.github.io：</p>
<p>创建即可，访问：<a href="https://bjlhx15.github.io/" target="_blank" rel="noopener">https://bjlhx15.github.io/</a>  博客首页</p>
<h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p>Hexo：是一个博客框架。它把本地文件里的信息生成一个网页。</p>
<p>使用 Hexo 之前，需要先安装 Node.js 和 Git。检测安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>hexo安装：<code>npm install -g hexo-cli</code></p>
<p>查看：<code>hexo -v</code></p>
<p>备注：<a href="https://www.cnblogs.com/bjlhx/p/12239748.html" target="_blank" rel="noopener">006-node npm 报错 rollbackFailedOptional: verb npm-session</a></p>
<h3 id="框架结合源码"><a href="#框架结合源码" class="headerlink" title="框架结合源码"></a>框架结合源码</h3><p>在其他目录下使用：hexo init，下载代码，因为 init 初始化需要一个空目录，否则报错</p>
<p>github上新建一个仓库：hexo-src.bjlhx15.github.io.git，拉取到本地，将上述代码拷贝至在仓库中即可</p>
<p>npm install 安装依赖包</p>
<p>hexo g 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</p>
<p>hexo s 将生成的网页放在了本地服务器（server）</p>
<p><a href="https://blog.bjlhx.top/categories/hexo/">更多</a></p>
<h3 id="新建博客并发布"><a href="#新建博客并发布" class="headerlink" title="新建博客并发布"></a>新建博客并发布</h3><p>source/_posts 放置 XX.md 文章即可，执行hexo g、hexo s查看</p>
<p>发布，将生成的前端代码发布到：bjlhx15.github.io.git  仓库，注意不是2.3中的源码仓库 hexo-src</p>
<p>在根目录：_config.yml 下修改deploy：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#39;git&#39;</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;bjlhx15&#x2F;bjlhx15.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>输入 <code>npm install hexo-deployer-git --save</code> 安装 hexo-deployer-git 此步骤只需要做一次。</p>
<p>输入 <code>hexo d</code>，会将本地代码部署至 部署仓库地址</p>
<p>至此基础版本搭建完成：<a href="https://bjlhx15.github.io/" target="_blank" rel="noopener">https://bjlhx15.github.io/</a></p>
<h2 id="使用Next主题"><a href="#使用Next主题" class="headerlink" title="使用Next主题"></a>使用Next主题</h2><p>以 Next 为例。 大概思路就是把整个主题的文件克隆到我们的主题文件夹中。在配置文件中注明使用该主题。【更多】</p>
<ol>
<li>下载主题</li>
</ol>
<p>在hexo-src源码的根目录下：<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p>
<p>这样，该主题的文件就全部克隆到:   themes\next 下面。</p>
<ol start="2">
<li>切换主题<pre><code class="text"># theme: landscape  next
theme: next</code></pre>
访问<a href="https://bjlhx15.github.io" target="_blank" rel="noopener">https://bjlhx15.github.io</a>即可</li>
</ol>
<h1 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h1><pre><code>将：src 源码下载，使用idea，eclipse等打开
在：source/_posts 下分目录 编写文章即可</code></pre>]]></content>
      <categories>
        <category>build_site</category>
      </categories>
  </entry>
  <entry>
    <title>001-建站系统系列</title>
    <url>/articles/20200130/f87cfa7a.html</url>
    <content><![CDATA[<p>一步一步，搭建网站系统<br>域名申请与绑定、</p>
<p><a href="https://blog.bjlhx.top/categories/build-site/">build-site</a></p>
<a id="more"></a>

<h1 id="域名申请与绑定"><a href="#域名申请与绑定" class="headerlink" title="域名申请与绑定"></a>域名申请与绑定</h1><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p><a href="https://www.aliyun.com" target="_blank" rel="noopener">https://www.aliyun.com</a></p>
<p>控制台→域名，可以注册域名，top域名比较便宜，个人申请使用：bjlhx.top</p>
<p><a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="noopener">https://wanwang.aliyun.com/domain/</a>  首年1块</p>
<h3 id="CNAME-域名解析"><a href="#CNAME-域名解析" class="headerlink" title="CNAME 域名解析"></a>CNAME 域名解析</h3><p>主要是一个域名解析到另一个域名</p>
<h4 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h4><p><img src="/images/post/build_site/domain.png" alt=""></p>
<h4 id="站点根目录增加"><a href="#站点根目录增加" class="headerlink" title="站点根目录增加"></a>站点根目录增加</h4><p>文件：CNAME</p>
<p>内容：blog.bjlhx.top</p>
<p>等待10分钟，然后访问 <a href="http://blog.bjlhx.top/">http://blog.bjlhx.top/</a> 就能看到 <a href="http://bjlhx15.github.io" target="_blank" rel="noopener">http://bjlhx15.github.io</a> 一样的页面，证明绑定成功了。 </p>
<h3 id="IP解析"><a href="#IP解析" class="headerlink" title="IP解析"></a>IP解析</h3><p>域名解析到指定的IP，A记录</p>
]]></content>
      <categories>
        <category>build_site</category>
      </categories>
  </entry>
  <entry>
    <title>007-hero-config配置说明</title>
    <url>/articles/20200130/6fe23d4d.html</url>
    <content><![CDATA[<p>位于站点根目录下的 _config.yml 文件，可以直接用记事本打开进行编辑，文件中的具体配置项.<br>Site、URL、Directory、Writing、Home page setting、Category &amp; Tag、Date / Time format、Pagination、Extensions、Deployment</p>
<a id="more"></a>

<h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><p>网站的个性化描述，大家需要根据自己的实际情况认真填写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">title	网站标题</span><br><span class="line">subtitle	网站副标题</span><br><span class="line">description	网站描述</span><br><span class="line">keywords	网站关键字</span><br><span class="line">author	网站作者</span><br><span class="line">language	网站使用的语言，默认是en ，中文网站填zh-Hans</span><br><span class="line">timezone	网站使用的时区，默认为 计算机的预设置，可以不填</span><br></pre></td></tr></table></figure>

<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>关于博客文章 URL 的设置，一般不用进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">url	网站的网址</span><br><span class="line">root	网站的根目录， 也是存放文章的目录</span><br><span class="line">permalink	文章的链接格式 ，默认为 :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults	永久链接中每个段的默认值</span><br></pre></td></tr></table></figure>

<h1 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h1><p>关于文件夹的设置，也是一般不用进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">source_dir	资源文件夹 ，存放用户的资源文件，默认为 source</span><br><span class="line">public_dir	公用文件夹 ，存放生成的静态文件，默认为 public</span><br><span class="line">tag_dir	标签目录 ，默认为 tags</span><br><span class="line">archive_dir	档案目录 ，默认为 archives</span><br><span class="line">category_dir	分类目录 ，默认为 categories</span><br><span class="line">code_dir	代码目录 ，默认为 downloads&#x2F;code</span><br><span class="line">i18n_dir	i18n目录 ，默认为 :lang</span><br><span class="line">skip_render	储存站长验证文件，跳过指定文件的渲染</span><br></pre></td></tr></table></figure>

<h1 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h1><p>这里是比较常用的写作设置，可以根据自己的写作习惯随时进行调整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">new_post_name	文章的文件名格式，默认为 :title.md</span><br><span class="line">default_layout	预设的布局模板，默认为 post</span><br><span class="line">titlecase	标题是否使用首字母大写 ，默认为 false</span><br><span class="line">external_link	链接是否在新标签页中打开，默认为 true</span><br><span class="line">filename_case	将文件名转换为 1 小写 或 2 大写，默认为 0</span><br><span class="line">render_drafts	是否显示渲染草稿，默认为 false</span><br><span class="line">post_asset_folder	是否启用 Asset 文件夹，默认为 false</span><br><span class="line">relative_link	是否建立相对于根文件夹的链接，默认为 false</span><br><span class="line">future	是否显示未来文章，默认为 true</span><br><span class="line">highlight	代码块设置</span><br></pre></td></tr></table></figure>
<h2 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">enable	是否使用代码高亮 ，默认为 true</span><br><span class="line">line_number	是否显示行号 ，默认为 true</span><br><span class="line">auto_detect	是否自动检测语言 ，默认为 false</span><br><span class="line">tab_replace	tab 替代设置</span><br></pre></td></tr></table></figure>

<h1 id="Home-page-setting"><a href="#Home-page-setting" class="headerlink" title="Home page setting"></a>Home page setting</h1><p>首页设置，可以自己决定每页显示的文章数量和显示文章的顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">index_generator	主页设置</span><br></pre></td></tr></table></figure>

<p>index_generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">path	首页的根目录</span><br><span class="line">per_page	每页显示文章的数量，默认为 10</span><br><span class="line">order_by	显示文章的顺序，默认为 -date</span><br></pre></td></tr></table></figure>

<h1 id="Category-amp-Tag"><a href="#Category-amp-Tag" class="headerlink" title="Category &amp; Tag"></a>Category &amp; Tag</h1><p>这里是关于分类和标签的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">default_category	预设分类，默认为 uncategorized</span><br><span class="line">category_map	分类别名</span><br><span class="line">tag_map	标签别名</span><br></pre></td></tr></table></figure>

<h1 id="Date-Time-format"><a href="#Date-Time-format" class="headerlink" title="Date / Time format"></a>Date / Time format</h1><p>时间和日期的显示格式，一般没特殊要求的也不需要改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">date_format	日期格式，默认为 YYYY-MM-DD</span><br><span class="line">time_format	时间格式，默认为 HH:mm:ss</span><br></pre></td></tr></table></figure>

<h1 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h1><p>这里是分页设置，可以自己决定单个页面上显示的文章数量和分页目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">per_page	单个页面上显示的文章数量，默认为 10 ，用 0 表示禁用分页</span><br><span class="line">pagination_dir	分页目录，默认为 page</span><br></pre></td></tr></table></figure>

<h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><p>这里可以设置主题类型和插件，之后的文章讲到更换博客主题时需要进行更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">theme	博客使用的主题，默认为 landscape</span><br></pre></td></tr></table></figure>

<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>这里是关于网站部署的配置，常用的有部署类型和部署地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">deploy	网站部署配置</span><br></pre></td></tr></table></figure>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting	描述</span><br><span class="line">type	网站部署类型</span><br><span class="line">repo	网站部署地址</span><br></pre></td></tr></table></figure>
<p><a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">【参考资料】</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>006-模板-NexT-三方服务-搜索、统计分析、评论</title>
    <url>/articles/20200129/f6f5115.html</url>
    <content><![CDATA[<p>包含了 站内搜索、埋点统计等，注意：凡是网络上写着改代码的配置，几乎都不用，一般都有人写好git能直接用npm了</p>
<a id="more"></a>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p>本地搜索不需要任何外部第三方服务，并且可以由搜索引擎额外索引。该搜索方法推荐给大多数用户。</p>
<p>通过在站点根目录中运行以下命令来安装hexo-generator-searchdb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>config配置</p>
<figure class="highlight plain"><figcaption><span>hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>

<h1 id="统计和分析"><a href="#统计和分析" class="headerlink" title="统计和分析"></a>统计和分析</h1><h2 id="1、分析-百度"><a href="#1、分析-百度" class="headerlink" title="1、分析-百度"></a>1、分析-百度</h2><ol>
<li>登录 <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度 分析</a>并找到网站代码获取页面。</li>
<li>将脚本ID复制到hm.js？之后，如下图：<br><img src="/images/post/hexo/analytics-baidu-id.png" alt="avatar"></li>
<li>配置<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Baidu Analytics ID</span><br><span class="line">baidu_analytics: your_id</span><br></pre></td></tr></table></figure>
代码检测是否成功，一般20分钟，可以看浏览器控制台 <a href="https://tongji.baidu.com/web/help/article?id=93&type=0" target="_blank" rel="noopener">代码手工检查攻略</a></li>
</ol>
<p>查看百度<a href="https://tongji.baidu.com/web/10000139146/homepage/index" target="_blank" rel="noopener">统计</a></p>
<h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><p>Hexo支持的评论比较多，Disqus、DisqusJS、LiveRe、Gitalk、Valine (China)、Changyan (China)<br>支持多个评论：Multiple Comment System Support<br>多说和网易云 不做了，其次畅言需要备案<br>Disqus，Hypercomments和LiveRe都是国外的，加载速度慢，甚至有被墙的可能，<br>valine 账户增加了 短信验证，实名认证等，需要个人信息 太多<br>Gitment 基于git的issues,由于 Next 更新，Gitment 已经预置了，所以不需要自己再添加代码。但是 作者 又不更新了，授权比较多,目前gitment.browser.js内使用授权，作者暂不维护<br>utterances 版本集成了utterances评论。这一工具原理和GITALK类似，但是索取的权限少，并且不用指定某个人来初始化。<em>推荐</em></p>
<ul>
<li>页面关闭评论<br><code>comments: false</code></li>
</ul>
<h2 id="utterances-【推荐】"><a href="#utterances-【推荐】" class="headerlink" title="utterances 【推荐】"></a>utterances <em>【推荐】</em></h2><p>源码<a href="https://github.com/theme-next/hexo-next-utteranc" target="_blank" rel="noopener">地址</a><br>首先来<a href="https://github.com/apps/utterances" target="_blank" rel="noopener">这里</a>为utterances在github上授权。<br>只有这样，才能让utterances有资格访问你的issue。还可指定utterances能够访问的仓库，可见其权限控制做的非常好。</p>
<p>授权完毕后，来到博客根目录，打开Git Bash，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save github:theme-next/hexo-next-utteranc</span><br></pre></td></tr></table></figure>
<p>后运行可能缺少依赖next-util ，原因是设置了<a href="https://www.cnblogs.com/bjlhx/p/12239748.html" target="_blank" rel="noopener">淘宝的 npm 源</a></p>
<p>打开主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Demo: https:&#x2F;&#x2F;utteranc.es&#x2F;  http:&#x2F;&#x2F;trumandu.github.io&#x2F;about&#x2F;</span><br><span class="line">utteranc:</span><br><span class="line">  enable: true</span><br><span class="line">  repo: #Github repo such as :TrumanDu&#x2F;comments</span><br><span class="line">  pathname: pathname</span><br><span class="line">  # theme: github-light,github-dark,github-dark-orange</span><br><span class="line">  theme: github-light</span><br><span class="line">  cdn: https:&#x2F;&#x2F;utteranc.es&#x2F;client.js</span><br></pre></td></tr></table></figure>

<h2 id="LiveRe"><a href="#LiveRe" class="headerlink" title="LiveRe"></a>LiveRe</h2><p>LiveRe是基于社交网站评论的内容平台，可帮助用户自由交流。</p>
<p>创建一个帐户或登录<a href="http://livere.com" target="_blank" rel="noopener">LiveRe</a>，单击安装按钮并选择免费的城市版本，然后单击立即安装按钮。</p>
<p>复制安装代码中的data-uid字段以获取LiveRe UID。</p>
<p>将获得的LiveRe UID添加到主题配置文件中的livere_uid部分，如下所示</p>
<figure class="highlight plain"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https:&#x2F;&#x2F;livere.com&#x2F;insight&#x2F;myCode (General web site)</span><br><span class="line">livere_uid: your_uid</span><br></pre></td></tr></table></figure>

<h2 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h2><p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。<br>支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>
<ol>
<li><p>github注册<br>首先要有github帐号<br>接着注册 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">OAuth Application</a>→<a href="https://github.com/settings/developers" target="_blank" rel="noopener">OAuth App</a><br>注册特别简单。之后能够查看 clientId,sercet等</p>
</li>
<li><p>引入gitment<br>在站点目录下，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save gitment</span><br></pre></td></tr></table></figure>
<p>打开主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true # 是否开启gitment评论系统</span><br><span class="line">  mint: true #</span><br><span class="line">  count: true # 是否显示评论数</span><br><span class="line">  lazy: true # 懒加载，设置为ture时需手动展开评论</span><br><span class="line">  cleanly: true # 是否隐藏&#39;Powered by ...&#39;</span><br><span class="line">  language: en # 语言，置空则随主题的语言</span><br><span class="line">  github_user: iamsea # Github用户名</span><br><span class="line">  github_repo: comment # 在Github新建一个仓库用于存放评论，这是仓库名</span><br><span class="line">  client_id: a6df579b14f7da8aAAAAc # 注册OAuth Application时生成</span><br><span class="line">  client_secret: 1f6568974d6f3ed28055d2243d05457f7eAAAAAAAA # 注册OAuth Application时生成</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https:&#x2F;&#x2F;github.com&#x2F;aimingoo&#x2F;intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure>
<p>github_repo # 在Github新建一个空仓库用于存放评论，这是仓库名</p>
</li>
<li><p>之后生成并且部署才会生效，本地有时没有效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>部署之后，有可能碰到 Not Found Error，先不要着急，等一段时间再看看。<br>之后文章底部会出现 初始化本文的评论页，点击初始化。</p>
</li>
</ol>
<h1 id="日历插件"><a href="#日历插件" class="headerlink" title="日历插件"></a>日历插件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save github:theme-next/theme-next-calendar</span><br><span class="line">``` </span><br><span class="line">在NexT的主题配置文件中添加配置</span><br><span class="line">``` text</span><br><span class="line">CloudCalendar:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  language: zh-CN</span><br><span class="line">  single: <span class="literal">true</span></span><br><span class="line">  root: /calendar/</span><br><span class="line">  calendarCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js</span><br><span class="line">  langCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js</span><br><span class="line">  <span class="comment">#disableSidebar: false</span></span><br></pre></td></tr></table></figure>
<p>即可使用。</p>
<p>此插件会在侧边栏的最下方添加一个日历。如侧边栏比较窄，视觉效果可能会稍差。此外，在低分辨率的屏幕上，增加日历会使侧边栏出现一个滚动条，可能会影响美观。</p>
<p>使用CDN的缺点是无法进行细节上的自定义配置，只能照着默认的来。如果想自己修改日历的颜色、位置等信息，请用这种方法安装，就可以自行修改文件。</p>
<h1 id="更多服务"><a href="#更多服务" class="headerlink" title="更多服务"></a>更多服务</h1><p><a href="https://theme-next.org/docs/third-party-services/" target="_blank" rel="noopener">third-party-services</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>005-模板-NexT-其他优化-页脚、菜单显示数量、代码块</title>
    <url>/articles/20200129/12b9aaef.html</url>
    <content><![CDATA[<p>关闭页脚的powered、hexo 首页文章只显示一部分、菜单显示数量、代码块</p>
<a id="more"></a>

<h1 id="关闭页脚的powered"><a href="#关闭页脚的powered" class="headerlink" title="关闭页脚的powered"></a>关闭页脚的powered</h1><p>进入：themes/next/_config.yml，找到footer 下 powered、theme 关闭即可</p>
<h1 id="hexo首页文章只显示一部分"><a href="#hexo首页文章只显示一部分" class="headerlink" title="hexo首页文章只显示一部分"></a>hexo首页文章只显示一部分</h1><p>方式一、Front-matter<br>在Front-matter中添加了描述并将其值设置为文章摘要，则默认情况下，NexT会将描述摘录为首页的前导文本。如果没有描述，则全部内容将为首页中的前导文字。<br>您可以通过在主题配置文件中将excerpt_description的值设置为false来禁用它。</p>
<p>方式二、在文章中加上<code>&lt;!--more--&gt;</code> 标记 ，该标记以后部分就不在显示了，只有展开全部才显示，这是hexo定义的。</p>
<p>方式三、插件【不推荐】</p>
<h1 id="菜单标签显示数值"><a href="#菜单标签显示数值" class="headerlink" title="菜单标签显示数值"></a>菜单标签显示数值</h1><p>在menu_settings如果设置icon: false则无图标，badges: true则标签都会显示数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true #默认是false</span><br></pre></td></tr></table></figure>

<h1 id="代码块设置"><a href="#代码块设置" class="headerlink" title="代码块设置"></a>代码块设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">  highlight_theme: normal</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: false</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: false</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>004-模板-NexT-菜单、侧栏、头像、阅读量</title>
    <url>/articles/20200129/8ecccc4b.html</url>
    <content><![CDATA[<p>Hexo 框架允许我们更换合适的主题，以便于构建不同风格的网站，这里介绍目前最常使用的一款主题之NexT</p>
<p>设置Scheme、设置动态背景、设置侧栏行为、设置菜单、设置头像、添加社交链接、添加文字统计功能、添加阅读量统计功能</p>
<a id="more"></a>
<h1 id="NexT-安装"><a href="#NexT-安装" class="headerlink" title="NexT 安装"></a>NexT 安装</h1><p>几个概念：</p>
<p>在使用 Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml</p>
<p>一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置</p>
<p>另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置</p>
<p>不同的主题会有不同的主题配置文件，由主题作者所提供</p>
<h2 id="下载-NexT"><a href="#下载-NexT" class="headerlink" title="下载 NexT"></a>下载 NexT</h2><p>在 站点根目录 中打开 git bash 窗口，使用如下命令下载 NexT 主题文件到 themes 目录 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line">或</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">或</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h2 id="启用-NexT"><a href="#启用-NexT" class="headerlink" title="启用 NexT"></a>启用 NexT</h2><p>打开 站点配置文件， 将 theme 选项的值改为 next，注意要在属性和值之间要加上一个空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>此时，登陆自己的站点，应该可以看到更改已经成功</p>
<h1 id="NexT-配置"><a href="#NexT-配置" class="headerlink" title="NexT 配置"></a>NexT 配置</h1><h2 id="设置Scheme"><a href="#设置Scheme" class="headerlink" title="设置Scheme"></a>设置Scheme</h2><p>Scheme 是用于 改变网站布局 的一个设置项，NexT 目前提供四种 Scheme：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Muse ：默认 Scheme，黑白主调，大量留白</span><br><span class="line">Mist：Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">Pisces：双栏 Scheme，小家碧玉的清新</span><br><span class="line">Gemini：新增 Scheme</span><br></pre></td></tr></table></figure>
<p>更改时，打开 主题配置文件，通过搜索关键字 Scheme Settings 定位，然后将使用的 scheme 打开注释即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h2 id="设置动态背景"><a href="#设置动态背景" class="headerlink" title="设置动态背景"></a>设置动态背景</h2><p>更改时，打开 主题配置文件，通过搜索关键字 Canvas-nest 定位，然后将 canvas_nest 的值改成 true 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure>


<h2 id="设置侧栏行为"><a href="#设置侧栏行为" class="headerlink" title="设置侧栏行为"></a>设置侧栏行为</h2><p>默认情况下，侧栏仅在文章页面（拥有目录列表时）才显示，并放置于右侧位置</p>
<p>可以通过修改 主题配置文件 中的 Sidebar Settings 字段控制侧栏的行为</p>
<p>（1）侧栏位置：position<br>left：靠左放置;<br>right：靠右放置;</p>
<p>（2）侧栏显示时机：display<br>post：默认行为，在文章页面（拥有目录列表时）显示;<br>always：在所有页面中都显示;<br>hide：在所有页面中都隐藏;<br>remove：完全移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">position: left</span><br><span class="line">#position: right</span><br><span class="line"></span><br><span class="line"># Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line">#  - post    expand on posts automatically. Default.</span><br><span class="line">#  - always  expand for all pages automatically</span><br><span class="line">#  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">#  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line">display: post</span><br><span class="line">#display: always</span><br><span class="line">#display: hide</span><br><span class="line">#display: remove</span><br></pre></td></tr></table></figure>


<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><p>（1）设置菜单项</p>
<p>打开 主题配置文件，搜索关键字 Menu Settings 进行定位，各个菜单项通过 # 注释开启或关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running the site in a subdirectory (e.g. domain.tld&#x2F;blog), remove the leading slash from link value (&#x2F;archives -&gt; archives).</span><br><span class="line"># Usage: &#96;Key: &#x2F;link&#x2F; || icon&#96;</span><br><span class="line"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span><br><span class="line"># Value before &#96;||&#96; delimeter is the target link.</span><br><span class="line"># Value after &#96;||&#96; delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>
<p>部分菜单项的功能描述如下：<br>home：主页;about：关于;tags：标签;categories：分类;archives：归档;</p>
<p>菜单具体 参看002</p>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>打开 主题配置文件， 搜索关键字 Sidebar Avatar 进行定位，将 avatar 的值设置成头像图片的链接地址即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class="line"># in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class="line">avatar: &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>头像图片的链接地址可以是：  </p>
<ul>
<li>完整的互联网地址：例如，<a href="https://www.example.com/avatar.jpg" target="_blank" rel="noopener">https://www.example.com/avatar.jpg</a></li>
<li>站点内的相对地址：例如，假设图片命名为 avatar.jpg，存放在 source/images/ 目录下，则链接地址可以写成 /images/avatar.jpg</li>
</ul>
<h2 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h2><p>打开 主题配置文件，搜索关键字 Social Links 进行定位，social 的值按 Key: permalink || icon 格式设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Social Links.</span><br><span class="line"># Usage: &#96;Key: permalink || icon&#96;</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before &#96;||&#96; delimeter is the target permalink.</span><br><span class="line"># Value after &#96;||&#96; delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;Forwhfang || Github</span><br><span class="line">  CSDN: https:&#x2F;&#x2F;blog.csdn.net&#x2F;wsmrzx || CSDN</span><br><span class="line">  cnblogs: https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wsmrzx || cnblogs</span><br></pre></td></tr></table></figure>


<h2 id="添加文字统计功能"><a href="#添加文字统计功能" class="headerlink" title="添加文字统计功能"></a>添加文字统计功能</h2><p>进入 站点根目录，打开 git bash 窗口，输入如下命令安装插件<br><code>pm install hexo-wordcount --save</code><br>然后打开 主题配置文件，进行如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;willin&#x2F;hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure>


<h2 id="添加阅读量统计功能"><a href="#添加阅读量统计功能" class="headerlink" title="添加阅读量统计功能"></a>添加阅读量统计功能</h2><p>在 主题配置文件 中修改 busuanzi_count 字段启用不蒜子统计功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_uv_footer: </span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_pv_footer: </span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure>
<p>【参考资料】</p>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">iissnan/hexo-theme-start</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="noopener">iissnan/hexo-theme-next</a></li>
<li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">third-party-services</a></li>
<li><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">hexo.io/plugins</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>003-模板-scaffolds、permalink永久链接</title>
    <url>/articles/20200129/5c36d9d6.html</url>
    <content><![CDATA[<p>模板以scaffolds/post.md为例，对updated、permalink等参数进行说明</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="scaffolds-post-md-说明"><a href="#scaffolds-post-md-说明" class="headerlink" title="scaffolds\post.md 说明"></a>scaffolds\post.md 说明</h2><p>打开.\scaffolds\post.md文件，默认参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>当我们在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new ABC</span><br></pre></td></tr></table></figure>
<p>则会在.\source_post\目录下产生一个ABC.md文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: ABC</span><br><span class="line">date: 2015-12-29 20:20:47</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="permalink设置"><a href="#permalink设置" class="headerlink" title="permalink设置"></a>permalink设置</h2><p>修改.\scaffolds\post.md，增加一个permalink属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">permalink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>让permalink为空，则Hexo会使用默认设置。默认设置是什么呢？就是你的根目录下的_config.yml中定义好的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;blog.bjlhx.top</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>
<p>:year表示年份，:month表示月份，:date表示日期。最终的展示效果为<a href="https://likianta.coding.me/2017/09/04/title/这种形式。" target="_blank" rel="noopener">https://likianta.coding.me/2017/09/04/title/这种形式。</a></p>
<p>方式一、可以把图中的斜杠改为短横线，效果会变成<a href="https://likianta.coding.me/2017-09-04/title/。" target="_blank" rel="noopener">https://likianta.coding.me/2017-09-04/title/。</a></p>
<p>方式二、将默认设置改成了permalink: :year/:category/:title，其最终的网址就是<a href="https://likianta.coding.me/2017/xx分组/xx标题。" target="_blank" rel="noopener">https://likianta.coding.me/2017/xx分组/xx标题。</a></p>
<p>分类设置:参看上文</p>
<p>另外需要注意的是，.\scaffolds\post.md中的permalink请一定要留空。</p>
<p>官网中虽然说.\scaffolds\post.md中的permalink内容可以覆盖根目录的默认设置，但实测发现会引起网址bug。</p>
<p>比如说你在.\scaffolds\post.md中修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :year:month&#x2F;:title</span><br></pre></td></tr></table></figure>

<p>Hexo会误把它当成一个字符串进行解析，结果就会生成：<a href="https://likianta.coding.me/2017/09/04/:year:month/:title/（一个错误的URL路径）。" target="_blank" rel="noopener">https://likianta.coding.me/2017/09/04/:year:month/:title/（一个错误的URL路径）。</a></p>
<p>不过如果我们在具体的文章中手动写上的话是不会报错的：</p>
<p>.\source_post\ABC.md:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 003-scaffolds.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">permalink: https:&#x2F;&#x2F;bjlhx.top&#x2F;2020&#x2F;01&#x2F;29&#x2F;ABC&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="Hexo-abbrlink生成唯一永久文章链接"><a href="#Hexo-abbrlink生成唯一永久文章链接" class="headerlink" title="Hexo-abbrlink生成唯一永久文章链接"></a>Hexo-abbrlink生成唯一永久文章链接</h3><p>hexo-next文章链接默认的生成规则是：:year/:month/:day/:title，是按照年、月、日、标题来生成的。</p>
<p>如果文章标题是中文的话，URL链接是也会是中文，</p>
<p>方案一、使用hexo-permalink-pinyin插件，将中文转英文</p>
<p>缺陷，比如修改了文章标题，重新hexo三连后，URL就变了，以前的文章地址变成了404。而且这样生成的URL层级也很深，不利于SEO。</p>
<p>方案二、Hexo-abbrlink</p>
<p>一、不用增加属性，也不用考虑分类中文化的问题。二、URL层级更短，更利于SEO。(一般SEO只爬三层)</p>
<p>在执行 <code>hexo g</code> 的时候根据 文件内的title 生成CRC，为了降低碰撞，建议文件内的title，date最好修改</p>
<p>并且 URL ：articles/:abbrlink.html 可设置为：<code>articles/:year:month:day/:abbrlink.html</code></p>
<ol>
<li>插件安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li>
<li>配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">articles/:year:month:day/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">    <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure>
生成的链接将会是这样的(官方样例)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br></pre></td></tr></table></figure>
生成完后，原md文件的Front-matter 内会增加abbrlink 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>002-命令new-页面分类标签</title>
    <url>/articles/20200129/1a1ce396.html</url>
    <content><![CDATA[<p>hexo new 命令使用：创建普通页面、创建”分类”选项、创建“标签”选项</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] title</span><br></pre></td></tr></table></figure>
<p>创建一个新文章。如果未提供布局，则Hexo将使用_config.yml中的default_layout: post。如果标题包含空格，请用引号引起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Option	Description</span><br><span class="line">-p, --path	Post path. Customize the path of the post.</span><br><span class="line">-r, --replace	Replace the current post if existed.</span><br><span class="line">-s, --slug	Post slug. Customize the URL of the post.</span><br></pre></td></tr></table></figure>
<h2 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h2><p>默认情况下，Hexo将使用标题定义文件的路径。对于页面，它将创建该名称的目录以及其中的index.md文件。使用–path选项覆盖该行为并定义文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">"About me"</span></span><br></pre></td></tr></table></figure>
<p>将创建源/about/me.md文件，文件的标题设置为“关于我”。 请注意，标题是必填项。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建普通页面"><a href="#创建普通页面" class="headerlink" title="创建普通页面"></a>创建普通页面</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br><span class="line">或</span><br><span class="line">hexo new post <span class="string">"My New Post 2"</span></span><br></pre></td></tr></table></figure>

<h2 id="创建”分类”选项"><a href="#创建”分类”选项" class="headerlink" title="创建”分类”选项"></a>创建”分类”选项</h2><h3 id="生成“分类”页并添加tpye属性"><a href="#生成“分类”页并添加tpye属性" class="headerlink" title="生成“分类”页并添加tpye属性"></a>生成“分类”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>成功后，会有路径提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="built_in">source</span>/categories/index.md</span><br></pre></td></tr></table></figure>
<p>打开 index.md 修改如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存关闭即可。主要是为了生存的分类有超链接，不执行此步，也会有分类，但是点击分类时候，没有超链接</p>
<h3 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h3><p>打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 002-分类标签.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h2 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h2><h3 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>成功后会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/<span class="built_in">source</span>/tags/index.md</span><br></pre></td></tr></table></figure>
<p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：<br>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-01-29 17:41:12</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h3 id="给文章添加“tags”属性"><a href="#给文章添加“tags”属性" class="headerlink" title="给文章添加“tags”属性"></a>给文章添加“tags”属性</h3><p>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的 - hexo - hexo分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 002-分类标签.md</span><br><span class="line">date: 2020-01-29 17:50:48</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- hexo分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。</p>
<p>其实，这两个的设置几乎一样！可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。</p>
<p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo分类</tag>
      </tags>
  </entry>
  <entry>
    <title>001-命令-服务、生成、部署、清理</title>
    <url>/articles/20200129/82195907.html</url>
    <content><![CDATA[<p>初始化代码库：<code>hexo init</code>；<br>本地服务运行 ：<code>hexo s</code>；生成静态文件：<code>hexo g</code>；部署远程站点：<code>hexo d</code>；清理缓存：<code>hexo clean</code></p>
<a id="more"></a>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="初始化代码库"><a href="#初始化代码库" class="headerlink" title="初始化代码库"></a>初始化代码库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>下载代码，因为 init 初始化需要一个空目录，否则报错</p>
<h3 id="本地服务运行"><a href="#本地服务运行" class="headerlink" title="本地服务运行"></a>本地服务运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="部署远程站点"><a href="#部署远程站点" class="headerlink" title="部署远程站点"></a>部署远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">或</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="命令用于清理缓存文件，是一个比较常用的命令"><a href="#命令用于清理缓存文件，是一个比较常用的命令" class="headerlink" title="命令用于清理缓存文件，是一个比较常用的命令"></a>命令用于清理缓存文件，是一个比较常用的命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>更过官方帮助：<br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br><a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a><br><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a><br><a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a><br><a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">commands</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础</title>
    <url>/articles/20190526/26856f5b.html</url>
    <content><![CDATA[<p>第一个测试程序</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
